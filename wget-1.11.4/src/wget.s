	.file	"src/wget.bc"
	.text
	.globl	connect_to_ip
	.align	16, 0x90
	.type	connect_to_ip,@function
connect_to_ip:                          # @connect_to_ip
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$332, %esp              # imm = 0x14C
	movl	356(%esp), %ebx
	movl	352(%esp), %edi
	cmpl	$0, 360(%esp)
	je	.LBB0_5
# BB#1:                                 # %if.then
	movl	%edi, (%esp)
	calll	print_address
	movl	%eax, %esi
	movl	%esi, 4(%esp)
	movl	360(%esp), %ebp
	movl	%ebp, (%esp)
	calll	strcmp
	testl	%eax, %eax
	je	.LBB0_3
# BB#2:                                 # %if.then3
	movl	$5, 8(%esp)
	movl	$.L.str, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	%ebp, (%esp)
	calll	escnonprint
	movl	%ebx, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	352(%esp), %edi
	jmp	.LBB0_4
.LBB0_3:                                # %if.else
	movl	$5, 8(%esp)
	movl	$.L.str1, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%ebx, 12(%esp)
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
.LBB0_4:                                # %if.else
	movl	$0, (%esp)
	calll	logprintf
.LBB0_5:                                # %if.end7
	movl	(%edi), %eax
	cmpl	$10, %eax
	jne	.LBB0_6
# BB#9:                                 # %sw.bb1.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 176(%esp)
	movl	$0, 200(%esp)
	movl	$0, 196(%esp)
	movl	$0, 192(%esp)
	movw	$10, 176(%esp)
	rolw	$8, %bx
	movw	%bx, 178(%esp)
	movsd	4(%edi), %xmm0
	movsd	12(%edi), %xmm1
	movsd	%xmm1, 192(%esp)
	movsd	%xmm0, 184(%esp)
	movl	20(%edi), %eax
	movl	%eax, 200(%esp)
	jmp	.LBB0_10
.LBB0_6:                                # %if.end7
	cmpl	$2, %eax
	jne	.LBB0_8
# BB#7:                                 # %sw.bb.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 176(%esp)
	movw	$2, 176(%esp)
	rolw	$8, %bx
	movw	%bx, 178(%esp)
	movl	4(%edi), %eax
	movl	%eax, 180(%esp)
.LBB0_10:                               # %sockaddr_set_data.exit
	movzwl	176(%esp), %eax
	movl	%eax, (%esp)
	movl	$0, 8(%esp)
	movl	$1, 4(%esp)
	calll	socket
	movl	%eax, %esi
	testl	%esi, %esi
	js	.LBB0_11
# BB#12:                                # %if.end12
	cmpb	$0, opt+335
	je	.LBB0_16
# BB#13:                                # %if.then14
	movl	$1, 172(%esp)
	leal	172(%esp), %eax
	movl	%eax, 12(%esp)
	movl	%esi, (%esp)
	movl	$4, 16(%esp)
	movl	$26, 8(%esp)
	movl	$41, 4(%esp)
	calll	setsockopt
	cmpb	$0, opt+250
	je	.LBB0_16
# BB#14:                                # %if.then14
	testl	%eax, %eax
	jns	.LBB0_16
# BB#15:                                # %if.then27
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 4(%esp)
	movl	$.L.str2, (%esp)
	calll	debug_logprintf
.LBB0_16:                               # %if.end33
	movl	opt+232, %ecx
	movl	opt+228, %eax
	movl	%eax, %edx
	orl	%ecx, %edx
	je	.LBB0_21
# BB#17:                                # %if.end33
	cmpl	$8191, %eax             # imm = 0x1FFF
	seta	%dl
	testl	%ecx, %ecx
	setg	%cl
	je	.LBB0_19
# BB#18:                                # %if.end33
	movb	%cl, %dl
.LBB0_19:                               # %if.end33
	testb	%dl, %dl
	jne	.LBB0_21
# BB#20:                                # %if.then38
	cmpl	$512, %eax              # imm = 0x200
	movl	$512, %ecx              # imm = 0x200
	cmovgel	%eax, %ecx
	movl	%ecx, 168(%esp)
	leal	168(%esp), %eax
	movl	%eax, 12(%esp)
	movl	%esi, (%esp)
	movl	$4, 16(%esp)
	movl	$8, 8(%esp)
	movl	$1, 4(%esp)
	calll	setsockopt
.LBB0_21:                               # %if.end45
	movl	opt+292, %eax
	testl	%eax, %eax
	je	.LBB0_41
# BB#22:                                # %if.then47
	movb	resolve_bind_address.called.b, %cl
	cmpb	$1, %cl
	jne	.LBB0_28
# BB#23:                                # %if.then.i
	movb	resolve_bind_address.should_bind.b, %al
	cmpb	$1, %al
	jne	.LBB0_41
# BB#24:                                # %if.then2.i
	movl	resolve_bind_address.ip, %eax
	cmpl	$10, %eax
	jne	.LBB0_25
# BB#35:                                # %sw.bb1.i.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 32(%esp)
	movl	$0, 56(%esp)
	movl	$0, 52(%esp)
	movl	$0, 48(%esp)
	movw	$10, 32(%esp)
	movw	$0, 34(%esp)
	movsd	resolve_bind_address.ip+12, %xmm0
	movsd	%xmm0, 48(%esp)
	movsd	resolve_bind_address.ip+4, %xmm0
	movsd	%xmm0, 40(%esp)
	movl	resolve_bind_address.ip+20, %eax
	movl	%eax, 56(%esp)
	jmp	.LBB0_36
.LBB0_11:                               # %err78.thread
	calll	__errno_location
	movl	%eax, %edi
	movl	(%edi), %ebx
	jmp	.LBB0_48
.LBB0_8:                                # %sw.default.i
	calll	abort
.LBB0_28:                               # %if.end4.i
	movb	$1, resolve_bind_address.called.b
	movl	%eax, (%esp)
	movl	$3, 4(%esp)
	calll	lookup_host
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB0_29
# BB#30:                                # %if.end8.i
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	address_list_address_at
	movsd	16(%eax), %xmm0
	movsd	%xmm0, resolve_bind_address.ip+16
	movsd	(%eax), %xmm0
	movsd	8(%eax), %xmm1
	movsd	%xmm1, resolve_bind_address.ip+8
	movsd	%xmm0, resolve_bind_address.ip
	movl	%edi, (%esp)
	calll	address_list_release
	movl	resolve_bind_address.ip, %eax
	cmpl	$10, %eax
	jne	.LBB0_31
# BB#33:                                # %sw.bb1.i20.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 32(%esp)
	movl	$0, 56(%esp)
	movl	$0, 52(%esp)
	movl	$0, 48(%esp)
	movw	$10, 32(%esp)
	movw	$0, 34(%esp)
	movsd	resolve_bind_address.ip+12, %xmm0
	movsd	%xmm0, 48(%esp)
	movsd	resolve_bind_address.ip+4, %xmm0
	movsd	%xmm0, 40(%esp)
	movl	resolve_bind_address.ip+20, %eax
	movl	%eax, 56(%esp)
	movb	$1, resolve_bind_address.should_bind.b
	jmp	.LBB0_37
.LBB0_29:                               # %resolve_bind_address.exit.thread106
	movl	$5, 8(%esp)
	movl	$.L.str15, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	opt+292, %edx
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movb	$0, resolve_bind_address.should_bind.b
	jmp	.LBB0_41
.LBB0_31:                               # %if.end8.i
	cmpl	$2, %eax
	jne	.LBB0_34
# BB#32:                                # %sw.bb.i15.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 32(%esp)
	movw	$2, 32(%esp)
	movw	$0, 34(%esp)
	movl	resolve_bind_address.ip+4, %eax
	movl	%eax, 36(%esp)
	movb	$1, resolve_bind_address.should_bind.b
	jmp	.LBB0_37
.LBB0_25:                               # %if.then2.i
	cmpl	$2, %eax
	jne	.LBB0_27
# BB#26:                                # %sw.bb.i.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 32(%esp)
	movw	$2, 32(%esp)
	movw	$0, 34(%esp)
	movl	resolve_bind_address.ip+4, %eax
	movl	%eax, 36(%esp)
.LBB0_36:                               # %resolve_bind_address.exit
	movb	resolve_bind_address.should_bind.b, %al
	cmpb	$1, %al
	jne	.LBB0_41
.LBB0_37:                               # %if.then49
	leal	32(%esp), %eax
	movl	%eax, 24(%esp)
	movl	$16, %eax
	movzwl	32(%esp), %ecx
	cmpl	$2, %ecx
	je	.LBB0_40
# BB#38:                                # %if.then49
	cmpl	$10, %ecx
	jne	.LBB0_61
# BB#39:                                # %sw.bb1.i93
	movl	$28, %eax
.LBB0_40:                               # %sockaddr_size.exit
	movl	%eax, 8(%esp)
	movl	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	bind
	testl	%eax, %eax
	js	.LBB0_46
.LBB0_41:                               # %if.end57
	movzwl	176(%esp), %ecx
	movl	$16, %eax
	cmpl	$2, %ecx
	je	.LBB0_44
# BB#42:                                # %if.end57
	cmpl	$10, %ecx
	jne	.LBB0_61
# BB#43:                                # %sw.bb1.i98
	movl	$28, %eax
.LBB0_44:                               # %sockaddr_size.exit101
	movsd	opt+196, %xmm0
	movl	%esi, 312(%esp)
	leal	176(%esp), %ecx
	movl	%ecx, 316(%esp)
	movl	%eax, 320(%esp)
	leal	312(%esp), %eax
	movl	%eax, 12(%esp)
	movsd	%xmm0, (%esp)
	movl	$connect_with_timeout_callback, 8(%esp)
	calll	run_with_timeout
	cmpb	$1, %al
	jne	.LBB0_51
# BB#45:                                # %if.then.i103
	calll	__errno_location
	movl	$110, (%eax)
	jmp	.LBB0_46
.LBB0_51:                               # %if.end.i104
	movl	324(%esp), %eax
	cmpl	$-1, %eax
	jne	.LBB0_54
# BB#52:                                # %land.lhs.true.i
	calll	__errno_location
	cmpl	$4, (%eax)
	jne	.LBB0_46
# BB#53:                                # %if.then7.i
	movl	$110, (%eax)
	movl	324(%esp), %eax
.LBB0_54:                               # %connect_with_timeout.exit
	testl	%eax, %eax
	js	.LBB0_46
# BB#55:                                # %if.end63
	testl	%esi, %esi
	movl	360(%esp), %eax
	js	.LBB0_62
# BB#56:                                # %cond.end
	testl	%eax, %eax
	je	.LBB0_58
# BB#57:                                # %if.then67
	movl	$5, 8(%esp)
	movl	$.L.str5, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB0_58:                               # %do.body70
	cmpb	$0, opt+250
	je	.LBB0_60
# BB#59:                                # %if.then75
	movl	%esi, 4(%esp)
	movl	$.L.str6, (%esp)
	calll	debug_logprintf
	jmp	.LBB0_60
.LBB0_46:                               # %err78
	calll	__errno_location
	movl	%eax, %edi
	movl	(%edi), %ebx
	testl	%esi, %esi
	js	.LBB0_48
# BB#47:                                # %if.then82
	movl	%esi, (%esp)
	calll	fd_close
.LBB0_48:                               # %if.end83
	cmpl	$0, 360(%esp)
	je	.LBB0_50
# BB#49:                                # %if.then85
	movl	$5, 8(%esp)
	movl	$.L.str7, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB0_50:                               # %if.end89
	movl	%ebx, (%edi)
	movl	$-1, %esi
.LBB0_60:                               # %return
	movl	%esi, %eax
	addl	$332, %esp              # imm = 0x14C
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB0_61:                               # %sw.default.i99
	calll	abort
.LBB0_34:                               # %sw.default.i21.i
	calll	abort
.LBB0_27:                               # %sw.default.i.i
	calll	abort
.LBB0_62:                               # %cond.false
	movl	$.L__PRETTY_FUNCTION__.connect_to_ip, 12(%esp)
	movl	$333, 8(%esp)           # imm = 0x14D
	movl	$.L.str4, 4(%esp)
	movl	$.L.str3, (%esp)
	calll	__assert_fail
.Ltmp0:
	.size	connect_to_ip, .Ltmp0-connect_to_ip

	.globl	fd_close
	.align	16, 0x90
	.type	fd_close,@function
fd_close:                               # @fd_close
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %edi
	testl	%edi, %edi
	js	.LBB1_10
# BB#1:                                 # %if.end
	movl	transport_map, %eax
	testl	%eax, %eax
	je	.LBB1_2
# BB#3:                                 # %if.end2
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB1_2
# BB#4:                                 # %land.lhs.true
	movl	(%esi), %eax
	movl	20(%eax), %eax
	testl	%eax, %eax
	je	.LBB1_5
# BB#11:                                # %if.then5
	movl	4(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%edi, (%esp)
	calll	*%eax
	jmp	.LBB1_9
.LBB1_2:
	xorb	%bl, %bl
	xorl	%esi, %esi
	jmp	.LBB1_6
.LBB1_5:
	movb	$1, %bl
.LBB1_6:                                # %if.else
	movl	%edi, (%esp)
	calll	close
	cmpb	$0, opt+250
	jne	.LBB1_7
# BB#8:                                 # %if.end8
	cmpb	$1, %bl
	jne	.LBB1_10
	jmp	.LBB1_9
.LBB1_7:                                # %if.then.i
	movl	%edi, 4(%esp)
	movl	$.L.str14, (%esp)
	calll	debug_logprintf
	testb	%bl, %bl
	je	.LBB1_10
.LBB1_9:                                # %if.then10
	movl	transport_map, %eax
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movl	%esi, (%esp)
	calll	checking_free
	incl	transport_map_modified_tick
.LBB1_10:                               # %if.end12
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp1:
	.size	fd_close, .Ltmp1-fd_close

	.globl	connect_to_host
	.align	16, 0x90
	.type	connect_to_host,@function
connect_to_host:                        # @connect_to_host
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %ebp
	movl	%ebp, (%esp)
	movl	$0, 4(%esp)
	jmp	.LBB2_1
	.align	16, 0x90
.LBB2_10:                               # %if.then8
                                        #   in Loop: Header=BB2_1 Depth=1
	movl	%ebp, (%esp)
	movl	$4, 4(%esp)
.LBB2_1:                                # %entry
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB2_4 Depth 2
	calll	lookup_host
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB2_2
# BB#3:                                 # %if.end
                                        #   in Loop: Header=BB2_1 Depth=1
	leal	20(%esp), %eax
	movl	%eax, 8(%esp)
	leal	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	address_list_get_bounds
	movl	24(%esp), %ebx
	jmp	.LBB2_4
	.align	16, 0x90
.LBB2_8:                                # %if.end6
                                        #   in Loop: Header=BB2_4 Depth=2
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	address_list_set_faulty
	incl	%ebx
.LBB2_4:                                # %for.cond
                                        #   Parent Loop BB2_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	20(%esp), %ebx
	jge	.LBB2_9
# BB#5:                                 # %for.body
                                        #   in Loop: Header=BB2_4 Depth=2
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	address_list_address_at
	movl	%ebp, 8(%esp)
	movl	52(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	connect_to_ip
	movl	%eax, %edi
	testl	%edi, %edi
	js	.LBB2_8
	jmp	.LBB2_6
.LBB2_9:                                # %for.end
                                        #   in Loop: Header=BB2_1 Depth=1
	movl	%esi, (%esp)
	calll	address_list_connected_p
	movb	%al, %bl
	movl	%esi, (%esp)
	calll	address_list_release
	movl	$-1, %edi
	testb	%bl, %bl
	je	.LBB2_7
	jmp	.LBB2_10
.LBB2_6:                                # %if.then5
	movl	%esi, (%esp)
	calll	address_list_set_connected
	movl	%esi, (%esp)
	calll	address_list_release
	.align	16, 0x90
.LBB2_7:                                # %return
	movl	%edi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB2_2:                                # %if.then
	movl	$5, 8(%esp)
	movl	$.L.str8, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%ebp, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$-100, %edi
	jmp	.LBB2_7
.Ltmp2:
	.size	connect_to_host, .Ltmp2-connect_to_host

	.globl	bind_local
	.align	16, 0x90
	.type	bind_local,@function
bind_local:                             # @bind_local
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$188, %esp
	movl	$1, 44(%esp)
	movl	208(%esp), %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 8(%esp)
	movl	$1, 4(%esp)
	calll	socket
	movl	%eax, %esi
	movl	$-1, %eax
	testl	%esi, %esi
	js	.LBB3_26
# BB#1:                                 # %if.end
	movl	212(%esp), %ebx
	leal	44(%esp), %eax
	movl	%eax, 12(%esp)
	movl	%esi, (%esp)
	movl	$4, 16(%esp)
	movl	$2, 8(%esp)
	movl	$1, 4(%esp)
	calll	setsockopt
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 160(%esp)
	movaps	%xmm0, 144(%esp)
	movaps	%xmm0, 128(%esp)
	movaps	%xmm0, 112(%esp)
	movaps	%xmm0, 96(%esp)
	movaps	%xmm0, 80(%esp)
	movaps	%xmm0, 64(%esp)
	movaps	%xmm0, 48(%esp)
	movl	(%ebx), %eax
	movl	(%edi), %ecx
	cmpl	$10, %ecx
	jne	.LBB3_2
# BB#5:                                 # %sw.bb1.i
	movaps	%xmm0, 48(%esp)
	movl	$0, 72(%esp)
	movl	$0, 68(%esp)
	movl	$0, 64(%esp)
	movw	$10, 48(%esp)
	rolw	$8, %ax
	movw	%ax, 50(%esp)
	movsd	4(%edi), %xmm0
	movsd	12(%edi), %xmm1
	movsd	%xmm1, 64(%esp)
	movsd	%xmm0, 56(%esp)
	movl	20(%edi), %eax
	movl	%eax, 72(%esp)
	jmp	.LBB3_6
.LBB3_2:                                # %if.end
	cmpl	$2, %ecx
	jne	.LBB3_4
# BB#3:                                 # %sw.bb.i
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 48(%esp)
	movw	$2, 48(%esp)
	rolw	$8, %ax
	movw	%ax, 50(%esp)
	movl	4(%edi), %eax
	movl	%eax, 52(%esp)
.LBB3_6:                                # %sockaddr_set_data.exit
	leal	48(%esp), %ebp
	movl	%ebp, 40(%esp)
	movl	$16, %eax
	movzwl	48(%esp), %ecx
	cmpl	$2, %ecx
	je	.LBB3_9
# BB#7:                                 # %sockaddr_set_data.exit
	cmpl	$10, %ecx
	jne	.LBB3_27
# BB#8:                                 # %sw.bb1.i39
	movl	$28, %eax
.LBB3_9:                                # %sockaddr_size.exit
	movl	%eax, 8(%esp)
	movl	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	bind
	testl	%eax, %eax
	js	.LBB3_25
# BB#10:                                # %do.body
	cmpb	$0, opt+250
	jne	.LBB3_11
	.align	16, 0x90
.LBB3_12:                               # %do.end
	cmpl	$0, (%ebx)
	jne	.LBB3_23
# BB#13:                                # %if.then12
	movzwl	48(%esp), %ecx
	movl	$16, %eax
	cmpl	$2, %ecx
	je	.LBB3_16
# BB#14:                                # %if.then12
	cmpl	$10, %ecx
	jne	.LBB3_27
# BB#15:                                # %sw.bb1.i43
	movl	$28, %eax
.LBB3_16:                               # %sockaddr_size.exit46
	movl	%eax, 36(%esp)
	movl	%ebp, 32(%esp)
	leal	36(%esp), %eax
	movl	%eax, 8(%esp)
	movl	32(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	getsockname
	testl	%eax, %eax
	js	.LBB3_25
# BB#17:                                # %if.end21
	movl	48(%esp), %ecx
	movl	%ecx, %eax
	shrl	$16, %eax
	movzwl	%cx, %ecx
	cmpl	$10, %ecx
	je	.LBB3_19
# BB#18:                                # %if.end21
	cmpl	$2, %ecx
	jne	.LBB3_27
.LBB3_19:                               # %if.end.i
	testl	%ebx, %ebx
	je	.LBB3_21
# BB#20:                                # %if.then2.i
	rolw	$8, %ax
	movzwl	%ax, %eax
	movl	%eax, (%ebx)
.LBB3_21:                               # %sockaddr_get_data.exit
	cmpb	$0, opt+250
	jne	.LBB3_22
	.align	16, 0x90
.LBB3_23:                               # %if.end31
	movl	%esi, (%esp)
	movl	$1, 4(%esp)
	calll	listen
	testl	%eax, %eax
	js	.LBB3_25
# BB#24:
	movl	%esi, %eax
	jmp	.LBB3_26
.LBB3_25:                               # %if.then35
	movl	%esi, (%esp)
	calll	fd_close
	movl	$-1, %eax
.LBB3_26:                               # %return
	addl	$188, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB3_4:                                # %sw.default.i
	calll	abort
.LBB3_27:                               # %sw.default.i51
	calll	abort
.LBB3_11:                               # %if.then8
	movl	%esi, 4(%esp)
	movl	$.L.str9, (%esp)
	calll	debug_logprintf
	jmp	.LBB3_12
.LBB3_22:                               # %if.then27
	movl	%edi, (%esp)
	calll	print_address
	movl	(%ebx), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str10, (%esp)
	calll	debug_logprintf
	jmp	.LBB3_23
.Ltmp3:
	.size	bind_local, .Ltmp3-bind_local

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI4_0:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
	.text
	.globl	accept_connection
	.align	16, 0x90
	.type	accept_connection,@function
accept_connection:                      # @accept_connection
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$300, %esp              # imm = 0x12C
	movl	$128, 28(%esp)
	movsd	opt+196, %xmm0
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	jne	.LBB4_1
	jnp	.LBB4_7
.LBB4_1:                                # %if.then
	leal	168(%esp), %esi
	xorl	%eax, %eax
	movl	%esi, %edi
	movl	$32, %ecx
	#APP
	cld; rep; stosl
	#NO_APP
	movl	320(%esp), %edx
	movl	%edx, %ecx
                                        # kill: CL<def> CL<kill> ECX<kill>
	movl	$1, %eax
	shll	%cl, %eax
	movl	%edx, %ecx
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%edx, %ecx
	sarl	$5, %ecx
	orl	%eax, 168(%esp,%ecx,4)
	cvttsd2si	%xmm0, %eax
	movl	%eax, 160(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI4_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 164(%esp)
	leal	1(%edx), %ebp
	leal	160(%esp), %ebx
	.align	16, 0x90
.LBB4_2:                                # %do.body11.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, 16(%esp)
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$0, 8(%esp)
	calll	select
	testl	%eax, %eax
	jns	.LBB4_4
# BB#3:                                 # %land.rhs.i
                                        #   in Loop: Header=BB4_2 Depth=1
	calll	__errno_location
	movl	$-1, %edi
	cmpl	$4, (%eax)
	je	.LBB4_2
	jmp	.LBB4_9
.LBB4_4:                                # %select_fd.exit
	testl	%eax, %eax
	je	.LBB4_5
# BB#6:                                 # %if.end
	movl	$-1, %edi
	jle	.LBB4_9
.LBB4_7:                                # %if.end6
	leal	32(%esp), %eax
	movl	%eax, 24(%esp)
	leal	28(%esp), %eax
	movl	%eax, 8(%esp)
	movl	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	320(%esp), %eax
	movl	%eax, (%esp)
	calll	accept
	movl	%eax, %edi
	cmpb	$0, opt+250
	je	.LBB4_9
# BB#8:                                 # %if.then10
	movl	%edi, 4(%esp)
	movl	$.L.str11, (%esp)
	calll	debug_logprintf
	jmp	.LBB4_9
.LBB4_5:                                # %if.then1
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-1, %edi
.LBB4_9:                                # %return
	movl	%edi, %eax
	addl	$300, %esp              # imm = 0x12C
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp4:
	.size	accept_connection, .Ltmp4-accept_connection

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI5_0:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
	.text
	.globl	select_fd
	.align	16, 0x90
	.type	select_fd,@function
select_fd:                              # @select_fd
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	leal	40(%esp), %edx
	xorl	%eax, %eax
	movl	$32, %ecx
	movl	%edx, %edi
	#APP
	cld; rep; stosl
	#NO_APP
	movl	192(%esp), %edi
	movl	%edi, %ecx
                                        # kill: CL<def> CL<kill> ECX<kill>
	movl	$1, %eax
	shll	%cl, %eax
	movl	%edi, %ecx
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%edi, %ecx
	sarl	$5, %ecx
	orl	%eax, 40(%esp,%ecx,4)
	movsd	196(%esp), %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 32(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI5_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 36(%esp)
	movl	204(%esp), %ebx
	movl	%ebx, %ebp
	shll	$30, %ebp
	sarl	$31, %ebp
	andl	%edx, %ebp
	shll	$31, %ebx
	sarl	$31, %ebx
	andl	%edx, %ebx
	incl	%edi
	.align	16, 0x90
.LBB5_1:                                # %do.body11
                                        # =>This Inner Loop Header: Depth=1
	leal	32(%esp), %eax
	movl	%eax, 16(%esp)
	movl	%ebp, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	calll	select
	movl	%eax, %esi
	testl	%esi, %esi
	jns	.LBB5_3
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB5_1 Depth=1
	calll	__errno_location
	cmpl	$4, (%eax)
	je	.LBB5_1
.LBB5_3:                                # %do.end16
	movl	%esi, %eax
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp5:
	.size	select_fd, .Ltmp5-select_fd

	.globl	socket_ip_address
	.align	16, 0x90
	.type	socket_ip_address,@function
socket_ip_address:                      # @socket_ip_address
# BB#0:                                 # %entry
	pushl	%esi
	subl	$168, %esp
	movl	$128, 36(%esp)
	movl	184(%esp), %ecx
	movl	180(%esp), %esi
	movl	176(%esp), %eax
	cmpl	$1, %ecx
	jne	.LBB6_1
# BB#4:                                 # %if.then2
	leal	40(%esp), %ecx
	movl	%ecx, 24(%esp)
	leal	36(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	24(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	getpeername
	jmp	.LBB6_5
.LBB6_1:                                # %entry
	testl	%ecx, %ecx
	jne	.LBB6_3
# BB#2:                                 # %if.then
	leal	40(%esp), %ecx
	movl	%ecx, 32(%esp)
	leal	36(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	32(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	getsockname
.LBB6_5:                                # %if.end8
	xorb	%cl, %cl
	testl	%eax, %eax
	js	.LBB6_11
# BB#6:                                 # %if.end11
	movzwl	40(%esp), %eax
	movl	%eax, (%esi)
	cmpl	$2, %eax
	jne	.LBB6_7
# BB#13:                                # %sw.bb19
	movl	44(%esp), %eax
	movl	%eax, 4(%esi)
	jmp	.LBB6_9
.LBB6_3:                                # %if.else7
	calll	abort
.LBB6_7:                                # %if.end11
	cmpl	$10, %eax
	jne	.LBB6_12
# BB#8:                                 # %sw.bb
	movsd	48(%esp), %xmm0
	movsd	56(%esp), %xmm1
	movsd	%xmm1, 12(%esi)
	movsd	%xmm0, 4(%esi)
	movl	64(%esp), %eax
	movl	%eax, 20(%esi)
.LBB6_9:                                # %sw.bb
	movb	$1, %cl
	cmpb	$0, opt+250
	jne	.LBB6_10
	.align	16, 0x90
.LBB6_11:                               # %return
	movzbl	%cl, %eax
	addl	$168, %esp
	popl	%esi
	ret
.LBB6_12:                               # %sw.default
	calll	abort
.LBB6_10:                               # %if.then16
	movl	%esi, (%esp)
	calll	print_address
	movl	%eax, 4(%esp)
	movl	$.L.str12, (%esp)
	calll	debug_logprintf
	movb	$1, %cl
	jmp	.LBB6_11
.Ltmp6:
	.size	socket_ip_address, .Ltmp6-socket_ip_address

	.globl	retryable_socket_connect_error
	.align	16, 0x90
	.type	retryable_socket_connect_error,@function
retryable_socket_connect_error:         # @retryable_socket_connect_error
# BB#0:                                 # %entry
	movl	4(%esp), %ecx
	leal	-96(%ecx), %edx
	xorb	%al, %al
	cmpl	$2, %edx
	jb	.LBB7_9
# BB#1:                                 # %entry
	cmpl	$94, %ecx
	je	.LBB7_9
# BB#2:                                 # %entry
	cmpl	$93, %ecx
	je	.LBB7_9
# BB#3:                                 # %entry
	cmpl	$92, %ecx
	je	.LBB7_9
# BB#4:                                 # %entry
	cmpl	$22, %ecx
	je	.LBB7_9
# BB#5:                                 # %if.end
	cmpb	$0, opt+12
	jne	.LBB7_8
# BB#6:                                 # %if.then10
	addl	$-101, %ecx
	cmpl	$12, %ecx
	ja	.LBB7_8
# BB#7:                                 # %if.then10
	xorb	%al, %al
	movl	$5121, %edx             # imm = 0x1401
	btl	%ecx, %edx
	jb	.LBB7_9
.LBB7_8:                                # %if.end18
	movb	$1, %al
.LBB7_9:                                # %return
	movzbl	%al, %eax
	ret
.Ltmp7:
	.size	retryable_socket_connect_error, .Ltmp7-retryable_socket_connect_error

	.globl	test_socket_open
	.align	16, 0x90
	.type	test_socket_open,@function
test_socket_open:                       # @test_socket_open
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$164, %esp
	leal	32(%esp), %edx
	xorl	%eax, %eax
	movl	$32, %ecx
	movl	%edx, %edi
	#APP
	cld; rep; stosl
	#NO_APP
	movl	176(%esp), %eax
	movl	%eax, %ecx
                                        # kill: CL<def> CL<kill> ECX<kill>
	movl	$1, %esi
	shll	%cl, %esi
	movl	%eax, %ecx
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%eax, %ecx
	sarl	$5, %ecx
	orl	%esi, 32(%esp,%ecx,4)
	movl	$0, 24(%esp)
	movl	$1, 28(%esp)
	leal	24(%esp), %ecx
	movl	%ecx, 16(%esp)
	movl	%edx, 4(%esp)
	incl	%eax
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$0, 8(%esp)
	calll	select
	testl	%eax, %eax
	sete	%al
	movzbl	%al, %eax
	addl	$164, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp8:
	.size	test_socket_open, .Ltmp8-test_socket_open

	.globl	fd_register_transport
	.align	16, 0x90
	.type	fd_register_transport,@function
fd_register_transport:                  # @fd_register_transport
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %edi
	testl	%edi, %edi
	js	.LBB9_4
# BB#1:                                 # %cond.end
	movl	56(%esp), %ebx
	movl	52(%esp), %ebp
	movl	$8, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	%ebp, (%esi)
	movl	%ebx, 4(%esi)
	movl	transport_map, %eax
	testl	%eax, %eax
	jne	.LBB9_3
# BB#2:                                 # %if.then
	movl	$0, 8(%esp)
	movl	$0, 4(%esp)
	movl	$0, (%esp)
	calll	hash_table_new
	movl	%eax, transport_map
.LBB9_3:                                # %if.end
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_put
	incl	transport_map_modified_tick
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB9_4:                                # %cond.false
	movl	$.L__PRETTY_FUNCTION__.fd_register_transport, 12(%esp)
	movl	$769, 8(%esp)           # imm = 0x301
	movl	$.L.str4, 4(%esp)
	movl	$.L.str13, (%esp)
	calll	__assert_fail
.Ltmp9:
	.size	fd_register_transport, .Ltmp9-fd_register_transport

	.globl	fd_transport_context
	.align	16, 0x90
	.type	fd_transport_context,@function
fd_transport_context:                   # @fd_transport_context
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	transport_map, %eax
	movl	16(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movl	4(%eax), %eax
	addl	$12, %esp
	ret
.Ltmp10:
	.size	fd_transport_context, .Ltmp10-fd_transport_context

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI11_0:
	.quad	-4616189618054758400    # double -1.000000e+00
                                        #  (0x0)
.LCPI11_1:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
	.text
	.globl	fd_read
	.align	16, 0x90
	.type	fd_read,@function
fd_read:                                # @fd_read
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	xorl	%eax, %eax
	movl	transport_map, %edx
	movl	192(%esp), %esi
	testl	%edx, %edx
	je	.LBB11_5
# BB#1:                                 # %if.else
	cmpl	%esi, fd_read.last_fd
	jne	.LBB11_4
# BB#2:                                 # %land.lhs.true
	movl	fd_read.last_tick, %ecx
	cmpl	transport_map_modified_tick, %ecx
	jne	.LBB11_4
# BB#3:                                 # %if.then2
	movl	fd_read.last_info, %eax
	jmp	.LBB11_5
.LBB11_4:                               # %if.else3
	movl	%esi, 4(%esp)
	movl	%edx, (%esp)
	calll	hash_table_get
	movl	%esi, fd_read.last_fd
	movl	%eax, fd_read.last_info
	movl	transport_map_modified_tick, %ecx
	movl	%ecx, fd_read.last_tick
.LBB11_5:                               # %do.end
	movl	%eax, 28(%esp)          # 4-byte Spill
	movsd	204(%esp), %xmm0
	ucomisd	.LCPI11_0, %xmm0
	setnp	%al
	sete	%cl
	testb	%al, %cl
	je	.LBB11_7
# BB#6:
	movsd	opt+180, %xmm0
.LBB11_7:                               # %do.end
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	jne	.LBB11_8
	jnp	.LBB11_17
.LBB11_8:                               # %if.then1.i
	movl	28(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	je	.LBB11_13
# BB#9:                                 # %land.lhs.true.i
	movl	(%ecx), %eax
	movl	8(%eax), %eax
	testl	%eax, %eax
	je	.LBB11_13
# BB#10:                                # %if.then4.i
	movl	4(%ecx), %ecx
	movl	%ecx, 16(%esp)
	movsd	%xmm0, 4(%esp)
	movl	%esi, (%esp)
	movl	$1, 12(%esp)
	calll	*%eax
	jmp	.LBB11_11
.LBB11_13:                              # %if.else.i
	movl	%ecx, 28(%esp)          # 4-byte Spill
	leal	40(%esp), %ebp
	xorl	%eax, %eax
	movl	%ebp, %edi
	movl	$32, %ecx
	#APP
	cld; rep; stosl
	#NO_APP
	movl	%esi, %edx
	movb	%dl, %cl
	movl	$1, %eax
	shll	%cl, %eax
	movl	%edx, %ecx
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%edx, %ecx
	sarl	$5, %ecx
	orl	%eax, 40(%esp,%ecx,4)
	cvttsd2si	%xmm0, %eax
	movl	%eax, 32(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI11_1, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 36(%esp)
	leal	1(%edx), %edi
	leal	32(%esp), %ebx
	.align	16, 0x90
.LBB11_14:                              # %do.body11.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, 16(%esp)
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$0, 8(%esp)
	calll	select
	testl	%eax, %eax
	jns	.LBB11_11
# BB#15:                                # %land.rhs.i21
                                        #   in Loop: Header=BB11_14 Depth=1
	calll	__errno_location
	movl	%eax, %ecx
	movl	$-1, %eax
	cmpl	$4, (%ecx)
	je	.LBB11_14
	jmp	.LBB11_22
.LBB11_11:                              # %if.end8.i
	testl	%eax, %eax
	je	.LBB11_12
# BB#16:                                # %if.end12.i
	movl	$-1, %eax
	jle	.LBB11_22
.LBB11_17:                              # %if.end7
	cmpl	$0, 28(%esp)            # 4-byte Folded Reload
	je	.LBB11_20
# BB#18:                                # %land.lhs.true9
	movl	28(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.LBB11_20
# BB#19:                                # %if.then11
	movl	28(%esp), %ecx          # 4-byte Reload
	movl	4(%ecx), %ecx
	movl	%ecx, 12(%esp)
	movl	200(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	196(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	calll	*%eax
	jmp	.LBB11_22
	.align	16, 0x90
.LBB11_20:                              # %do.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	200(%esp), %eax
	movl	%eax, 8(%esp)
	movl	196(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	read
	cmpl	$-1, %eax
	jne	.LBB11_22
# BB#21:                                # %land.rhs.i
                                        #   in Loop: Header=BB11_20 Depth=1
	calll	__errno_location
	movl	%eax, %ecx
	movl	$-1, %eax
	cmpl	$4, (%ecx)
	je	.LBB11_20
	jmp	.LBB11_22
.LBB11_12:                              # %if.end12.thread.i
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-1, %eax
.LBB11_22:                              # %return
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp11:
	.size	fd_read, .Ltmp11-fd_read

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI12_0:
	.quad	-4616189618054758400    # double -1.000000e+00
                                        #  (0x0)
.LCPI12_1:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
	.text
	.globl	fd_peek
	.align	16, 0x90
	.type	fd_peek,@function
fd_peek:                                # @fd_peek
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	xorl	%eax, %eax
	movl	transport_map, %edx
	movl	192(%esp), %esi
	testl	%edx, %edx
	je	.LBB12_5
# BB#1:                                 # %if.else
	cmpl	%esi, fd_peek.last_fd
	jne	.LBB12_4
# BB#2:                                 # %land.lhs.true
	movl	fd_peek.last_tick, %ecx
	cmpl	transport_map_modified_tick, %ecx
	jne	.LBB12_4
# BB#3:                                 # %if.then2
	movl	fd_peek.last_info, %eax
	jmp	.LBB12_5
.LBB12_4:                               # %if.else3
	movl	%esi, 4(%esp)
	movl	%edx, (%esp)
	calll	hash_table_get
	movl	%esi, fd_peek.last_fd
	movl	%eax, fd_peek.last_info
	movl	transport_map_modified_tick, %ecx
	movl	%ecx, fd_peek.last_tick
.LBB12_5:                               # %do.end
	movl	%eax, 28(%esp)          # 4-byte Spill
	movsd	204(%esp), %xmm0
	ucomisd	.LCPI12_0, %xmm0
	setnp	%al
	sete	%cl
	testb	%al, %cl
	je	.LBB12_7
# BB#6:
	movsd	opt+180, %xmm0
.LBB12_7:                               # %do.end
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	jne	.LBB12_8
	jnp	.LBB12_17
.LBB12_8:                               # %if.then1.i
	movl	28(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	je	.LBB12_13
# BB#9:                                 # %land.lhs.true.i
	movl	(%ecx), %eax
	movl	8(%eax), %eax
	testl	%eax, %eax
	je	.LBB12_13
# BB#10:                                # %if.then4.i
	movl	4(%ecx), %ecx
	movl	%ecx, 16(%esp)
	movsd	%xmm0, 4(%esp)
	movl	%esi, (%esp)
	movl	$1, 12(%esp)
	calll	*%eax
	jmp	.LBB12_11
.LBB12_13:                              # %if.else.i
	movl	%ecx, 28(%esp)          # 4-byte Spill
	leal	40(%esp), %ebp
	xorl	%eax, %eax
	movl	%ebp, %edi
	movl	$32, %ecx
	#APP
	cld; rep; stosl
	#NO_APP
	movl	%esi, %edx
	movb	%dl, %cl
	movl	$1, %eax
	shll	%cl, %eax
	movl	%edx, %ecx
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%edx, %ecx
	sarl	$5, %ecx
	orl	%eax, 40(%esp,%ecx,4)
	cvttsd2si	%xmm0, %eax
	movl	%eax, 32(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI12_1, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 36(%esp)
	leal	1(%edx), %edi
	leal	32(%esp), %ebx
	.align	16, 0x90
.LBB12_14:                              # %do.body11.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, 16(%esp)
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$0, 8(%esp)
	calll	select
	testl	%eax, %eax
	jns	.LBB12_11
# BB#15:                                # %land.rhs.i21
                                        #   in Loop: Header=BB12_14 Depth=1
	calll	__errno_location
	movl	%eax, %ecx
	movl	$-1, %eax
	cmpl	$4, (%ecx)
	je	.LBB12_14
	jmp	.LBB12_22
.LBB12_11:                              # %if.end8.i
	testl	%eax, %eax
	je	.LBB12_12
# BB#16:                                # %if.end12.i
	movl	$-1, %eax
	jle	.LBB12_22
.LBB12_17:                              # %if.end7
	cmpl	$0, 28(%esp)            # 4-byte Folded Reload
	je	.LBB12_20
# BB#18:                                # %land.lhs.true9
	movl	28(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	12(%eax), %eax
	testl	%eax, %eax
	je	.LBB12_20
# BB#19:                                # %if.then11
	movl	28(%esp), %ecx          # 4-byte Reload
	movl	4(%ecx), %ecx
	movl	%ecx, 12(%esp)
	movl	200(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	196(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	calll	*%eax
	jmp	.LBB12_22
	.align	16, 0x90
.LBB12_20:                              # %do.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	200(%esp), %eax
	movl	%eax, 8(%esp)
	movl	196(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	$2, 12(%esp)
	calll	recv
	cmpl	$-1, %eax
	jne	.LBB12_22
# BB#21:                                # %land.rhs.i
                                        #   in Loop: Header=BB12_20 Depth=1
	calll	__errno_location
	movl	%eax, %ecx
	movl	$-1, %eax
	cmpl	$4, (%ecx)
	je	.LBB12_20
	jmp	.LBB12_22
.LBB12_12:                              # %if.end12.thread.i
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-1, %eax
.LBB12_22:                              # %return
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp12:
	.size	fd_peek, .Ltmp12-fd_peek

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI13_0:
	.quad	-4616189618054758400    # double -1.000000e+00
                                        #  (0x0)
.LCPI13_1:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
.LCPI13_2:
	.quad	0                       # double 0.000000e+00
                                        #  (0x0)
	.text
	.globl	fd_write
	.align	16, 0x90
	.type	fd_write,@function
fd_write:                               # @fd_write
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$188, %esp
	xorl	%edi, %edi
	movl	transport_map, %esi
	movl	208(%esp), %ecx
	testl	%esi, %esi
	movl	%edi, %eax
	je	.LBB13_5
# BB#1:                                 # %if.else
	cmpl	%ecx, fd_write.last_fd
	jne	.LBB13_4
# BB#2:                                 # %land.lhs.true
	movl	%ecx, %edx
	movl	fd_write.last_tick, %ecx
	cmpl	transport_map_modified_tick, %ecx
	movl	%edx, %ecx
	jne	.LBB13_4
# BB#3:                                 # %if.then2
	movl	fd_write.last_info, %eax
	jmp	.LBB13_5
.LBB13_4:                               # %if.else3
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	movl	%ecx, %esi
	calll	hash_table_get
	movl	%esi, %ecx
	movl	%ecx, fd_write.last_fd
	movl	%eax, fd_write.last_info
	movl	transport_map_modified_tick, %edx
	movl	%edx, fd_write.last_tick
.LBB13_5:                               # %do.end
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	216(%esp), %ebx
	movl	212(%esp), %ebp
	movl	%ecx, %eax
	movl	$1, %edx
	shll	%cl, %edx
	movl	%edx, 36(%esp)          # 4-byte Spill
	sarl	$31, %ecx
	shrl	$27, %ecx
	addl	%eax, %ecx
	sarl	$5, %ecx
	movl	%ecx, 32(%esp)          # 4-byte Spill
	leal	1(%eax), %ecx
	movl	%ecx, 44(%esp)          # 4-byte Spill
	movl	%eax, %esi
	jmp	.LBB13_6
	.align	16, 0x90
.LBB13_23:                              # %if.end21
                                        #   in Loop: Header=BB13_6 Depth=1
	subl	%edi, %ebx
	addl	%edi, %ebp
.LBB13_6:                               # %while.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB13_24 Depth 2
                                        #     Child Loop BB13_16 Depth 2
	testl	%ebx, %ebx
	jle	.LBB13_26
# BB#7:                                 # %while.body
                                        #   in Loop: Header=BB13_6 Depth=1
	movsd	220(%esp), %xmm0
	ucomisd	.LCPI13_0, %xmm0
	setnp	%al
	sete	%cl
	testb	%al, %cl
	je	.LBB13_9
# BB#8:                                 #   in Loop: Header=BB13_6 Depth=1
	movsd	opt+180, %xmm0
.LBB13_9:                               # %while.body
                                        #   in Loop: Header=BB13_6 Depth=1
	ucomisd	.LCPI13_2, %xmm0
	jne	.LBB13_10
	jnp	.LBB13_19
.LBB13_10:                              # %if.then1.i
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	40(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	je	.LBB13_15
# BB#11:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	(%ecx), %eax
	movl	8(%eax), %eax
	testl	%eax, %eax
	jne	.LBB13_12
.LBB13_15:                              # %if.else.i
                                        #   in Loop: Header=BB13_6 Depth=1
	xorl	%eax, %eax
	movl	$32, %ecx
	leal	56(%esp), %edi
	#APP
	cld; rep; stosl
	#NO_APP
	movl	36(%esp), %eax          # 4-byte Reload
	movl	32(%esp), %ecx          # 4-byte Reload
	orl	%eax, 56(%esp,%ecx,4)
	cvttsd2si	%xmm0, %eax
	movl	%eax, 48(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI13_1, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 52(%esp)
	.align	16, 0x90
.LBB13_16:                              # %do.body11.i
                                        #   Parent Loop BB13_6 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	48(%esp), %eax
	movl	%eax, 16(%esp)
	leal	56(%esp), %eax
	movl	%eax, 8(%esp)
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$0, 4(%esp)
	calll	select
	testl	%eax, %eax
	jns	.LBB13_13
# BB#17:                                # %land.rhs.i26
                                        #   in Loop: Header=BB13_16 Depth=2
	calll	__errno_location
	movl	$-1, %edi
	cmpl	$4, (%eax)
	je	.LBB13_16
	jmp	.LBB13_26
.LBB13_12:                              # %if.then4.i
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	4(%ecx), %ecx
	movl	%ecx, 16(%esp)
	movsd	%xmm0, 4(%esp)
	movl	%esi, (%esp)
	movl	$2, 12(%esp)
	calll	*%eax
.LBB13_13:                              # %if.end8.i
                                        #   in Loop: Header=BB13_6 Depth=1
	testl	%eax, %eax
	je	.LBB13_14
# BB#18:                                # %if.end12.i
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	$-1, %edi
	jle	.LBB13_26
.LBB13_19:                              # %if.end8
                                        #   in Loop: Header=BB13_6 Depth=1
	cmpl	$0, 40(%esp)            # 4-byte Folded Reload
	je	.LBB13_24
# BB#20:                                # %land.lhs.true10
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	40(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	4(%eax), %eax
	testl	%eax, %eax
	jne	.LBB13_21
	.align	16, 0x90
.LBB13_24:                              # %do.body.i
                                        #   Parent Loop BB13_6 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ebx, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
	calll	write
	movl	%eax, %edi
	cmpl	$-1, %edi
	jne	.LBB13_22
# BB#25:                                # %land.rhs.i
                                        #   in Loop: Header=BB13_24 Depth=2
	calll	__errno_location
	movl	$-1, %edi
	cmpl	$4, (%eax)
	je	.LBB13_24
	jmp	.LBB13_26
.LBB13_21:                              # %if.then12
                                        #   in Loop: Header=BB13_6 Depth=1
	movl	40(%esp), %ecx          # 4-byte Reload
	movl	4(%ecx), %ecx
	movl	%ecx, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
	calll	*%eax
	movl	%eax, %edi
.LBB13_22:                              # %if.end18
                                        #   in Loop: Header=BB13_6 Depth=1
	testl	%edi, %edi
	jle	.LBB13_26
	jmp	.LBB13_23
.LBB13_14:                              # %if.end12.thread.i
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-1, %edi
.LBB13_26:                              # %return
	movl	%edi, %eax
	addl	$188, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp13:
	.size	fd_write, .Ltmp13-fd_write

	.globl	fd_errstr
	.align	16, 0x90
	.type	fd_errstr,@function
fd_errstr:                              # @fd_errstr
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	transport_map, %eax
	testl	%eax, %eax
	je	.LBB14_4
# BB#1:                                 # %if.end
	movl	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	testl	%eax, %eax
	je	.LBB14_4
# BB#2:                                 # %land.lhs.true
	movl	(%eax), %ecx
	movl	16(%ecx), %ecx
	testl	%ecx, %ecx
	je	.LBB14_4
# BB#3:                                 # %if.then3
	movl	4(%eax), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	*%ecx
	testl	%eax, %eax
	jne	.LBB14_5
.LBB14_4:                               # %if.end10
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
.LBB14_5:                               # %return
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp14:
	.size	fd_errstr, .Ltmp14-fd_errstr

	.align	16, 0x90
	.type	connect_with_timeout_callback,@function
connect_with_timeout_callback:          # @connect_with_timeout_callback
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	32(%esp), %esi
	movl	(%esi), %eax
	movl	4(%esi), %ecx
	movl	%ecx, 16(%esp)
	movl	8(%esi), %ecx
	movl	%ecx, 8(%esp)
	movl	16(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	connect
	movl	%eax, 12(%esi)
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp15:
	.size	connect_with_timeout_callback, .Ltmp15-connect_with_timeout_callback

	.globl	convert_all_links
	.align	16, 0x90
	.type	convert_all_links,@function
convert_all_links:                      # @convert_all_links
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$76, %esp
	calll	ptimer_new
	movl	%eax, -80(%ebp)         # 4-byte Spill
	movl	downloaded_html_set, %eax
	testl	%eax, %eax
	je	.LBB16_87
# BB#1:                                 # %if.end
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	hash_table_count
	addl	$16, %esp
	movl	%eax, %esi
	movl	%esi, -64(%ebp)         # 4-byte Spill
	testl	%esi, %esi
	je	.LBB16_87
# BB#2:                                 # %if.end3
	leal	15(,%esi,4), %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	subl	%eax, %ecx
	movl	%ecx, -76(%ebp)         # 4-byte Spill
	movl	%ecx, %esp
	movl	downloaded_html_set, %eax
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_to_array
	addl	$16, %esp
	xorl	%eax, %eax
	movl	%eax, %edi
	movl	$0, -72(%ebp)           # 4-byte Folded Spill
	jmp	.LBB16_3
	.align	16, 0x90
.LBB16_7:                               # %for.inc62
                                        #   in Loop: Header=BB16_3 Depth=1
	incl	%edi
	.align	16, 0x90
.LBB16_3:                               # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB16_23 Depth 2
                                        #     Child Loop BB16_11 Depth 2
                                        #     Child Loop BB16_41 Depth 2
                                        #       Child Loop BB16_69 Depth 3
                                        #       Child Loop BB16_64 Depth 3
                                        #       Child Loop BB16_59 Depth 3
	cmpl	%esi, %edi
	jge	.LBB16_86
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	-76(%ebp), %eax         # 4-byte Reload
	movl	(%eax,%edi,4), %ebx
	movl	dl_file_url_map, %eax
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	movl	%eax, %esi
	movb	opt+250, %al
	testl	%esi, %esi
	jne	.LBB16_8
# BB#5:                                 # %do.body
                                        #   in Loop: Header=BB16_3 Depth=1
	testb	%al, %al
	movl	-64(%ebp), %esi         # 4-byte Reload
	je	.LBB16_7
# BB#6:                                 # %if.then10
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str16, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB16_7
.LBB16_8:                               # %do.body13
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	%edi, -68(%ebp)         # 4-byte Spill
	testb	%al, %al
	movl	%ebx, %edi
	je	.LBB16_10
# BB#9:                                 # %if.then18
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$.L.str117, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
.LBB16_10:                              # %do.end20
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	%edi, -36(%ebp)         # 4-byte Spill
	movl	$0, 8(%esp)
	calll	get_urls_html
	addl	$16, %esp
	movl	%eax, -60(%ebp)         # 4-byte Spill
	testl	%eax, %eax
	movl	%eax, %edi
	jne	.LBB16_11
# BB#27:                                # %if.then2.i.critedge
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str824, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	-36(%ebp), %ecx         # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	jmp	.LBB16_28
	.align	16, 0x90
.LBB16_15:                              # %if.then41
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	(%ebx), %eax
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str218, (%esp)
	.align	16, 0x90
.LBB16_20:                              # %if.then57
                                        #   in Loop: Header=BB16_11 Depth=2
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB16_21
	.align	16, 0x90
.LBB16_11:                              # %for.body24
                                        #   Parent Loop BB16_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	$8, 8(%edi)
	jne	.LBB16_12
# BB#13:                                # %if.end28
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	(%edi), %ebx
	movl	(%ebx), %eax
	movl	dl_url_file_map, %ecx
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB16_14
# BB#16:                                # %if.else
                                        #   in Loop: Header=BB16_11 Depth=2
	testb	$4, 8(%edi)
	jne	.LBB16_18
# BB#17:                                # %if.then48
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	$2, 16(%edi)
.LBB16_18:                              # %if.end50
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	$0, 4(%edi)
	cmpb	$0, opt+250
	je	.LBB16_21
# BB#19:                                # %if.then57
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	(%ebx), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str319, (%esp)
	jmp	.LBB16_20
.LBB16_12:                              # %if.then27
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	$3, 16(%edi)
	jmp	.LBB16_21
.LBB16_14:                              # %if.then32
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	$1, 16(%edi)
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, 4(%edi)
	cmpb	$0, opt+250
	jne	.LBB16_15
.LBB16_21:                              # %for.inc
                                        #   in Loop: Header=BB16_11 Depth=2
	movl	28(%edi), %edi
	testl	%edi, %edi
	jne	.LBB16_11
# BB#22:                                # %for.end
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str824, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	-36(%ebp), %edi         # 4-byte Reload
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	xorl	%eax, %eax
	movl	-60(%ebp), %ecx         # 4-byte Reload
	testl	%ecx, %ecx
	je	.LBB16_28
	.align	16, 0x90
.LBB16_23:                              # %for.body.i
                                        #   Parent Loop BB16_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	$1, 16(%ecx)
	sbbl	$-1, %eax
	movl	28(%ecx), %ecx
	testl	%ecx, %ecx
	jne	.LBB16_23
# BB#24:                                # %for.end.i
                                        #   in Loop: Header=BB16_3 Depth=1
	testl	%eax, %eax
	jne	.LBB16_25
.LBB16_28:                              # %if.then2.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str925, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	.align	16, 0x90
.LBB16_49:                              # %if.end129.i
                                        #   in Loop: Header=BB16_3 Depth=1
	addl	$16, %esp
	subl	$16, %esp
	movl	-60(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	incl	-72(%ebp)               # 4-byte Folded Spill
	calll	free_urlpos
	addl	$16, %esp
	movl	-64(%ebp), %esi         # 4-byte Reload
	movl	-68(%ebp), %edi         # 4-byte Reload
	incl	%edi
	jmp	.LBB16_3
.LBB16_25:                              # %if.end4.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	read_file
	addl	$16, %esp
	movl	%eax, -44(%ebp)         # 4-byte Spill
	testl	%eax, %eax
	jne	.LBB16_29
# BB#26:                                # %if.then7.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1026, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	jmp	.LBB16_48
.LBB16_29:                              # %if.end11.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	downloaded_files_hash, %eax
	testl	%eax, %eax
	je	.LBB16_34
# BB#30:                                # %if.end.i.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB16_34
# BB#31:                                # %downloaded_file.exit.i
                                        #   in Loop: Header=BB16_3 Depth=1
	cmpb	$0, opt+252
	je	.LBB16_34
# BB#32:                                # %downloaded_file.exit.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	(%eax), %edx
	testl	%edx, %edx
	je	.LBB16_34
# BB#33:                                # %if.then15.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	%edi, %ecx
	calll	write_backup_file
.LBB16_34:                              # %if.end16.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	unlink
	addl	$16, %esp
	testl	%eax, %eax
	jns	.LBB16_38
# BB#35:                                # %land.lhs.true19.i
                                        #   in Loop: Header=BB16_3 Depth=1
	calll	__errno_location
	movl	%eax, %esi
	cmpl	$2, (%esi)
	jne	.LBB16_36
.LBB16_38:                              # %if.end26.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str1228, 4(%esp)
	calll	fopen64
	addl	$16, %esp
	movl	%eax, -28(%ebp)         # 4-byte Spill
	testl	%eax, %eax
	jne	.LBB16_40
# BB#39:                                # %if.then29.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1026, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	jmp	.LBB16_37
.LBB16_40:                              # %if.end33.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	$1, %eax
	subl	%edi, %eax
	movl	%eax, -24(%ebp)         # 4-byte Spill
	movl	-44(%ebp), %eax         # 4-byte Reload
	movl	(%eax), %ebx
	movl	$0, -52(%ebp)           # 4-byte Folded Spill
	movl	-60(%ebp), %esi         # 4-byte Reload
	movl	$0, -56(%ebp)           # 4-byte Folded Spill
	jmp	.LBB16_41
	.align	16, 0x90
.LBB16_54:                              #   in Loop: Header=BB16_41 Depth=2
	movl	%edi, %ebx
	movl	28(%esi), %esi
	.align	16, 0x90
.LBB16_41:                              # %for.cond34.i
                                        #   Parent Loop BB16_3 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB16_69 Depth 3
                                        #       Child Loop BB16_64 Depth 3
                                        #       Child Loop BB16_59 Depth 3
	testl	%esi, %esi
	je	.LBB16_45
# BB#42:                                # %for.body36.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	20(%esi), %edi
	movl	-44(%ebp), %eax         # 4-byte Reload
	cmpl	4(%eax), %edi
	jge	.LBB16_43
# BB#50:                                # %if.end45.i
                                        #   in Loop: Header=BB16_41 Depth=2
	cmpl	$0, 16(%esi)
	jne	.LBB16_53
# BB#51:                                # %do.body50.i
                                        #   in Loop: Header=BB16_41 Depth=2
	cmpb	$0, opt+250
	jne	.LBB16_52
	.align	16, 0x90
.LBB16_85:                              # %for.inc112.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	28(%esi), %esi
	jmp	.LBB16_41
.LBB16_53:                              # %if.end60.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	-44(%ebp), %eax         # 4-byte Reload
	addl	(%eax), %edi
	subl	$16, %esp
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	%edi, %eax
	subl	%ebx, %eax
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$1, 4(%esp)
	calll	fwrite
	addl	$16, %esp
	movl	16(%esi), %eax
	cmpl	$3, %eax
	ja	.LBB16_54
# BB#55:                                # %if.end60.i
                                        #   in Loop: Header=BB16_41 Depth=2
	jmpl	*.LJTI16_0(,%eax,4)
.LBB16_56:                              # %sw.bb.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	%edi, -40(%ebp)         # 4-byte Spill
	movl	-36(%ebp), %eax         # 4-byte Reload
	movb	(%eax), %cl
	movl	%eax, %ebx
	movl	4(%esi), %eax
	movl	%eax, -32(%ebp)         # 4-byte Spill
	movl	%esi, -48(%ebp)         # 4-byte Spill
	xorl	%esi, %esi
	cmpb	(%eax), %cl
	movl	%esi, %eax
	jne	.LBB16_63
# BB#57:                                # %sw.bb.i
                                        #   in Loop: Header=BB16_41 Depth=2
	testb	%cl, %cl
	movl	%esi, %eax
	je	.LBB16_63
# BB#58:                                # %for.body.i.i.preheader
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	-32(%ebp), %eax         # 4-byte Reload
	leal	1(%eax), %edx
	xorl	%eax, %eax
	movl	%ebx, %edi
	.align	16, 0x90
.LBB16_59:                              # %for.body.i.i
                                        #   Parent Loop BB16_3 Depth=1
                                        #     Parent Loop BB16_41 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	cmpb	$47, %cl
	jne	.LBB16_61
# BB#60:                                # %if.then.i.i
                                        #   in Loop: Header=BB16_59 Depth=3
	movl	-24(%ebp), %eax         # 4-byte Reload
	leal	(%eax,%edi), %eax
.LBB16_61:                              # %for.inc.i.i
                                        #   in Loop: Header=BB16_59 Depth=3
	movb	1(%edi), %cl
	cmpb	(%edx), %cl
	jne	.LBB16_63
# BB#62:                                # %for.inc.i.i
                                        #   in Loop: Header=BB16_59 Depth=3
	incl	%edx
	incl	%edi
	testb	%cl, %cl
	jne	.LBB16_59
.LBB16_63:                              # %for.end.i.i
                                        #   in Loop: Header=BB16_41 Depth=2
	leal	(%ebx,%eax), %ecx
	jmp	.LBB16_64
.LBB16_52:                              # %if.then55.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	(%esi), %eax
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str1430, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	28(%esi), %esi
	jmp	.LBB16_41
.LBB16_77:                              # %sw.bb83.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	%edi, %ebx
	movl	(%esi), %eax
	movl	(%eax), %eax
	movl	%eax, -32(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	html_quote_string
	addl	$16, %esp
	movl	%esi, %edi
	movl	%eax, %esi
	movl	24(%edi), %edx
	testb	$64, 8(%edi)
	jne	.LBB16_79
# BB#78:                                # %if.then90.i
                                        #   in Loop: Header=BB16_41 Depth=2
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	%ebx, %ecx
	calll	replace_attr
	jmp	.LBB16_80
.LBB16_84:                              # %sw.bb108.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	24(%esi), %edx
	subl	$16, %esp
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$.L.str17, 4(%esp)
	movl	%edi, %ecx
	calll	replace_attr
	addl	$16, %esp
	movl	%eax, %ebx
	jmp	.LBB16_85
	.align	16, 0x90
.LBB16_67:                              # %for.inc18.i.i
                                        #   in Loop: Header=BB16_64 Depth=3
	incl	%ecx
.LBB16_64:                              # %for.cond11.i.i
                                        #   Parent Loop BB16_3 Depth=1
                                        #     Parent Loop BB16_41 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB16_68
# BB#65:                                # %for.cond11.i.i
                                        #   in Loop: Header=BB16_64 Depth=3
	cmpb	$47, %dl
	jne	.LBB16_67
# BB#66:                                # %if.then16.i.i
                                        #   in Loop: Header=BB16_64 Depth=3
	incl	%esi
	jmp	.LBB16_67
.LBB16_79:                              # %if.else93.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	12(%edi), %eax
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	%ebx, %ecx
	calll	replace_attr_refresh_hack
.LBB16_80:                              # %if.else93.i
                                        #   in Loop: Header=BB16_41 Depth=2
	addl	$16, %esp
	movl	%eax, %ebx
	cmpb	$0, opt+250
	je	.LBB16_82
# BB#81:                                # %if.then103.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	20(%edi), %eax
	subl	$16, %esp
	movl	-36(%ebp), %ecx         # 4-byte Reload
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	-32(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str1632, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
.LBB16_82:                              # %do.end106.i
                                        #   in Loop: Header=BB16_41 Depth=2
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_free
	addl	$16, %esp
	incl	-52(%ebp)               # 4-byte Folded Spill
	movl	%edi, %esi
	movl	28(%esi), %esi
	jmp	.LBB16_41
.LBB16_68:                              # %for.end20.i.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	-32(%ebp), %ecx         # 4-byte Reload
	addl	%eax, %ecx
	movl	%ecx, -32(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%ecx, (%esp)
	leal	(%esi,%esi,2), %edi
	calll	strlen
	addl	$16, %esp
	leal	1(%eax,%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_malloc
	addl	$16, %esp
	movl	%eax, %ebx
	testl	%esi, %esi
	movl	%ebx, %ecx
	jle	.LBB16_71
	.align	16, 0x90
.LBB16_69:                              # %for.body27.i.i
                                        #   Parent Loop BB16_3 Depth=1
                                        #     Parent Loop BB16_41 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	$47, 2(%eax)
	movw	$11822, (%eax)          # imm = 0x2E2E
	addl	$3, %eax
	decl	%esi
	jne	.LBB16_69
# BB#70:                                # %for.cond24.for.end32_crit_edge.i.i
                                        #   in Loop: Header=BB16_41 Depth=2
	addl	%ebx, %edi
	movl	%edi, %ecx
.LBB16_71:                              # %construct_relative.exit.i
                                        #   in Loop: Header=BB16_41 Depth=2
	subl	$16, %esp
	movl	-32(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	strcpy
	addl	$16, %esp
	movl	%ebx, %ecx
	calll	local_quote_string
	movl	%eax, %esi
	movl	-48(%ebp), %edi         # 4-byte Reload
	movl	24(%edi), %edx
	testb	$64, 8(%edi)
	jne	.LBB16_73
# BB#72:                                # %if.then66.i
                                        #   in Loop: Header=BB16_41 Depth=2
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	-40(%ebp), %ecx         # 4-byte Reload
	calll	replace_attr
	jmp	.LBB16_74
.LBB16_73:                              # %if.else.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	12(%edi), %eax
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	-40(%ebp), %ecx         # 4-byte Reload
	calll	replace_attr_refresh_hack
.LBB16_74:                              # %if.else.i
                                        #   in Loop: Header=BB16_41 Depth=2
	addl	$16, %esp
	movl	%eax, -32(%ebp)         # 4-byte Spill
	cmpb	$0, opt+250
	je	.LBB16_76
# BB#75:                                # %if.then76.i
                                        #   in Loop: Header=BB16_41 Depth=2
	movl	(%edi), %eax
	movl	20(%edi), %ecx
	movl	(%eax), %eax
	subl	$32, %esp
	movl	-36(%ebp), %edx         # 4-byte Reload
	movl	%edx, 16(%esp)
	movl	%ecx, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str1531, (%esp)
	calll	debug_logprintf
	addl	$32, %esp
.LBB16_76:                              # %do.end81.i
                                        #   in Loop: Header=BB16_41 Depth=2
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	checking_free
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_free
	addl	$16, %esp
	incl	-56(%ebp)               # 4-byte Folded Spill
	movl	%edi, %esi
	movl	-32(%ebp), %ebx         # 4-byte Reload
	movl	28(%esi), %esi
	jmp	.LBB16_41
.LBB16_36:                              # %if.then22.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1127, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%edi, %ebx
	movl	%eax, %edi
	movl	(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
.LBB16_37:                              # %if.then22.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-44(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	read_file_free
	jmp	.LBB16_49
.LBB16_43:                              # %do.body.i
                                        #   in Loop: Header=BB16_3 Depth=1
	cmpb	$0, opt+250
	jne	.LBB16_44
	.align	16, 0x90
.LBB16_45:                              # %for.end114.i
                                        #   in Loop: Header=BB16_3 Depth=1
	movl	%ebx, %eax
	movl	-44(%ebp), %edx         # 4-byte Reload
	subl	(%edx), %eax
	movl	4(%edx), %ecx
	movl	%edx, %esi
	cmpl	%ecx, %eax
	movl	-28(%ebp), %edi         # 4-byte Reload
	jge	.LBB16_47
# BB#46:                                # %if.then122.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, 12(%esp)
	subl	%eax, %ecx
	movl	%ecx, 8(%esp)
	movl	%ebx, (%esp)
	movl	$1, 4(%esp)
	calll	fwrite
	addl	$16, %esp
.LBB16_47:                              # %if.end129.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fclose
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	read_file_free
	addl	$16, %esp
	subl	$16, %esp
	movl	-52(%ebp), %eax         # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	-56(%ebp), %eax         # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	$.L.str18, 4(%esp)
	movl	$0, (%esp)
.LBB16_48:                              # %if.end129.i
                                        #   in Loop: Header=BB16_3 Depth=1
	calll	logprintf
	jmp	.LBB16_49
.LBB16_44:                              # %if.then43.i
                                        #   in Loop: Header=BB16_3 Depth=1
	subl	$16, %esp
	movl	$.L.str1329, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB16_45
.LBB16_86:                              # %for.end64
	subl	$16, %esp
	movl	-80(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	ptimer_measure
	addl	$16, %esp
	fstpt	-24(%ebp)               # 10-byte Folded Spill
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str420, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	fldt	-24(%ebp)               # 10-byte Folded Reload
	fstpl	(%esp)
	calll	print_decimal
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	-72(%ebp), %eax         # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB16_87:                              # %cleanup
	subl	$16, %esp
	movl	-80(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	ptimer_destroy
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB16_83:                              # %sw.bb111.i
	calll	abort
.Ltmp16:
	.size	convert_all_links, .Ltmp16-convert_all_links
	.section	.rodata,"a",@progbits
	.align	4
.LJTI16_0:
	.long	.LBB16_83
	.long	.LBB16_56
	.long	.LBB16_77
	.long	.LBB16_84

	.text
	.globl	register_download
	.align	16, 0x90
	.type	register_download,@function
register_download:                      # @register_download
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	dl_file_url_map, %eax
	testl	%eax, %eax
	jne	.LBB17_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_file_url_map
.LBB17_2:                               # %if.end
	movl	52(%esp), %edi
	cmpl	$0, dl_url_file_map
	jne	.LBB17_4
# BB#3:                                 # %if.then2
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_url_file_map
	movl	dl_file_url_map, %eax
.LBB17_4:                               # %do.end
	movl	48(%esp), %ebx
	leal	20(%esp), %ecx
	movl	%ecx, 12(%esp)
	leal	24(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get_pair
	testl	%eax, %eax
	je	.LBB17_20
# BB#5:                                 # %if.then7
	movl	20(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcmp
	testl	%eax, %eax
	je	.LBB17_24
# BB#6:
	xorl	%ecx, %ecx
	jmp	.LBB17_7
	.align	16, 0x90
.LBB17_10:                              # %for.inc.i
                                        #   in Loop: Header=BB17_7 Depth=1
	incl	%ecx
.LBB17_7:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%ebx,%ecx), %dl
	movb	$1, %al
	testb	%dl, %dl
	je	.LBB17_11
# BB#8:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB17_7 Depth=1
	movb	(%esi,%ecx), %ah
	xorb	%al, %al
	testb	%ah, %ah
	je	.LBB17_11
# BB#9:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB17_7 Depth=1
	cmpb	%ah, %dl
	je	.LBB17_10
.LBB17_11:                              # %for.end.i
	testl	%ecx, %ecx
	je	.LBB17_19
# BB#12:                                # %if.end.i
	leal	(%ebx,%ecx), %edx
	addl	%ecx, %esi
	movb	(%esi), %cl
	cmpb	$1, %al
	jne	.LBB17_14
# BB#13:                                # %land.lhs.true10.i
	testb	%cl, %cl
	jne	.LBB17_15
	jmp	.LBB17_18
.LBB17_14:                              # %land.lhs.true15.i
	testb	%cl, %cl
	jne	.LBB17_19
.LBB17_15:                              # %if.else19.i
	testb	%al, %al
	cmovnel	%esi, %edx
	leal	-1(%edx), %eax
	cmpb	$47, (%edx)
	cmovel	%edx, %eax
	cmpb	$47, (%eax)
	jne	.LBB17_17
# BB#16:                                # %land.lhs.true35.i
	cmpb	$0, 1(%eax)
	je	.LBB17_18
.LBB17_17:                              # %match_except_index.exit
	movl	%eax, (%esp)
	movl	$.L.str723, 4(%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB17_19
.LBB17_18:                              # %land.lhs.true
	movl	dl_url_file_map, %eax
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_contains
	testl	%eax, %eax
	je	.LBB17_21
.LBB17_19:                              # %if.end15
	movl	dl_file_url_map, %eax
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movl	24(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	dl_url_file_map, %eax
	movl	%edi, 8(%esp)
	movl	%eax, (%esp)
	movl	$dissociate_urls_from_file_mapper, 4(%esp)
	calll	hash_table_for_each
.LBB17_20:                              # %if.end17
	movl	dl_file_url_map, %ebp
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, %esi
	movl	%ebx, (%esp)
	calll	checking_strdup
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	calll	hash_table_put
.LBB17_21:                              # %url_only
	movl	dl_url_file_map, %eax
	leal	24(%esp), %ecx
	movl	%ecx, 12(%esp)
	leal	20(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get_pair
	testl	%eax, %eax
	je	.LBB17_23
# BB#22:                                # %if.then22
	movl	dl_url_file_map, %eax
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
.LBB17_23:                              # %if.end24
	movl	dl_url_file_map, %ebp
	movl	%ebx, (%esp)
	calll	checking_strdup
	movl	%eax, %esi
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	calll	hash_table_put
.LBB17_24:                              # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp17:
	.size	register_download, .Ltmp17-register_download

	.globl	register_redirection
	.align	16, 0x90
	.type	register_redirection,@function
register_redirection:                   # @register_redirection
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	cmpl	$0, dl_file_url_map
	jne	.LBB18_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_file_url_map
.LBB18_2:                               # %if.end
	movl	36(%esp), %esi
	movl	dl_url_file_map, %eax
	testl	%eax, %eax
	jne	.LBB18_4
# BB#3:                                 # %if.then2
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_url_file_map
.LBB18_4:                               # %do.end
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB18_8
# BB#5:                                 # %cond.end
	movl	32(%esp), %edi
	movl	dl_url_file_map, %eax
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_contains
	testl	%eax, %eax
	jne	.LBB18_7
# BB#6:                                 # %if.then8
	movl	dl_url_file_map, %ebx
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	hash_table_put
.LBB18_7:                               # %if.end11
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB18_8:                               # %cond.false
	movl	$.L__PRETTY_FUNCTION__.register_redirection, 12(%esp)
	movl	$804, 8(%esp)           # imm = 0x324
	movl	$.L.str622, 4(%esp)
	movl	$.L.str521, (%esp)
	calll	__assert_fail
.Ltmp18:
	.size	register_redirection, .Ltmp18-register_redirection

	.globl	register_delete_file
	.align	16, 0x90
	.type	register_delete_file,@function
register_delete_file:                   # @register_delete_file
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	dl_file_url_map, %eax
	testl	%eax, %eax
	jne	.LBB19_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_file_url_map
.LBB19_2:                               # %if.end
	movl	32(%esp), %esi
	cmpl	$0, dl_url_file_map
	jne	.LBB19_4
# BB#3:                                 # %if.then2
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, dl_url_file_map
	movl	dl_file_url_map, %eax
.LBB19_4:                               # %do.end
	leal	20(%esp), %ecx
	movl	%ecx, 12(%esp)
	leal	16(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get_pair
	testl	%eax, %eax
	je	.LBB19_6
# BB#5:                                 # %if.end8
	movl	dl_file_url_map, %eax
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	dl_url_file_map, %eax
	movl	%esi, 8(%esp)
	movl	%eax, (%esp)
	movl	$dissociate_urls_from_file_mapper, 4(%esp)
	calll	hash_table_for_each
.LBB19_6:                               # %return
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp19:
	.size	register_delete_file, .Ltmp19-register_delete_file

	.globl	register_html
	.align	16, 0x90
	.type	register_html,@function
register_html:                          # @register_html
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	downloaded_html_set, %eax
	movl	20(%esp), %esi
	testl	%eax, %eax
	jne	.LBB20_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, downloaded_html_set
.LBB20_2:                               # %if.end
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_add
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp20:
	.size	register_html, .Ltmp20-register_html

	.globl	convert_cleanup
	.align	16, 0x90
	.type	convert_cleanup,@function
convert_cleanup:                        # @convert_cleanup
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	dl_file_url_map, %eax
	testl	%eax, %eax
	je	.LBB21_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	free_keys_and_values
	movl	dl_file_url_map, %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	$0, dl_file_url_map
.LBB21_2:                               # %if.end
	movl	dl_url_file_map, %eax
	testl	%eax, %eax
	je	.LBB21_4
# BB#3:                                 # %if.then2
	movl	%eax, (%esp)
	calll	free_keys_and_values
	movl	dl_url_file_map, %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	$0, dl_url_file_map
.LBB21_4:                               # %if.end3
	movl	downloaded_html_set, %eax
	testl	%eax, %eax
	je	.LBB21_6
# BB#5:                                 # %if.then5
	movl	%eax, (%esp)
	calll	string_set_free
.LBB21_6:                               # %if.end6
	movl	downloaded_files_hash, %eax
	testl	%eax, %eax
	je	.LBB21_11
# BB#7:                                 # %if.then.i
	leal	8(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB21_9
	.align	16, 0x90
.LBB21_8:                               # %for.body.i
                                        #   in Loop: Header=BB21_9 Depth=1
	movl	8(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
.LBB21_9:                               # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB21_8
# BB#10:                                # %for.end.i
	movl	downloaded_files_hash, %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	$0, downloaded_files_hash
.LBB21_11:                              # %downloaded_files_free.exit
	movl	converted_files, %eax
	testl	%eax, %eax
	je	.LBB21_13
# BB#12:                                # %if.then8
	movl	%eax, (%esp)
	calll	string_set_free
.LBB21_13:                              # %if.end9
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp21:
	.size	convert_cleanup, .Ltmp21-convert_cleanup

	.globl	downloaded_file
	.align	16, 0x90
	.type	downloaded_file,@function
downloaded_file:                        # @downloaded_file
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	downloaded_files_hash, %eax
	movl	36(%esp), %esi
	movl	32(%esp), %edi
	cmpl	$3, %edi
	jne	.LBB22_4
# BB#1:                                 # %if.then
	xorl	%ecx, %ecx
	testl	%eax, %eax
	je	.LBB22_15
# BB#2:                                 # %if.end
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	xorl	%ecx, %ecx
	testl	%eax, %eax
	je	.LBB22_15
# BB#3:                                 # %if.end4
	movl	(%eax), %ecx
	jmp	.LBB22_15
.LBB22_4:                               # %if.end5
	testl	%eax, %eax
	jne	.LBB22_6
# BB#5:                                 # %if.then7
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, downloaded_files_hash
.LBB22_6:                               # %if.end9
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	testl	%eax, %eax
	je	.LBB22_8
# BB#7:                                 # %if.then12
	movl	(%eax), %ecx
	jmp	.LBB22_15
.LBB22_8:                               # %if.end13
	cmpl	$3, %edi
	jbe	.LBB22_9
# BB#13:                                # %sw.epilog.i
	xorl	%ebx, %ebx
	jmp	.LBB22_14
.LBB22_9:                               # %if.end13
	movl	$downloaded_mode_to_ptr.v1, %ebx
	jmpl	*.LJTI22_0(,%edi,4)
.LBB22_10:                              # %sw.bb1.i
	movl	$downloaded_mode_to_ptr.v2, %ebx
	jmp	.LBB22_14
.LBB22_11:                              # %sw.bb2.i
	movl	$downloaded_mode_to_ptr.v3, %ebx
	jmp	.LBB22_14
.LBB22_12:                              # %sw.bb3.i
	movl	$downloaded_mode_to_ptr.v4, %ebx
.LBB22_14:                              # %downloaded_mode_to_ptr.exit
	movl	downloaded_files_hash, %edi
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	hash_table_put
	xorl	%ecx, %ecx
.LBB22_15:                              # %return
	movl	%ecx, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp22:
	.size	downloaded_file, .Ltmp22-downloaded_file
	.section	.rodata,"a",@progbits
	.align	4
.LJTI22_0:
	.long	.LBB22_14
	.long	.LBB22_10
	.long	.LBB22_11
	.long	.LBB22_12

	.text
	.globl	html_quote_string
	.align	16, 0x90
	.type	html_quote_string,@function
html_quote_string:                      # @html_quote_string
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	xorl	%eax, %eax
	movl	16(%esp), %esi
	movl	%esi, %ecx
	jmp	.LBB23_1
	.align	16, 0x90
.LBB23_20:                              # %for.inc
                                        #   in Loop: Header=BB23_1 Depth=1
	incl	%eax
	incl	%ecx
.LBB23_1:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movb	(%ecx), %dl
	cmpb	$31, %dl
	jg	.LBB23_11
# BB#2:                                 # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	testb	%dl, %dl
	jne	.LBB23_20
	jmp	.LBB23_3
.LBB23_11:                              # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$59, %dl
	jg	.LBB23_16
# BB#12:                                # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$32, %dl
	je	.LBB23_15
# BB#13:                                # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$34, %dl
	jne	.LBB23_14
# BB#19:                                # %if.then14
                                        #   in Loop: Header=BB23_1 Depth=1
	addl	$5, %eax
	jmp	.LBB23_20
.LBB23_16:                              # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$60, %dl
	je	.LBB23_18
# BB#17:                                # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$62, %dl
	jne	.LBB23_20
.LBB23_18:                              # %if.then8
                                        #   in Loop: Header=BB23_1 Depth=1
	addl	$3, %eax
	jmp	.LBB23_20
.LBB23_14:                              # %for.cond
                                        #   in Loop: Header=BB23_1 Depth=1
	cmpb	$38, %dl
	jne	.LBB23_20
.LBB23_15:                              # %if.then20
                                        #   in Loop: Header=BB23_1 Depth=1
	addl	$4, %eax
	jmp	.LBB23_20
.LBB23_3:                               # %for.end
	incl	%eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movb	(%esi), %dl
	testb	%dl, %dl
	movl	%eax, %ecx
	je	.LBB23_30
# BB#4:                                 # %for.body28.preheader
	incl	%esi
	movl	%eax, %ecx
	.align	16, 0x90
.LBB23_5:                               # %for.body28
                                        # =>This Inner Loop Header: Depth=1
	movsbl	%dl, %edi
	cmpl	$59, %edi
	jg	.LBB23_21
# BB#6:                                 # %for.body28
                                        #   in Loop: Header=BB23_5 Depth=1
	cmpl	$32, %edi
	jne	.LBB23_7
# BB#27:                                # %sw.bb51
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$38, (%ecx)
	movb	$35, 1(%ecx)
	movb	$51, 2(%ecx)
	movb	$50, 3(%ecx)
	jmp	.LBB23_10
.LBB23_21:                              # %for.body28
                                        #   in Loop: Header=BB23_5 Depth=1
	cmpl	$60, %edi
	je	.LBB23_23
# BB#22:                                # %for.body28
                                        #   in Loop: Header=BB23_5 Depth=1
	cmpl	$62, %edi
	jne	.LBB23_28
.LBB23_23:                              # %sw.bb35
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$38, (%ecx)
	movb	$108, %dl
	cmpb	$60, -1(%esi)
	je	.LBB23_25
# BB#24:                                # %sw.bb35
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$103, %dl
.LBB23_25:                              # %sw.bb35
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	%dl, 1(%ecx)
	movb	$116, 2(%ecx)
	movb	$59, 3(%ecx)
	addl	$4, %ecx
	jmp	.LBB23_29
.LBB23_7:                               # %for.body28
                                        #   in Loop: Header=BB23_5 Depth=1
	cmpl	$34, %edi
	jne	.LBB23_8
# BB#26:                                # %sw.bb44
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$38, (%ecx)
	movb	$113, 1(%ecx)
	movb	$117, 2(%ecx)
	movb	$111, 3(%ecx)
	movb	$116, 4(%ecx)
	movb	$59, 5(%ecx)
	addl	$6, %ecx
	jmp	.LBB23_29
.LBB23_8:                               # %for.body28
                                        #   in Loop: Header=BB23_5 Depth=1
	cmpl	$38, %edi
	jne	.LBB23_28
# BB#9:                                 # %sw.bb
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$38, (%ecx)
	movb	$97, 1(%ecx)
	movb	$109, 2(%ecx)
	movb	$112, 3(%ecx)
.LBB23_10:                              # %sw.bb
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	$59, 4(%ecx)
	addl	$5, %ecx
	jmp	.LBB23_29
.LBB23_28:                              # %sw.default
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	%dl, (%ecx)
	incl	%ecx
.LBB23_29:                              # %for.inc58
                                        #   in Loop: Header=BB23_5 Depth=1
	movb	(%esi), %dl
	incl	%esi
	testb	%dl, %dl
	jne	.LBB23_5
.LBB23_30:                              # %for.end60
	movb	$0, (%ecx)
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp23:
	.size	html_quote_string, .Ltmp23-html_quote_string

	.align	16, 0x90
	.type	dissociate_urls_from_file_mapper,@function
dissociate_urls_from_file_mapper:       # @dissociate_urls_from_file_mapper
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	36(%esp), %esi
	movl	%esi, (%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB24_2
# BB#1:                                 # %if.then
	movl	32(%esp), %edi
	movl	dl_url_file_map, %eax
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movl	%edi, (%esp)
	calll	checking_free
	movl	%esi, (%esp)
	calll	checking_free
.LBB24_2:                               # %if.end
	xorl	%eax, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp24:
	.size	dissociate_urls_from_file_mapper, .Ltmp24-dissociate_urls_from_file_mapper

	.align	16, 0x90
	.type	write_backup_file,@function
write_backup_file:                      # @write_backup_file
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, %ebx
	movl	%ecx, %esi
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %edi
	cmpl	$2, %ebx
	jne	.LBB25_2
# BB#1:                                 # %if.then
	leal	16(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcpy
	addl	$16, %esp
	movb	$0, (%edi,%ebx)
	movl	$1734963823, -4(%edi,%ebx) # imm = 0x6769726F
	jmp	.LBB25_3
.LBB25_2:                               # %if.else
	leal	21(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcpy
	addl	$16, %esp
	movw	$103, 4(%ebx,%edi)
	movl	$1769107246, (%edi,%ebx) # imm = 0x69726F2E
.LBB25_3:                               # %if.end
	movl	converted_files, %eax
	testl	%eax, %eax
	jne	.LBB25_5
# BB#4:                                 # %if.then8
	subl	$16, %esp
	movl	$0, (%esp)
	calll	make_string_hash_table
	addl	$16, %esp
	movl	%eax, converted_files
.LBB25_5:                               # %if.end10
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_contains
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB25_9
# BB#6:                                 # %if.then13
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	rename
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB25_8
# BB#7:                                 # %if.then16
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str24, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %edi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$32, %esp
.LBB25_8:                               # %if.end20
	movl	converted_files, %eax
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_add
	addl	$16, %esp
.LBB25_9:                               # %if.end21
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp25:
	.size	write_backup_file, .Ltmp25-write_backup_file

	.align	16, 0x90
	.type	local_quote_string,@function
local_quote_string:                     # @local_quote_string
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%edi
	pushl	%esi
	movl	%ecx, %esi
	movl	%esi, %eax
	.align	16, 0x90
.LBB26_1:                               # %while.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%eax), %cl
	cmpb	$63, %cl
	setne	%ch
	testb	%cl, %cl
	setne	%dl
	cmpb	$35, %cl
	setne	%dh
	incl	%eax
	cmpb	$37, %cl
	je	.LBB26_3
# BB#2:                                 # %while.cond.i
                                        #   in Loop: Header=BB26_1 Depth=1
	andb	%ch, %dl
	andb	%dh, %dl
	testb	%dl, %dl
	jne	.LBB26_1
.LBB26_3:                               # %__strpbrk_c3.exit
	testb	%cl, %cl
	setne	%cl
	cmpl	$1, %eax
	je	.LBB26_5
# BB#4:                                 # %__strpbrk_c3.exit
	testb	%cl, %cl
	je	.LBB26_5
# BB#6:                                 # %if.end
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	leal	16(%eax,%eax,2), %ecx
	andl	$-16, %ecx
	movl	%esp, %eax
	subl	%ecx, %eax
	movl	%eax, %esp
	movb	(%esi), %dl
	testb	%dl, %dl
	movl	%eax, %ecx
	je	.LBB26_17
# BB#7:                                 # %for.body.preheader
	incl	%esi
	movl	%eax, %ecx
	.align	16, 0x90
.LBB26_8:                               # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movsbl	%dl, %edi
	cmpl	$35, %edi
	jne	.LBB26_9
# BB#12:                                # %sw.bb43
                                        #   in Loop: Header=BB26_8 Depth=1
	movb	$37, (%ecx)
	movb	$50, 1(%ecx)
	movb	$51, 2(%ecx)
	addl	$3, %ecx
	jmp	.LBB26_16
.LBB26_9:                               # %for.body
                                        #   in Loop: Header=BB26_8 Depth=1
	cmpl	$63, %edi
	jne	.LBB26_10
# BB#13:                                # %sw.bb47
                                        #   in Loop: Header=BB26_8 Depth=1
	cmpb	$0, opt+289
	je	.LBB26_15
# BB#14:                                # %if.then49
                                        #   in Loop: Header=BB26_8 Depth=1
	movb	$37, (%ecx)
	movb	$51, 1(%ecx)
	movb	$70, 2(%ecx)
	addl	$3, %ecx
	jmp	.LBB26_16
.LBB26_10:                              # %for.body
                                        #   in Loop: Header=BB26_8 Depth=1
	cmpl	$37, %edi
	jne	.LBB26_15
# BB#11:                                # %sw.bb
                                        #   in Loop: Header=BB26_8 Depth=1
	movb	$37, (%ecx)
	movb	$50, 1(%ecx)
	movb	$53, 2(%ecx)
	addl	$3, %ecx
	jmp	.LBB26_16
.LBB26_15:                              # %sw.default
                                        #   in Loop: Header=BB26_8 Depth=1
	movb	%dl, (%ecx)
	incl	%ecx
.LBB26_16:                              # %for.inc
                                        #   in Loop: Header=BB26_8 Depth=1
	movb	(%esi), %dl
	incl	%esi
	testb	%dl, %dl
	jne	.LBB26_8
.LBB26_17:                              # %for.end
	movb	$0, (%ecx)
	subl	$16, %esp
	movl	%eax, (%esp)
	jmp	.LBB26_18
.LBB26_5:                               # %if.then
	subl	$16, %esp
	movl	%esi, (%esp)
.LBB26_18:                              # %for.end
	calll	html_quote_string
	addl	$16, %esp
	leal	-8(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebp
	ret
.Ltmp26:
	.size	local_quote_string, .Ltmp26-local_quote_string

	.align	16, 0x90
	.type	replace_attr,@function
replace_attr:                           # @replace_attr
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%ecx, %esi
	movsbl	(%esi), %ebx
	movl	52(%esp), %ebp
	movl	48(%esp), %eax
	cmpl	$34, %ebx
	je	.LBB27_3
# BB#1:                                 # %entry
	cmpb	$39, %bl
	jne	.LBB27_2
.LBB27_3:                               # %if.then
	addl	$-2, %edx
	incl	%esi
	movl	$1, 24(%esp)            # 4-byte Folded Spill
	jmp	.LBB27_4
.LBB27_2:
	movl	$0, 24(%esp)            # 4-byte Folded Spill
	movl	$34, %ebx
.LBB27_4:                               # %if.then
	movl	%edx, %edi
	movl	%edi, 20(%esp)          # 4-byte Spill
	movl	%ebx, %ecx
	movl	%ecx, 16(%esp)          # 4-byte Spill
	movl	%eax, %ebx
	movl	%ebx, 4(%esp)
	movl	%ecx, (%esp)
	calll	_IO_putc
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	leal	(%esi,%edi), %ebp
	calll	fputs
	xorb	%cl, %cl
	movl	%esi, %eax
	jmp	.LBB27_5
	.align	16, 0x90
.LBB27_10:                              # %for.inc.i
                                        #   in Loop: Header=BB27_5 Depth=1
	incl	%eax
	movb	%dl, %cl
.LBB27_5:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%ebp, %eax
	jae	.LBB27_12
# BB#6:                                 # %for.body.i
                                        #   in Loop: Header=BB27_5 Depth=1
	movsbl	(%eax), %edi
	movb	$1, %dl
	cmpl	$38, %edi
	je	.LBB27_10
# BB#7:                                 # %for.body.i
                                        #   in Loop: Header=BB27_5 Depth=1
	cmpl	$35, %edi
	jne	.LBB27_9
# BB#8:                                 # %sw.bb1.i
                                        #   in Loop: Header=BB27_5 Depth=1
	testb	$1, %cl
	je	.LBB27_11
.LBB27_9:                               # %sw.default.i
                                        #   in Loop: Header=BB27_5 Depth=1
	xorb	%dl, %dl
	jmp	.LBB27_10
.LBB27_11:                              # %if.then8
	movl	%ebx, 12(%esp)
	subl	%eax, %ebp
	movl	%ebp, 8(%esp)
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	fwrite
.LBB27_12:                              # %if.end10
	movl	%ebx, 4(%esp)
	movl	16(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	addl	24(%esp), %eax          # 4-byte Folded Reload
	addl	%eax, %esi
	calll	_IO_putc
	movl	%esi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp27:
	.size	replace_attr, .Ltmp27-replace_attr

	.align	16, 0x90
	.type	replace_attr_refresh_hack,@function
replace_attr_refresh_hack:              # @replace_attr_refresh_hack
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, -16(%ebp)         # 4-byte Spill
	movl	%ecx, -20(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	16(%ebp), %esi
	movl	%esi, %eax
	sarl	$31, %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	numdigit
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	12(%ebp), %edi
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	leal	22(%ebx,%eax), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	%esi, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str19, 4(%esp)
	calll	sprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	-20(%ebp), %ecx         # 4-byte Reload
	movl	-16(%ebp), %edx         # 4-byte Reload
	calll	replace_attr
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp28:
	.size	replace_attr_refresh_hack, .Ltmp28-replace_attr_refresh_hack

	.globl	cookie_jar_new
	.align	16, 0x90
	.type	cookie_jar_new,@function
cookie_jar_new:                         # @cookie_jar_new
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	$8, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	$0, (%esp)
	calll	make_nocase_string_hash_table
	movl	%eax, (%esi)
	movl	$0, 4(%esi)
	movl	%esi, %eax
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp29:
	.size	cookie_jar_new, .Ltmp29-cookie_jar_new

	.globl	cookie_handle_set_cookie
	.align	16, 0x90
	.type	cookie_handle_set_cookie,@function
cookie_handle_set_cookie:               # @cookie_handle_set_cookie
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	subl	$16, %esp
	movl	$0, (%esp)
	calll	time
	addl	$16, %esp
	movl	%eax, cookies_now
	subl	$16, %esp
	movl	20(%ebp), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$17, %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	movl	%ecx, %edx
	subl	%eax, %edx
	movl	%edx, -28(%ebp)         # 4-byte Spill
	movl	%edx, %esp
	negl	%eax
	movb	$47, (%ecx,%eax)
	subl	$16, %esp
	movl	%esi, 4(%esp)
	leal	1(%edx), %eax
	movl	%eax, (%esp)
	calll	strcpy
	addl	$16, %esp
	movl	24(%ebp), %ecx
	calll	parse_set_cookie
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB30_72
# BB#1:                                 # %if.end
	movl	12(%ebp), %ebx
	movl	(%edi), %esi
	testl	%esi, %esi
	je	.LBB30_2
# BB#5:                                 # %if.else
	movl	%edi, -24(%ebp)         # 4-byte Spill
	cmpb	$0, opt+250
	jne	.LBB30_6
	.align	16, 0x90
.LBB30_7:                               # %do.end.i
	movl	%esi, %ecx
	calll	numeric_address_p
	testb	%al, %al
	je	.LBB30_8
# BB#44:                                # %check_domain_match.exit
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_41
	jmp	.LBB30_45
.LBB30_8:                               # %do.body6.i
	cmpb	$0, opt+250
	jne	.LBB30_9
	.align	16, 0x90
.LBB30_10:                              # %do.end13.i
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_41
# BB#11:                                # %do.body19.i
	cmpb	$0, opt+250
	jne	.LBB30_12
	.align	16, 0x90
.LBB30_13:                              # %do.end26.i
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, 8(%esp)
	calll	match_tail
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB30_45
# BB#14:                                # %if.end29.i
	movl	%esi, -20(%ebp)         # 4-byte Spill
	leal	1(%esi), %ebx
	cmpb	$46, (%esi)
	cmovnel	%esi, %ebx
	cmpb	$0, opt+250
	jne	.LBB30_15
	.align	16, 0x90
.LBB30_16:                              # %for.cond.i.preheader
	incl	%ebx
	movl	$1, %esi
	xorl	%ecx, %ecx
	xorl	%edi, %edi
	xorl	%edx, %edx
	jmp	.LBB30_17
	.align	16, 0x90
.LBB30_23:                              # %for.inc.i
                                        #   in Loop: Header=BB30_17 Depth=1
	incl	%ebx
	.align	16, 0x90
.LBB30_17:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	testl	%edx, %edx
	jne	.LBB30_24
# BB#18:                                # %for.body.i
                                        #   in Loop: Header=BB30_17 Depth=1
	movsbl	-1(%ebx), %eax
	movl	$1, %edx
	testl	%eax, %eax
	je	.LBB30_23
# BB#19:                                # %for.body.i
                                        #   in Loop: Header=BB30_17 Depth=1
	cmpl	$46, %eax
	jne	.LBB30_22
# BB#20:                                # %sw.bb45.i
                                        #   in Loop: Header=BB30_17 Depth=1
	testl	%ecx, %ecx
	je	.LBB30_45
# BB#21:                                # %if.end49.i
                                        #   in Loop: Header=BB30_17 Depth=1
	cmpb	$0, (%ebx)
	cmovnel	%ecx, %edi
	movl	$0, %eax
	cmovnel	%eax, %ecx
	sete	%al
	movzbl	%al, %edx
	movl	%edx, %eax
	xorl	$1, %eax
	addl	%eax, %esi
	incl	%ebx
	jmp	.LBB30_17
.LBB30_22:                              # %sw.default.i
                                        #   in Loop: Header=BB30_17 Depth=1
	incl	%ecx
	xorl	%edx, %edx
	jmp	.LBB30_23
.LBB30_24:                              # %do.body57.i
	cmpb	$0, opt+250
	jne	.LBB30_25
	.align	16, 0x90
.LBB30_26:                              # %do.end64.i
	cmpl	$2, %esi
	jl	.LBB30_45
# BB#27:                                # %do.body69.i
	cmpb	$0, opt+250
	jne	.LBB30_28
	.align	16, 0x90
.LBB30_29:                              # %do.end76.i
	cmpl	$2, %esi
	jne	.LBB30_34
# BB#30:
	xorl	%esi, %esi
	.align	16, 0x90
.LBB30_31:                              # %for.cond80.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$6, %esi
	ja	.LBB30_33
# BB#32:                                # %for.body83.i
                                        #   in Loop: Header=BB30_31 Depth=1
	subl	$16, %esp
	movl	check_domain_match.known_toplevel_domains(,%esi,4), %eax
	movl	%eax, 4(%esp)
	movl	-20(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$1, 8(%esp)
	incl	%esi
	calll	match_tail
	addl	$16, %esp
	testb	%al, %al
	je	.LBB30_31
	jmp	.LBB30_34
.LBB30_6:                               # %if.then.i
	subl	$16, %esp
	movl	$.L.str31, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_7
.LBB30_9:                               # %if.then11.i
	subl	$16, %esp
	movl	$.L.str32, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_10
.LBB30_12:                              # %if.then24.i
	subl	$16, %esp
	movl	$.L.str3357, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_13
.LBB30_33:                              # %land.lhs.true.critedge.i
	cmpl	$4, %edi
	jl	.LBB30_45
.LBB30_34:                              # %do.body96.i
	cmpb	$0, opt+250
	jne	.LBB30_35
	.align	16, 0x90
.LBB30_36:                              # %do.end103.i
	movl	-20(%ebp), %eax         # 4-byte Reload
	cmpb	$46, (%eax)
	je	.LBB30_39
# BB#37:                                # %if.then107.i
	subl	$16, %esp
	movl	-20(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	12(%ebp), %eax
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	cmpl	%ebx, %eax
	jle	.LBB30_39
# BB#38:                                # %land.lhs.true112.i
	notl	%ebx
	addl	%eax, %ebx
	movl	12(%ebp), %eax
	cmpb	$46, (%eax,%ebx)
	jne	.LBB30_45
.LBB30_39:                              # %do.body121.i
	cmpb	$0, opt+250
	je	.LBB30_41
# BB#40:                                # %if.then126.i
	subl	$16, %esp
	movl	$.L.str45, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_41
.LBB30_45:                              # %if.then15
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str33, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -20(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	12(%ebp), %ebx
	movl	%ebx, (%esp)
	calll	escnonprint
	addl	$16, %esp
	movl	%eax, %edi
	movl	-24(%ebp), %esi         # 4-byte Reload
	movl	(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, %edi
	movl	-20(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB30_2:                               # %copy_domain
	movl	%edi, -24(%ebp)         # 4-byte Spill
	movl	16(%ebp), %esi
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, (%edi)
	orb	$4, 12(%edi)
	cmpl	$80, %esi
	je	.LBB30_41
# BB#3:                                 # %copy_domain
	cmpl	$443, %esi              # imm = 0x1BB
	je	.LBB30_41
# BB#4:                                 # %if.then10
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	%esi, 4(%eax)
.LBB30_41:                              # %if.end22
	movl	-24(%ebp), %edi         # 4-byte Reload
	movl	8(%edi), %esi
	subl	$16, %esp
	testl	%esi, %esi
	je	.LBB30_42
# BB#57:                                # %if.else36
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	strncmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB30_59
# BB#58:                                # %if.else36
	cmpl	$-1, %ebx
	jne	.LBB30_48
.LBB30_59:                              # %do.body40
	cmpb	$0, opt+250
	movl	-28(%ebp), %eax         # 4-byte Reload
	je	.LBB30_71
# BB#60:                                # %if.then43
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str134, (%esp)
	.align	16, 0x90
.LBB30_70:                              # %if.then22.i
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_71
.LBB30_42:                              # %if.then25
	movl	-28(%ebp), %esi         # 4-byte Reload
	movl	%esi, (%esp)
	movl	$47, 4(%esp)
	calll	strrchr
	addl	$16, %esp
	subl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_46
# BB#43:                                # %if.then28
	incl	%eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	strdupdelim
	jmp	.LBB30_47
.LBB30_46:                              # %if.else32
	movl	%esi, (%esp)
	calll	checking_strdup
.LBB30_47:                              # %if.else32
	addl	$16, %esp
	movl	%eax, 8(%edi)
.LBB30_48:                              # %if.end48
	testb	$1, 12(%edi)
	je	.LBB30_74
# BB#49:                                # %if.then51
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	hash_table_count
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_71
# BB#50:                                # %if.end.i
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	movl	(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_71
# BB#51:                                # %if.end.i.i
	xorl	%esi, %esi
	jmp	.LBB30_52
	.align	16, 0x90
.LBB30_56:                              # %for.inc.i.i
                                        #   in Loop: Header=BB30_52 Depth=1
	movl	28(%ebx), %eax
	movl	%ebx, %esi
.LBB30_52:                              # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ebx
	testl	%ebx, %ebx
	je	.LBB30_71
# BB#53:                                # %for.body.i.i
                                        #   in Loop: Header=BB30_52 Depth=1
	movl	8(%edi), %eax
	movl	8(%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB30_56
# BB#54:                                # %land.lhs.true.i.i
                                        #   in Loop: Header=BB30_52 Depth=1
	movl	20(%edi), %eax
	movl	20(%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB30_56
# BB#55:                                # %land.lhs.true9.i.i
                                        #   in Loop: Header=BB30_52 Depth=1
	movl	4(%edi), %eax
	cmpl	4(%ebx), %eax
	jne	.LBB30_56
# BB#61:                                # %if.then3.i
	testl	%esi, %esi
	je	.LBB30_63
# BB#62:                                # %if.then5.i
	movl	28(%ebx), %eax
	movl	%eax, 28(%esi)
	jmp	.LBB30_68
.LBB30_74:                              # %if.end52
	movl	8(%ebp), %ecx
	movl	%edi, %edx
	calll	store_cookie
	jmp	.LBB30_72
.LBB30_63:                              # %if.else.i
	movl	$0, -16(%ebp)
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	movl	(%ebx), %ecx
	subl	$16, %esp
	leal	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	calll	hash_table_get_pair
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB30_73
# BB#64:                                # %cond.end.i
	movl	(%esi), %eax
	movl	28(%ebx), %ecx
	testl	%ecx, %ecx
	je	.LBB30_65
# BB#66:                                # %if.else15.i
	movl	-16(%ebp), %edx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_put
	jmp	.LBB30_67
.LBB30_15:                              # %if.then40.i
	subl	$16, %esp
	movl	$.L.str34, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_16
.LBB30_25:                              # %if.then62.i
	subl	$16, %esp
	movl	$.L.str35, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_26
.LBB30_28:                              # %if.then74.i
	subl	$16, %esp
	movl	$.L.str36, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_29
.LBB30_35:                              # %if.then101.i
	subl	$16, %esp
	movl	$.L.str44, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB30_36
.LBB30_65:                              # %if.then11.i63
	movl	(%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	addl	$16, %esp
	movl	-16(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
.LBB30_67:                              # %if.else15.i
	addl	$16, %esp
.LBB30_68:                              # %if.end19.i
	movl	%ebx, %ecx
	calll	delete_cookie
	cmpb	$0, opt+250
	jne	.LBB30_69
.LBB30_71:                              # %if.then54
	movl	%edi, %ecx
	calll	delete_cookie
.LBB30_72:                              # %if.end55
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB30_73:                              # %cond.false.i
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.discard_matching_cookie, 12(%esp)
	movl	$304, 8(%esp)           # imm = 0x130
	movl	$.L.str336, 4(%esp)
	movl	$.L.str29, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB30_69:                              # %if.then22.i
	subl	$16, %esp
	movl	$.L.str30, (%esp)
	jmp	.LBB30_70
.Ltmp30:
	.size	cookie_handle_set_cookie, .Ltmp30-cookie_handle_set_cookie

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI31_0:
	.quad	-4616189618054758400    # double -1.000000e+00
                                        #  (0x0)
.LCPI31_1:
	.quad	0                       # double 0.000000e+00
                                        #  (0x0)
	.text
	.align	16, 0x90
	.type	parse_set_cookie,@function
parse_set_cookie:                       # @parse_set_cookie
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	%ecx, -44(%ebp)         # 4-byte Spill
	movl	%ecx, -16(%ebp)
	subl	$16, %esp
	movl	$32, (%esp)
	calll	checking_malloc0
	addl	$16, %esp
	movl	%eax, %esi
	movl	$-1, 4(%esi)
	subl	$16, %esp
	leal	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$59, 12(%esp)
	calll	extract_param
	addl	$16, %esp
	testb	%al, %al
	je	.LBB31_37
# BB#1:                                 # %if.end
	cmpl	$0, -32(%ebp)
	je	.LBB31_37
# BB#2:                                 # %if.end3
	movl	-24(%ebp), %eax
	movl	-20(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, 20(%esi)
	movl	-32(%ebp), %eax
	movl	-28(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, 24(%esi)
	jmp	.LBB31_3
	.align	16, 0x90
.LBB31_12:                              # %if.end34
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-28(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, (%esi)
	.align	16, 0x90
.LBB31_3:                               # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	subl	$16, %esp
	leal	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$59, 12(%esp)
	calll	extract_param
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB31_36
# BB#4:                                 # %while.body
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-24(%ebp), %ebx
	movl	-20(%ebp), %edi
	subl	%ebx, %edi
	cmpl	$6, %edi
	jne	.LBB31_13
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$6, 8(%esp)
	movl	$.L.str46, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB31_33
# BB#6:                                 # %if.then16
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-32(%ebp), %eax
	testl	%eax, %eax
	je	.LBB31_37
# BB#7:                                 # %land.lhs.true19
                                        #   in Loop: Header=BB31_3 Depth=1
	cmpl	-28(%ebp), %eax
	je	.LBB31_37
# BB#8:                                 # %if.end24
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	(%esi), %ecx
	testl	%ecx, %ecx
	je	.LBB31_10
# BB#9:                                 # %if.else
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-32(%ebp), %eax
.LBB31_10:                              # %if.end28
                                        #   in Loop: Header=BB31_3 Depth=1
	cmpb	$46, (%eax)
	jne	.LBB31_12
# BB#11:                                # %if.then32
                                        #   in Loop: Header=BB31_3 Depth=1
	incl	%eax
	movl	%eax, -32(%ebp)
	jmp	.LBB31_12
.LBB31_13:                              # %if.else39
                                        #   in Loop: Header=BB31_3 Depth=1
	cmpl	$7, %edi
	jne	.LBB31_14
# BB#21:                                # %land.lhs.true79
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$7, 8(%esp)
	movl	$.L.str48, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB31_27
# BB#22:                                # %if.then83
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-32(%ebp), %eax
	testl	%eax, %eax
	je	.LBB31_37
# BB#23:                                # %land.lhs.true87
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-28(%ebp), %edi
	cmpl	%edi, %eax
	je	.LBB31_37
# BB#24:                                # %do.body
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	%eax, %edi
	leal	16(%edi), %ecx
	andl	$-16, %ecx
	movl	%esp, %ebx
	subl	%ecx, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%edi,%ebx)
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	http_atotm
	addl	$16, %esp
	cmpl	$-1, %eax
	je	.LBB31_3
# BB#25:                                # %if.then102
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	12(%esi), %ecx
	movl	%ecx, %edx
	orl	$8, %edx
	movl	%edx, 12(%esi)
	movl	%eax, 16(%esi)
	cmpl	cookies_now, %eax
	jge	.LBB31_3
# BB#26:                                # %if.then106
                                        #   in Loop: Header=BB31_3 Depth=1
	orl	$9, %ecx
	movl	%ecx, 12(%esi)
	jmp	.LBB31_3
.LBB31_14:                              # %if.else39
                                        #   in Loop: Header=BB31_3 Depth=1
	cmpl	$4, %edi
	jne	.LBB31_3
# BB#15:                                # %land.lhs.true47
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str47, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB31_33
# BB#16:                                # %if.then51
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-32(%ebp), %eax
	testl	%eax, %eax
	je	.LBB31_37
# BB#17:                                # %land.lhs.true55
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-28(%ebp), %ecx
	cmpl	%ecx, %eax
	je	.LBB31_37
# BB#18:                                # %if.end61
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	8(%esi), %edx
	testl	%edx, %edx
	je	.LBB31_20
# BB#19:                                # %if.else64
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%edx, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-32(%ebp), %eax
	movl	-28(%ebp), %ecx
.LBB31_20:                              # %if.end66
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, 8(%esi)
	jmp	.LBB31_3
.LBB31_27:                              # %land.lhs.true119
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$7, 8(%esp)
	movl	$.L.str49, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB31_33
# BB#28:                                # %if.then123
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	$-1074790400, -36(%ebp) # imm = 0xFFFFFFFFBFF00000
	movl	$0, -40(%ebp)
	movl	-32(%ebp), %eax
	testl	%eax, %eax
	je	.LBB31_37
# BB#29:                                # %land.lhs.true128
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	-28(%ebp), %edi
	cmpl	%edi, %eax
	je	.LBB31_37
# BB#30:                                # %do.body135
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	%eax, %edi
	leal	16(%edi), %ecx
	andl	$-16, %ecx
	movl	%esp, %ebx
	subl	%ecx, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%edi,%ebx)
	subl	$16, %esp
	leal	-40(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str841, 4(%esp)
	calll	sscanf
	addl	$16, %esp
	movsd	-40(%ebp), %xmm0
	ucomisd	.LCPI31_0, %xmm0
	jne	.LBB31_31
	jnp	.LBB31_37
.LBB31_31:                              # %if.end151
                                        #   in Loop: Header=BB31_3 Depth=1
	movl	12(%esi), %eax
	movl	%eax, %ecx
	orl	$8, %ecx
	movl	%ecx, 12(%esi)
	movsd	-40(%ebp), %xmm0
	cvtsi2sd	cookies_now, %xmm1
	addsd	%xmm0, %xmm1
	cvttsd2si	%xmm1, %ecx
	movl	%ecx, 16(%esi)
	ucomisd	.LCPI31_1, %xmm0
	jne	.LBB31_3
	jp	.LBB31_3
# BB#32:                                # %if.then159
                                        #   in Loop: Header=BB31_3 Depth=1
	orl	$9, %eax
	movl	%eax, 12(%esi)
	jmp	.LBB31_3
.LBB31_33:                              # %if.else162
                                        #   in Loop: Header=BB31_3 Depth=1
	cmpl	$6, %edi
	jne	.LBB31_3
# BB#34:                                # %land.lhs.true170
                                        #   in Loop: Header=BB31_3 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$6, 8(%esp)
	movl	$.L.str26, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB31_3
# BB#35:                                # %if.then174
                                        #   in Loop: Header=BB31_3 Depth=1
	orb	$2, 12(%esi)
	jmp	.LBB31_3
.LBB31_36:                              # %while.end
	movl	-16(%ebp), %eax
	cmpb	$0, (%eax)
	je	.LBB31_38
.LBB31_37:                              # %if.then186
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str50, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	-44(%ebp), %edi         # 4-byte Reload
	movl	%edi, (%esp)
	calll	escnonprint
	addl	$16, %esp
	movl	-16(%ebp), %ecx
	subl	%edi, %ecx
	subl	$16, %esp
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	%esi, %ecx
	calll	delete_cookie
	xorl	%esi, %esi
.LBB31_38:                              # %return
	movl	%esi, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp31:
	.size	parse_set_cookie, .Ltmp31-parse_set_cookie

	.align	16, 0x90
	.type	store_cookie,@function
store_cookie:                           # @store_cookie
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	%edx, %esi
	movl	%ecx, %edi
	movl	(%edi), %eax
	movl	(%esi), %ecx
	leal	56(%esp), %edx
	movl	%edx, 12(%esp)
	leal	52(%esp), %edx
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get_pair
	testl	%eax, %eax
	je	.LBB32_13
# BB#1:                                 # %if.then
	movl	(%edi), %eax
	movl	(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	testl	%eax, %eax
	je	.LBB32_12
# BB#2:                                 # %if.end.i
	xorl	%ebp, %ebp
	jmp	.LBB32_3
	.align	16, 0x90
.LBB32_7:                               # %for.inc.i
                                        #   in Loop: Header=BB32_3 Depth=1
	movl	28(%ebx), %eax
	movl	%ebx, %ebp
.LBB32_3:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ebx
	testl	%ebx, %ebx
	je	.LBB32_12
# BB#4:                                 # %for.body.i
                                        #   in Loop: Header=BB32_3 Depth=1
	movl	8(%esi), %eax
	movl	8(%ebx), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB32_7
# BB#5:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB32_3 Depth=1
	movl	20(%esi), %eax
	movl	20(%ebx), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB32_7
# BB#6:                                 # %land.lhs.true9.i
                                        #   in Loop: Header=BB32_3 Depth=1
	movl	4(%esi), %eax
	cmpl	4(%ebx), %eax
	jne	.LBB32_7
# BB#8:                                 # %if.then3
	movl	28(%ebx), %eax
	testl	%ebp, %ebp
	je	.LBB32_10
# BB#9:                                 # %if.then5
	movl	%eax, 28(%ebp)
	movl	56(%esp), %eax
.LBB32_10:                              # %if.else
	movl	%eax, 28(%esi)
	movl	%ebx, %ecx
	calll	delete_cookie
	decl	4(%edi)
	cmpb	$0, opt+250
	je	.LBB32_14
# BB#11:                                # %if.then12
	movl	$.L.str20, (%esp)
	calll	debug_logprintf
	jmp	.LBB32_14
.LBB32_12:                              # %if.else14
	movl	56(%esp), %eax
	movl	%eax, 28(%esi)
	jmp	.LBB32_14
.LBB32_13:                              # %if.else17
	movl	$0, 28(%esi)
	movl	(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, 52(%esp)
.LBB32_14:                              # %if.end21
	movl	(%edi), %eax
	movl	52(%esp), %ecx
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_put
	incl	4(%edi)
	cmpb	$0, opt+250
	jne	.LBB32_15
	.align	16, 0x90
.LBB32_18:                              # %if.end50
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB32_15:                              # %if.then28
	movl	(%esi), %eax
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	4(%esi), %ecx
	movl	%ecx, 44(%esp)          # 4-byte Spill
	movl	$.L.str2254, %eax
	cmpl	$-1, %ecx
	movl	$.L.str2355, %ebp
	cmovel	%eax, %ebp
	movl	12(%esi), %eax
	movl	%eax, %ecx
	andl	$2, %ecx
	shrl	%ecx
	movl	$.L.str26, %edx
	testl	%ecx, %ecx
	movl	$.L.str27, %edi
	cmovnel	%edx, %edi
	andl	$8, %eax
	shrl	$3, %eax
	movl	$.L.str2456, %ecx
	testl	%eax, %eax
	movl	$.L.str25, %ebx
	cmovnel	%ecx, %ebx
	movl	8(%esi), %eax
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	16(%esi), %ecx
	movl	$.L.str28, %eax
	testl	%ecx, %ecx
	je	.LBB32_17
# BB#16:                                # %cond.true
	movl	%ecx, (%esp)
	calll	datetime_str
.LBB32_17:                              # %cond.end
	movl	20(%esi), %ecx
	movl	24(%esi), %edx
	movl	%edx, 36(%esp)
	movl	%ecx, 32(%esp)
	movl	%eax, 28(%esp)
	movl	%edi, 24(%esp)
	movl	%ebx, 20(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 16(%esp)
	movl	%ebp, 12(%esp)
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str2153, (%esp)
	calll	debug_logprintf
	jmp	.LBB32_18
.Ltmp32:
	.size	store_cookie, .Ltmp32-store_cookie

	.align	16, 0x90
	.type	delete_cookie,@function
delete_cookie:                          # @delete_cookie
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	%ecx, %esi
	movl	(%esi), %eax
	testl	%eax, %eax
	je	.LBB33_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB33_2:                               # %if.end
	movl	8(%esi), %eax
	testl	%eax, %eax
	je	.LBB33_4
# BB#3:                                 # %if.else4
	movl	%eax, (%esp)
	calll	checking_free
.LBB33_4:                               # %if.end6
	movl	20(%esi), %eax
	testl	%eax, %eax
	je	.LBB33_6
# BB#5:                                 # %if.else9
	movl	%eax, (%esp)
	calll	checking_free
.LBB33_6:                               # %if.end11
	movl	24(%esi), %eax
	testl	%eax, %eax
	je	.LBB33_8
# BB#7:                                 # %if.else14
	movl	%eax, (%esp)
	calll	checking_free
.LBB33_8:                               # %if.end16
	movl	%esi, (%esp)
	calll	checking_free
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp33:
	.size	delete_cookie, .Ltmp33-delete_cookie

	.globl	cookie_header
	.align	16, 0x90
	.type	cookie_header,@function
cookie_header:                          # @cookie_header
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	subl	$16, %esp
	movl	20(%ebp), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$17, %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	movl	%ecx, %edi
	subl	%eax, %edi
	movl	%edi, %esp
	negl	%eax
	movb	$47, (%ecx,%eax)
	subl	$16, %esp
	movl	%esi, 4(%esp)
	leal	1(%edi), %eax
	movl	%eax, (%esp)
	calll	strcpy
	addl	$16, %esp
	xorl	%eax, %eax
	movl	12(%ebp), %edx
	movl	%edx, %ecx
	movl	%edx, %esi
	jmp	.LBB34_1
	.align	16, 0x90
.LBB34_4:                               # %for.inc.i
                                        #   in Loop: Header=BB34_1 Depth=1
	incl	%ecx
.LBB34_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB34_5
# BB#2:                                 # %for.cond.i
                                        #   in Loop: Header=BB34_1 Depth=1
	cmpb	$46, %dl
	jne	.LBB34_4
# BB#3:                                 # %if.then.i
                                        #   in Loop: Header=BB34_1 Depth=1
	incl	%eax
	jmp	.LBB34_4
.LBB34_5:                               # %count_char.exit
	leal	19(,%eax,4), %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	subl	%eax, %ecx
	movl	%ecx, -36(%ebp)         # 4-byte Spill
	movl	%ecx, %esp
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	hash_table_count
	xorl	%ecx, %ecx
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB34_52
# BB#6:                                 # %if.end.i
	movl	%edi, -24(%ebp)         # 4-byte Spill
	movl	%esi, %ecx
	calll	numeric_address_p
	movl	%esi, %edx
	movl	$1, -20(%ebp)           # 4-byte Folded Spill
	testb	%al, %al
	jne	.LBB34_10
# BB#7:
	xorl	%esi, %esi
	movl	%edx, %eax
	jmp	.LBB34_8
	.align	16, 0x90
.LBB34_17:                              # %for.inc.i.i
                                        #   in Loop: Header=BB34_8 Depth=1
	incl	%eax
.LBB34_8:                               # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB34_9
# BB#15:                                # %for.cond.i.i
                                        #   in Loop: Header=BB34_8 Depth=1
	cmpb	$46, %cl
	jne	.LBB34_17
# BB#16:                                # %if.then.i.i
                                        #   in Loop: Header=BB34_8 Depth=1
	incl	%esi
	jmp	.LBB34_17
.LBB34_9:
	movl	%esi, -20(%ebp)         # 4-byte Spill
.LBB34_10:                              # %if.end4.i
	xorl	%esi, %esi
	movl	%esi, %ebx
	movl	%edx, %edi
	jmp	.LBB34_11
	.align	16, 0x90
.LBB34_14:                              # %if.end12.i106
                                        #   in Loop: Header=BB34_11 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$46, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movl	%eax, %edi
	incl	%edi
.LBB34_11:                              # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB34_13
# BB#12:                                # %if.then8.i
                                        #   in Loop: Header=BB34_11 Depth=1
	movl	-36(%ebp), %ecx         # 4-byte Reload
	movl	%eax, (%ecx,%ebx,4)
	incl	%ebx
.LBB34_13:                              # %if.end9.i
                                        #   in Loop: Header=BB34_11 Depth=1
	incl	%esi
	cmpl	-20(%ebp), %esi         # 4-byte Folded Reload
	jl	.LBB34_14
# BB#18:                                # %find_chains_of_host.exit
	xorl	%ecx, %ecx
	movl	%ebx, %edi
	movl	%edi, -40(%ebp)         # 4-byte Spill
	testl	%edi, %edi
	movl	16(%ebp), %esi
	je	.LBB34_52
# BB#19:                                # %if.end
	subl	$16, %esp
	movl	$0, (%esp)
	calll	time
	addl	$16, %esp
	movl	%eax, cookies_now
	xorl	%ecx, %ecx
	testl	%edi, %edi
	jle	.LBB34_52
# BB#20:
	xorl	%edx, %edx
	.align	16, 0x90
.LBB34_21:                              # %for.body
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB34_22 Depth 2
	movl	%ecx, -20(%ebp)         # 4-byte Spill
	movl	-36(%ebp), %eax         # 4-byte Reload
	movl	(%eax,%ecx,4), %ebx
	testl	%ebx, %ebx
	movl	%edx, %edi
	je	.LBB34_23
	.align	16, 0x90
.LBB34_22:                              # %for.body9
                                        #   Parent Loop BB34_21 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	subl	$16, %esp
	movzbl	24(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 12(%esp)
	movl	%ebx, %ecx
	movl	12(%ebp), %edx
	calll	cookie_matches_url
	addl	$16, %esp
	movzbl	%al, %eax
	addl	%eax, %edi
	movl	28(%ebx), %ebx
	testl	%ebx, %ebx
	jne	.LBB34_22
.LBB34_23:                              # %for.inc14
                                        #   in Loop: Header=BB34_21 Depth=1
	movl	%edi, %edx
	movl	-20(%ebp), %ecx         # 4-byte Reload
	incl	%ecx
	movl	-40(%ebp), %edi         # 4-byte Reload
	cmpl	%edi, %ecx
	jne	.LBB34_21
# BB#24:                                # %for.end16
	xorl	%ecx, %ecx
	testl	%edx, %edx
	je	.LBB34_52
# BB#25:                                # %if.end19
	movl	%edx, -48(%ebp)         # 4-byte Spill
	imull	$12, %edx, %eax
	movl	%eax, -32(%ebp)         # 4-byte Spill
	leal	15(%eax), %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	subl	%eax, %ecx
	movl	%ecx, -28(%ebp)         # 4-byte Spill
	movl	%ecx, %esp
	xorl	%ebx, %ebx
	testl	%edi, %edi
	jle	.LBB34_32
# BB#26:
	movl	%ebx, %edi
	movb	24(%ebp), %al
	movl	12(%ebp), %edx
	.align	16, 0x90
.LBB34_27:                              # %for.body23
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB34_28 Depth 2
	movl	%edi, -44(%ebp)         # 4-byte Spill
	movl	-36(%ebp), %ecx         # 4-byte Reload
	movl	(%ecx,%edi,4), %edi
	testl	%edi, %edi
	je	.LBB34_31
	.align	16, 0x90
.LBB34_28:                              # %for.body27
                                        #   Parent Loop BB34_27 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	subl	$16, %esp
	leal	-16(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movzbl	%al, %eax
	movl	%eax, 8(%esp)
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	%edi, %ecx
	calll	cookie_matches_url
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB34_30
# BB#29:                                # %if.end31
                                        #   in Loop: Header=BB34_28 Depth=2
	movl	%ebx, -20(%ebp)         # 4-byte Spill
	imull	$12, -20(%ebp), %ebx    # 4-byte Folded Reload
	movl	-28(%ebp), %esi         # 4-byte Reload
	movl	%edi, (%esi,%ebx)
	movl	(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, 4(%esi,%ebx)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esi,%ebx)
	movl	-20(%ebp), %ebx         # 4-byte Reload
	movl	16(%ebp), %esi
	incl	%ebx
.LBB34_30:                              # %for.inc38
                                        #   in Loop: Header=BB34_28 Depth=2
	movl	28(%edi), %edi
	testl	%edi, %edi
	movb	24(%ebp), %al
	movl	12(%ebp), %edx
	jne	.LBB34_28
.LBB34_31:                              # %for.inc41
                                        #   in Loop: Header=BB34_27 Depth=1
	movl	-44(%ebp), %edi         # 4-byte Reload
	incl	%edi
	movl	-40(%ebp), %ecx         # 4-byte Reload
	cmpl	%ecx, %edi
	jne	.LBB34_27
.LBB34_32:                              # %for.end43
	movl	-48(%ebp), %eax         # 4-byte Reload
	subl	$16, %esp
	cmpl	%eax, %ebx
	jne	.LBB34_53
# BB#33:                                # %cond.end
	movl	%eax, 4(%esp)
	movl	-28(%ebp), %esi         # 4-byte Reload
	movl	%esi, (%esp)
	movl	$equality_comparator, 12(%esp)
	movl	$12, 8(%esp)
	movl	%eax, %edi
	calll	qsort
	addl	$16, %esp
	testl	%edi, %edi
	movl	-32(%ebp), %ecx         # 4-byte Reload
	jle	.LBB34_43
# BB#34:                                # %for.body.lr.ph.i
	movl	-28(%ebp), %eax         # 4-byte Reload
	leal	(%eax,%ecx), %edx
	movl	%edx, -20(%ebp)         # 4-byte Spill
	addl	$-12, %ecx
	movl	%eax, %esi
	movl	%eax, %edi
	jmp	.LBB34_35
	.align	16, 0x90
.LBB34_38:                              #   in Loop: Header=BB34_35 Depth=1
	movl	-32(%ebp), %ecx         # 4-byte Reload
	movl	-24(%ebp), %esi         # 4-byte Reload
	jmp	.LBB34_42
	.align	16, 0x90
.LBB34_35:                              # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, -24(%ebp)         # 4-byte Spill
	movl	%ecx, -32(%ebp)         # 4-byte Spill
	testl	%ecx, %ecx
	je	.LBB34_39
# BB#36:                                # %if.then.i98
                                        #   in Loop: Header=BB34_35 Depth=1
	movl	(%edi), %ebx
	movl	12(%edi), %esi
	movl	20(%ebx), %eax
	movl	20(%esi), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB34_39
# BB#37:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB34_35 Depth=1
	movl	24(%ebx), %eax
	movl	24(%esi), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB34_38
.LBB34_39:                              # %if.end12.i
                                        #   in Loop: Header=BB34_35 Depth=1
	movl	-24(%ebp), %edx         # 4-byte Reload
	leal	12(%edx), %eax
	cmpl	%edx, %edi
	je	.LBB34_41
# BB#40:                                # %if.then14.i
                                        #   in Loop: Header=BB34_35 Depth=1
	movl	8(%edi), %ecx
	movl	%ecx, 8(%edx)
	movsd	(%edi), %xmm0
	movsd	%xmm0, (%edx)
.LBB34_41:                              # %if.then14.i
                                        #   in Loop: Header=BB34_35 Depth=1
	movl	%eax, %esi
	movl	-32(%ebp), %ecx         # 4-byte Reload
.LBB34_42:                              # %for.inc.i100
                                        #   in Loop: Header=BB34_35 Depth=1
	addl	$-12, %ecx
	addl	$12, %edi
	cmpl	-20(%ebp), %edi         # 4-byte Folded Reload
	jb	.LBB34_35
.LBB34_43:                              # %eliminate_dups.exit
	subl	$16, %esp
	movl	-28(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	subl	%eax, %esi
	movl	%esi, -24(%ebp)         # 4-byte Spill
	movl	%esi, %eax
	sarl	$2, %eax
	imull	$-1431655765, %eax, %eax # imm = 0xFFFFFFFFAAAAAAAB
	movl	%eax, -36(%ebp)         # 4-byte Spill
	movl	%eax, 4(%esp)
	movl	$goodness_comparator, 12(%esp)
	movl	$12, 8(%esp)
	calll	qsort
	addl	$16, %esp
	movl	$0, -32(%ebp)           # 4-byte Folded Spill
	testl	%esi, %esi
	movl	$0, %eax
	jle	.LBB34_46
# BB#44:
	movl	-28(%ebp), %edi         # 4-byte Reload
	xorl	%eax, %eax
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB34_45:                              # %for.body48
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, -20(%ebp)         # 4-byte Spill
	movl	(%edi), %eax
	movl	%eax, -40(%ebp)         # 4-byte Spill
	movl	20(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	movl	-40(%ebp), %eax         # 4-byte Reload
	movl	24(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	addl	-20(%ebp), %esi         # 4-byte Folded Reload
	calll	strlen
	addl	$16, %esp
	leal	1(%eax,%esi), %eax
	addl	$12, %edi
	incl	%ebx
	cmpl	-36(%ebp), %ebx         # 4-byte Folded Reload
	jl	.LBB34_45
.LBB34_46:                              # %for.end58
	movl	-36(%ebp), %esi         # 4-byte Reload
	leal	-1(%eax,%esi,2), %eax
	movl	%eax, -52(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_malloc
	addl	$16, %esp
	movl	%eax, -20(%ebp)         # 4-byte Spill
	cmpl	$0, -24(%ebp)           # 4-byte Folded Reload
	movl	%esi, %eax
	jle	.LBB34_51
# BB#47:
	leal	-1(%eax), %ecx
	movl	%ecx, -48(%ebp)         # 4-byte Spill
	xorl	%ebx, %ebx
	movl	-28(%ebp), %eax         # 4-byte Reload
	.align	16, 0x90
.LBB34_48:                              # %for.body65
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, -28(%ebp)         # 4-byte Spill
	movl	(%eax), %edi
	movl	%edi, -24(%ebp)         # 4-byte Spill
	movl	20(%edi), %eax
	movl	%eax, -44(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	movl	24(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, -40(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	-44(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	-20(%ebp), %edi         # 4-byte Reload
	movl	-32(%ebp), %ecx         # 4-byte Reload
	leal	(%edi,%ecx), %eax
	movl	%eax, (%esp)
	addl	%ecx, %esi
	calll	memcpy
	addl	$16, %esp
	movb	$61, (%edi,%esi)
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	24(%eax), %eax
	subl	$16, %esp
	movl	-40(%ebp), %ecx         # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	leal	1(%ecx,%esi), %esi
	calll	memcpy
	addl	$16, %esp
	cmpl	-48(%ebp), %ebx         # 4-byte Folded Reload
	jge	.LBB34_50
# BB#49:                                # %if.then83
                                        #   in Loop: Header=BB34_48 Depth=1
	movb	$59, (%edi,%esi)
	movb	$32, 1(%edi,%esi)
	addl	$2, %esi
.LBB34_50:                              # %if.then83
                                        #   in Loop: Header=BB34_48 Depth=1
	movl	%esi, -32(%ebp)         # 4-byte Spill
	movl	-28(%ebp), %eax         # 4-byte Reload
	addl	$12, %eax
	incl	%ebx
	cmpl	-36(%ebp), %ebx         # 4-byte Folded Reload
	jl	.LBB34_48
.LBB34_51:                              # %for.end91
	movl	-20(%ebp), %ecx         # 4-byte Reload
	movl	-32(%ebp), %eax         # 4-byte Reload
	movb	$0, (%ecx,%eax)
	incl	%eax
	cmpl	-52(%ebp), %eax         # 4-byte Folded Reload
	jne	.LBB34_54
.LBB34_52:                              # %return
	movl	%ecx, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB34_53:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.cookie_header, 12(%esp)
	movl	$1016, 8(%esp)          # imm = 0x3F8
	movl	$.L.str336, 4(%esp)
	movl	$.L.str235, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB34_54:                              # %cond.false96
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.cookie_header, 12(%esp)
	movl	$1060, 8(%esp)          # imm = 0x424
	movl	$.L.str336, 4(%esp)
	movl	$.L.str437, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.Ltmp34:
	.size	cookie_header, .Ltmp34-cookie_header

	.align	16, 0x90
	.type	cookie_matches_url,@function
cookie_matches_url:                     # @cookie_matches_url
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	%ecx, %esi
	movl	16(%esi), %eax
	testl	%eax, %eax
	je	.LBB35_2
# BB#1:                                 # %entry
	movl	cookies_now, %edi
	xorb	%cl, %cl
	cmpl	%edi, %eax
	jl	.LBB35_11
.LBB35_2:                               # %if.end
	movl	12(%esi), %eax
	movl	%eax, %ecx
	testb	$2, %cl
	je	.LBB35_4
# BB#3:                                 # %if.end
	movb	40(%esp), %ch
	xorb	%cl, %cl
	cmpb	$1, %ch
	jne	.LBB35_11
.LBB35_4:                               # %if.end3
	movl	4(%esi), %edi
	cmpl	$-1, %edi
	je	.LBB35_6
# BB#5:                                 # %if.end3
	movl	32(%esp), %ebx
	xorb	%cl, %cl
	cmpl	%ebx, %edi
	jne	.LBB35_11
.LBB35_6:                               # %if.end9
	testb	$4, %al
	je	.LBB35_8
# BB#7:                                 # %land.lhs.true13
	movl	(%esi), %eax
	movl	%eax, 4(%esp)
	movl	%edx, (%esp)
	calll	strcasecmp
	xorb	%cl, %cl
	testl	%eax, %eax
	jne	.LBB35_11
.LBB35_8:                               # %if.end17
	movl	36(%esp), %edi
	movl	8(%esi), %ebx
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, %esi
	movl	%esi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	incl	%esi
	calll	strncmp
	testl	%eax, %eax
	movl	$0, %eax
	cmovel	%esi, %eax
	xorb	%cl, %cl
	testl	%eax, %eax
	je	.LBB35_11
# BB#9:                                 # %if.end22
	movl	44(%esp), %edx
	movb	$1, %cl
	testl	%edx, %edx
	je	.LBB35_11
# BB#10:                                # %if.then24
	movl	%eax, (%edx)
	movb	$1, %cl
.LBB35_11:                              # %return
	movzbl	%cl, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp35:
	.size	cookie_matches_url, .Ltmp35-cookie_matches_url

	.align	16, 0x90
	.type	goodness_comparator,@function
goodness_comparator:                    # @goodness_comparator
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	movl	12(%esp), %ecx
	movl	4(%ecx), %edx
	movl	16(%esp), %eax
	movl	4(%eax), %esi
	movl	8(%eax), %eax
	movl	%esi, %edi
	subl	%edx, %edi
	subl	8(%ecx), %eax
	cmpl	%edx, %esi
	cmovnel	%edi, %eax
	popl	%esi
	popl	%edi
	ret
.Ltmp36:
	.size	goodness_comparator, .Ltmp36-goodness_comparator

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI37_0:
	.quad	-4616189618054758400    # double -1.000000e+00
                                        #  (0x0)
.LCPI37_1:
	.quad	0                       # double 0.000000e+00
                                        #  (0x0)
	.text
	.globl	cookie_jar_load
	.align	16, 0x90
	.type	cookie_jar_load,@function
cookie_jar_load:                        # @cookie_jar_load
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$92, %esp
	movl	116(%esp), %edi
	movl	%edi, (%esp)
	movl	$.L.str538, 4(%esp)
	calll	fopen64
	movl	%eax, %esi
	movl	%esi, 20(%esp)          # 4-byte Spill
	testl	%esi, %esi
	je	.LBB37_1
# BB#2:                                 # %if.end
	movl	$0, (%esp)
	calll	time
	movl	%eax, cookies_now
	jmp	.LBB37_3
	.align	16, 0x90
.LBB37_62:                              # %for.inc
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %esi          # 4-byte Reload
.LBB37_3:                               # %if.end
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB37_51 Depth 2
                                        #     Child Loop BB37_35 Depth 2
                                        #     Child Loop BB37_30 Depth 2
                                        #     Child Loop BB37_25 Depth 2
                                        #     Child Loop BB37_20 Depth 2
                                        #     Child Loop BB37_15 Depth 2
                                        #     Child Loop BB37_9 Depth 2
                                        #     Child Loop BB37_5 Depth 2
	movl	%esi, (%esp)
	calll	read_whole_line
	movl	%eax, 76(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB37_63
# BB#4:                                 # %while.cond.preheader
                                        #   in Loop: Header=BB37_3 Depth=1
	xorl	%edx, %edx
	.align	16, 0x90
.LBB37_5:                               # %while.cond
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	76(%esp), %eax          # 4-byte Reload
	movzbl	(%eax,%edx), %ecx
	testl	%ecx, %ecx
	je	.LBB37_62
# BB#6:                                 # %land.rhs
                                        #   in Loop: Header=BB37_5 Depth=2
	incl	%edx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB37_5
# BB#7:                                 # %while.end
                                        #   in Loop: Header=BB37_3 Depth=1
	cmpb	$35, %cl
	je	.LBB37_62
# BB#8:                                 # %while.cond17.preheader
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%edx, %esi
	leal	-1(%eax,%esi), %edi
	addl	%eax, %esi
	xorl	%eax, %eax
                                        # kill: CL<def> CL<kill> ECX<kill>
	jmp	.LBB37_9
	.align	16, 0x90
.LBB37_11:                              # %while.cond17.while.cond17_crit_edge
                                        #   in Loop: Header=BB37_9 Depth=2
	movb	(%esi,%eax), %cl
	incl	%eax
.LBB37_9:                               # %while.cond17
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	setne	%dl
	cmpb	$9, %cl
	je	.LBB37_12
# BB#10:                                # %while.cond17
                                        #   in Loop: Header=BB37_9 Depth=2
	cmpb	$1, %dl
	je	.LBB37_11
.LBB37_12:                              # %while.end27
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%edi, 52(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB37_62
# BB#13:                                # %while.end27
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%cl, %cl
	je	.LBB37_62
# BB#14:                                # %while.cond36.preheader
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%esi, 56(%esp)          # 4-byte Spill
	leal	(%esi,%eax), %edx
	leal	-1(%eax,%esi), %eax
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	%eax, 68(%esp)          # 4-byte Spill
	xorl	%esi, %esi
	.align	16, 0x90
.LBB37_15:                              # %while.cond36
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%edx,%esi), %al
	testb	%al, %al
	setne	%cl
	incl	%esi
	cmpb	$9, %al
	je	.LBB37_17
# BB#16:                                # %while.cond36
                                        #   in Loop: Header=BB37_15 Depth=2
	testb	%cl, %cl
	jne	.LBB37_15
.LBB37_17:                              # %while.end46
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%edx, %ecx
	cmpl	$1, %esi
	je	.LBB37_62
# BB#18:                                # %while.end46
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%al, %al
	je	.LBB37_62
# BB#19:                                #   in Loop: Header=BB37_3 Depth=1
	movl	%ecx, 44(%esp)          # 4-byte Spill
	leal	-1(%esi,%ecx), %ebp
	movl	%ebp, 32(%esp)          # 4-byte Spill
	addl	%ecx, %esi
	movl	$1, %eax
	.align	16, 0x90
.LBB37_20:                              # %while.cond56
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	decl	%eax
	movb	1(%ebp), %cl
	incl	%ebp
	testb	%cl, %cl
	setne	%dl
	cmpb	$9, %cl
	je	.LBB37_22
# BB#21:                                # %while.cond56
                                        #   in Loop: Header=BB37_20 Depth=2
	testb	%dl, %dl
	jne	.LBB37_20
.LBB37_22:                              # %while.end66
                                        #   in Loop: Header=BB37_3 Depth=1
	testl	%eax, %eax
	je	.LBB37_62
# BB#23:                                # %while.end66
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%cl, %cl
	je	.LBB37_62
# BB#24:                                #   in Loop: Header=BB37_3 Depth=1
	movl	$1, %eax
	leal	1(%ebp), %ecx
	movl	%ecx, 28(%esp)          # 4-byte Spill
	movl	%ebp, %ebx
	.align	16, 0x90
.LBB37_25:                              # %while.cond76
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	decl	%eax
	movb	1(%ebx), %cl
	incl	%ebx
	testb	%cl, %cl
	setne	%dl
	cmpb	$9, %cl
	je	.LBB37_27
# BB#26:                                # %while.cond76
                                        #   in Loop: Header=BB37_25 Depth=2
	testb	%dl, %dl
	jne	.LBB37_25
.LBB37_27:                              # %while.end86
                                        #   in Loop: Header=BB37_3 Depth=1
	testl	%eax, %eax
	je	.LBB37_62
# BB#28:                                # %while.end86
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%cl, %cl
	je	.LBB37_62
# BB#29:                                #   in Loop: Header=BB37_3 Depth=1
	movl	$1, %eax
	leal	1(%ebx), %ecx
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	%ebx, %edi
	.align	16, 0x90
.LBB37_30:                              # %while.cond96
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	decl	%eax
	movb	1(%edi), %cl
	incl	%edi
	testb	%cl, %cl
	setne	%dl
	cmpb	$9, %cl
	je	.LBB37_32
# BB#31:                                # %while.cond96
                                        #   in Loop: Header=BB37_30 Depth=2
	testb	%dl, %dl
	jne	.LBB37_30
.LBB37_32:                              # %while.end106
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%edi, %edx
	testl	%eax, %eax
	je	.LBB37_62
# BB#33:                                # %while.end106
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%cl, %cl
	je	.LBB37_62
# BB#34:                                #   in Loop: Header=BB37_3 Depth=1
	movl	$1, %eax
	movl	%edx, 36(%esp)          # 4-byte Spill
	leal	1(%edx), %ecx
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	%edx, %edi
	.align	16, 0x90
.LBB37_35:                              # %while.cond116
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	decl	%eax
	movb	1(%edi), %cl
	incl	%edi
	testb	%cl, %cl
	setne	%dl
	cmpb	$9, %cl
	je	.LBB37_37
# BB#36:                                # %while.cond116
                                        #   in Loop: Header=BB37_35 Depth=2
	testb	%dl, %dl
	jne	.LBB37_35
.LBB37_37:                              # %while.end126
                                        #   in Loop: Header=BB37_3 Depth=1
	testl	%eax, %eax
	je	.LBB37_62
# BB#38:                                # %while.end126
                                        #   in Loop: Header=BB37_3 Depth=1
	testb	%cl, %cl
	je	.LBB37_62
# BB#39:                                # %if.end132
                                        #   in Loop: Header=BB37_3 Depth=1
	leal	1(%edi), %eax
	movl	%eax, 64(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%edi,%eax), %edx
	leal	1(%eax), %ecx
	cmpl	$2, %ecx
	jl	.LBB37_40
# BB#41:                                # %land.lhs.true
                                        #   in Loop: Header=BB37_3 Depth=1
	leal	(%edi,%eax), %ecx
	cmpb	$10, (%edi,%eax)
	cmovnel	%edx, %ecx
	jmp	.LBB37_42
.LBB37_40:                              #   in Loop: Header=BB37_3 Depth=1
	movl	%edx, %ecx
.LBB37_42:                              # %if.end144
                                        #   in Loop: Header=BB37_3 Depth=1
	cmpl	64(%esp), %ecx          # 4-byte Folded Reload
	jbe	.LBB37_43
# BB#44:                                # %land.lhs.true147
                                        #   in Loop: Header=BB37_3 Depth=1
	leal	-1(%ecx), %eax
	cmpb	$13, -1(%ecx)
	cmovnel	%ecx, %eax
	movl	%eax, 60(%esp)          # 4-byte Spill
	jmp	.LBB37_45
.LBB37_43:                              #   in Loop: Header=BB37_3 Depth=1
	movl	%ecx, 60(%esp)          # 4-byte Spill
.LBB37_45:                              # %if.end154
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	$32, (%esp)
	calll	checking_malloc0
	movl	$-1, 4(%eax)
	movl	%edi, 4(%esp)
	movl	%eax, %edi
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, 20(%edi)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, 24(%edi)
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
	calll	strdupdelim
	movl	%eax, 8(%edi)
	movl	28(%esp), %ecx          # 4-byte Reload
	subl	%ecx, %ebx
	xorb	%al, %al
	cmpl	$4, %ebx
	jne	.LBB37_47
# BB#46:                                # %land.rhs161
                                        #   in Loop: Header=BB37_3 Depth=1
	cmpl	$1163219540, (%ecx)     # imm = 0x45555254
	sete	%al
.LBB37_47:                              # %land.end164
                                        #   in Loop: Header=BB37_3 Depth=1
	movzbl	%al, %ecx
	addl	%ecx, %ecx
	movl	12(%edi), %eax
	andl	$-3, %eax
	orl	%ecx, %eax
	movl	%eax, 12(%edi)
	movl	44(%esp), %edx          # 4-byte Reload
	movl	32(%esp), %esi          # 4-byte Reload
	subl	%edx, %esi
	movb	$1, %cl
	cmpl	$4, %esi
	movl	52(%esp), %ebp          # 4-byte Reload
	jne	.LBB37_49
# BB#48:                                # %land.rhs170
                                        #   in Loop: Header=BB37_3 Depth=1
	cmpl	$1163219540, (%edx)     # imm = 0x45555254
	setne	%cl
.LBB37_49:                              # %land.end174
                                        #   in Loop: Header=BB37_3 Depth=1
	andl	$-5, %eax
	movzbl	%cl, %ecx
	shll	$2, %ecx
	orl	%eax, %ecx
	movl	%ecx, 12(%edi)
	movl	48(%esp), %eax          # 4-byte Reload
	subl	%ebp, %eax
	movl	%eax, 8(%esp)
	movl	%ebp, (%esp)
	movl	$58, 4(%esp)
	calll	memchr
	testl	%eax, %eax
	je	.LBB37_57
# BB#50:                                # %for.cond.i.preheader
                                        #   in Loop: Header=BB37_3 Depth=1
	leal	1(%eax), %edx
	xorl	%ecx, %ecx
	jmp	.LBB37_51
	.align	16, 0x90
.LBB37_53:                              # %for.body.i
                                        #   in Loop: Header=BB37_51 Depth=2
	imull	$10, %ecx, %ecx
	leal	-48(%ecx,%ebx), %ecx
	incl	%edx
.LBB37_51:                              # %for.cond.i
                                        #   Parent Loop BB37_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	72(%esp), %edx          # 4-byte Folded Reload
	jae	.LBB37_54
# BB#52:                                # %land.rhs.i
                                        #   in Loop: Header=BB37_51 Depth=2
	movsbl	(%edx), %ebx
	movzbl	%bl, %esi
	testb	$4, _sch_istable(%esi,%esi)
	je	.LBB37_57
	jmp	.LBB37_53
.LBB37_54:                              # %domain_port.exit
                                        #   in Loop: Header=BB37_3 Depth=1
	testl	%ecx, %ecx
	je	.LBB37_56
# BB#55:                                # %if.then181
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%ecx, 4(%edi)
.LBB37_56:                              # %if.then181
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%eax, 68(%esp)          # 4-byte Spill
.LBB37_57:                              # %if.end183
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	56(%esp), %eax          # 4-byte Reload
	cmpb	$46, -1(%eax)
	cmovel	%eax, %ebp
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	strdupdelim
	movl	%edi, %esi
	movl	%eax, (%esi)
	cvtsi2sd	cookies_now, %xmm0
	addsd	.LCPI37_0, %xmm0
	movsd	%xmm0, 80(%esp)
	movl	36(%esp), %eax          # 4-byte Reload
	movb	$0, (%eax)
	leal	80(%esp), %eax
	movl	%eax, 8(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$.L.str841, 4(%esp)
	calll	sscanf
	movsd	80(%esp), %xmm0
	ucomisd	.LCPI37_1, %xmm0
	jne	.LBB37_58
	jnp	.LBB37_60
.LBB37_58:                              # %if.else
                                        #   in Loop: Header=BB37_3 Depth=1
	cvtsi2sd	cookies_now, %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB37_59
# BB#61:                                # %abort_cookie
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	%esi, %ecx
	calll	delete_cookie
	jmp	.LBB37_62
.LBB37_59:                              # %if.end200
                                        #   in Loop: Header=BB37_3 Depth=1
	cvttsd2si	%xmm0, %eax
	movl	%eax, 16(%esi)
	orb	$8, 12(%esi)
.LBB37_60:                              # %if.end203
                                        #   in Loop: Header=BB37_3 Depth=1
	movl	112(%esp), %ecx
	movl	%esi, %edx
	calll	store_cookie
	jmp	.LBB37_62
.LBB37_63:                              # %for.end
	movl	%esi, (%esp)
	calll	fclose
	jmp	.LBB37_64
.LBB37_1:                               # %if.then
	movl	$5, 8(%esp)
	movl	$.L.str639, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB37_64:                              # %return
	addl	$92, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp37:
	.size	cookie_jar_load, .Ltmp37-cookie_jar_load

	.globl	cookie_jar_save
	.align	16, 0x90
	.type	cookie_jar_save,@function
cookie_jar_save:                        # @cookie_jar_save
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	84(%esp), %edi
	cmpb	$0, opt+250
	jne	.LBB38_1
	.align	16, 0x90
.LBB38_2:                               # %do.end
	movl	$0, (%esp)
	calll	time
	movl	%eax, cookies_now
	movl	%edi, (%esp)
	movl	$.L.str1043, 4(%esp)
	calll	fopen64
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB38_3
# BB#4:                                 # %if.end8
	movl	80(%esp), %edi
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$20, 4(%esp)
	movl	$.L.str1144, (%esp)
	calll	fwrite
	movl	cookies_now, %eax
	movl	%eax, (%esp)
	calll	datetime_str
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str1245, 4(%esp)
	calll	fprintf
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$26, 4(%esp)
	movl	$.L.str1346, (%esp)
	calll	fwrite
	movl	(%edi), %eax
	leal	40(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	.align	16, 0x90
.LBB38_5:                               # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB38_7 Depth 2
	leal	40(%esp), %eax
	movl	%eax, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	je	.LBB38_18
# BB#6:                                 # %for.body
                                        #   in Loop: Header=BB38_5 Depth=1
	movl	40(%esp), %edi
	movl	44(%esp), %ebp
	jmp	.LBB38_7
	.align	16, 0x90
.LBB38_17:                              # %for.inc
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	28(%ebp), %ebp
.LBB38_7:                               # %for.cond15
                                        #   Parent Loop BB38_5 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testl	%ebp, %ebp
	je	.LBB38_5
# BB#8:                                 # %for.body17
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	12(%ebp), %eax
	movl	%eax, %ecx
	testb	$8, %cl
	jne	.LBB38_10
# BB#9:                                 # %for.body17
                                        #   in Loop: Header=BB38_7 Depth=2
	movb	opt+308, %cl
	testb	%cl, %cl
	je	.LBB38_17
.LBB38_10:                              # %if.end21
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	16(%ebp), %ecx
	testl	%ecx, %ecx
	je	.LBB38_12
# BB#11:                                # %if.end21
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	cookies_now, %edx
	cmpl	%edx, %ecx
	jl	.LBB38_17
.LBB38_12:                              # %if.end24
                                        #   in Loop: Header=BB38_7 Depth=2
	testb	$4, %al
	jne	.LBB38_14
# BB#13:                                # %if.then28
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	%esi, 4(%esp)
	movl	$46, (%esp)
	calll	fputc
.LBB38_14:                              # %if.end30
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	fputs
	movl	4(%ebp), %eax
	cmpl	$-1, %eax
	je	.LBB38_16
# BB#15:                                # %if.then33
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str1447, 4(%esp)
	calll	fprintf
.LBB38_16:                              # %if.end36
                                        #   in Loop: Header=BB38_7 Depth=2
	movl	8(%ebp), %ecx
	movl	12(%ebp), %eax
	cvtsi2sd	16(%ebp), %xmm0
	movl	20(%ebp), %edx
	movl	24(%ebp), %ebx
	movl	%ebx, 32(%esp)
	movl	%edx, 28(%esp)
	movsd	%xmm0, 20(%esp)
	movl	%ecx, 12(%esp)
	movl	%esi, (%esp)
	movl	%eax, %ecx
	andl	$2, %ecx
	shrl	%ecx
	testl	%ecx, %ecx
	movl	$.L.str1649, %ecx
	movl	$.L.str740, %edx
	cmovnel	%edx, %ecx
	movl	%ecx, 16(%esp)
	andl	$4, %eax
	shrl	$2, %eax
	testl	%eax, %eax
	movl	$.L.str740, %eax
	movl	$.L.str1649, %ecx
	cmovnel	%ecx, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str1548, 4(%esp)
	calll	fprintf
	movl	%esi, (%esp)
	calll	ferror
	testl	%eax, %eax
	je	.LBB38_17
.LBB38_18:                              # %out
	movl	%esi, (%esp)
	calll	ferror
	testl	%eax, %eax
	movl	84(%esp), %ebx
	je	.LBB38_20
# BB#19:                                # %if.then54
	movl	$5, 8(%esp)
	movl	$.L.str1750, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB38_20:                              # %if.end58
	movl	%esi, (%esp)
	calll	fclose
	testl	%eax, %eax
	jns	.LBB38_22
# BB#21:                                # %if.then62
	movl	$5, 8(%esp)
	movl	$.L.str1851, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB38_22:                              # %do.body67
	cmpb	$0, opt+250
	je	.LBB38_24
# BB#23:                                # %if.then72
	movl	$.L.str1952, (%esp)
	calll	debug_logprintf
	jmp	.LBB38_24
.LBB38_3:                               # %if.then4
	movl	$5, 8(%esp)
	movl	$.L.str639, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB38_24:                              # %do.end74
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB38_1:                               # %if.then
	movl	%edi, 4(%esp)
	movl	$.L.str942, (%esp)
	calll	debug_logprintf
	jmp	.LBB38_2
.Ltmp38:
	.size	cookie_jar_save, .Ltmp38-cookie_jar_save

	.globl	cookie_jar_delete
	.align	16, 0x90
	.type	cookie_jar_delete,@function
cookie_jar_delete:                      # @cookie_jar_delete
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %edi
	movl	(%edi), %eax
	leal	8(%esp), %ebx
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB39_1
	.align	16, 0x90
.LBB39_2:                               # %for.body
                                        #   in Loop: Header=BB39_1 Depth=1
	movl	8(%esp), %eax
	movl	12(%esp), %esi
	movl	%eax, (%esp)
	calll	checking_free
	testl	%esi, %esi
	je	.LBB39_1
	.align	16, 0x90
.LBB39_3:                               # %while.body
                                        #   Parent Loop BB39_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	28(%esi), %ebp
	movl	%esi, %ecx
	calll	delete_cookie
	testl	%ebp, %ebp
	movl	%ebp, %esi
	jne	.LBB39_3
.LBB39_1:                               # %entry
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB39_3 Depth 2
	movl	%ebx, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB39_2
# BB#4:                                 # %for.end
	movl	(%edi), %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	%edi, (%esp)
	calll	checking_free
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp39:
	.size	cookie_jar_delete, .Ltmp39-cookie_jar_delete

	.align	16, 0x90
	.type	equality_comparator,@function
equality_comparator:                    # @equality_comparator
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %eax
	movl	(%eax), %edi
	movl	20(%edi), %eax
	movl	36(%esp), %ecx
	movl	(%ecx), %ebx
	movl	20(%ebx), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	movl	%eax, %esi
	movl	24(%edi), %eax
	movl	24(%ebx), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	testl	%esi, %esi
	cmovnel	%esi, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp40:
	.size	equality_comparator, .Ltmp40-equality_comparator

	.align	16, 0x90
	.type	numeric_address_p,@function
numeric_address_p:                      # @numeric_address_p
# BB#0:                                 # %entry
	movzbl	(%ecx), %edx
	xorb	%al, %al
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB41_13
# BB#1:                                 # %if.end
	addl	$4, %ecx
	.align	16, 0x90
.LBB41_2:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-3(%ecx), %edx
	incl	%ecx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB41_2
# BB#3:                                 # %do.body10
	xorb	%al, %al
	cmpb	$46, %dl
	jne	.LBB41_13
# BB#4:                                 # %do.body17
	movzbl	-3(%ecx), %edx
	xorb	%al, %al
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB41_13
	.align	16, 0x90
.LBB41_5:                               # %for.cond27
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-2(%ecx), %edx
	incl	%ecx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB41_5
# BB#6:                                 # %do.body39
	xorb	%al, %al
	cmpb	$46, %dl
	jne	.LBB41_13
# BB#7:                                 # %do.body47
	movzbl	-2(%ecx), %edx
	xorb	%al, %al
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB41_13
	.align	16, 0x90
.LBB41_8:                               # %for.cond57
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-1(%ecx), %edx
	incl	%ecx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB41_8
# BB#9:                                 # %do.body69
	xorb	%al, %al
	cmpb	$46, %dl
	jne	.LBB41_13
# BB#10:                                # %do.body77
	movzbl	-1(%ecx), %edx
	xorb	%al, %al
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB41_13
	.align	16, 0x90
.LBB41_11:                              # %for.cond87
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%ecx), %eax
	incl	%ecx
	testb	$4, _sch_istable(%eax,%eax)
	jne	.LBB41_11
# BB#12:                                # %do.end98
	testb	%al, %al
	sete	%al
.LBB41_13:                              # %return
	movzbl	%al, %eax
	ret
.Ltmp41:
	.size	numeric_address_p, .Ltmp41-numeric_address_p

	.globl	ftp_loop
	.align	16, 0x90
	.type	ftp_loop,@function
ftp_loop:                               # @ftp_loop
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	movl	196(%esp), %eax
	movl	$0, (%eax)
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 144(%esp)
	movaps	%xmm0, 128(%esp)
	movl	$-1, 136(%esp)
	movl	$1, 128(%esp)
	movl	$0, 148(%esp)
	movl	$0, 152(%esp)
	movl	200(%esp), %eax
	movl	%eax, 160(%esp)
	movl	192(%esp), %edi
	movl	36(%edi), %eax
	movb	204(%esp), %bl
	cmpb	$0, (%eax)
	jne	.LBB42_25
# BB#1:                                 # %entry
	testb	%bl, %bl
	je	.LBB42_2
.LBB42_25:                              # %if.else38
	movb	208(%esp), %cl
	xorb	%al, %al
	cmpb	$1, %cl
	jne	.LBB42_27
# BB#26:                                # %if.then40
	movl	16(%edi), %esi
	movl	%esi, (%esp)
	movl	$47, 4(%esp)
	calll	strrchr
	testl	%eax, %eax
	cmovel	%esi, %eax
	movl	%eax, (%esp)
	calll	has_wildcards_p
.LBB42_27:                              # %if.end48
	cmpb	$0, opt+251
	jne	.LBB42_29
# BB#28:                                # %if.end48
	orb	%al, %bl
	xorb	$1, %bl
	testb	%bl, %bl
	je	.LBB42_29
# BB#30:                                # %if.else57
	leal	128(%esp), %eax
	movl	%eax, (%esp)
	movl	%edi, %ecx
	xorl	%edx, %edx
	calll	ftp_loop_internal
	jmp	.LBB42_31
.LBB42_29:                              # %if.then53
	testb	%al, %al
	sete	%al
	movzbl	%al, %eax
	addl	%eax, %eax
	movl	%eax, (%esp)
	leal	128(%esp), %edx
	movl	%edi, %ecx
	calll	ftp_retrieve_glob
	jmp	.LBB42_31
.LBB42_2:                               # %if.then
	leal	124(%esp), %eax
	movl	%eax, (%esp)
	leal	128(%esp), %edx
	movl	%edi, %ecx
	calll	ftp_get_listing
	cmpl	$31, %eax
	jne	.LBB42_31
# BB#3:                                 # %if.then4
	cmpb	$0, opt+266
	je	.LBB42_5
# BB#4:                                 # %if.then4
	movb	opt+57, %al
	testb	%al, %al
	jne	.LBB42_5
# BB#6:                                 # %if.then8
	movl	opt+104, %eax
	testl	%eax, %eax
	jne	.LBB42_7
# BB#8:                                 # %cond.false
	movl	156(%esp), %eax
	testl	%eax, %eax
	je	.LBB42_9
.LBB42_7:                               # %cond.true
	movl	%eax, (%esp)
	calll	checking_strdup
	.align	16, 0x90
.LBB42_10:                              # %cond.false15
	movl	%eax, %ebx
	movl	124(%esp), %ebp
	movl	%ebp, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_index
	movl	%eax, 20(%esp)          # 4-byte Spill
	cmpl	$10, %eax
	jne	.LBB42_18
# BB#11:                                # %cond.end17
	movl	opt, %eax
	testl	%eax, %eax
	je	.LBB42_18
# BB#12:                                # %if.then23
	cmpl	$0, opt+104
	je	.LBB42_13
# BB#16:                                # %if.else32
	movl	$5, 8(%esp)
	movl	$.L.str159, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%ebx, 8(%esp)
	jmp	.LBB42_17
.LBB42_5:                               # %if.then4.if.end36_crit_edge
	movl	$31, %eax
	movl	124(%esp), %ebp
	jmp	.LBB42_19
.LBB42_9:                               # %cond.false15
	movl	%edi, (%esp)
	calll	url_file_name
	jmp	.LBB42_10
.LBB42_13:                              # %if.then25
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	movl	$-1, %esi
	testl	%eax, %eax
	movl	$-1, %edi
	jne	.LBB42_15
# BB#14:                                # %if.then29
	movl	68(%esp), %esi
	movl	72(%esp), %edi
.LBB42_15:                              # %if.end
	movl	$5, 8(%esp)
	movl	$.L.str58, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 16(%esp)          # 4-byte Spill
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_static_string
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	16(%esp), %eax          # 4-byte Reload
.LBB42_17:                              # %if.else32
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB42_18:                              # %if.end35
	movl	%ebx, (%esp)
	calll	checking_free
	movl	20(%esp), %eax          # 4-byte Reload
.LBB42_19:                              # %if.end36
	testl	%ebp, %ebp
	je	.LBB42_31
# BB#20:
	movl	%eax, %edi
	.align	16, 0x90
.LBB42_21:                              # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%ebp), %eax
	movl	32(%ebp), %esi
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%ebp), %eax
	testl	%eax, %eax
	je	.LBB42_23
# BB#22:                                # %if.then.i
                                        #   in Loop: Header=BB42_21 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB42_23:                              # %if.end.i
                                        #   in Loop: Header=BB42_21 Depth=1
	movl	%ebp, (%esp)
	calll	checking_free
	testl	%esi, %esi
	movl	%esi, %ebp
	jne	.LBB42_21
# BB#24:
	movl	%edi, %eax
.LBB42_31:                              # %if.end60
	cmpl	$10, %eax
	movl	$31, %edi
	cmovnel	%eax, %edi
	cmpl	$31, %edi
	jne	.LBB42_33
# BB#32:                                # %if.then65
	movl	196(%esp), %eax
	orb	$2, (%eax)
.LBB42_33:                              # %if.end66
	movl	136(%esp), %eax
	cmpl	$-1, %eax
	je	.LBB42_35
# BB#34:                                # %if.then69
	movl	%eax, (%esp)
	calll	fd_close
.LBB42_35:                              # %if.end71
	movl	152(%esp), %eax
	testl	%eax, %eax
	je	.LBB42_37
# BB#36:                                # %if.else75
	movl	%eax, (%esp)
	calll	checking_free
.LBB42_37:                              # %if.end77
	movl	$0, 152(%esp)
	movl	156(%esp), %eax
	testl	%eax, %eax
	je	.LBB42_39
# BB#38:                                # %if.else82
	movl	%eax, (%esp)
	calll	checking_free
.LBB42_39:                              # %if.end84
	movl	%edi, %eax
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp42:
	.size	ftp_loop, .Ltmp42-ftp_loop

	.align	16, 0x90
	.type	ftp_get_listing,@function
ftp_get_listing:                        # @ftp_get_listing
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %esi
	movl	%ecx, %ebx
	movl	28(%esi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	andl	$-2, (%esi)
	movl	4(%esi), %eax
	andl	$-29, %eax
	orl	$24, %eax
	movl	%eax, 4(%esi)
	movl	%ebx, (%esp)
	calll	url_file_name
	movl	%eax, %ebp
	movl	%ebp, (%esp)
	movl	$.L.str113, 4(%esp)
	calll	file_merge
	movl	%eax, %edi
	movl	%ebp, (%esp)
	calll	checking_free
	cmpb	$0, opt+250
	jne	.LBB43_1
	.align	16, 0x90
.LBB43_2:                               # %do.end
	movl	%edi, 28(%esi)
	movl	%esi, (%esp)
	xorl	%ebp, %ebp
	movl	%ebx, %ecx
	xorl	%edx, %edx
	calll	ftp_loop_internal
	movl	%eax, %ebx
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 28(%esi)
	cmpl	$31, %ebx
	jne	.LBB43_4
# BB#3:                                 # %if.then10
	movl	20(%esi), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_parse_ls
	movl	%eax, %ebp
.LBB43_4:                               # %if.end12
	movl	48(%esp), %eax
	movl	%ebp, (%eax)
	cmpb	$0, opt+265
	je	.LBB43_9
# BB#5:                                 # %if.then14
	movl	%edi, (%esp)
	calll	unlink
	testl	%eax, %eax
	je	.LBB43_7
# BB#6:                                 # %if.then17
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	$.L.str1068, 4(%esp)
	movl	$1, (%esp)
	jmp	.LBB43_8
.LBB43_7:                               # %if.else20
	movl	$5, 8(%esp)
	movl	$.L.str115, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
.LBB43_8:                               # %if.else20
	calll	logprintf
.LBB43_9:                               # %if.end23
	movl	%edi, (%esp)
	calll	checking_free
	andb	$-9, 4(%esi)
	movl	%ebx, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB43_1:                               # %if.then
	movl	$5, 8(%esp)
	movl	$.L.str114, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	debug_logprintf
	jmp	.LBB43_2
.Ltmp43:
	.size	ftp_get_listing, .Ltmp43-ftp_get_listing

	.align	16, 0x90
	.type	ftp_retrieve_glob,@function
ftp_retrieve_glob:                      # @ftp_retrieve_glob
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	%edx, 24(%esp)          # 4-byte Spill
	movl	%ecx, %esi
	orb	$16, 4(%edx)
	leal	40(%esp), %eax
	movl	%eax, (%esp)
	calll	ftp_get_listing
	cmpl	$31, %eax
	jne	.LBB44_76
# BB#1:                                 # %if.end
	movl	%esi, 36(%esp)          # 4-byte Spill
	movl	40(%esp), %edi
	movl	opt+60, %eax
	orl	opt+64, %eax
	je	.LBB44_15
# BB#2:                                 # %if.then2
	movl	$0, 28(%esp)            # 4-byte Folded Spill
	testl	%edi, %edi
	je	.LBB44_28
# BB#3:
	movl	%edi, %ebp
	jmp	.LBB44_4
	.align	16, 0x90
.LBB44_6:                               # %if.then6
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str90, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %ebx
	movl	4(%ebp), %eax
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	32(%ebp), %esi
	movl	4(%ebp), %eax
	movl	28(%ebp), %ebx
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%ebp), %eax
	testl	%eax, %eax
	je	.LBB44_8
# BB#7:                                 # %if.else.i
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_8:                               # %if.end.i107
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	%ebp, (%esp)
	calll	checking_free
	testl	%esi, %esi
	je	.LBB44_10
# BB#9:                                 # %if.then5.i
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	%ebx, 28(%esi)
.LBB44_10:                              # %if.end7.i
                                        #   in Loop: Header=BB44_4 Depth=1
	testl	%ebx, %ebx
	jne	.LBB44_11
# BB#12:                                # %if.else11.i
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	%esi, 40(%esp)
	movl	%esi, %edi
	movl	%esi, %ebp
	jmp	.LBB44_14
.LBB44_11:                              # %if.then9.i
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	%esi, 32(%ebx)
	movl	%esi, %ebp
	jmp	.LBB44_14
	.align	16, 0x90
.LBB44_4:                               # %while.body
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, (%ebp)
	je	.LBB44_13
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	4(%ebp), %eax
	movl	%eax, (%esp)
	calll	acceptable
	testb	%al, %al
	je	.LBB44_6
.LBB44_13:                              # %if.else
                                        #   in Loop: Header=BB44_4 Depth=1
	movl	32(%ebp), %ebp
.LBB44_14:                              # %while.cond.backedge
                                        #   in Loop: Header=BB44_4 Depth=1
	testl	%ebp, %ebp
	jne	.LBB44_4
.LBB44_15:                              # %if.end12
	movl	$0, 28(%esp)            # 4-byte Folded Spill
	testl	%edi, %edi
	je	.LBB44_28
# BB#16:
	movl	%edi, 28(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB44_17:                              # %while.body15
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%edi), %eax
	cmpb	$47, (%eax)
	je	.LBB44_19
# BB#18:                                # %has_insecure_name_p.exit
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%eax, (%esp)
	movl	$.L.str112, 4(%esp)
	calll	strstr
	testl	%eax, %eax
	jne	.LBB44_19
# BB#26:                                # %if.else23
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	32(%edi), %edi
	jmp	.LBB44_27
.LBB44_19:                              # %if.then18
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str90, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %ebp
	movl	4(%edi), %eax
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	32(%edi), %esi
	movl	4(%edi), %eax
	movl	28(%edi), %ebx
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%edi), %eax
	testl	%eax, %eax
	je	.LBB44_21
# BB#20:                                # %if.else.i114
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_21:                              # %if.end.i116
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	testl	%esi, %esi
	je	.LBB44_23
# BB#22:                                # %if.then5.i118
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%ebx, 28(%esi)
.LBB44_23:                              # %if.end7.i120
                                        #   in Loop: Header=BB44_17 Depth=1
	testl	%ebx, %ebx
	jne	.LBB44_24
# BB#25:                                # %if.else11.i123
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%esi, 40(%esp)
	movl	%esi, 28(%esp)          # 4-byte Spill
	movl	%esi, %edi
	jmp	.LBB44_27
.LBB44_24:                              # %if.then9.i122
                                        #   in Loop: Header=BB44_17 Depth=1
	movl	%esi, 32(%ebx)
	movl	%esi, %edi
.LBB44_27:                              # %while.cond13.backedge
                                        #   in Loop: Header=BB44_17 Depth=1
	testl	%edi, %edi
	jne	.LBB44_17
.LBB44_28:                              # %while.end26
	movl	36(%esp), %ebp          # 4-byte Reload
	movl	36(%ebp), %eax
	cmpb	$0, (%eax)
	je	.LBB44_63
# BB#29:                                # %if.then28
	movl	64(%esp), %ecx
	cmpl	$2, %ecx
	movl	28(%esp), %edi          # 4-byte Reload
	jne	.LBB44_30
# BB#51:                                # %if.then59
	movl	$strcasecmp, %ecx
	cmpb	$0, opt+76
	movl	$strcmp, %edx
	cmovnel	%ecx, %edx
	movl	%edx, 32(%esp)          # 4-byte Spill
	testl	%edi, %edi
	je	.LBB44_72
# BB#52:
	movl	%edi, %ecx
	movl	%ebp, %edi
	movl	%ecx, %ebp
	jmp	.LBB44_53
	.align	16, 0x90
.LBB44_77:                              # %while.cond63.backedge.while.body65_crit_edge
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	36(%ebp), %eax
	movl	%ebp, %edi
	movl	%esi, %ebp
.LBB44_53:                              # %while.body65
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	*32(%esp)               # 4-byte Folded Reload
	testl	%eax, %eax
	jne	.LBB44_54
# BB#61:                                # %if.else72
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	32(%ebp), %esi
	movl	%edi, %ebp
	jmp	.LBB44_62
.LBB44_54:                              # %if.then70
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	32(%ebp), %esi
	movl	4(%ebp), %eax
	movl	28(%ebp), %ebx
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%ebp), %eax
	testl	%eax, %eax
	je	.LBB44_56
# BB#55:                                # %if.else.i157
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_56:                              # %if.end.i159
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	%ebp, (%esp)
	calll	checking_free
	testl	%esi, %esi
	je	.LBB44_58
# BB#57:                                # %if.then5.i161
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	%ebx, 28(%esi)
.LBB44_58:                              # %if.end7.i163
                                        #   in Loop: Header=BB44_53 Depth=1
	testl	%ebx, %ebx
	movl	%edi, %ebp
	jne	.LBB44_59
# BB#60:                                # %if.else11.i166
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	%esi, 40(%esp)
	movl	%esi, 28(%esp)          # 4-byte Spill
	jmp	.LBB44_62
.LBB44_59:                              # %if.then9.i165
                                        #   in Loop: Header=BB44_53 Depth=1
	movl	%esi, 32(%ebx)
.LBB44_62:                              # %while.cond63.backedge
                                        #   in Loop: Header=BB44_53 Depth=1
	testl	%esi, %esi
	jne	.LBB44_77
	jmp	.LBB44_63
.LBB44_30:                              # %if.then28
	testl	%ecx, %ecx
	jne	.LBB44_64
# BB#31:                                # %if.then30
	movl	$fnmatch_nocase, %eax
	cmpb	$0, opt+76
	movl	$fnmatch, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 32(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	jmp	.LBB44_32
	.align	16, 0x90
.LBB44_47:                              # %if.else11.i139
                                        #   in Loop: Header=BB44_32 Depth=1
	movl	%ebx, 40(%esp)
	movl	%ebx, %edi
.LBB44_32:                              # %while.cond32.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB44_33 Depth 2
	movl	%edi, 28(%esp)          # 4-byte Spill
	movl	%edi, %esi
	jmp	.LBB44_33
	.align	16, 0x90
.LBB44_46:                              # %if.then9.i138
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	%ebx, 32(%edi)
	movl	%ebx, %esi
	.align	16, 0x90
.LBB44_33:                              # %while.cond32
                                        #   Parent Loop BB44_32 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testl	%esi, %esi
	je	.LBB44_49
# BB#34:                                # %while.body34
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	36(%esp), %eax          # 4-byte Reload
	movl	36(%eax), %eax
	movl	4(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 8(%esp)
	calll	*32(%esp)               # 4-byte Folded Reload
	movl	%eax, %ebp
	cmpl	$1, %ebp
	jne	.LBB44_35
# BB#41:                                # %if.then48
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	32(%esi), %ebx
	movl	4(%esi), %eax
	movl	28(%esi), %edi
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%esi), %eax
	testl	%eax, %eax
	je	.LBB44_43
# BB#42:                                # %if.else.i130
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_43:                              # %if.end.i132
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	%esi, (%esp)
	calll	checking_free
	testl	%ebx, %ebx
	je	.LBB44_45
# BB#44:                                # %if.then5.i134
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	%edi, 28(%ebx)
.LBB44_45:                              # %if.end7.i136
                                        #   in Loop: Header=BB44_33 Depth=2
	testl	%edi, %edi
	je	.LBB44_47
	jmp	.LBB44_46
.LBB44_35:                              # %while.body34
                                        #   in Loop: Header=BB44_33 Depth=2
	cmpl	$-1, %ebp
	je	.LBB44_36
# BB#48:                                # %if.else50
                                        #   in Loop: Header=BB44_33 Depth=2
	movl	32(%esi), %esi
	jmp	.LBB44_33
.LBB44_36:                              # %while.end53.thread
	movl	$5, 8(%esp)
	movl	$.L.str91, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	36(%esp), %eax          # 4-byte Reload
	movl	36(%eax), %ebx
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	.align	16, 0x90
.LBB44_37:                              # %if.then55
	movl	$45, %eax
	movl	28(%esp), %edi          # 4-byte Reload
	testl	%edi, %edi
	je	.LBB44_76
	.align	16, 0x90
.LBB44_38:                              # %while.body.i147
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%edi), %eax
	movl	32(%edi), %esi
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%edi), %eax
	testl	%eax, %eax
	je	.LBB44_40
# BB#39:                                # %if.then.i148
                                        #   in Loop: Header=BB44_38 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_40:                              # %if.end.i150
                                        #   in Loop: Header=BB44_38 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	movl	$45, %eax
	testl	%esi, %esi
	movl	%esi, %edi
	jne	.LBB44_38
	jmp	.LBB44_76
.LBB44_49:                              # %while.end53
	cmpl	$-1, %ebp
	je	.LBB44_37
# BB#50:
	movl	36(%esp), %ebp          # 4-byte Reload
.LBB44_63:
	movl	28(%esp), %edi          # 4-byte Reload
.LBB44_64:                              # %if.end78
	testl	%edi, %edi
	je	.LBB44_72
# BB#65:                                # %if.end96.thread
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	%ebp, %ecx
	movl	%edi, %edx
	calll	ftp_retrieve_list
	.align	16, 0x90
.LBB44_66:                              # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%edi), %eax
	movl	32(%edi), %esi
	movl	%eax, (%esp)
	calll	checking_free
	movl	24(%edi), %eax
	testl	%eax, %eax
	je	.LBB44_68
# BB#67:                                # %if.then.i
                                        #   in Loop: Header=BB44_66 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB44_68:                              # %if.end.i
                                        #   in Loop: Header=BB44_66 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	testl	%esi, %esi
	movl	%esi, %edi
	jne	.LBB44_66
	jmp	.LBB44_69
.LBB44_72:                              # %if.else82
	cmpl	$0, 64(%esp)
	je	.LBB44_73
# BB#74:                                # %if.else88
	movl	36(%ebp), %eax
	cmpb	$0, (%eax)
	je	.LBB44_69
# BB#75:                                # %if.then91
	movl	24(%esp), %eax          # 4-byte Reload
	orb	$1, (%eax)
	movl	%eax, (%esp)
	movl	%ebp, %ecx
	xorl	%edx, %edx
	calll	ftp_loop_internal
	jmp	.LBB44_76
.LBB44_73:                              # %if.then84
	movl	$5, 8(%esp)
	movl	$.L.str92, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	36(%ebp), %eax
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB44_69:                              # %freefileinfo.exit
	movl	opt+236, %eax
	cmpl	%eax, total_downloaded_bytes
	seta	%cl
	movl	opt+240, %edx
	cmpl	%edx, total_downloaded_bytes+4
	setg	%ch
	je	.LBB44_71
# BB#70:                                # %freefileinfo.exit
	movb	%ch, %cl
.LBB44_71:                              # %freefileinfo.exit
	orl	%edx, %eax
	setne	%al
	movl	$51, %edx
	testb	%cl, %al
	movl	$31, %eax
	cmovnel	%edx, %eax
.LBB44_76:                              # %return
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp44:
	.size	ftp_retrieve_glob, .Ltmp44-ftp_retrieve_glob

	.align	16, 0x90
	.type	ftp_loop_internal,@function
ftp_loop_internal:                      # @ftp_loop_internal
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$428, %esp              # imm = 0x1AC
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	$0, 420(%esp)
	movl	$0, 416(%esp)
	movl	448(%esp), %edi
	movl	28(%edi), %eax
	testl	%eax, %eax
	jne	.LBB45_2
# BB#1:                                 # %if.then
	movl	%ecx, (%esp)
	movl	%ecx, %esi
	calll	url_file_name
	movl	%esi, %ecx
	movl	%eax, 28(%edi)
.LBB45_2:                               # %if.end
	movl	%ecx, 52(%esp)          # 4-byte Spill
	cmpb	$0, opt+42
	je	.LBB45_6
# BB#3:                                 # %if.end
	movl	opt+104, %ecx
	testl	%ecx, %ecx
	jne	.LBB45_6
# BB#4:                                 # %land.lhs.true4
	movl	%eax, (%esp)
	calll	file_exists_p
	testb	%al, %al
	je	.LBB45_5
# BB#66:                                # %if.then7
	movl	$5, 8(%esp)
	movl	$.L.str260, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	28(%edi), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	jmp	.LBB45_64
.LBB45_5:                               # %land.lhs.true4.if.end10_crit_edge
	movl	28(%edi), %eax
.LBB45_6:                               # %if.end10
	movl	%eax, (%esp)
	calll	remove_link
	movl	opt+104, %eax
	movl	%eax, 56(%esp)          # 4-byte Spill
	testl	%eax, %eax
	jne	.LBB45_8
# BB#7:                                 # %if.then14
	movl	28(%edi), %eax
	movl	%eax, 56(%esp)          # 4-byte Spill
.LBB45_8:                               # %if.end16
	testb	$1, (%edi)
	je	.LBB45_10
# BB#9:                                 # %if.then19
	movl	$1, (%edi)
.LBB45_10:                              # %if.end21
	movl	4(%edi), %eax
	andl	$16, %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	leal	64(%esp), %esi
	jmp	.LBB45_11
	.align	16, 0x90
.LBB45_32:                              # %sw.bb106
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	opt+8, %eax
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	printwhat
	cmpl	$25, %ebp
	jne	.LBB45_39
# BB#33:                                # %if.then108
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	28(%edi), %eax
	testl	%eax, %eax
	je	.LBB45_35
# BB#34:                                # %if.else112
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB45_35:                              # %if.end114
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_file_name
	movl	%eax, 56(%esp)          # 4-byte Spill
	movl	%eax, 28(%edi)
	.align	16, 0x90
.LBB45_39:                              # %do.cond
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	opt+8, %eax
	testl	%eax, %eax
	movl	60(%esp), %ecx          # 4-byte Reload
	movl	%ecx, %ebp
	je	.LBB45_11
# BB#40:                                # %do.cond
                                        #   in Loop: Header=BB45_11 Depth=1
	cmpl	%eax, %ecx
	movl	%ecx, %ebp
	jl	.LBB45_11
	jmp	.LBB45_41
	.align	16, 0x90
.LBB45_36:                              # %sw.bb119
                                        #   in Loop: Header=BB45_11 Depth=1
	testl	%edx, %edx
	je	.LBB45_38
# BB#37:                                # %lor.lhs.false
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	xorl	12(%edx), %ecx
	xorl	8(%edx), %eax
	orl	%ecx, %eax
	je	.LBB45_45
.LBB45_38:                              # %if.then123
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	opt+8, %eax
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	printwhat
	jmp	.LBB45_39
.LBB45_11:                              # %do.body
                                        # =>This Inner Loop Header: Depth=1
	leal	1(%ebp), %eax
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	sleep_between_retrievals
	movl	(%edi), %ecx
	testb	$1, %cl
	jne	.LBB45_12
# BB#15:                                # %if.else37
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	4(%edi), %eax
	movl	%eax, %edx
	orl	$1, %edx
	andl	$-2, %eax
	cmpl	$-1, 8(%edi)
	cmovel	%edx, %eax
	movl	%eax, 4(%edi)
	testb	$2, %cl
	jne	.LBB45_16
# BB#17:                                # %if.else53
                                        #   in Loop: Header=BB45_11 Depth=1
	orl	$2, %eax
	jmp	.LBB45_18
.LBB45_12:                              # %if.then27
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	$20, 4(%edi)
	cmpl	$-1, 8(%edi)
	jne	.LBB45_13
# BB#14:                                # %if.else33
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	$23, 4(%edi)
	jmp	.LBB45_19
.LBB45_16:                              # %if.then50
                                        #   in Loop: Header=BB45_11 Depth=1
	andl	$-3, %eax
.LBB45_18:                              # %if.end57
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%eax, 4(%edi)
	xorl	%ebx, %ebx
	testb	$8, %al
	movl	$0, %ecx
	jne	.LBB45_24
	jmp	.LBB45_19
.LBB45_13:                              # %if.then30
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	$20, 4(%edi)
.LBB45_19:                              # %if.else62
                                        #   in Loop: Header=BB45_11 Depth=1
	cmpb	$0, opt+116
	je	.LBB45_23
# BB#20:                                # %land.lhs.true64
                                        #   in Loop: Header=BB45_11 Depth=1
	leal	320(%esp), %eax
	movl	%eax, 8(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	jne	.LBB45_23
# BB#21:                                # %land.lhs.true67
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	336(%esp), %eax
	movl	$61440, %ecx            # imm = 0xF000
	andl	%ecx, %eax
	cmpl	$32768, %eax            # imm = 0x8000
	jne	.LBB45_23
# BB#22:                                # %if.then70
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	364(%esp), %ebx
	movl	368(%esp), %ecx
	jmp	.LBB45_24
.LBB45_23:                              # %if.else71
                                        #   in Loop: Header=BB45_11 Depth=1
	testl	%ebp, %ebp
	movl	420(%esp), %ecx
	movl	$0, %eax
	cmovlel	%eax, %ecx
	movl	416(%esp), %ebx
	cmovlel	%eax, %ebx
.LBB45_24:                              # %if.end77
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	%ebp, 44(%esp)          # 4-byte Spill
	movl	$0, (%esp)
	calll	time
	movl	%eax, (%esp)
	calll	datetime_str
	movl	%eax, %ebp
	cmpl	$0, opt
	je	.LBB45_28
# BB#25:                                # %if.then81
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %edi
	movb	$0, 72(%esp)
	movl	$538976288, 68(%esp)    # imm = 0x20202020
	movl	$538976288, 64(%esp)    # imm = 0x20202020
	cmpl	$0, 44(%esp)            # 4-byte Folded Reload
	jle	.LBB45_27
# BB#26:                                # %if.then85
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str462, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	60(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	sprintf
.LBB45_27:                              # %if.end89
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 20(%esp)
	movl	%esi, 16(%esp)
	movl	%edi, 12(%esp)
	movl	%ebp, 8(%esp)
	movl	$.L.str563, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	%edi, (%esp)
	calll	checking_free
.LBB45_28:                              # %if.end91
                                        #   in Loop: Header=BB45_11 Depth=1
	xorl	%eax, %eax
	movl	48(%esp), %edx          # 4-byte Reload
	testl	%edx, %edx
	movl	$0, %ecx
	movl	448(%esp), %edi
	je	.LBB45_30
# BB#29:                                # %if.then93
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	8(%edx), %eax
	movl	12(%edx), %ecx
.LBB45_30:                              # %if.end95
                                        #   in Loop: Header=BB45_11 Depth=1
	movl	%eax, 416(%esp)
	movl	%ecx, 420(%esp)
	movl	%edi, 8(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	52(%esp), %ecx          # 4-byte Reload
	movl	%edx, %ebp
	leal	416(%esp), %edx
	calll	getftp
	movl	%ebp, %edx
	movl	%eax, %ebp
	movl	(%edi), %eax
	movl	%eax, %ecx
	andl	$-3, %ecx
	orl	$2, %eax
	cmpl	$-1, 8(%edi)
	cmovel	%ecx, %eax
	movl	%eax, (%edi)
	leal	-1(%ebp), %eax
	cmpl	$51, %eax
	ja	.LBB45_44
# BB#31:                                # %if.end95
                                        #   in Loop: Header=BB45_11 Depth=1
	jmpl	*.LJTI45_0(,%eax,4)
.LBB45_45:                              # %sw.epilog
	movl	$0, (%esp)
	calll	time
	movl	%eax, (%esp)
	xorl	%ebp, %ebp
	calll	datetime_str
	movl	%eax, 60(%esp)          # 4-byte Spill
	cmpb	$0, opt+57
	jne	.LBB45_47
# BB#46:                                # %if.then128
	movsd	12(%edi), %xmm0
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movsd	%xmm0, 8(%esp)
	subl	%ebx, %eax
	sbbl	40(%esp), %ecx          # 4-byte Folded Reload
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	retr_rate
	movl	%eax, %ebp
.LBB45_47:                              # %if.end130
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	downloaded_file
	testb	$1, (%edi)
	je	.LBB45_49
# BB#48:                                # %if.then135
	movl	8(%edi), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$-1, 8(%edi)
.LBB45_49:                              # %if.end138
	movl	%edi, %esi
	cmpb	$0, opt+57
	jne	.LBB45_51
# BB#50:                                # %if.then140
	movl	$5, 8(%esp)
	movl	$.L.str664, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 20(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 16(%esp)
	movl	%ebp, 12(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB45_51:                              # %if.end143
	cmpl	$0, opt
	movl	44(%esp), %ebx          # 4-byte Reload
	jne	.LBB45_54
# BB#52:                                # %if.end143
	movb	opt+4, %al
	testb	%al, %al
	jne	.LBB45_54
# BB#53:                                # %if.then147
	incl	%ebx
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %edi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%ebx, 24(%esp)
	movl	56(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 20(%esp)
	movl	%eax, 16(%esp)
	movl	%edi, 12(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	$.L.str765, 4(%esp)
	movl	$2, (%esp)
	calll	logprintf
	movl	%edi, (%esp)
	calll	checking_free
.LBB45_54:                              # %if.end152
	testb	$8, 4(%esi)
	je	.LBB45_57
# BB#55:                                # %if.then156
	cmpb	$0, opt+265
	jne	.LBB45_63
# BB#56:                                # %if.then158
	movl	total_downloaded_bytes+4, %ecx
	movl	total_downloaded_bytes, %eax
	addl	416(%esp), %eax
	adcl	420(%esp), %ecx
	movl	%ecx, total_downloaded_bytes+4
	movl	%eax, total_downloaded_bytes
	incl	opt+244
	jmp	.LBB45_63
.LBB45_44:                              # %sw.default
	calll	abort
.LBB45_57:                              # %if.else161
	cmpb	$0, opt+57
	jne	.LBB45_63
# BB#58:                                # %if.then163
	movl	total_downloaded_bytes+4, %ecx
	movl	total_downloaded_bytes, %eax
	addl	416(%esp), %eax
	adcl	420(%esp), %ecx
	movl	%ecx, total_downloaded_bytes+4
	movl	%eax, total_downloaded_bytes
	incl	opt+244
	cmpb	$0, opt+288
	je	.LBB45_63
# BB#59:                                # %do.body168
	cmpb	$0, opt+250
	jne	.LBB45_60
	.align	16, 0x90
.LBB45_61:                              # %do.end
	movl	$5, 8(%esp)
	movl	$.L.str967, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	56(%esp), %edi          # 4-byte Reload
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	%edi, (%esp)
	calll	unlink
	testl	%eax, %eax
	je	.LBB45_63
# BB#62:                                # %if.then176
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	$.L.str1068, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB45_63:                              # %if.end182
	movl	4(%esi), %eax
	movl	%eax, %ecx
	andl	$-17, %ecx
	orl	$16, %eax
	cmpl	$0, 36(%esp)            # 4-byte Folded Reload
	cmovel	%ecx, %eax
	movl	%eax, 4(%esi)
.LBB45_64:                              # %if.end182
	movl	$31, %ebp
	.align	16, 0x90
.LBB45_65:                              # %return
	movl	%ebp, %eax
	addl	$428, %esp              # imm = 0x1AC
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB45_41:                              # %do.end194
	movl	8(%edi), %eax
	movl	$41, %ebp
	cmpl	$-1, %eax
	je	.LBB45_65
# BB#42:                                # %land.lhs.true198
	movl	$41, %ebp
	testb	$1, (%edi)
	je	.LBB45_65
# BB#43:                                # %if.then202
	movl	%eax, (%esp)
	calll	fd_close
	movl	$-1, 8(%edi)
	movl	$41, %ebp
	jmp	.LBB45_65
.LBB45_60:                              # %if.then171
	movl	$.L.str866, (%esp)
	calll	debug_logprintf
	jmp	.LBB45_61
.Ltmp45:
	.size	ftp_loop_internal, .Ltmp45-ftp_loop_internal
	.section	.rodata,"a",@progbits
	.align	4
.LJTI45_0:
	.long	.LBB45_65
	.long	.LBB45_32
	.long	.LBB45_32
	.long	.LBB45_44
	.long	.LBB45_65
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_65
	.long	.LBB45_32
	.long	.LBB45_32
	.long	.LBB45_32
	.long	.LBB45_65
	.long	.LBB45_44
	.long	.LBB45_32
	.long	.LBB45_32
	.long	.LBB45_44
	.long	.LBB45_32
	.long	.LBB45_36
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_65
	.long	.LBB45_32
	.long	.LBB45_65
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_32
	.long	.LBB45_65
	.long	.LBB45_65
	.long	.LBB45_44
	.long	.LBB45_45
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_44
	.long	.LBB45_32

	.text
	.align	16, 0x90
	.type	getftp,@function
getftp:                                 # @getftp
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$140, %esp
	movl	%ecx, %edi
	movl	16(%ebp), %esi
	testl	%esi, %esi
	je	.LBB46_317
# BB#1:                                 # %cond.end
	cmpl	$0, 28(%esi)
	je	.LBB46_318
# BB#2:                                 # %cond.end5
	movl	%edx, -104(%ebp)        # 4-byte Spill
	movl	4(%esi), %ecx
	movl	%ecx, %eax
	andl	$8, %eax
	movl	%eax, -128(%ebp)        # 4-byte Spill
	sete	%al
	movl	%ecx, %edx
	andl	$4, %edx
	movl	%edx, -120(%ebp)        # 4-byte Spill
	jne	.LBB46_3
	.align	16, 0x90
.LBB46_4:                               # %cond.end10
	movl	%edi, %eax
	testb	$15, %cl
	movl	%ecx, %ebx
	je	.LBB46_320
# BB#5:                                 # %cond.end15
	movl	%eax, %ecx
	movl	%ecx, -108(%ebp)        # 4-byte Spill
	movl	40(%ecx), %eax
	movl	%eax, -48(%ebp)
	movl	44(%ecx), %eax
	movl	%eax, -52(%ebp)
	movl	8(%ecx), %eax
	subl	$16, %esp
	leal	-52(%ebp), %ecx
	movl	%ecx, 8(%esp)
	leal	-48(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$1, 12(%esp)
	calll	search_netrc
	addl	$16, %esp
	movl	-48(%ebp), %eax
	testl	%eax, %eax
	jne	.LBB46_7
# BB#6:                                 # %cond.false20
	movl	opt+120, %eax
	testl	%eax, %eax
	cmovel	opt+108, %eax
.LBB46_7:                               # %cond.end25
	testl	%eax, %eax
	movl	$.L.str1674, %edi
	cmovnel	%eax, %edi
	movl	%edi, -48(%ebp)
	movl	-52(%ebp), %eax
	testl	%eax, %eax
	jne	.LBB46_9
# BB#8:                                 # %cond.false30
	movl	opt+124, %eax
	testl	%eax, %eax
	cmovel	opt+112, %eax
.LBB46_9:                               # %cond.end36
	testl	%eax, %eax
	movl	$.L.str1775, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, -52(%ebp)
	movl	$-1, -44(%ebp)
	movl	$0, 16(%esi)
	movl	$0, 12(%esi)
	leal	12(%esi), %eax
	movl	%eax, -124(%ebp)        # 4-byte Spill
	movl	%ebx, -112(%ebp)        # 4-byte Spill
	testb	$1, %bl
	je	.LBB46_10
# BB#11:                                # %if.else
	movl	-108(%ebp), %ebx        # 4-byte Reload
	leal	8(%ebx), %eax
	movl	32(%esi), %ecx
	testl	%ecx, %ecx
	movl	%ecx, %edx
	cmovel	%ebx, %edx
	leal	8(%ecx), %ecx
	movl	12(%edx), %esi
	cmovel	%eax, %ecx
	movl	(%ecx), %ebx
	je	.LBB46_13
# BB#12:                                # %if.then65
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$.L.str1876, 4(%esp)
	calll	concat_strings
	addl	$16, %esp
	movl	%eax, %edi
.LBB46_13:                              # %if.end67
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	connect_to_host
	addl	$16, %esp
	movl	$1, %esi
	cmpl	$-100, %eax
	je	.LBB46_316
# BB#14:                                # %if.else71
	movl	%eax, %ecx
	testl	%ecx, %ecx
	js	.LBB46_15
# BB#17:                                # %if.end78
	movl	-112(%ebp), %eax        # 4-byte Reload
	andl	$16, %eax
	cmpl	$1, %eax
	sbbl	%eax, %eax
	orl	%ecx, %eax
	movl	%ecx, -96(%ebp)         # 4-byte Spill
	movl	16(%ebp), %ebx
	movl	%eax, 8(%ebx)
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1977, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	-48(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	cmpb	$0, opt+248
	je	.LBB46_19
# BB#18:                                # %if.then89
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$3, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_19:                              # %if.end90
	movl	-52(%ebp), %eax
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	ftp_login
	addl	$16, %esp
	movl	%eax, %esi
	cmpl	$0, 32(%ebx)
	je	.LBB46_21
# BB#20:                                # %if.then94
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB46_21:                              # %if.end95
	cmpl	$51, %esi
	jg	.LBB46_25
# BB#22:                                # %if.end95
	addl	$-10, %esi
	cmpl	$10, %esi
	movl	-96(%ebp), %edi         # 4-byte Reload
	ja	.LBB46_29
# BB#23:                                # %if.end95
	jmpl	*.LJTI46_0(,%esi,4)
.LBB46_30:                              # %sw.bb110
	cmpb	$0, opt+248
	jne	.LBB46_33
# BB#31:                                # %sw.epilog
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2684, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	cmpb	$0, opt+248
	jne	.LBB46_33
# BB#32:                                # %if.then116
	subl	$16, %esp
	movl	$.L.str2785, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_33:                              # %if.end117
	subl	$16, %esp
	leal	20(%ebx), %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_syst
	addl	$16, %esp
	cmpl	$10, %eax
	jne	.LBB46_34
# BB#37:                                # %sw.epilog125
	cmpb	$0, opt+248
	jne	.LBB46_41
# BB#38:                                # %if.then129
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2987, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	jmp	.LBB46_39
.LBB46_10:                              # %if.then43
	movl	8(%esi), %esi
	movl	$31, %ebx
	.align	16, 0x90
.LBB46_79:                              # %if.end239
	movl	-112(%ebp), %eax        # 4-byte Reload
	testb	$2, %al
	je	.LBB46_120
# BB#80:                                # %if.then242
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	32(%eax), %edi
	movb	(%edi), %al
	testb	%al, %al
	je	.LBB46_81
# BB#82:                                # %if.else246
	cmpb	$0, opt+250
	jne	.LBB46_83
	.align	16, 0x90
.LBB46_84:                              # %do.end256
	movl	%esi, -96(%ebp)         # 4-byte Spill
	cmpb	$47, %al
	movl	16(%ebp), %esi
	je	.LBB46_96
# BB#85:                                # %land.lhs.true260
	movl	20(%esi), %ecx
	testl	%ecx, %ecx
	je	.LBB46_89
# BB#86:                                # %land.lhs.true264
	movzbl	%al, %eax
	testb	$-120, _sch_istable(%eax,%eax)
	je	.LBB46_88
# BB#87:                                # %land.lhs.true272
	cmpb	$58, 1(%edi)
	je	.LBB46_96
.LBB46_88:                              # %land.lhs.true277
	cmpl	$4, %ecx
	je	.LBB46_96
.LBB46_89:                              # %if.then281
	movl	%edi, -100(%ebp)        # 4-byte Spill
	movl	24(%esi), %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	.align	16, 0x90
.LBB46_90:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %esi
	testl	%esi, %esi
	jle	.LBB46_92
# BB#91:                                # %land.rhs
                                        #   in Loop: Header=BB46_90 Depth=1
	leal	-1(%esi), %eax
	cmpb	$47, -1(%ebx,%esi)
	je	.LBB46_90
.LBB46_92:                              # %while.end
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	32(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	leal	17(%eax,%esi), %eax
	andl	$-16, %eax
	movl	%esp, %edi
	subl	%eax, %edi
	movl	%edi, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$47, (%esi,%edi)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	calll	strcpy
	addl	$16, %esp
	cmpb	$0, opt+250
	jne	.LBB46_94
# BB#93:
	movl	16(%ebp), %esi
	.align	16, 0x90
.LBB46_96:                              # %if.end316
	cmpl	$1, 20(%esi)
	jne	.LBB46_97
# BB#98:                                # %if.then320
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	addl	$17, %esi
	andl	$-16, %esi
	movl	%esp, %ebx
	movl	%ebx, -100(%ebp)        # 4-byte Spill
	subl	%esi, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcpy
	addl	$16, %esp
	negl	%esi
	movl	-100(%ebp), %eax        # 4-byte Reload
	cmpb	$47, (%eax,%esi)
	jne	.LBB46_323
# BB#99:                                # %cond.end330
	movb	$91, (%ebx)
	leal	2(%ebx), %eax
	jmp	.LBB46_100
.LBB46_120:                             # %if.else384
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str49107, 4(%esp)
	jmp	.LBB46_121
.LBB46_15:                              # %if.then73
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	.align	16, 0x90
.LBB46_16:                              # %if.then73
	calll	retryable_socket_connect_error
	addl	$16, %esp
	testb	%al, %al
	sete	%al
	movzbl	%al, %eax
	imull	$2, %eax, %esi
	addl	$3, %esi
	jmp	.LBB46_316
.LBB46_25:                              # %if.end95
	cmpl	$52, %esi
	movl	-96(%ebp), %esi         # 4-byte Reload
	jne	.LBB46_29
# BB#26:                                # %sw.bb101
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$52, %esi
	jmp	.LBB46_316
.LBB46_81:                              # %if.then244
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str4098, 4(%esp)
.LBB46_121:                             # %if.else384
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	.align	16, 0x90
.LBB46_122:                             # %if.end386
	cmpl	$0, -120(%ebp)          # 4-byte Folded Reload
	movl	%esi, %edi
	je	.LBB46_136
# BB#123:                               # %land.lhs.true389
	movl	-104(%ebp), %ecx        # 4-byte Reload
	movl	(%ecx), %eax
	orl	4(%ecx), %eax
	jne	.LBB46_136
# BB#124:                               # %if.then392
	cmpl	$0, opt
	movl	-108(%ebp), %esi        # 4-byte Reload
	je	.LBB46_127
# BB#125:                               # %if.then392
	movb	opt+248, %al
	testb	%al, %al
	jne	.LBB46_127
# BB#126:                               # %if.then396
	movl	36(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str50108, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_127:                             # %if.end399
	movl	36(%esi), %eax
	subl	$16, %esp
	movl	-104(%ebp), %ebx        # 4-byte Reload
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_size
	addl	$16, %esp
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB46_128
# BB#132:                               # %sw.epilog406
	movl	%ebx, -104(%ebp)        # 4-byte Spill
	movl	$10, %ebx
	cmpb	$0, opt+248
	jne	.LBB46_136
# BB#133:                               # %if.then408
	movl	-104(%ebp), %ebx        # 4-byte Reload
	movl	(%ebx), %eax
	movl	4(%ebx), %ecx
	movl	$.L.str51, %esi
	movl	%eax, %edx
	orl	%ecx, %edx
	jne	.LBB46_135
# BB#134:                               # %cond.false411
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	(%ebx), %eax
	movl	4(%ebx), %ecx
.LBB46_135:                             # %cond.end413
	movl	%ebx, -104(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	$10, %ebx
.LBB46_136:                             # %if.end417
	movl	$-1, -100(%ebp)         # 4-byte Folded Spill
	xorb	%al, %al
	movl	-112(%ebp), %ecx        # 4-byte Reload
	andl	$12, %ecx
	movl	%ecx, -132(%ebp)        # 4-byte Spill
	movb	$0, -113(%ebp)          # 1-byte Folded Spill
	movl	12(%ebp), %esi
	je	.LBB46_202
# BB#137:                               # %if.then420
	cmpb	$0, opt+130
	je	.LBB46_160
# BB#138:                               # %if.then422
	subl	$16, %esp
	leal	-88(%ebp), %ebx
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	movl	$1, 8(%esp)
	calll	socket_ip_address
	addl	$16, %esp
	testb	%al, %al
	je	.LBB46_324
# BB#139:                               # %if.end.i
	movl	-88(%ebp), %eax
	cmpl	$10, %eax
	jne	.LBB46_140
# BB#144:                               # %sw.bb4.i
	cmpb	$0, opt+248
	jne	.LBB46_146
# BB#145:                               # %if.then6.i
	subl	$16, %esp
	movl	$.L.str88, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_146:                             # %if.end7.i
	subl	$16, %esp
	leal	-92(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_epsv
	addl	$16, %esp
	cmpl	$36, %eax
	jne	.LBB46_151
# BB#147:                               # %if.then9.i
	cmpb	$0, opt+248
	jne	.LBB46_149
# BB#148:                               # %if.then11.i
	subl	$16, %esp
	movl	$.L.str89, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_149:                             # %if.end12.i
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_lpsv
	jmp	.LBB46_150
.LBB46_97:
	movl	%edi, %ebx
	jmp	.LBB46_107
.LBB46_29:                              # %sw.default
	calll	abort
.LBB46_140:                             # %if.end.i
	cmpl	$2, %eax
	jne	.LBB46_324
# BB#141:                               # %sw.bb.i
	cmpb	$0, opt+248
	jne	.LBB46_143
# BB#142:                               # %if.then1.i
	subl	$16, %esp
	movl	$.L.str87, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_143:                             # %if.end2.i
	subl	$16, %esp
	leal	-92(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_pasv
.LBB46_150:                             # %if.end12.i
	addl	$16, %esp
.LBB46_151:                             # %ftp_do_pasv.exit
	cmpl	$51, %eax
	movl	12(%ebp), %esi
	jg	.LBB46_162
# BB#152:                               # %ftp_do_pasv.exit
	cmpl	$34, %eax
	jg	.LBB46_156
# BB#153:                               # %ftp_do_pasv.exit
	cmpl	$10, %eax
	jne	.LBB46_154
# BB#166:                               # %do.body439
	cmpb	$0, opt+250
	jne	.LBB46_167
	.align	16, 0x90
.LBB46_168:                             # %do.end447
	movl	-92(%ebp), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 8(%esp)
	calll	connect_to_ip
	addl	$16, %esp
	movl	%eax, -100(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	js	.LBB46_169
# BB#170:                               # %if.end460
	cmpb	$0, opt+248
	je	.LBB46_172
# BB#171:
	movb	$1, %al
	movl	$10, %ebx
	jmp	.LBB46_202
	.align	16, 0x90
.LBB46_102:                             # %for.cond332.backedge
                                        #   in Loop: Header=BB46_100 Depth=1
	incl	%eax
	.align	16, 0x90
.LBB46_100:                             # %for.cond332
                                        # =>This Inner Loop Header: Depth=1
	movb	-1(%eax), %cl
	testb	%cl, %cl
	je	.LBB46_104
# BB#101:                               # %for.cond332
                                        #   in Loop: Header=BB46_100 Depth=1
	cmpb	$47, %cl
	jne	.LBB46_102
# BB#103:                               # %if.then338
                                        #   in Loop: Header=BB46_100 Depth=1
	movb	$46, -1(%eax)
	incl	%eax
	jmp	.LBB46_100
.LBB46_104:                             # %for.end342
	movb	$93, -1(%eax)
	movb	$0, (%eax)
	cmpb	$0, opt+250
	jne	.LBB46_105
	.align	16, 0x90
.LBB46_107:                             # %if.then357
	movl	-96(%ebp), %edi         # 4-byte Reload
	cmpb	$0, opt+248
	jne	.LBB46_109
# BB#108:                               # %if.then362
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str47105, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_109:                             # %if.end364
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_cwd
	addl	$16, %esp
	cmpl	$51, %eax
	jg	.LBB46_114
# BB#110:                               # %if.end364
	cmpl	$10, %eax
	jne	.LBB46_111
# BB#118:                               # %sw.epilog378
	movl	%edi, %esi
	movl	$10, %ebx
	cmpb	$0, opt+248
	jne	.LBB46_122
# BB#119:                               # %if.then380
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$10, %ebx
	jmp	.LBB46_122
.LBB46_114:                             # %if.end364
	cmpl	$52, %eax
	movl	16(%ebp), %esi
	jne	.LBB46_117
# BB#115:                               # %sw.bb369
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%esi)
	movl	$52, %esi
	jmp	.LBB46_316
.LBB46_111:                             # %if.end364
	movl	%edi, %ebx
	cmpl	$15, %eax
	movl	-108(%ebp), %edi        # 4-byte Reload
	jne	.LBB46_112
# BB#116:                               # %sw.bb372
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str48106, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	32(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	movl	$15, %esi
	jmp	.LBB46_316
.LBB46_162:                             # %ftp_do_pasv.exit
	cmpl	$52, %eax
	jne	.LBB46_165
# BB#163:                               # %sw.bb427
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	movl	$52, %esi
	jmp	.LBB46_316
.LBB46_128:                             # %if.end399
	movl	%edi, %ebx
	cmpl	$18, %esi
	movl	16(%ebp), %edi
	je	.LBB46_130
# BB#129:                               # %if.end399
	cmpl	$20, %esi
	jne	.LBB46_131
.LBB46_130:                             # %sw.bb402
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%edi)
	jmp	.LBB46_316
.LBB46_28:                              # %sw.bb107
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2583, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$11, %esi
	jmp	.LBB46_316
.LBB46_27:                              # %sw.bb104
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2482, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$12, %esi
	jmp	.LBB46_316
.LBB46_24:                              # %sw.bb98
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2280, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$20, %esi
	jmp	.LBB46_316
.LBB46_112:                             # %if.end364
	cmpl	$18, %eax
	movl	16(%ebp), %esi
	jne	.LBB46_117
# BB#113:                               # %sw.bb366
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%esi)
	movl	$18, %esi
	jmp	.LBB46_316
.LBB46_117:                             # %sw.default377
	calll	abort
.LBB46_156:                             # %ftp_do_pasv.exit
	cmpl	$35, %eax
	jne	.LBB46_157
# BB#164:                               # %sw.bb432
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str53, 4(%esp)
	jmp	.LBB46_159
.LBB46_34:                              # %if.end117
	cmpl	$20, %eax
	jne	.LBB46_35
# BB#321:                               # %sw.epilog125.thread
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2886, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
.LBB46_39:                              # %if.then129
	calll	logputs
	addl	$16, %esp
	cmpb	$0, opt+248
	jne	.LBB46_41
# BB#40:                                # %if.then133
	subl	$16, %esp
	movl	$.L.str3088, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_41:                              # %if.end134
	subl	$16, %esp
	leal	24(%ebx), %eax
	movl	%eax, -100(%ebp)        # 4-byte Spill
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_pwd
	addl	$16, %esp
	cmpl	$10, %eax
	je	.LBB46_48
# BB#42:                                # %if.end134
	cmpl	$20, %eax
	jne	.LBB46_43
# BB#45:                                # %sw.bb139
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.LBB46_47
# BB#46:                                # %if.else143
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB46_47:                              # %if.end145
	subl	$16, %esp
	movl	$.L.str3189, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	-100(%ebp), %ecx        # 4-byte Reload
	movl	%eax, (%ecx)
.LBB46_48:                              # %sw.epilog149
	cmpl	$1, (%esi)
	jne	.LBB46_63
# BB#49:                                # %if.then152
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$91, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB46_51
# BB#50:                                # %cond.end159
	subl	$16, %esp
	incl	%esi
	movl	%esi, (%esp)
	movl	$93, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB46_51
# BB#53:                                # %if.else168
	cmpb	$0, opt+250
	je	.LBB46_56
# BB#54:                                # %do.body178
	subl	$16, %esp
	movl	$.L.str3391, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	je	.LBB46_56
# BB#55:                                # %if.then183
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str3492, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
.LBB46_56:                              # %do.end186
	movb	$47, (%ebx)
	incl	%ebx
	cmpl	%edi, %esi
	jae	.LBB46_60
	.align	16, 0x90
.LBB46_57:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movb	(%esi), %cl
	movb	$47, %al
	cmpb	$46, %cl
	je	.LBB46_59
# BB#58:                                # %for.body
                                        #   in Loop: Header=BB46_57 Depth=1
	movb	%cl, %al
.LBB46_59:                              # %for.body
                                        #   in Loop: Header=BB46_57 Depth=1
	movb	%al, (%ebx)
	incl	%ebx
	incl	%esi
	cmpl	%esi, %edi
	jne	.LBB46_57
.LBB46_60:                              # %for.end
	movb	$0, (%ebx)
	cmpb	$0, opt+250
	je	.LBB46_63
# BB#61:                                # %if.then206
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str3593, (%esp)
	jmp	.LBB46_62
.LBB46_83:                              # %if.then254
	subl	$16, %esp
	movl	$.L.str4199, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movb	(%edi), %al
	jmp	.LBB46_84
.LBB46_154:                             # %ftp_do_pasv.exit
	cmpl	$18, %eax
	jne	.LBB46_165
# BB#155:                               # %sw.bb424
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	movl	$18, %esi
	jmp	.LBB46_316
.LBB46_131:                             # %sw.default405
	calll	abort
.LBB46_157:                             # %ftp_do_pasv.exit
	cmpl	$36, %eax
	jne	.LBB46_165
# BB#158:                               # %sw.bb430
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str52, 4(%esp)
.LBB46_159:                             # %sw.bb430
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_160:                             # %if.then468
	subl	$16, %esp
	leal	-40(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	movl	$1, 8(%esp)
	calll	socket_ip_address
	addl	$16, %esp
	testb	%al, %al
	je	.LBB46_161
# BB#173:                               # %if.end.i833
	movl	-40(%ebp), %eax
	cmpl	$10, %eax
	jne	.LBB46_174
# BB#178:                               # %sw.bb4.i840
	cmpb	$0, opt+248
	jne	.LBB46_180
# BB#179:                               # %if.then6.i841
	subl	$16, %esp
	movl	$.L.str85, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_180:                             # %if.end7.i844
	subl	$16, %esp
	leal	-44(%ebp), %ebx
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_eprt
	addl	$16, %esp
	cmpl	$13, %eax
	jne	.LBB46_185
# BB#181:                               # %if.then9.i846
	cmpb	$0, opt+248
	jne	.LBB46_183
# BB#182:                               # %if.then11.i847
	subl	$16, %esp
	movl	$.L.str86, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_183:                             # %if.end12.i849
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_lprt
	jmp	.LBB46_184
.LBB46_174:                             # %if.end.i833
	cmpl	$2, %eax
	jne	.LBB46_324
# BB#175:                               # %sw.bb.i835
	cmpb	$0, opt+248
	jne	.LBB46_177
# BB#176:                               # %if.then1.i836
	subl	$16, %esp
	movl	$.L.str84, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_177:                             # %if.end2.i838
	subl	$16, %esp
	leal	-44(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_port
.LBB46_184:                             # %if.end12.i849
	addl	$16, %esp
.LBB46_185:                             # %ftp_do_port.exit
	cmpl	$51, %eax
	jg	.LBB46_193
# BB#186:                               # %ftp_do_port.exit
	cmpl	$9, %eax
	jg	.LBB46_189
# BB#187:                               # %ftp_do_port.exit
	cmpl	$2, %eax
	jne	.LBB46_198
# BB#188:                               # %sw.bb476
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str56, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	$-1, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$2, %esi
	jmp	.LBB46_316
.LBB46_324:                             # %sw.default.i850
	calll	abort
.LBB46_165:                             # %sw.default434
	calll	abort
.LBB46_193:                             # %ftp_do_port.exit
	cmpl	$52, %eax
	jne	.LBB46_198
# BB#194:                               # %sw.bb473
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	$-1, (%esp)
	jmp	.LBB46_195
.LBB46_189:                             # %ftp_do_port.exit
	addl	$-10, %eax
	cmpl	$8, %eax
	ja	.LBB46_198
# BB#190:                               # %ftp_do_port.exit
	jmpl	*.LJTI46_1(,%eax,4)
.LBB46_199:                             # %sw.epilog488
	cmpb	$0, opt+248
	je	.LBB46_201
# BB#200:
	xorb	%al, %al
	movl	$-1, -100(%ebp)         # 4-byte Folded Spill
	movl	$10, %ebx
	jmp	.LBB46_202
.LBB46_198:                             # %sw.default487
	calll	abort
.LBB46_105:                             # %do.body352
	subl	$16, %esp
	movl	$.L.str45103, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	je	.LBB46_107
# BB#106:                               # %if.then357
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$.L.str46104, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB46_107
.LBB46_35:                              # %if.end117
	cmpl	$18, %eax
	je	.LBB46_44
# BB#36:                                # %sw.default124
	calll	abort
.LBB46_94:                              # %do.body307
	subl	$16, %esp
	movl	$.L.str42100, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	movl	16(%ebp), %esi
	je	.LBB46_96
# BB#95:                                # %if.then312
	movl	24(%esi), %eax
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	-100(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str43101, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB46_96
.LBB46_169:                             # %if.then451
	calll	__errno_location
	movl	%ebx, %esi
	movl	(%eax), %ebx
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str55, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -96(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	print_address
	addl	$16, %esp
	movl	%eax, %edi
	movl	-92(%ebp), %esi
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%edi, 8(%esp)
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$32, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	jmp	.LBB46_16
.LBB46_43:                              # %if.end134
	cmpl	$18, %eax
	je	.LBB46_44
# BB#322:                               # %sw.default148
	calll	abort
.LBB46_44:                              # %sw.bb
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$18, %esi
	jmp	.LBB46_316
.LBB46_197:                             # %sw.bb484
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str58109, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	$-1, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$13, %esi
	jmp	.LBB46_316
.LBB46_196:                             # %sw.bb480
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str57, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	$-1, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$14, %esi
	jmp	.LBB46_316
.LBB46_191:                             # %sw.bb470
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	$-1, (%esp)
	jmp	.LBB46_192
.LBB46_172:                             # %if.then462
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2987, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$10, %ebx
	movb	$1, %al
	jmp	.LBB46_202
.LBB46_51:                              # %do.body
	cmpb	$0, opt+250
	je	.LBB46_63
# BB#52:                                # %if.then166
	subl	$16, %esp
	movl	$.L.str3290, (%esp)
.LBB46_62:                              # %if.then206
	calll	debug_logprintf
	addl	$16, %esp
.LBB46_63:                              # %if.end211
	cmpb	$0, opt+248
	jne	.LBB46_65
# BB#64:                                # %if.then213
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_65:                              # %if.end215
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	20(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	ftp_process_type
	addl	$16, %esp
	movsbl	%al, %esi
	cmpb	$0, opt+248
	movl	16(%ebp), %edi
	jne	.LBB46_67
# BB#66:                                # %if.then218
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$.L.str3795, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_67:                              # %if.end220
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	ftp_type
	addl	$16, %esp
	cmpl	$51, %eax
	jg	.LBB46_72
# BB#68:                                # %if.end220
	cmpl	$10, %eax
	jne	.LBB46_69
# BB#76:                                # %sw.epilog234
	movl	$10, %ebx
	cmpb	$0, opt+248
	jne	.LBB46_78
# BB#77:                                # %if.then236
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3997, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$10, %ebx
.LBB46_78:                              # %if.then236
	movl	-96(%ebp), %esi         # 4-byte Reload
	jmp	.LBB46_79
.LBB46_317:                             # %cond.false
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.getftp, 12(%esp)
	movl	$250, 8(%esp)
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str1169, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB46_318:                             # %cond.false4
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.getftp, 12(%esp)
	movl	$251, 8(%esp)
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str1371, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB46_3:                               # %cond.end5
	testb	%al, %al
	jne	.LBB46_4
# BB#319:                               # %cond.false9
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.getftp, 12(%esp)
	movl	$256, 8(%esp)           # imm = 0x100
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str1472, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB46_320:                             # %cond.false14
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.getftp, 12(%esp)
	movl	$258, 8(%esp)           # imm = 0x102
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str1573, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB46_323:                             # %cond.false329
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.getftp, 12(%esp)
	movl	$536, 8(%esp)           # imm = 0x218
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str44102, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB46_167:                             # %if.then444
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	print_address
	addl	$16, %esp
	movl	-92(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str54, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB46_168
.LBB46_161:                             # %if.then.i831
	calll	abort
.LBB46_201:                             # %if.then490
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2987, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$-1, -100(%ebp)         # 4-byte Folded Spill
	movl	$10, %ebx
	xorb	%al, %al
.LBB46_202:                             # %if.end494
	movb	%al, -133(%ebp)         # 1-byte Spill
	cmpl	$0, -120(%ebp)          # 4-byte Folded Reload
	sete	%al
	movl	8(%ebp), %ecx
	orl	%esi, %ecx
	sete	-134(%ebp)              # 1-byte Folded Spill
	je	.LBB46_217
# BB#203:                               # %if.end494
	testb	%al, %al
	jne	.LBB46_217
# BB#204:                               # %if.then499
	movl	%edi, -96(%ebp)         # 4-byte Spill
	cmpb	$0, opt+248
	movl	16(%ebp), %esi
	movl	12(%ebp), %ebx
	movl	8(%ebp), %edi
	jne	.LBB46_206
# BB#205:                               # %if.then501
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str59, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_206:                             # %if.end503
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	-96(%ebp), %edi         # 4-byte Reload
	movl	%edi, (%esp)
	calll	ftp_rest
	addl	$16, %esp
	cmpl	$51, %eax
	jg	.LBB46_211
# BB#207:                               # %if.end503
	cmpl	$10, %eax
	jne	.LBB46_208
# BB#214:                               # %sw.epilog514
	cmpb	$0, opt+248
	je	.LBB46_216
# BB#215:
	movb	$0, -113(%ebp)          # 1-byte Folded Spill
	movl	$10, %ebx
	jmp	.LBB46_217
.LBB46_211:                             # %if.end503
	cmpl	$52, %eax
	jne	.LBB46_213
	jmp	.LBB46_212
.LBB46_208:                             # %if.end503
	cmpl	$18, %eax
	je	.LBB46_242
# BB#209:                               # %if.end503
	cmpl	$22, %eax
	jne	.LBB46_213
# BB#210:                               # %sw.epilog514.thread
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str60, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$22, %ebx
	movb	$1, -113(%ebp)          # 1-byte Folded Spill
	jmp	.LBB46_217
.LBB46_213:                             # %sw.default513
	calll	abort
.LBB46_216:                             # %if.then519
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2987, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$10, %ebx
	movb	$0, -113(%ebp)          # 1-byte Folded Spill
.LBB46_217:                             # %if.end522
	movl	%edi, -96(%ebp)         # 4-byte Spill
	xorl	%eax, %eax
	cmpl	$0, -120(%ebp)          # 4-byte Folded Reload
	movl	$0, %edx
	je	.LBB46_235
# BB#218:                               # %if.then525
	cmpb	$0, opt+57
	movl	8(%ebp), %ecx
	je	.LBB46_220
# BB#219:                               # %if.then527
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	.align	16, 0x90
.LBB46_315:                             # %while.end809
	addl	$16, %esp
	movl	$39, %esi
	jmp	.LBB46_316
.LBB46_220:                             # %if.end529
	cmpl	$0, opt
	movl	16(%ebp), %esi
	movl	-96(%ebp), %edi         # 4-byte Reload
	movl	-108(%ebp), %ebx        # 4-byte Reload
	je	.LBB46_222
# BB#221:                               # %if.end529
	movb	opt+248, %al
	testb	%al, %al
	jne	.LBB46_222
# BB#223:                               # %if.then533
	movl	%ecx, %eax
	orl	12(%ebp), %eax
	je	.LBB46_225
# BB#224:                               # %if.then535
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_225:                             # %if.end536
	movl	36(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str61, 4(%esp)
	movl	$0, (%esp)
	addl	$36, %ebx
	calll	logprintf
	addl	$16, %esp
	jmp	.LBB46_226
.LBB46_222:                             # %if.end529.if.end540_crit_edge
	addl	$36, %ebx
.LBB46_226:                             # %if.end540
	movl	(%ebx), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	ftp_retr
	addl	$16, %esp
	cmpl	$51, %eax
	jg	.LBB46_230
# BB#227:                               # %if.end540
	cmpl	$10, %eax
	jne	.LBB46_228
# BB#232:                               # %sw.epilog554
	cmpb	$0, opt+248
	jne	.LBB46_234
# BB#233:                               # %if.then556
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_234:                             # %if.end558
	calll	ftp_expected_bytes
	movl	$10, %ebx
.LBB46_235:                             # %if.end560
	cmpl	$0, -128(%ebp)          # 4-byte Folded Reload
	je	.LBB46_250
# BB#236:                               # %if.then563
	cmpb	$0, opt+248
	movl	16(%ebp), %esi
	jne	.LBB46_238
# BB#237:                               # %if.then565
	subl	$16, %esp
	movl	$.L.str63, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_238:                             # %if.end566
	subl	$16, %esp
	movl	-96(%ebp), %edi         # 4-byte Reload
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	ftp_list
	addl	$16, %esp
	cmpl	$51, %eax
	jg	.LBB46_243
# BB#239:                               # %if.end566
	cmpl	$10, %eax
	jne	.LBB46_240
# BB#247:                               # %sw.epilog577
	cmpb	$0, opt+248
	jne	.LBB46_249
# BB#248:                               # %if.then579
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_249:                             # %if.end581
	calll	ftp_expected_bytes
	movl	$10, %ebx
.LBB46_250:                             # %if.end583
	movl	%edx, -108(%ebp)        # 4-byte Spill
	movl	%eax, %edi
	movl	$39, %esi
	cmpl	$0, -132(%ebp)          # 4-byte Folded Reload
	je	.LBB46_316
# BB#251:                               # %lor.lhs.false586
	cmpb	$0, opt+57
	je	.LBB46_253
# BB#252:                               # %lor.lhs.false586
	movl	$39, %esi
	cmpl	$0, -128(%ebp)          # 4-byte Folded Reload
	je	.LBB46_316
.LBB46_253:                             # %if.end593
	movl	%ebx, -120(%ebp)        # 4-byte Spill
	movl	-104(%ebp), %ecx        # 4-byte Reload
	movl	(%ecx), %eax
	movl	4(%ecx), %ecx
	movl	%eax, %edx
	orl	%ecx, %edx
	sete	%dl
	orb	-134(%ebp), %dl         # 1-byte Folded Reload
	movl	%edi, %esi
	jne	.LBB46_259
# BB#254:                               # %if.end593
	movl	%esi, %edx
	movl	-108(%ebp), %ebx        # 4-byte Reload
	orl	%ebx, %edx
	je	.LBB46_255
# BB#256:                               # %land.lhs.true599
	movl	%eax, %edx
	subl	8(%ebp), %edx
	movl	%esi, %edi
	movl	%ecx, %esi
	sbbl	12(%ebp), %esi
	xorl	%edi, %edx
	xorl	%ebx, %esi
	orl	%edx, %esi
	movl	%edi, %esi
	jne	.LBB46_259
# BB#257:                               # %do.body604
	cmpb	$0, opt+250
	movl	%eax, %esi
	movl	%ecx, -108(%ebp)        # 4-byte Spill
	je	.LBB46_259
# BB#258:                               # %if.then609
	subl	$16, %esp
	movl	$.L.str66, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	-104(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %esi
	movl	4(%eax), %eax
	movl	%eax, -108(%ebp)        # 4-byte Spill
	jmp	.LBB46_259
.LBB46_243:                             # %if.end566
	cmpl	$52, %eax
	je	.LBB46_212
	jmp	.LBB46_244
.LBB46_230:                             # %if.end540
	cmpl	$52, %eax
	jne	.LBB46_231
.LBB46_212:                             # %sw.bb508
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%esi)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
.LBB46_195:                             # %sw.bb473
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$52, %esi
	jmp	.LBB46_316
.LBB46_240:                             # %if.end566
	cmpl	$15, %eax
	jne	.LBB46_241
# BB#245:                               # %sw.bb574
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str64, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str65, 8(%esp)
	jmp	.LBB46_246
.LBB46_228:                             # %if.end540
	cmpl	$15, %eax
	jne	.LBB46_229
# BB#325:                               # %sw.bb549
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str62, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
.LBB46_246:                             # %sw.bb574
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$15, %esi
	jmp	.LBB46_316
.LBB46_241:                             # %if.end566
	cmpl	$18, %eax
	je	.LBB46_242
.LBB46_244:                             # %sw.default576
	calll	abort
.LBB46_255:
	movl	%ebx, -108(%ebp)        # 4-byte Spill
.LBB46_259:                             # %if.end612
	cmpb	$0, -133(%ebp)          # 1-byte Folded Reload
	jne	.LBB46_262
# BB#260:                               # %if.then614
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	accept_connection
	addl	$16, %esp
	movl	%eax, -100(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	js	.LBB46_261
.LBB46_262:                             # %if.end622
	movl	%esi, %edi
	movl	output_stream, %eax
	testl	%eax, %eax
	movl	16(%ebp), %ebx
	movl	12(%ebp), %esi
	je	.LBB46_264
# BB#263:                               # %lor.lhs.false624
	testb	$8, 4(%ebx)
	je	.LBB46_279
.LBB46_264:                             # %if.then628
	movl	28(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	mkalldirs
	addl	$16, %esp
	cmpb	$0, opt+253
	je	.LBB46_266
# BB#265:                               # %if.then632
	movl	28(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	rotate_backups
	addl	$16, %esp
.LBB46_266:                             # %if.end634
	movl	8(%ebp), %eax
	orl	%esi, %eax
	je	.LBB46_272
# BB#267:                               # %land.lhs.true636
	testb	$8, 4(%ebx)
	je	.LBB46_268
.LBB46_272:                             # %if.else643
	movb	opt+116, %al
	orb	opt+42, %al
	orb	opt+251, %al
	jne	.LBB46_275
# BB#273:                               # %lor.lhs.false652
	cmpb	$0, opt+32
	jne	.LBB46_275
# BB#274:                               # %lor.lhs.false652
	movl	opt+104, %eax
	testl	%eax, %eax
	je	.LBB46_276
.LBB46_275:                             # %if.then657
	movl	28(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$.L.str69, 4(%esp)
	jmp	.LBB46_269
.LBB46_229:                             # %if.end540
	cmpl	$18, %eax
	je	.LBB46_242
.LBB46_231:                             # %sw.default553
	calll	abort
.LBB46_242:                             # %sw.bb505
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%esi)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
.LBB46_192:                             # %sw.bb470
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$18, %esi
	.align	16, 0x90
.LBB46_316:                             # %return
	movl	%esi, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB46_72:                              # %if.end220
	cmpl	$52, %eax
	jne	.LBB46_75
# BB#73:                                # %sw.bb226
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2381, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%edi)
	movl	$52, %esi
	jmp	.LBB46_316
.LBB46_69:                              # %if.end220
	cmpl	$17, %eax
	jne	.LBB46_70
# BB#74:                                # %sw.bb229
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3896, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%edi)
	movl	$17, %esi
	jmp	.LBB46_316
.LBB46_261:                             # %if.then618
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str67, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	-120(%ebp), %esi        # 4-byte Reload
	jmp	.LBB46_316
.LBB46_268:                             # %if.then640
	movl	28(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$.L.str68, 4(%esp)
.LBB46_269:                             # %if.then640
	calll	fopen64
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB46_279
# BB#270:                               # %if.end674.if.then676_crit_edge
	calll	__errno_location
	jmp	.LBB46_271
.LBB46_276:                             # %if.else660
	movl	28(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	fopen_excl
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB46_277
.LBB46_279:                             # %if.end683
	movl	%eax, -120(%ebp)        # 4-byte Spill
	movl	-104(%ebp), %ebx        # 4-byte Reload
	movl	(%ebx), %ecx
	movl	4(%ebx), %edx
	movl	%ecx, %eax
	orl	%edx, %eax
	je	.LBB46_281
# BB#280:                               # %if.then685
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$1, 8(%esp)
	calll	print_length
	addl	$16, %esp
	movl	(%ebx), %eax
	movl	4(%ebx), %ecx
	jmp	.LBB46_283
.LBB46_70:                              # %if.end220
	cmpl	$18, %eax
	jne	.LBB46_75
# BB#71:                                # %sw.bb223
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str2179, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%edi)
	movl	$18, %esi
	jmp	.LBB46_316
.LBB46_277:                             # %land.lhs.true664
	calll	__errno_location
	cmpl	$17, (%eax)
	jne	.LBB46_271
# BB#278:                               # %if.then668
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str70, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	28(%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$25, %esi
	jmp	.LBB46_316
.LBB46_281:                             # %if.else686
	xorl	%eax, %eax
	movl	%edi, %ecx
	movl	-108(%ebp), %edx        # 4-byte Reload
	orl	%edx, %ecx
	movl	%eax, %ecx
	movl	8(%ebp), %esi
	je	.LBB46_283
# BB#282:                               # %if.then688
	subl	$16, %esp
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 8(%esp)
	movl	%edi, %ecx
	movl	%edx, %ebx
	calll	print_length
	addl	$16, %esp
	movl	%edi, %eax
	movl	%ebx, %ecx
	movl	-104(%ebp), %ebx        # 4-byte Reload
.LBB46_283:                             # %if.end690
	movl	%ebx, %edx
	movl	%esi, %edi
	movl	12(%ebp), %esi
	orl	%esi, %edi
	movl	$0, %edi
	je	.LBB46_285
# BB#284:                               # %land.lhs.true692
	cmpb	$0, -113(%ebp)          # 1-byte Folded Reload
	setne	%bl
	movzbl	%bl, %edi
	addl	%edi, %edi
.LBB46_285:                             # %if.end696
	movl	8(%ebp), %ebx
	movl	%ebx, (%edx)
	movl	%esi, 4(%edx)
	movl	$0, -60(%ebp)
	movl	$0, -64(%ebp)
	subl	$48, %esp
	movl	%edi, 36(%esp)
	movl	-124(%ebp), %edi        # 4-byte Reload
	movl	%edi, 32(%esp)
	movl	%edx, 28(%esp)
	leal	-64(%ebp), %edi
	movl	%edi, 24(%esp)
	movl	%esi, 20(%esp)
	movl	%ebx, 16(%esp)
	movl	%eax, %edi
	subl	%ebx, %edi
	movl	%ecx, %ebx
	sbbl	%esi, %ebx
	orl	%ecx, %eax
	movl	$0, %eax
	cmovel	%eax, %ebx
	movl	%ebx, 12(%esp)
	cmovel	%eax, %edi
	movl	%edi, 8(%esp)
	movl	-120(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_read_body
	addl	$48, %esp
	movl	%eax, %edi
	subl	$16, %esp
	movl	$0, (%esp)
	calll	time
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	datetime_str
	addl	$16, %esp
	movl	%eax, -104(%ebp)        # 4-byte Spill
	movl	-124(%ebp), %esi        # 4-byte Reload
	movsd	(%esi), %xmm0
	movl	-64(%ebp), %eax
	movl	-60(%ebp), %ecx
	subl	$16, %esp
	movsd	%xmm0, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	retr_rate
	addl	$16, %esp
	movl	%eax, -108(%ebp)        # 4-byte Spill
	movsd	total_download_time, %xmm0
	addsd	(%esi), %xmm0
	movsd	%xmm0, total_download_time
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	cmpl	$0, output_stream
	movl	16(%ebp), %ebx
	je	.LBB46_287
# BB#286:                               # %lor.lhs.false712
	testb	$8, 4(%ebx)
	je	.LBB46_288
.LBB46_287:                             # %if.then716
	subl	$16, %esp
	movl	-120(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	addl	$16, %esp
.LBB46_288:                             # %if.end718
	cmpl	$-2, %edi
	jne	.LBB46_290
# BB#289:                               # %if.then721
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str72, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	28(%ebx), %edi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$26, %esi
	jmp	.LBB46_316
.LBB46_75:                              # %sw.default233
	calll	abort
.LBB46_271:                             # %if.then676
	movl	28(%ebx), %esi
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str71, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-44(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$24, %esi
	jmp	.LBB46_316
.LBB46_290:                             # %if.else727
	cmpl	$-1, %edi
	jne	.LBB46_293
# BB#291:                               # %if.then730
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str73, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_errstr
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	-104(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$32, %esp
	cmpb	$0, opt+248
	je	.LBB46_293
# BB#292:                               # %if.then734
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$3, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB46_293:                             # %if.end737
	subl	$16, %esp
	movl	-100(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	subl	$16, %esp
	leal	-56(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	-96(%ebp), %esi         # 4-byte Reload
	movl	%esi, (%esp)
	calll	ftp_response
	addl	$16, %esp
	cmpl	$10, %eax
	jne	.LBB46_294
# BB#297:                               # %if.end748
	movl	-56(%ebp), %eax
	movb	(%eax), %bl
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	cmpb	$50, %bl
	jne	.LBB46_298
# BB#301:                               # %if.end758
	movl	$21, %esi
	cmpl	$-1, %edi
	je	.LBB46_316
# BB#302:                               # %if.end762
	movl	-112(%ebp), %eax        # 4-byte Reload
	testb	$16, %al
	jne	.LBB46_304
# BB#303:                               # %if.then765
	subl	$16, %esp
	movl	-96(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	16(%ebp), %eax
	movl	$-1, 8(%eax)
.LBB46_304:                             # %if.end767
	movl	$39, %esi
	cmpb	$0, opt+248
	je	.LBB46_316
# BB#305:                               # %land.lhs.true770
	movl	$39, %esi
	movl	16(%ebp), %eax
	testb	$8, 4(%eax)
	je	.LBB46_316
# BB#306:                               # %if.then774
	movl	16(%ebp), %edi
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	mkalldirs
	addl	$16, %esp
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$.L.str77, 4(%esp)
	calll	fopen64
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB46_307
# BB#326:                               # %if.then780
	movl	28(%edi), %esi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str71, 4(%esp)
	movl	$3, (%esp)
	calll	logprintf
	jmp	.LBB46_315
.LBB46_294:                             # %if.then741
	cmpl	$-1, %edi
	je	.LBB46_296
# BB#295:                               # %if.then744
	subl	$16, %esp
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	-104(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	$.L.str74, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_296:                             # %if.end745
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str75, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$-1, 8(%ebx)
	movl	$21, %esi
	jmp	.LBB46_316
.LBB46_298:                             # %if.then752
	cmpl	$-1, %edi
	je	.LBB46_300
# BB#299:                               # %if.then755
	subl	$16, %esp
	movl	-108(%ebp), %eax        # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	-104(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	$.L.str74, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB46_300:                             # %if.end756
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str76, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	$21, %esi
	jmp	.LBB46_316
	.align	16, 0x90
.LBB46_313:                             # %while.end807
                                        #   in Loop: Header=BB46_307 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str51, 4(%esp)
	movl	$3, (%esp)
	calll	logprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB46_307:                             # %while.cond785.preheader
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB46_309 Depth 2
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	read_whole_line
	addl	$16, %esp
	movl	%eax, %edi
	subl	$16, %esp
	testl	%edi, %edi
	je	.LBB46_314
# BB#308:                               # %while.body789
                                        #   in Loop: Header=BB46_307 Depth=1
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	addl	$16, %esp
	jmp	.LBB46_309
	.align	16, 0x90
.LBB46_312:                             # %while.body805
                                        #   in Loop: Header=BB46_309 Depth=2
	movb	$0, -1(%eax)
	decl	%eax
.LBB46_309:                             # %while.cond792
                                        #   Parent Loop BB46_307 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	%edi, %eax
	jbe	.LBB46_313
# BB#310:                               # %land.rhs795
                                        #   in Loop: Header=BB46_309 Depth=2
	movb	-1(%eax), %cl
	cmpb	$10, %cl
	je	.LBB46_312
# BB#311:                               # %land.rhs795
                                        #   in Loop: Header=BB46_309 Depth=2
	cmpb	$13, %cl
	jne	.LBB46_313
	jmp	.LBB46_312
.LBB46_314:                             # %while.end809
	movl	%esi, (%esp)
	calll	fclose
	jmp	.LBB46_315
.Ltmp46:
	.size	getftp, .Ltmp46-getftp
	.section	.rodata,"a",@progbits
	.align	4
.LJTI46_0:
	.long	.LBB46_30
	.long	.LBB46_28
	.long	.LBB46_27
	.long	.LBB46_29
	.long	.LBB46_29
	.long	.LBB46_29
	.long	.LBB46_29
	.long	.LBB46_29
	.long	.LBB46_44
	.long	.LBB46_29
	.long	.LBB46_24
.LJTI46_1:
	.long	.LBB46_199
	.long	.LBB46_198
	.long	.LBB46_198
	.long	.LBB46_197
	.long	.LBB46_196
	.long	.LBB46_198
	.long	.LBB46_198
	.long	.LBB46_198
	.long	.LBB46_191

	.text
	.align	16, 0x90
	.type	ftp_expected_bytes,@function
ftp_expected_bytes:                     # @ftp_expected_bytes
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	$ftp_last_respline, 24(%esp)
	movl	$ftp_last_respline, %ebp
	leal	24(%esp), %ebx
	jmp	.LBB47_1
	.align	16, 0x90
.LBB47_3:                               # %while.body4
                                        #   in Loop: Header=BB47_1 Depth=1
	incl	%ebp
	movl	%ebp, 24(%esp)
	.align	16, 0x90
.LBB47_1:                               # %while.cond1
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB47_6 Depth 2
	movb	(%ebp), %cl
	testb	%cl, %cl
	setne	%al
	cmpb	$40, %cl
	je	.LBB47_4
# BB#2:                                 # %while.cond1
                                        #   in Loop: Header=BB47_1 Depth=1
	cmpb	$1, %al
	je	.LBB47_3
.LBB47_4:                               # %while.end
                                        #   in Loop: Header=BB47_1 Depth=1
	xorl	%eax, %eax
	testb	%cl, %cl
	movl	$0, %edx
	je	.LBB47_11
# BB#5:                                 # %if.end
                                        #   in Loop: Header=BB47_1 Depth=1
	incl	%ebp
	movl	%ebp, 24(%esp)
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$10, 8(%esp)
	calll	strtoll
	movl	%eax, %esi
	movl	%edx, %edi
	movl	24(%esp), %ebp
	movb	(%ebp), %cl
	xorl	%eax, %eax
	testb	%cl, %cl
	movl	$0, %edx
	je	.LBB47_11
	jmp	.LBB47_6
	.align	16, 0x90
.LBB47_8:                               # %while.body19
                                        #   in Loop: Header=BB47_6 Depth=2
	movl	%ebp, 24(%esp)
	movb	(%ebp), %cl
.LBB47_6:                               # %while.cond10.preheader
                                        #   Parent Loop BB47_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	incl	%ebp
	xorl	%eax, %eax
	testb	%cl, %cl
	movl	$0, %edx
	je	.LBB47_11
# BB#7:                                 # %land.end18
                                        #   in Loop: Header=BB47_6 Depth=2
	movzbl	%cl, %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB47_8
# BB#9:                                 # %if.end24
                                        #   in Loop: Header=BB47_1 Depth=1
	decl	%ebp
	cmpb	$98, _sch_tolower(%eax)
	jne	.LBB47_1
# BB#10:                                # %if.end32
                                        #   in Loop: Header=BB47_1 Depth=1
	movl	%ebp, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str83, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	movl	%esi, %eax
	movl	%edi, %edx
	jne	.LBB47_1
.LBB47_11:                              # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp47:
	.size	ftp_expected_bytes, .Ltmp47-ftp_expected_bytes

	.align	16, 0x90
	.type	print_length,@function
print_length:                           # @print_length
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %edi
	movl	%ecx, %esi
	movl	$5, 8(%esp)
	movl	$.L.str78, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %ebx
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$0, (%esp)
	cmpl	$1024, %esi             # imm = 0x400
	setb	%bl
	testl	%edi, %edi
	sets	%al
	je	.LBB48_2
# BB#1:                                 # %entry
	movb	%al, %bl
.LBB48_2:                               # %entry
	calll	logprintf
	movl	48(%esp), %ebp
	testb	%bl, %bl
	jne	.LBB48_4
# BB#3:                                 # %if.then
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	human_readable
	movl	%eax, 8(%esp)
	movl	$.L.str79, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB48_4:                               # %if.end
	testl	%ebp, %ebp
	sete	%al
	movl	52(%esp), %edx
	testl	%edx, %edx
	sets	%cl
	je	.LBB48_6
# BB#5:                                 # %if.end
	movb	%cl, %al
.LBB48_6:                               # %if.end
	testb	%al, %al
	jne	.LBB48_13
# BB#7:                                 # %if.then4
	cmpl	$1024, %ebp             # imm = 0x400
	setb	%al
	testl	%edx, %edx
	sets	%cl
	je	.LBB48_9
# BB#8:                                 # %if.then4
	movb	%cl, %al
.LBB48_9:                               # %if.then4
	testb	%al, %al
	jne	.LBB48_11
# BB#10:                                # %if.then6
	movl	$5, 8(%esp)
	movl	$.L.str80, 4(%esp)
	movl	$0, (%esp)
	subl	%ebp, %esi
	sbbl	%edx, %edi
	calll	dcgettext
	movl	%eax, %ebx
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_static_string
	movl	%eax, %ebp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	human_readable
	movl	%eax, 12(%esp)
	movl	%ebp, 8(%esp)
	jmp	.LBB48_12
.LBB48_11:                              # %if.else
	movl	$5, 8(%esp)
	movl	$.L.str81, 4(%esp)
	movl	$0, (%esp)
	subl	%ebp, %esi
	sbbl	%edx, %edi
	calll	dcgettext
	movl	%eax, %ebx
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
.LBB48_12:                              # %if.else
	movl	%ebx, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB48_13:                              # %if.end15
	movb	56(%esp), %cl
	movl	$.L.str2078, %eax
	testb	%cl, %cl
	jne	.LBB48_15
# BB#14:                                # %cond.true
	movl	$5, 8(%esp)
	movl	$.L.str82, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
.LBB48_15:                              # %cond.end
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp48:
	.size	print_length, .Ltmp48-print_length

	.align	16, 0x90
	.type	ftp_retrieve_list,@function
ftp_retrieve_list:                      # @ftp_retrieve_list
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$220, %esp
	movl	%ecx, -216(%ebp)        # 4-byte Spill
	movl	ftp_retrieve_list.depth, %eax
	incl	%eax
	movl	%eax, ftp_retrieve_list.depth
	movl	opt+28, %ecx
	cmpl	$-1, %ecx
	je	.LBB49_5
# BB#1:                                 # %entry
	cmpl	%ecx, %eax
	jle	.LBB49_5
# BB#2:                                 # %do.body
	cmpb	$0, opt+250
	jne	.LBB49_3
	.align	16, 0x90
.LBB49_4:                               # %do.end
	decl	%eax
	movl	%eax, ftp_retrieve_list.depth
	jmp	.LBB49_83
.LBB49_5:                               # %if.end4
	testl	%edx, %edx
	je	.LBB49_84
# BB#6:                                 # %cond.end
	movl	8(%ebp), %edi
	movl	(%edi), %ecx
	movl	%ecx, %eax
	andl	$-2, %eax
	movl	%eax, (%edi)
	movl	4(%edi), %eax
	movl	%eax, %esi
	orl	$2, %esi
	andl	$-3, %eax
	testb	$2, %cl
	cmovel	%esi, %eax
	movl	%eax, %ecx
	orl	$21, %ecx
	andl	$-22, %eax
	orl	$20, %eax
	cmpl	$0, 8(%edi)
	cmovsl	%ecx, %eax
	movl	%eax, 4(%edi)
	movl	%edx, %eax
	movl	%edx, -232(%ebp)        # 4-byte Spill
	jmp	.LBB49_7
	.align	16, 0x90
.LBB49_73:                              # %if.end229
                                        #   in Loop: Header=BB49_7 Depth=1
	andb	$-4, 4(%edi)
	movl	-212(%ebp), %eax        # 4-byte Reload
	movl	32(%eax), %eax
.LBB49_7:                               # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	testl	%eax, %eax
	movl	%eax, %ebx
	je	.LBB49_74
# BB#8:                                 # %while.body
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	opt+240, %eax
	movl	opt+236, %ecx
	movl	%ecx, %edx
	orl	%eax, %edx
	jne	.LBB49_9
	.align	16, 0x90
.LBB49_12:                              # %if.end32
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %eax
	movl	%eax, -224(%ebp)        # 4-byte Spill
	movl	-216(%ebp), %esi        # 4-byte Reload
	movl	36(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, -220(%ebp)        # 4-byte Spill
	movl	4(%ebx), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	url_set_file
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	url_file_name
	addl	$16, %esp
	movl	%eax, 28(%edi)
	movb	$1, %cl
	cmpb	$0, opt+251
	je	.LBB49_24
# BB#13:                                # %land.lhs.true38
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	$1, %cl
	cmpl	$0, (%ebx)
	jne	.LBB49_24
# BB#14:                                # %if.then41
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	leal	-112(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	movb	$1, %cl
	testl	%eax, %eax
	jne	.LBB49_24
# BB#15:                                # %if.then46
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	20(%edi), %edx
	orl	$2, %edx
	movl	%ebx, %esi
	movl	-68(%ebp), %edi
	movl	-64(%ebp), %ebx
	movb	$1, %al
	movl	-40(%ebp), %ecx
	cmpl	$2, %edx
	jne	.LBB49_17
# BB#16:                                # %cond.true54
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	8(%esi), %eax
	xorl	%edi, %eax
	movl	12(%esi), %edx
	xorl	%ebx, %edx
	orl	%eax, %edx
	sete	%al
.LBB49_17:                              # %cond.end58
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	%ecx, 16(%esi)
	movl	%esi, -212(%ebp)        # 4-byte Spill
	jg	.LBB49_20
# BB#18:                                # %cond.end58
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	%al, %cl
	xorb	$1, %cl
	testb	%cl, %cl
	je	.LBB49_19
.LBB49_20:                              # %if.else69
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	cmpb	$1, %al
	jne	.LBB49_22
# BB#21:                                # %if.then71
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str96, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	8(%ebp), %ebx
	movl	%ebx, %edi
	movl	28(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	$1, %cl
	jmp	.LBB49_23
.LBB49_9:                               # %while.body
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %esi
	cmpl	%ecx, %esi
	setbe	%cl
	cmpl	%eax, %edx
	setle	%al
	je	.LBB49_11
# BB#10:                                # %while.body
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	%al, %cl
.LBB49_11:                              # %while.body
                                        #   in Loop: Header=BB49_7 Depth=1
	testb	%cl, %cl
	je	.LBB49_82
	jmp	.LBB49_12
.LBB49_22:                              # %if.else74
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str97, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	$1, %cl
	movl	8(%ebp), %ebx
	movl	%ebx, %edi
	jmp	.LBB49_23
.LBB49_19:                              # %if.then66
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str95, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	8(%ebp), %ebx
	movl	%ebx, %edi
	movl	28(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	xorb	%cl, %cl
.LBB49_23:                              # %if.else74
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	-212(%ebp), %ebx        # 4-byte Reload
.LBB49_24:                              # %if.end80
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	%cl, -212(%ebp)         # 1-byte Spill
	movl	(%ebx), %eax
	movl	$31, %esi
	cmpl	$3, %eax
	ja	.LBB49_49
# BB#25:                                # %if.end80
                                        #   in Loop: Header=BB49_7 Depth=1
	jmpl	*.LJTI49_0(,%eax,4)
.LBB49_42:                              # %sw.bb146
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	-212(%ebp), %al         # 1-byte Reload
	testb	%al, %al
	je	.LBB49_39
# BB#43:                                # %if.then148
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	%al, -212(%ebp)         # 1-byte Spill
	jmp	.LBB49_44
.LBB49_40:                              # %sw.bb139
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	$31, %esi
	cmpb	$0, opt+15
	jne	.LBB49_49
# BB#41:                                # %if.then141
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str102, 4(%esp)
	jmp	.LBB49_46
.LBB49_26:                              # %sw.bb
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpb	$0, opt+101
	jne	.LBB49_38
# BB#27:                                # %if.then83
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$0, 24(%ebx)
	jne	.LBB49_29
# BB#28:                                # %if.then85
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str98, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	jmp	.LBB49_47
.LBB49_45:                              # %sw.bb151
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str103, 4(%esp)
.LBB49_46:                              # %sw.bb151
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	4(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	.align	16, 0x90
.LBB49_47:                              # %sw.bb151
                                        #   in Loop: Header=BB49_7 Depth=1
	addl	$16, %esp
	.align	16, 0x90
.LBB49_48:                              # %sw.bb151
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	$31, %esi
	jmp	.LBB49_49
.LBB49_38:                              # %if.else133
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpb	$0, -212(%ebp)          # 1-byte Folded Reload
	je	.LBB49_39
.LBB49_44:                              # %if.then135
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	-216(%ebp), %ecx        # 4-byte Reload
	movl	%ebx, %edx
	calll	ftp_loop_internal
	addl	$16, %esp
	movl	%eax, %esi
	jmp	.LBB49_49
.LBB49_39:                              #   in Loop: Header=BB49_7 Depth=1
	movl	$31, %esi
	movb	$0, -212(%ebp)          # 1-byte Folded Spill
.LBB49_49:                              # %sw.epilog
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$2, (%ebx)
	jne	.LBB49_51
# BB#50:                                # %sw.epilog
                                        #   in Loop: Header=BB49_7 Depth=1
	movb	opt+101, %al
	testb	%al, %al
	je	.LBB49_59
.LBB49_51:                              # %land.lhs.true160
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$-1, 16(%ebx)
	je	.LBB49_59
# BB#52:                                # %land.lhs.true164
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpb	$0, -212(%ebp)          # 1-byte Folded Reload
	je	.LBB49_59
# BB#53:                                # %land.lhs.true167
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	file_exists_p
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB49_59
# BB#54:                                # %if.then171
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	opt+104, %eax
	testl	%eax, %eax
	jne	.LBB49_55
# BB#56:                                # %if.else177
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %eax
	jmp	.LBB49_57
.LBB49_59:                              # %if.else184
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$-1, 16(%ebx)
	jne	.LBB49_62
# BB#60:                                # %if.then188
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str104, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	28(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	.align	16, 0x90
.LBB49_61:                              # %if.then188
                                        #   in Loop: Header=BB49_7 Depth=1
	addl	$16, %esp
	.align	16, 0x90
.LBB49_62:                              # %if.end192
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	20(%ebx), %eax
	testl	%eax, %eax
	je	.LBB49_67
# BB#63:                                # %land.lhs.true194
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$0, (%ebx)
	jne	.LBB49_67
# BB#64:                                # %land.lhs.true198
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpb	$0, -212(%ebp)          # 1-byte Folded Reload
	jne	.LBB49_65
.LBB49_67:                              # %do.body209
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	%ebx, -212(%ebp)        # 4-byte Spill
	cmpb	$0, opt+250
	jne	.LBB49_68
	.align	16, 0x90
.LBB49_70:                              # %if.end218
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-224(%ebp), %eax        # 4-byte Reload
	movl	%eax, 28(%edi)
	subl	$16, %esp
	movl	-220(%ebp), %ebx        # 4-byte Reload
	movl	%ebx, 4(%esp)
	movl	-216(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_set_file
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	checking_free
	addl	$16, %esp
	cmpl	$1, %esi
	je	.LBB49_74
# BB#71:                                # %if.end218
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$26, %esi
	je	.LBB49_74
# BB#72:                                # %if.end218
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpl	$51, %esi
	je	.LBB49_74
	jmp	.LBB49_73
.LBB49_65:                              # %if.then201
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	%ebx, -212(%ebp)        # 4-byte Spill
	cmpb	$0, opt+333
	je	.LBB49_70
# BB#66:                                # %if.then203
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %ecx
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	chmod
	jmp	.LBB49_69
.LBB49_55:                              # %if.then173
                                        #   in Loop: Header=BB49_7 Depth=1
	cmpb	$0, output_stream_regular
	movl	$0, %ecx
	cmovel	%ecx, %eax
.LBB49_57:                              # %if.end179
                                        #   in Loop: Header=BB49_7 Depth=1
	testl	%eax, %eax
	je	.LBB49_62
# BB#58:                                # %if.then181
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	16(%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	touch
	jmp	.LBB49_61
.LBB49_68:                              # %if.then214
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str105, (%esp)
	calll	debug_logprintf
.LBB49_69:                              # %if.then214
                                        #   in Loop: Header=BB49_7 Depth=1
	addl	$16, %esp
	jmp	.LBB49_70
.LBB49_29:                              # %if.else87
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	%edi, %eax
	movl	28(%eax), %eax
	subl	$16, %esp
	leal	-208(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__lxstat64
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB49_34
# BB#30:                                # %if.then93
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	24(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	movl	-192(%ebp), %eax
	movl	$61440, %ecx            # imm = 0xF000
	andl	%ecx, %eax
	cmpl	$40960, %eax            # imm = 0xA000
	jne	.LBB49_34
# BB#31:                                # %if.then99
                                        #   in Loop: Header=BB49_7 Depth=1
	leal	1(%esi), %eax
	leal	15(%eax), %ecx
	andl	$-16, %ecx
	movl	%esp, %edi
	subl	%ecx, %edi
	movl	%edi, %esp
	movl	8(%ebp), %ecx
	movl	28(%ecx), %ecx
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ecx, (%esp)
	calll	readlink
	addl	$16, %esp
	cmpl	%esi, %eax
	jne	.LBB49_34
# BB#32:                                # %land.lhs.true104
                                        #   in Loop: Header=BB49_7 Depth=1
	movl	24(%ebx), %eax
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	memcmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB49_34
# BB#33:                                # %if.then109
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str99, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -212(%ebp)        # 4-byte Spill
	movl	8(%ebp), %esi
	movl	28(%esi), %edi
	movl	24(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, %edi
	movl	-212(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	$0, -212(%ebp)          # 1-byte Folded Spill
	jmp	.LBB49_48
.LBB49_34:                              # %if.end116
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str100, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -228(%ebp)        # 4-byte Spill
	movl	8(%ebp), %esi
	movl	28(%esi), %edi
	movl	24(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, %edi
	movl	-228(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	28(%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	unlink
	addl	$16, %esp
	movl	24(%ebx), %eax
	movl	28(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	symlink
	addl	$16, %esp
	cmpl	$-1, %eax
	jne	.LBB49_36
# BB#35:                                # %if.then128
                                        #   in Loop: Header=BB49_7 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str101, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB49_36:                              # %if.end131
                                        #   in Loop: Header=BB49_7 Depth=1
	subl	$16, %esp
	movl	$.L.str2078, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	jmp	.LBB49_47
.LBB49_74:                              # %while.end
	movb	opt+15, %al
	testb	%al, %al
	movl	-232(%ebp), %edx        # 4-byte Reload
	je	.LBB49_82
# BB#75:                                # %land.lhs.true234
	movl	opt+28, %ecx
	cmpl	$-1, %ecx
	je	.LBB49_77
# BB#76:                                # %land.lhs.true234
	movl	ftp_retrieve_list.depth, %esi
	cmpl	%ecx, %esi
	jge	.LBB49_78
.LBB49_77:                              # %if.then240
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	-216(%ebp), %ecx        # 4-byte Reload
	calll	ftp_retrieve_dirs
	.align	16, 0x90
.LBB49_81:                              # %if.then250
	addl	$16, %esp
	.align	16, 0x90
.LBB49_82:                              # %if.end255
	decl	ftp_retrieve_list.depth
.LBB49_83:                              # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB49_78:                              # %if.else242
	testb	%al, %al
	je	.LBB49_82
# BB#79:                                # %if.else242
	movb	opt+250, %al
	testb	%al, %al
	je	.LBB49_82
# BB#80:                                # %if.then250
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str106, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	ftp_retrieve_list.depth, %ecx
	movl	opt+28, %edx
	subl	$16, %esp
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	debug_logprintf
	jmp	.LBB49_81
.LBB49_3:                               # %if.then3
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str93, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	ftp_retrieve_list.depth, %ecx
	movl	opt+28, %edx
	subl	$16, %esp
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	ftp_retrieve_list.depth, %eax
	jmp	.LBB49_4
.LBB49_84:                              # %cond.false
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.ftp_retrieve_list, 12(%esp)
	movl	$1378, 8(%esp)          # imm = 0x562
	movl	$.L.str1270, 4(%esp)
	movl	$.L.str94, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.Ltmp49:
	.size	ftp_retrieve_list, .Ltmp49-ftp_retrieve_list
	.section	.rodata,"a",@progbits
	.align	4
.LJTI49_0:
	.long	.LBB49_42
	.long	.LBB49_40
	.long	.LBB49_26
	.long	.LBB49_45

	.text
	.align	16, 0x90
	.type	ftp_retrieve_dirs,@function
ftp_retrieve_dirs:                      # @ftp_retrieve_dirs
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %edi
	movl	%ecx, -24(%ebp)         # 4-byte Spill
	movl	$0, -20(%ebp)           # 4-byte Folded Spill
	jmp	.LBB50_1
	.align	16, 0x90
.LBB50_25:                              # %for.inc
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	32(%edi), %edi
.LBB50_1:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	opt+240, %eax
	movl	opt+236, %ecx
	testl	%edi, %edi
	je	.LBB50_2
# BB#6:                                 # %for.body
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	%ecx, %edx
	orl	%eax, %edx
	jne	.LBB50_7
	.align	16, 0x90
.LBB50_10:                              # %if.end
                                        #   in Loop: Header=BB50_1 Depth=1
	cmpl	$1, (%edi)
	jne	.LBB50_25
# BB#11:                                # %if.end4
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	32(%eax), %esi
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	movl	%edi, -16(%ebp)         # 4-byte Spill
	movl	4(%edi), %edi
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	leal	2(%ebx,%eax), %eax
	testl	%eax, %eax
	movl	-20(%ebp), %ebx         # 4-byte Reload
	jle	.LBB50_13
# BB#12:                                # %if.then9
                                        #   in Loop: Header=BB50_1 Depth=1
	addl	$15, %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
.LBB50_13:                              # %if.end10
                                        #   in Loop: Header=BB50_1 Depth=1
	movb	(%esi), %al
	testb	%al, %al
	je	.LBB50_16
# BB#14:                                # %if.end10
                                        #   in Loop: Header=BB50_1 Depth=1
	cmpb	$47, %al
	jne	.LBB50_17
# BB#15:                                # %land.lhs.true17
                                        #   in Loop: Header=BB50_1 Depth=1
	cmpb	$0, 1(%esi)
	jne	.LBB50_17
.LBB50_16:                              # %if.then21
                                        #   in Loop: Header=BB50_1 Depth=1
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	%esi, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str107, 4(%esp)
	jmp	.LBB50_18
.LBB50_17:                              # %if.else
                                        #   in Loop: Header=BB50_1 Depth=1
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	%esi, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str108, 4(%esp)
.LBB50_18:                              # %if.else
                                        #   in Loop: Header=BB50_1 Depth=1
	calll	sprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	movl	-16(%ebp), %edi         # 4-byte Reload
	jne	.LBB50_19
	.align	16, 0x90
.LBB50_21:                              # %do.end40
                                        #   in Loop: Header=BB50_1 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	accdir
	addl	$16, %esp
	testb	%al, %al
	movl	%ebx, %edi
	je	.LBB50_22
# BB#23:                                # %if.end45
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	8(%ebp), %ebx
	andb	$-3, (%ebx)
	movl	-24(%ebp), %esi         # 4-byte Reload
	movl	32(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, -28(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%edi, -20(%ebp)         # 4-byte Spill
	movl	%esi, (%esp)
	calll	url_set_dir
	addl	$16, %esp
	subl	$16, %esp
	movl	$1, (%esp)
	movl	%esi, %ecx
	movl	%ebx, %edx
	calll	ftp_retrieve_glob
	addl	$16, %esp
	subl	$16, %esp
	movl	-28(%ebp), %edi         # 4-byte Reload
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	url_set_dir
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	jmp	.LBB50_24
.LBB50_22:                              # %if.then42
                                        #   in Loop: Header=BB50_1 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str111, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	%edi, -20(%ebp)         # 4-byte Spill
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB50_24:                              # %if.end45
                                        #   in Loop: Header=BB50_1 Depth=1
	addl	$16, %esp
	movl	-16(%ebp), %edi         # 4-byte Reload
	jmp	.LBB50_25
.LBB50_7:                               # %for.body
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %esi
	cmpl	%ecx, %esi
	seta	%bl
	cmpl	%eax, %edx
	setg	%bh
	je	.LBB50_9
# BB#8:                                 # %for.body
                                        #   in Loop: Header=BB50_1 Depth=1
	movb	%bh, %bl
.LBB50_9:                               # %for.body
                                        #   in Loop: Header=BB50_1 Depth=1
	testb	%bl, %bl
	jne	.LBB50_3
	jmp	.LBB50_10
.LBB50_19:                              # %do.body32
                                        #   in Loop: Header=BB50_1 Depth=1
	subl	$16, %esp
	movl	$.L.str109, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	je	.LBB50_21
# BB#20:                                # %if.then37
                                        #   in Loop: Header=BB50_1 Depth=1
	movl	4(%edi), %eax
	subl	$16, %esp
	movl	%ebx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str110, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB50_21
.LBB50_2:                               # %for.cond.for.end_crit_edge
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %esi
.LBB50_3:                               # %for.end
	cmpl	%ecx, %esi
	seta	%bl
	cmpl	%eax, %edx
	setg	%dl
	je	.LBB50_5
# BB#4:                                 # %for.end
	movb	%dl, %bl
.LBB50_5:                               # %for.end
	orl	%eax, %ecx
	setne	%al
	movl	$51, %ecx
	testb	%bl, %al
	movl	$31, %eax
	cmovnel	%ecx, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp50:
	.size	ftp_retrieve_dirs, .Ltmp50-ftp_retrieve_dirs

	.globl	ftp_response
	.align	16, 0x90
	.type	ftp_response,@function
ftp_response:                           # @ftp_response
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	36(%esp), %edi
	movl	32(%esp), %ebx
	jmp	.LBB51_1
	.align	16, 0x90
.LBB51_18:                              # %if.end55
                                        #   in Loop: Header=BB51_1 Depth=1
	movl	%esi, (%esp)
	calll	checking_free
.LBB51_1:                               # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, (%esp)
	calll	fd_read_line
	movl	%eax, %esi
	movl	$18, %eax
	testl	%esi, %esi
	je	.LBB51_17
# BB#2:                                 # %if.end
                                        #   in Loop: Header=BB51_1 Depth=1
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	cmpl	%esi, %eax
	jbe	.LBB51_5
# BB#3:                                 # %land.lhs.true
                                        #   in Loop: Header=BB51_1 Depth=1
	cmpb	$10, -1(%eax)
	jne	.LBB51_5
# BB#4:                                 # %if.then4
                                        #   in Loop: Header=BB51_1 Depth=1
	leal	-1(%eax), %eax
	movb	$0, (%eax)
.LBB51_5:                               # %if.end5
                                        #   in Loop: Header=BB51_1 Depth=1
	cmpl	%esi, %eax
	jbe	.LBB51_8
# BB#6:                                 # %land.lhs.true8
                                        #   in Loop: Header=BB51_1 Depth=1
	cmpb	$13, -1(%eax)
	jne	.LBB51_8
# BB#7:                                 # %if.then13
                                        #   in Loop: Header=BB51_1 Depth=1
	movb	$0, -1(%eax)
.LBB51_8:                               # %if.end15
                                        #   in Loop: Header=BB51_1 Depth=1
	movl	opt+248, %eax
	testb	%al, %al
	jne	.LBB51_9
# BB#10:                                # %do.body
                                        #   in Loop: Header=BB51_1 Depth=1
	testl	$16711680, %eax         # imm = 0xFF0000
	je	.LBB51_12
# BB#11:                                # %if.then22
                                        #   in Loop: Header=BB51_1 Depth=1
	movl	%esi, (%esp)
	calll	escnonprint
	movl	%eax, 4(%esp)
	movl	$.L.str116, (%esp)
	calll	debug_logprintf
	jmp	.LBB51_12
.LBB51_9:                               # %if.then17
                                        #   in Loop: Header=BB51_1 Depth=1
	movl	%esi, (%esp)
	calll	escnonprint
	movl	%eax, 8(%esp)
	movl	$.L.str116, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB51_12:                              # %if.end25
                                        #   in Loop: Header=BB51_1 Depth=1
	movzbl	(%esi), %eax
	testb	$4, _sch_istable(%eax,%eax)
	je	.LBB51_18
# BB#13:                                # %land.lhs.true32
                                        #   in Loop: Header=BB51_1 Depth=1
	movzbl	1(%esi), %eax
	testb	$4, _sch_istable(%eax,%eax)
	je	.LBB51_18
# BB#14:                                # %land.lhs.true40
                                        #   in Loop: Header=BB51_1 Depth=1
	movzbl	2(%esi), %eax
	testb	$4, _sch_istable(%eax,%eax)
	je	.LBB51_18
# BB#15:                                # %land.lhs.true48
                                        #   in Loop: Header=BB51_1 Depth=1
	cmpb	$32, 3(%esi)
	jne	.LBB51_18
# BB#16:                                # %if.then53
	movl	%esi, 4(%esp)
	movl	$128, 8(%esp)
	movl	$ftp_last_respline, (%esp)
	calll	strncpy
	movb	$0, ftp_last_respline+127
	movl	%esi, (%edi)
	movl	$10, %eax
.LBB51_17:                              # %return
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp51:
	.size	ftp_response, .Ltmp51-ftp_response

	.globl	ftp_login
	.align	16, 0x90
	.type	ftp_login,@function
ftp_login:                              # @ftp_login
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	leal	24(%esp), %ebp
	movl	%ebp, 4(%esp)
	movl	48(%esp), %esi
	movl	%esi, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB52_20
# BB#1:                                 # %if.end
	movl	24(%esp), %eax
	movb	(%eax), %bl
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$50, %bl
	movl	%esi, %ebx
	movl	$20, %eax
	jne	.LBB52_20
# BB#2:                                 # %if.end4
	movl	52(%esp), %edx
	movl	$.L.str1119, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB52_20
# BB#3:                                 # %if.end11
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB52_20
# BB#4:                                 # %if.end16
	movl	24(%esp), %ebx
	movb	(%ebx), %al
	cmpb	$51, %al
	je	.LBB52_5
# BB#17:                                # %if.end16
	cmpb	$50, %al
	jne	.LBB52_19
# BB#18:                                # %if.then20
	movl	%ebx, (%esp)
	calll	checking_free
	movl	$10, %eax
	jmp	.LBB52_20
.LBB52_5:
	movl	56(%esp), %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	.align	16, 0x90
.LBB52_6:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, %ebp
	ja	.LBB52_14
# BB#7:                                 # %for.body
                                        #   in Loop: Header=BB52_6 Depth=1
	movl	ftp_login.skey_head(,%ebp,4), %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	incl	%ebp
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB52_6
# BB#8:                                 # %for.end
	addl	%ebx, %edi
	je	.LBB52_14
# BB#9:                                 # %for.cond37.preheader
	movb	(%edi), %cl
	movsbl	%cl, %edx
	movzbl	%dl, %esi
	xorl	%eax, %eax
	jmp	.LBB52_11
	.align	16, 0x90
.LBB52_10:                              # %for.body43
                                        #   in Loop: Header=BB52_11 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%edx), %eax
	movb	1(%edi), %cl
	incl	%edi
	movsbl	%cl, %edx
	movzbl	%dl, %esi
.LBB52_11:                              # %for.body43
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%esi,%esi)
	jne	.LBB52_10
# BB#12:                                # %for.end46
	cmpb	$32, %cl
	jne	.LBB52_19
# BB#13:                                # %if.then50
	movl	56(%esp), %ecx
	movl	%ecx, 8(%esp)
	incl	%edi
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	skey_response
	movl	%eax, 20(%esp)          # 4-byte Spill
.LBB52_14:                              # %if.end54
	movl	%ebx, (%esp)
	calll	checking_free
	movl	$.L.str4122, %ecx
	movl	20(%esp), %edx          # 4-byte Reload
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	leal	24(%esp), %ecx
	js	.LBB52_20
# BB#15:                                # %if.end61
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB52_20
# BB#16:                                # %if.end66
	movl	24(%esp), %eax
	cmpb	$50, (%eax)
	setne	%bl
	movl	%eax, (%esp)
	calll	checking_free
	movzbl	%bl, %eax
	orl	$10, %eax
	jmp	.LBB52_20
.LBB52_19:                              # %if.then25
	movl	%ebx, (%esp)
	calll	checking_free
	movl	$12, %eax
.LBB52_20:                              # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp52:
	.size	ftp_login, .Ltmp52-ftp_login

	.align	16, 0x90
	.type	ftp_request,@function
ftp_request:                            # @ftp_request
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, %edi
	movl	%ecx, %esi
	testl	%edi, %edi
	je	.LBB53_17
# BB#1:
	movl	%edi, %eax
	.align	16, 0x90
.LBB53_2:                               # %while.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%eax), %cl
	cmpb	$13, %cl
	setne	%dl
	testb	%cl, %cl
	setne	%ch
	incl	%eax
	cmpb	$10, %cl
	je	.LBB53_4
# BB#3:                                 # %while.cond.i
                                        #   in Loop: Header=BB53_2 Depth=1
	andb	%dl, %ch
	testb	%ch, %ch
	jne	.LBB53_2
.LBB53_4:                               # %__strpbrk_c2.exit
	testb	%cl, %cl
	setne	%cl
	cmpl	$1, %eax
	je	.LBB53_5
# BB#6:                                 # %__strpbrk_c2.exit
	cmpb	$1, %cl
	jne	.LBB53_7
# BB#8:                                 # %do.body
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$16, %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcpy
	addl	$16, %esp
	movl	%ebx, %eax
	jmp	.LBB53_9
.LBB53_17:                              # %if.else
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$0, 8(%esp)
	movl	$.L.str53168, 4(%esp)
	calll	concat_strings
	addl	$16, %esp
	jmp	.LBB53_18
.LBB53_5:
	movl	%edi, %ebx
	jmp	.LBB53_16
.LBB53_7:
	movl	%edi, %ebx
	jmp	.LBB53_16
	.align	16, 0x90
.LBB53_13:                              # %for.inc
                                        #   in Loop: Header=BB53_9 Depth=1
	incl	%eax
.LBB53_9:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB53_14
# BB#10:                                # %for.cond
                                        #   in Loop: Header=BB53_9 Depth=1
	cmpb	$10, %cl
	je	.LBB53_12
# BB#11:                                # %for.cond
                                        #   in Loop: Header=BB53_9 Depth=1
	cmpb	$13, %cl
	jne	.LBB53_13
.LBB53_12:                              # %if.then48
                                        #   in Loop: Header=BB53_9 Depth=1
	movb	$32, (%eax)
	jmp	.LBB53_13
.LBB53_14:                              # %do.body49
	cmpb	$0, opt+250
	jne	.LBB53_15
	.align	16, 0x90
.LBB53_16:                              # %if.end58
	subl	$32, %esp
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$0, 16(%esp)
	movl	$.L.str53168, 12(%esp)
	movl	$.L.str34152, 4(%esp)
	calll	concat_strings
	addl	$32, %esp
.LBB53_18:                              # %if.else
	movl	%eax, %esi
	movl	opt+248, %eax
	testb	%al, %al
	je	.LBB53_22
# BB#19:                                # %if.then63
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str4122, 4(%esp)
	calll	strncmp
	addl	$16, %esp
	subl	$16, %esp
	testl	%eax, %eax
	je	.LBB53_21
# BB#20:                                # %if.then67
	movl	%esi, 8(%esp)
	movl	$.L.str55170, 4(%esp)
	movl	$3, (%esp)
	calll	logprintf
	jmp	.LBB53_24
.LBB53_22:                              # %do.body71
	testl	$16711680, %eax         # imm = 0xFF0000
	je	.LBB53_25
# BB#23:                                # %if.then76
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str57172, (%esp)
	calll	debug_logprintf
	jmp	.LBB53_24
.LBB53_21:                              # %if.else68
	movl	$.L.str56171, 4(%esp)
	movl	$3, (%esp)
	calll	logputs
.LBB53_24:                              # %if.then76
	addl	$16, %esp
.LBB53_25:                              # %if.end79
	movl	%esi, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB53_15:                              # %if.then53
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	escnonprint
	addl	$16, %esp
	movl	%eax, %edi
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str54169, (%esp)
	calll	debug_logprintf
	addl	$32, %esp
	jmp	.LBB53_16
.Ltmp53:
	.size	ftp_request, .Ltmp53-ftp_request

	.globl	ftp_port
	.align	16, 0x90
	.type	ftp_port,@function
ftp_port:                               # @ftp_port
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$108, %esp
	leal	80(%esp), %edi
	movl	%edi, 4(%esp)
	movl	128(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$0, 8(%esp)
	calll	socket_ip_address
	movl	$14, %esi
	testb	%al, %al
	je	.LBB54_10
# BB#1:                                 # %if.end
	cmpl	$2, 80(%esp)
	jne	.LBB54_11
# BB#2:                                 # %cond.end
	movl	132(%esp), %ebp
	movl	$0, 76(%esp)
	leal	76(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	bind_local
	movl	%eax, (%ebp)
	movl	$14, %esi
	testl	%eax, %eax
	js	.LBB54_10
# BB#3:                                 # %if.end4
	cmpl	$2, 80(%esp)
	jne	.LBB54_12
# BB#4:                                 # %ip_address_to_port_repr.exit
	movl	76(%esp), %ecx
	movl	84(%esp), %eax
	movl	%eax, %edx
	shrl	$24, %edx
	movl	%edx, 24(%esp)
	leal	51(%esp), %esi
	movl	%esi, (%esp)
	movzbl	%cl, %edx
	movl	%edx, 32(%esp)
	movzbl	%ch, %ecx
	movl	%ecx, 28(%esp)
	movl	%eax, %ecx
	movzbl	%ch, %edx
	movl	%edx, 16(%esp)
	movzbl	%cl, %ecx
	movl	%ecx, 12(%esp)
	shrl	$16, %eax
	movzbl	%al, %eax
	movl	%eax, 20(%esp)
	movl	$.L.str52167, 8(%esp)
	movl	$25, 4(%esp)
	calll	snprintf
	movb	$0, 75(%esp)
	movl	$.L.str7125, %ecx
	movl	%esi, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	testl	%edi, %edi
	js	.LBB54_5
# BB#6:                                 # %if.end11
	leal	104(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB54_7
# BB#8:                                 # %if.end15
	movl	104(%esp), %eax
	movb	(%eax), %bl
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$50, %bl
	movl	$10, %esi
	je	.LBB54_10
# BB#9:                                 # %if.then18
	movl	(%ebp), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$13, %esi
	jmp	.LBB54_10
.LBB54_5:                               # %if.then10
	movl	(%ebp), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$52, %esi
	jmp	.LBB54_10
.LBB54_7:                               # %if.then14
	movl	(%ebp), %eax
	movl	%eax, (%esp)
	calll	fd_close
.LBB54_10:                              # %return
	movl	%esi, %eax
	addl	$108, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB54_11:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.ftp_port, 12(%esp)
	movl	$282, 8(%esp)           # imm = 0x11A
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str5123, (%esp)
	calll	__assert_fail
.LBB54_12:                              # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.ip_address_to_port_repr, 12(%esp)
	movl	$254, 8(%esp)
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str50166, (%esp)
	calll	__assert_fail
.Ltmp54:
	.size	ftp_port, .Ltmp54-ftp_port

	.globl	ftp_lprt
	.align	16, 0x90
	.type	ftp_lprt,@function
ftp_lprt:                               # @ftp_lprt
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$220, %esp
	leal	192(%esp), %edi
	movl	%edi, 4(%esp)
	movl	240(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$0, 8(%esp)
	calll	socket_ip_address
	movl	$14, %esi
	testb	%al, %al
	je	.LBB55_14
# BB#1:                                 # %if.end
	movl	192(%esp), %eax
	orl	$8, %eax
	cmpl	$10, %eax
	jne	.LBB55_15
# BB#2:                                 # %cond.end
	movl	244(%esp), %esi
	movl	$0, 188(%esp)
	leal	188(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	bind_local
	movl	%eax, (%esi)
	movl	$14, %esi
	testl	%eax, %eax
	js	.LBB55_14
# BB#3:                                 # %if.end6
	movl	192(%esp), %eax
	movl	188(%esp), %edi
	cmpl	$10, %eax
	jne	.LBB55_4
# BB#8:                                 # %sw.bb8.i
	movl	196(%esp), %eax
	movl	200(%esp), %ecx
	movl	204(%esp), %edx
	movl	208(%esp), %esi
	movl	%ebx, %ebp
	movl	%esi, %ebx
	shrl	$24, %ebx
	movl	%ebx, 80(%esp)
	movl	%edx, %ebx
	shrl	$24, %ebx
	movl	%ebx, 64(%esp)
	movl	%ecx, %ebx
	shrl	$24, %ebx
	movl	%ebx, 48(%esp)
	movl	%eax, %ebx
	shrl	$24, %ebx
	movl	%ebx, 32(%esp)
	leal	103(%esp), %ebx
	movl	%ebx, (%esp)
	movl	%edi, %ebx
	movzbl	%bl, %edi
	movl	%edi, 92(%esp)
	movzbl	%bh, %edi
	movl	%edi, 88(%esp)
	movl	%esi, %ebx
	movzbl	%bh, %edi
	movl	%edi, 72(%esp)
	movzbl	%bl, %edi
	movl	%edi, 68(%esp)
	movl	%edx, %ebx
	movzbl	%bh, %edi
	movl	%edi, 56(%esp)
	movzbl	%bl, %edi
	movl	%edi, 52(%esp)
	movl	%ecx, %ebx
	movzbl	%bh, %edi
	movl	%edi, 40(%esp)
	movzbl	%bl, %edi
	movl	%edi, 36(%esp)
	movl	%eax, %ebx
	movzbl	%bh, %edi
	movl	%edi, 24(%esp)
	movzbl	%bl, %edi
	movl	%edi, 20(%esp)
	shrl	$16, %esi
	movl	%esi, %ebx
	movzbl	%bl, %esi
	movl	%ebp, %ebx
	movl	%esi, 76(%esp)
	shrl	$16, %edx
	movzbl	%dl, %edx
	movl	%edx, 60(%esp)
	shrl	$16, %ecx
	movzbl	%cl, %ecx
	movl	%ecx, 44(%esp)
	shrl	$16, %eax
	movzbl	%al, %eax
	movl	%eax, 28(%esp)
	movl	$2, 84(%esp)
	movl	$16, 16(%esp)
	movl	$6, 12(%esp)
	movl	$.L.str49165, 8(%esp)
	jmp	.LBB55_6
.LBB55_4:                               # %if.end6
	cmpl	$2, %eax
	jne	.LBB55_9
# BB#5:                                 # %sw.bb.i
	movl	196(%esp), %eax
	movl	%eax, %ecx
	shrl	$24, %ecx
	movl	%ecx, 32(%esp)
	leal	103(%esp), %ecx
	movl	%ecx, (%esp)
	movl	%edi, %ecx
	movzbl	%cl, %edx
	movl	%edx, 44(%esp)
	movzbl	%ch, %ecx
	movl	%ecx, 40(%esp)
	movl	%eax, %ecx
	movzbl	%ch, %edx
	movl	%edx, 24(%esp)
	movzbl	%cl, %ecx
	movl	%ecx, 20(%esp)
	shrl	$16, %eax
	movzbl	%al, %eax
	movl	%eax, 28(%esp)
	movl	$2, 36(%esp)
	movl	$4, 16(%esp)
	movl	$4, 12(%esp)
	movl	$.L.str48164, 8(%esp)
.LBB55_6:                               # %sw.bb.i
	movl	$85, 4(%esp)
	calll	snprintf
	leal	103(%esp), %edx
	movl	$.L.str9127, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	testl	%edi, %edi
	js	.LBB55_7
# BB#10:                                # %if.end13
	leal	216(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB55_11
# BB#12:                                # %if.end17
	movl	216(%esp), %eax
	movb	(%eax), %bl
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$50, %bl
	movl	$10, %esi
	je	.LBB55_14
# BB#13:                                # %if.then20
	movl	244(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$13, %esi
	jmp	.LBB55_14
.LBB55_7:                               # %if.then12
	movl	244(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$52, %esi
	jmp	.LBB55_14
.LBB55_9:                               # %sw.default.i
	calll	abort
.LBB55_11:                              # %if.then16
	movl	244(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
.LBB55_14:                              # %return
	movl	%esi, %eax
	addl	$220, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB55_15:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.ftp_lprt, 12(%esp)
	movl	$372, 8(%esp)           # imm = 0x174
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str8126, (%esp)
	calll	__assert_fail
.Ltmp55:
	.size	ftp_lprt, .Ltmp55-ftp_lprt

	.globl	ftp_eprt
	.align	16, 0x90
	.type	ftp_eprt,@function
ftp_eprt:                               # @ftp_eprt
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$124, %esp
	leal	96(%esp), %edi
	movl	%edi, 4(%esp)
	movl	144(%esp), %ebp
	movl	%ebp, (%esp)
	movl	$0, 8(%esp)
	calll	socket_ip_address
	movl	$14, %esi
	testb	%al, %al
	je	.LBB56_8
# BB#1:                                 # %if.end
	movl	148(%esp), %esi
	movl	$0, 92(%esp)
	leal	92(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	bind_local
	movl	%eax, (%esi)
	movl	$14, %esi
	testl	%eax, %eax
	js	.LBB56_8
# BB#2:                                 # %if.end3
	cmpl	$2, 96(%esp)
	setne	%bl
	movl	92(%esp), %esi
	movl	%edi, (%esp)
	calll	print_address
	movl	%eax, 16(%esp)
	movl	%esi, 20(%esp)
	movzbl	%bl, %eax
	incl	%eax
	movl	%eax, 12(%esp)
	leal	35(%esp), %esi
	movl	%esi, (%esp)
	movl	$.L.str46163, 8(%esp)
	movl	$57, 4(%esp)
	calll	snprintf
	movb	$0, 91(%esp)
	movl	$.L.str10128, %ecx
	movl	%esi, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	testl	%edi, %edi
	js	.LBB56_3
# BB#4:                                 # %if.end10
	leal	120(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	ftp_response
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB56_5
# BB#6:                                 # %if.end14
	movl	120(%esp), %eax
	movb	(%eax), %bl
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$50, %bl
	movl	$10, %esi
	je	.LBB56_8
# BB#7:                                 # %if.then17
	movl	148(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$13, %esi
	jmp	.LBB56_8
.LBB56_3:                               # %if.then9
	movl	148(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
	movl	$52, %esi
	jmp	.LBB56_8
.LBB56_5:                               # %if.then13
	movl	148(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	fd_close
.LBB56_8:                               # %return
	movl	%esi, %eax
	addl	$124, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp56:
	.size	ftp_eprt, .Ltmp56-ftp_eprt

	.globl	ftp_pasv
	.align	16, 0x90
	.type	ftp_pasv,@function
ftp_pasv:                               # @ftp_pasv
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	68(%esp), %ebp
	testl	%ebp, %ebp
	je	.LBB57_21
# BB#1:                                 # %cond.end
	cmpl	$0, 72(%esp)
	je	.LBB57_22
# BB#2:                                 # %cond.end4
	movl	64(%esp), %ebx
	movl	$0, 4(%ebp)
	movl	$0, (%ebp)
	movl	$0, 12(%ebp)
	movl	$0, 8(%ebp)
	movl	$0, 20(%ebp)
	movl	$0, 16(%ebp)
	movl	$.L.str13131, %ecx
	xorl	%edx, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB57_20
# BB#3:                                 # %if.end
	leal	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB57_20
# BB#4:                                 # %if.end11
	movl	40(%esp), %edi
	cmpb	$50, (%edi)
	jne	.LBB57_5
# BB#6:                                 # %if.end15
	leal	3(%edi), %edx
	xorl	%esi, %esi
	movl	$35, %eax
	.align	16, 0x90
.LBB57_7:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%edx), %ecx
	testl	%ecx, %ecx
	je	.LBB57_20
# BB#8:                                 # %land.rhs
                                        #   in Loop: Header=BB57_7 Depth=1
	incl	%edx
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB57_7
# BB#9:
	movb	$10, %bl
	jmp	.LBB57_10
	.align	16, 0x90
.LBB57_16:                              # %for.inc55
                                        #   in Loop: Header=BB57_10 Depth=1
	incl	%esi
.LBB57_10:                              # %for.cond24
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB57_13 Depth 2
	cmpl	$5, %esi
	jg	.LBB57_19
# BB#11:                                # %for.body27
                                        #   in Loop: Header=BB57_10 Depth=1
	movb	$0, 32(%esp,%esi)
	movzbl	(%edx), %ecx
	xorb	%al, %al
	jmp	.LBB57_13
	.align	16, 0x90
.LBB57_12:                              # %for.body36
                                        #   in Loop: Header=BB57_13 Depth=2
	mulb	%bl
	addb	%cl, %al
	addb	$-48, %al
	movb	%al, 32(%esp,%esi)
	movzbl	1(%edx), %ecx
	incl	%edx
.LBB57_13:                              # %for.body36
                                        #   Parent Loop BB57_10 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	$4, _sch_istable(%ecx,%ecx)
	jne	.LBB57_12
# BB#14:                                # %for.end44
                                        #   in Loop: Header=BB57_10 Depth=1
	cmpb	$44, %cl
	jne	.LBB57_17
# BB#15:                                # %if.then48
                                        #   in Loop: Header=BB57_10 Depth=1
	incl	%edx
	jmp	.LBB57_16
.LBB57_17:                              # %if.else
                                        #   in Loop: Header=BB57_10 Depth=1
	cmpl	$4, %esi
	jg	.LBB57_16
# BB#18:                                # %if.then52
	movl	%edi, (%esp)
	calll	checking_free
	movl	$35, %eax
	jmp	.LBB57_20
.LBB57_5:                               # %if.then14
	movl	%edi, (%esp)
	calll	checking_free
	movl	$36, %eax
	jmp	.LBB57_20
.LBB57_19:                              # %for.end56
	movl	%edi, (%esp)
	calll	checking_free
	movl	$2, (%ebp)
	movl	32(%esp), %eax
	movl	%eax, 4(%ebp)
	movzwl	36(%esp), %eax
	bswapl	%eax
	shrl	$16, %eax
	movl	72(%esp), %ecx
	movl	%eax, (%ecx)
	movl	$10, %eax
.LBB57_20:                              # %return
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB57_21:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.ftp_pasv, 12(%esp)
	movl	$499, 8(%esp)           # imm = 0x1F3
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str11129, (%esp)
	calll	__assert_fail
.LBB57_22:                              # %cond.false3
	movl	$.L__PRETTY_FUNCTION__.ftp_pasv, 12(%esp)
	movl	$500, 8(%esp)           # imm = 0x1F4
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str12130, (%esp)
	calll	__assert_fail
.Ltmp57:
	.size	ftp_pasv, .Ltmp57-ftp_pasv

	.globl	ftp_lpsv
	.align	16, 0x90
	.type	ftp_lpsv,@function
ftp_lpsv:                               # @ftp_lpsv
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	68(%esp), %eax
	testl	%eax, %eax
	je	.LBB58_56
# BB#1:                                 # %cond.end
	cmpl	$0, 72(%esp)
	je	.LBB58_57
# BB#2:                                 # %cond.end5
	movl	64(%esp), %ebx
	movl	$0, 4(%eax)
	movl	$0, (%eax)
	movl	$0, 12(%eax)
	movl	$0, 8(%eax)
	movl	$0, 20(%eax)
	movl	$0, 16(%eax)
	movl	$.L.str14132, %ecx
	xorl	%edx, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB58_55
# BB#3:                                 # %if.end
	leal	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB58_55
# BB#4:                                 # %if.end12
	movl	40(%esp), %esi
	cmpb	$50, (%esi)
	jne	.LBB58_5
# BB#6:                                 # %if.end16
	leal	3(%esi), %ecx
	movl	$35, %eax
	.align	16, 0x90
.LBB58_7:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%ecx), %edx
	testl	%edx, %edx
	je	.LBB58_55
# BB#8:                                 # %land.rhs
                                        #   in Loop: Header=BB58_7 Depth=1
	incl	%ecx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB58_7
# BB#9:                                 # %for.cond25.preheader
	movsbl	%dl, %eax
	movzbl	%al, %edx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB58_13
# BB#10:
	xorl	%ebp, %ebp
	.align	16, 0x90
.LBB58_11:                              # %for.body32
                                        # =>This Inner Loop Header: Depth=1
	imull	$10, %ebp, %edx
	leal	-48(%edx,%eax), %ebp
	movb	1(%ecx), %dl
	incl	%ecx
	movsbl	%dl, %eax
	movzbl	%al, %edi
	testb	$4, _sch_istable(%edi,%edi)
	jne	.LBB58_11
# BB#12:                                # %for.end36
	movl	%ebp, %eax
	orl	$2, %eax
	cmpl	$6, %eax
	jne	.LBB58_13
# BB#14:                                # %if.end42
	cmpb	$44, %dl
	jne	.LBB58_13
# BB#15:                                # %for.cond50.preheader
	movb	1(%ecx), %al
	movsbl	%al, %edx
	movzbl	%dl, %ebx
	xorl	%edi, %edi
	jmp	.LBB58_17
	.align	16, 0x90
.LBB58_16:                              # %for.body57
                                        #   in Loop: Header=BB58_17 Depth=1
	imull	$10, %edi, %eax
	leal	-48(%eax,%edx), %edi
	movb	2(%ecx), %al
	incl	%ecx
	movsbl	%al, %edx
	movzbl	%dl, %ebx
.LBB58_17:                              # %for.body57
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%ebx,%ebx)
	jne	.LBB58_16
# BB#18:                                # %for.end64
	testb	%al, %al
	je	.LBB58_13
# BB#19:                                # %lor.lhs.false66
	cmpb	$44, %al
	jne	.LBB58_13
# BB#20:                                # %if.end72
	cmpl	$17, %edi
	jge	.LBB58_13
# BB#21:                                # %if.end76
	cmpl	$4, %ebp
	setne	%al
	cmpl	$4, %edi
	je	.LBB58_23
# BB#22:                                # %if.end76
	cmpb	$1, %al
	jne	.LBB58_13
.LBB58_23:                              # %lor.lhs.false82
	addl	$2, %ecx
	cmpl	$6, %ebp
	setne	%al
	xorl	%ebx, %ebx
	cmpl	$16, %edi
	je	.LBB58_25
# BB#24:                                # %lor.lhs.false82
	testb	%al, %al
	je	.LBB58_13
	jmp	.LBB58_25
.LBB58_5:                               # %if.then15
	movl	%esi, (%esp)
	calll	checking_free
	movl	$36, %eax
	jmp	.LBB58_55
.LBB58_56:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.ftp_lpsv, 12(%esp)
	movl	$565, 8(%esp)           # imm = 0x235
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str11129, (%esp)
	calll	__assert_fail
.LBB58_57:                              # %cond.false4
	movl	$.L__PRETTY_FUNCTION__.ftp_lpsv, 12(%esp)
	movl	$566, 8(%esp)           # imm = 0x236
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str12130, (%esp)
	calll	__assert_fail
	.align	16, 0x90
.LBB58_44:                              # %if.then117
                                        #   in Loop: Header=BB58_25 Depth=1
	incl	%ebx
	incl	%ecx
.LBB58_25:                              # %for.cond90
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB58_42 Depth 2
	cmpl	%edi, %ebx
	jge	.LBB58_26
# BB#40:                                # %for.body93
                                        #   in Loop: Header=BB58_25 Depth=1
	movb	$0, 24(%esp,%ebx)
	movzbl	(%ecx), %edx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB58_43
# BB#41:                                #   in Loop: Header=BB58_25 Depth=1
	xorb	%al, %al
	.align	16, 0x90
.LBB58_42:                              # %for.body102
                                        #   Parent Loop BB58_25 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	$10, %ah
	mulb	%ah
	addb	%dl, %al
	addb	$-48, %al
	movb	%al, 24(%esp,%ebx)
	movzbl	1(%ecx), %edx
	incl	%ecx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB58_42
.LBB58_43:                              # %for.end113
                                        #   in Loop: Header=BB58_25 Depth=1
	cmpb	$44, %dl
	jne	.LBB58_13
	jmp	.LBB58_44
.LBB58_26:                              # %for.cond122.preheader
	movb	(%ecx), %dl
	movsbl	%dl, %ebx
	movzbl	%bl, %edi
	xorl	%eax, %eax
	jmp	.LBB58_28
	.align	16, 0x90
.LBB58_27:                              # %for.body129
                                        #   in Loop: Header=BB58_28 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%ebx), %eax
	movb	1(%ecx), %dl
	incl	%ecx
	movsbl	%dl, %ebx
	movzbl	%bl, %edi
.LBB58_28:                              # %for.body129
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%edi,%edi)
	jne	.LBB58_27
# BB#29:                                # %for.end136
	cmpb	$44, %dl
	jne	.LBB58_13
# BB#30:                                # %if.end144
	cmpl	$2, %eax
	jg	.LBB58_13
# BB#31:                                # %for.cond150.preheader
	movb	1(%ecx), %al
	movsbl	%al, %edx
	movzbl	%dl, %ebx
	xorl	%edi, %edi
	jmp	.LBB58_33
	.align	16, 0x90
.LBB58_32:                              # %for.body157
                                        #   in Loop: Header=BB58_33 Depth=1
	imull	$10, %edi, %eax
	leal	208(%eax,%edx), %eax
	movzbl	%al, %edi
	movb	2(%ecx), %al
	incl	%ecx
	movsbl	%al, %edx
	movzbl	%dl, %ebx
.LBB58_33:                              # %for.body157
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%ebx,%ebx)
	jne	.LBB58_32
# BB#34:                                # %for.end168
	cmpb	$44, %al
	jne	.LBB58_13
# BB#35:                                # %if.end176
	movsbl	2(%ecx), %eax
	addl	$2, %ecx
	movzbl	%al, %edx
	xorl	%ebx, %ebx
	jmp	.LBB58_37
.LBB58_13:                              # %if.then41
	movl	%esi, (%esp)
	calll	checking_free
	movl	$35, %eax
	.align	16, 0x90
.LBB58_55:                              # %return
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
	.align	16, 0x90
.LBB58_36:                              # %for.body185
                                        #   in Loop: Header=BB58_37 Depth=1
	imull	$10, %ebx, %edx
	leal	208(%edx,%eax), %eax
	movzbl	%al, %ebx
	movsbl	1(%ecx), %eax
	incl	%ecx
	movzbl	%al, %edx
.LBB58_37:                              # %for.body185
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB58_36
# BB#38:                                # %for.end196
	testl	%ecx, %ecx
	movl	68(%esp), %ecx
	je	.LBB58_39
# BB#45:                                # %cond.end201
	cmpl	$4, %ebp
	jne	.LBB58_47
# BB#46:                                # %if.then204
	movl	$2, (%ecx)
	movl	24(%esp), %eax
	movl	%eax, 4(%ecx)
	jmp	.LBB58_49
.LBB58_39:                              # %cond.false200
	movl	$.L__PRETTY_FUNCTION__.ftp_lpsv, 12(%esp)
	movl	$687, 8(%esp)           # imm = 0x2AF
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str15133, (%esp)
	calll	__assert_fail
.LBB58_47:                              # %if.else245
	cmpl	$6, %ebp
	jne	.LBB58_58
# BB#48:                                # %cond.end250
	movl	$10, (%ecx)
	movsd	24(%esp), %xmm0
	movsd	32(%esp), %xmm1
	movsd	%xmm1, 12(%ecx)
	movsd	%xmm0, 4(%ecx)
.LBB58_49:                              # %cond.end250
	movl	%edi, %eax
	shll	$8, %eax
	orl	%ebx, %eax
	movl	72(%esp), %ebp
	movl	%eax, (%ebp)
	cmpb	$0, opt+250
	je	.LBB58_54
# BB#50:                                # %do.body270
	movl	%ecx, (%esp)
	calll	print_address
	movl	%eax, 4(%esp)
	movl	$.L.str16134, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	je	.LBB58_54
# BB#51:                                # %do.body280
	movl	%edi, 4(%esp)
	movl	$.L.str17135, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	je	.LBB58_54
# BB#52:                                # %do.body290
	movl	%ebx, 4(%esp)
	movl	$.L.str18136, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	je	.LBB58_54
# BB#53:                                # %if.then295
	movl	(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str19137, (%esp)
	calll	debug_logprintf
.LBB58_54:                              # %if.end298
	movl	%esi, (%esp)
	calll	checking_free
	movl	$10, %eax
	jmp	.LBB58_55
.LBB58_58:                              # %cond.false249
	movl	$.L__PRETTY_FUNCTION__.ftp_lpsv, 12(%esp)
	movl	$701, 8(%esp)           # imm = 0x2BD
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str20138, (%esp)
	calll	__assert_fail
.Ltmp58:
	.size	ftp_lpsv, .Ltmp58-ftp_lpsv

	.globl	ftp_epsv
	.align	16, 0x90
	.type	ftp_epsv,@function
ftp_epsv:                               # @ftp_epsv
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %eax
	testl	%eax, %eax
	je	.LBB59_24
# BB#1:                                 # %cond.end
	cmpl	$0, 56(%esp)
	je	.LBB59_25
# BB#2:                                 # %cond.end4
	movl	48(%esp), %ebp
	movl	$.L.str23141, %ecx
	cmpl	$2, (%eax)
	movl	$.L.str24142, %edx
	cmovel	%ecx, %edx
	movl	$.L.str22140, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB59_6
# BB#3:                                 # %if.end
	leal	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB59_6
# BB#4:                                 # %if.end12
	movl	24(%esp), %esi
	cmpb	$50, (%esi)
	jne	.LBB59_5
# BB#7:                                 # %if.end16
	testl	%esi, %esi
	je	.LBB59_26
# BB#8:                                 # %do.body
	cmpb	$0, opt+250
	jne	.LBB59_9
	.align	16, 0x90
.LBB59_10:                              # %do.end
	movl	%esi, (%esp)
	movl	$40, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	je	.LBB59_11
# BB#12:                                # %if.end30
	movb	1(%eax), %cl
	cmpb	$33, %cl
	jl	.LBB59_11
# BB#13:                                # %if.end30
	cmpb	$127, %cl
	je	.LBB59_11
# BB#14:                                # %for.cond.preheader
	xorl	%edx, %edx
	jmp	.LBB59_15
	.align	16, 0x90
.LBB59_23:                              # %for.inc
                                        #   in Loop: Header=BB59_15 Depth=1
	incl	%edx
.LBB59_15:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movb	2(%eax,%edx), %ch
	cmpl	$2, %edx
	jge	.LBB59_16
# BB#22:                                # %for.body
                                        #   in Loop: Header=BB59_15 Depth=1
	cmpb	%cl, %ch
	jne	.LBB59_11
	jmp	.LBB59_23
.LBB59_5:                               # %if.then15
	movl	%esi, (%esp)
	calll	checking_free
	movl	$36, %eax
	jmp	.LBB59_6
.LBB59_16:                              # %for.cond48.preheader
	movsbl	%ch, %ebx
	leal	2(%eax,%edx), %eax
	movzbl	%bl, %edi
	xorl	%edx, %edx
	jmp	.LBB59_18
	.align	16, 0x90
.LBB59_17:                              # %if.end57
                                        #   in Loop: Header=BB59_18 Depth=1
	imull	$10, %edx, %edx
	leal	-48(%edx,%ebx), %edx
	movb	1(%eax), %ch
	incl	%eax
	movsbl	%ch, %ebx
	movzbl	%bl, %edi
.LBB59_18:                              # %if.end57
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%edi,%edi)
	jne	.LBB59_17
# BB#19:                                # %for.end61
	cmpb	%cl, %ch
	jne	.LBB59_11
# BB#20:                                # %if.end68
	cmpb	$41, 1(%eax)
	jne	.LBB59_11
# BB#21:                                # %if.end74
	movl	56(%esp), %eax
	movl	%edx, (%eax)
	movl	%esi, (%esp)
	calll	checking_free
	movl	$10, %eax
	jmp	.LBB59_6
.LBB59_11:                              # %if.then29
	movl	%esi, (%esp)
	calll	checking_free
	movl	$35, %eax
.LBB59_6:                               # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB59_9:                               # %if.then24
	movl	%esi, 4(%esp)
	movl	$.L.str26144, (%esp)
	calll	debug_logprintf
	jmp	.LBB59_10
.LBB59_24:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.ftp_epsv, 12(%esp)
	movl	$726, 8(%esp)           # imm = 0x2D6
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str21139, (%esp)
	calll	__assert_fail
.LBB59_25:                              # %cond.false3
	movl	$.L__PRETTY_FUNCTION__.ftp_epsv, 12(%esp)
	movl	$727, 8(%esp)           # imm = 0x2D7
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str12130, (%esp)
	calll	__assert_fail
.LBB59_26:                              # %cond.false20
	movl	$.L__PRETTY_FUNCTION__.ftp_epsv, 12(%esp)
	movl	$755, 8(%esp)           # imm = 0x2F3
	movl	$.L.str6124, 4(%esp)
	movl	$.L.str25143, (%esp)
	calll	__assert_fail
.Ltmp59:
	.size	ftp_epsv, .Ltmp59-ftp_epsv

	.globl	ftp_type
	.align	16, 0x90
	.type	ftp_type,@function
ftp_type:                               # @ftp_type
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movb	52(%esp), %al
	movb	%al, 26(%esp)
	movb	$0, 27(%esp)
	leal	26(%esp), %edx
	movl	$.L.str27145, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %esi
	testl	%edi, %edi
	js	.LBB60_3
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB60_3
# BB#2:                                 # %if.end9
	movl	$10, %ecx
	movl	28(%esp), %eax
	cmpb	$50, (%eax)
	movl	$17, %esi
	cmovel	%ecx, %esi
	movl	%eax, (%esp)
	calll	checking_free
.LBB60_3:                               # %return
	movl	%esi, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp60:
	.size	ftp_type, .Ltmp60-ftp_type

	.globl	ftp_cwd
	.align	16, 0x90
	.type	ftp_cwd,@function
ftp_cwd:                                # @ftp_cwd
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %edx
	movl	$.L.str28146, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB61_5
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB61_5
# BB#2:                                 # %if.end6
	movl	28(%esp), %eax
	movb	(%eax), %bl
	cmpb	$53, %bl
	jne	.LBB61_4
# BB#3:                                 # %if.then9
	movl	%eax, (%esp)
	calll	checking_free
	movl	$15, %eax
	jmp	.LBB61_5
.LBB61_4:                               # %if.end10
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$50, %bl
	setne	%al
	movzbl	%al, %eax
	leal	10(,%eax,8), %eax
.LBB61_5:                               # %return
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp61:
	.size	ftp_cwd, .Ltmp61-ftp_cwd

	.globl	ftp_rest
	.align	16, 0x90
	.type	ftp_rest,@function
ftp_rest:                               # @ftp_rest
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	56(%esp), %eax
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	$.L.str29147, %ecx
	movl	%eax, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %esi
	testl	%edi, %edi
	js	.LBB62_3
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	movl	%eax, %esi
	cmpl	$10, %esi
	jne	.LBB62_3
# BB#2:                                 # %if.end7
	movl	$10, %ecx
	movl	28(%esp), %eax
	cmpb	$51, (%eax)
	movl	$22, %esi
	cmovel	%ecx, %esi
	movl	%eax, (%esp)
	calll	checking_free
.LBB62_3:                               # %return
	movl	%esi, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp62:
	.size	ftp_rest, .Ltmp62-ftp_rest

	.globl	ftp_retr
	.align	16, 0x90
	.type	ftp_retr,@function
ftp_retr:                               # @ftp_retr
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %edx
	movl	$.L.str30148, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB63_5
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB63_5
# BB#2:                                 # %if.end6
	movl	28(%esp), %eax
	movb	(%eax), %bl
	cmpb	$53, %bl
	jne	.LBB63_4
# BB#3:                                 # %if.then9
	movl	%eax, (%esp)
	calll	checking_free
	movl	$15, %eax
	jmp	.LBB63_5
.LBB63_4:                               # %if.end10
	movl	%eax, (%esp)
	calll	checking_free
	cmpb	$49, %bl
	setne	%al
	movzbl	%al, %eax
	leal	10(,%eax,8), %eax
.LBB63_5:                               # %return
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp63:
	.size	ftp_retr, .Ltmp63-ftp_retr

	.globl	ftp_list
	.align	16, 0x90
	.type	ftp_list,@function
ftp_list:                               # @ftp_list
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	xorl	%ebp, %ebp
	movb	$0, 23(%esp)            # 1-byte Folded Spill
	movl	48(%esp), %esi
	.align	16, 0x90
.LBB64_1:                               # %do.body
                                        # =>This Inner Loop Header: Depth=1
	movl	.Lftp_list.list_commands(,%ebp,4), %ecx
	movl	52(%esp), %edx
	calll	ftp_request
	movl	%eax, %edi
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %ebx
	movl	%edi, (%esp)
	calll	checking_free
	movl	$52, %edi
	testl	%ebx, %ebx
	js	.LBB64_10
# BB#2:                                 # %if.end
                                        #   in Loop: Header=BB64_1 Depth=1
	leal	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	ftp_response
	movl	%eax, %edi
	cmpl	$10, %edi
	jne	.LBB64_8
# BB#3:                                 # %if.then5
                                        #   in Loop: Header=BB64_1 Depth=1
	movl	24(%esp), %eax
	movb	(%eax), %cl
	movl	$15, %edi
	cmpb	$53, %cl
	je	.LBB64_7
# BB#4:                                 # %if.then5
                                        #   in Loop: Header=BB64_1 Depth=1
	cmpb	$49, %cl
	jne	.LBB64_6
# BB#5:                                 # %if.then12
                                        #   in Loop: Header=BB64_1 Depth=1
	movb	$1, 23(%esp)            # 1-byte Folded Spill
	movl	$10, %edi
	jmp	.LBB64_7
.LBB64_6:                               # %if.else13
                                        #   in Loop: Header=BB64_1 Depth=1
	movl	$18, %edi
.LBB64_7:                               # %if.end15
                                        #   in Loop: Header=BB64_1 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB64_8:                               # %if.end16
                                        #   in Loop: Header=BB64_1 Depth=1
	incl	%ebp
	cmpl	$1, %ebp
	ja	.LBB64_10
# BB#9:                                 # %land.rhs
                                        #   in Loop: Header=BB64_1 Depth=1
	testb	$1, 23(%esp)            # 1-byte Folded Reload
	je	.LBB64_1
.LBB64_10:                              # %return
	movl	%edi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp64:
	.size	ftp_list, .Ltmp64-ftp_list

	.globl	ftp_syst
	.align	16, 0x90
	.type	ftp_syst,@function
ftp_syst:                               # @ftp_syst
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	$.L.str33151, %ecx
	xorl	%edx, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB65_18
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB65_18
# BB#2:                                 # %if.end6
	movl	28(%esp), %edi
	cmpb	$53, (%edi)
	jne	.LBB65_4
# BB#3:                                 # %if.then9
	movl	%edi, (%esp)
	calll	checking_free
	movl	$20, %eax
	jmp	.LBB65_18
.LBB65_4:                               # %if.end10
	movl	52(%esp), %ebx
	movl	%edi, (%esp)
	movl	$.L.str34152, 4(%esp)
	calll	strtok
	movl	$.L.str34152, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB65_16
# BB#5:                                 # %if.else
	movl	%esi, (%esp)
	movl	$.L.str35153, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_6
# BB#7:                                 # %if.else18
	movl	%esi, (%esp)
	movl	$.L.str36154, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_8
# BB#9:                                 # %if.else22
	movl	%esi, (%esp)
	movl	$.L.str37155, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_11
# BB#10:                                # %lor.lhs.false
	movl	%esi, (%esp)
	movl	$.L.str38156, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_11
# BB#12:                                # %if.else28
	movl	%esi, (%esp)
	movl	$.L.str39157, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_13
# BB#14:                                # %if.else32
	movl	%esi, (%esp)
	movl	$.L.str40158, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB65_15
.LBB65_16:                              # %if.else36
	movl	$5, (%ebx)
	jmp	.LBB65_17
.LBB65_6:                               # %if.then17
	movl	$1, (%ebx)
	jmp	.LBB65_17
.LBB65_8:                               # %if.then21
	movl	$0, (%ebx)
	jmp	.LBB65_17
.LBB65_11:                              # %if.then27
	movl	$2, (%ebx)
	jmp	.LBB65_17
.LBB65_13:                              # %if.then31
	movl	$3, (%ebx)
	jmp	.LBB65_17
.LBB65_15:                              # %if.then35
	movl	$4, (%ebx)
.LBB65_17:                              # %if.end42
	movl	%edi, (%esp)
	calll	checking_free
	movl	$10, %eax
.LBB65_18:                              # %return
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp65:
	.size	ftp_syst, .Ltmp65-ftp_syst

	.globl	ftp_pwd
	.align	16, 0x90
	.type	ftp_pwd,@function
ftp_pwd:                                # @ftp_pwd
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	$.L.str41159, %ecx
	xorl	%edx, %edx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebx
	movl	%ebx, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	$52, %eax
	testl	%edi, %edi
	js	.LBB66_8
# BB#1:                                 # %if.end
	leal	28(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB66_8
# BB#2:                                 # %if.end6
	movl	28(%esp), %edi
	cmpb	$53, (%edi)
	je	.LBB66_3
# BB#4:                                 # %if.end11
	movl	%edi, (%esp)
	movl	$.L.str42160, 4(%esp)
	calll	strtok
	movl	$.L.str42160, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB66_3
# BB#5:                                 # %if.end15
	movl	52(%esp), %ebx
	movl	(%ebx), %eax
	testl	%eax, %eax
	je	.LBB66_7
# BB#6:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB66_7:                               # %if.end18
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, (%ebx)
	movl	%edi, (%esp)
	calll	checking_free
	movl	$10, %eax
	jmp	.LBB66_8
.LBB66_3:                               # %err10
	movl	%edi, (%esp)
	calll	checking_free
	movl	$20, %eax
.LBB66_8:                               # %return
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp66:
	.size	ftp_pwd, .Ltmp66-ftp_pwd

	.globl	ftp_size
	.align	16, 0x90
	.type	ftp_size,@function
ftp_size:                               # @ftp_size
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %edx
	movl	$.L.str43161, %ecx
	calll	ftp_request
	movl	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %ebp
	movl	%ebp, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	checking_free
	movl	56(%esp), %ebx
	testl	%edi, %edi
	js	.LBB67_1
# BB#2:                                 # %if.end
	leal	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	ftp_response
	cmpl	$10, %eax
	jne	.LBB67_3
# BB#4:                                 # %if.end6
	movl	24(%esp), %edi
	cmpb	$53, (%edi)
	jne	.LBB67_6
# BB#5:                                 # %if.then9
	movl	%edi, (%esp)
	calll	checking_free
	jmp	.LBB67_7
.LBB67_1:                               # %if.then
	movl	$0, 4(%ebx)
	movl	$0, (%ebx)
	movl	$52, %eax
	jmp	.LBB67_8
.LBB67_3:                               # %if.then5
	movl	$0, 4(%ebx)
	movl	$0, (%ebx)
	jmp	.LBB67_8
.LBB67_6:                               # %if.end10
	calll	__errno_location
	movl	%eax, %esi
	movl	$0, (%esi)
	leal	4(%edi), %eax
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtoll
	movl	%edx, 4(%ebx)
	movl	%eax, (%ebx)
	movl	(%esi), %esi
	movl	%edi, (%esp)
	calll	checking_free
	cmpl	$0, %esi
	movl	$10, %eax
	je	.LBB67_8
.LBB67_7:                               # %if.then14
	movl	$0, 4(%ebx)
	movl	$0, (%ebx)
	movl	$10, %eax
.LBB67_8:                               # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp67:
	.size	ftp_size, .Ltmp67-ftp_size

	.globl	ftp_process_type
	.align	16, 0x90
	.type	ftp_process_type,@function
ftp_process_type:                       # @ftp_process_type
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movb	$73, %cl
	movl	32(%esp), %esi
	testl	%esi, %esi
	je	.LBB68_4
# BB#1:                                 # %land.lhs.true
	movl	%esi, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str44162, 4(%esp)
	calll	strncasecmp
	movb	$73, %cl
	testl	%eax, %eax
	jne	.LBB68_4
# BB#2:                                 # %land.lhs.true1
	movzbl	5(%esi), %eax
	movb	$73, %cl
	testl	%eax, %eax
	je	.LBB68_4
# BB#3:                                 # %if.then
	movb	_sch_toupper(%eax), %cl
.LBB68_4:                               # %return
	movsbl	%cl, %eax
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp68:
	.size	ftp_process_type, .Ltmp68-ftp_process_type

	.globl	ftp_parse_ls
	.align	16, 0x90
	.type	ftp_parse_ls,@function
ftp_parse_ls:                           # @ftp_parse_ls
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	movl	196(%esp), %eax
	movl	192(%esp), %esi
	cmpl	$3, %eax
	jbe	.LBB69_1
# BB#165:                               # %sw.default
	movl	$5, 8(%esp)
	movl	$.L.str2209, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	jmp	.LBB69_166
.LBB69_1:                               # %entry
	jmpl	*.LJTI69_0(,%eax,4)
.LBB69_51:                              # %sw.bb11
	movl	%esi, (%esp)
	movl	$.L.str207, 4(%esp)
	calll	fopen64
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)          # 4-byte Spill
	testl	%ebp, %ebp
	je	.LBB69_3
# BB#52:                                # %if.end.i
	movl	%ebp, (%esp)
	calll	read_whole_line
	testl	%eax, %eax
	je	.LBB69_54
# BB#53:                                # %if.else.i24
	movl	%eax, (%esp)
	calll	checking_free
.LBB69_54:                              # %if.end6.i
	movl	%ebp, (%esp)
	calll	read_whole_line
	testl	%eax, %eax
	je	.LBB69_56
# BB#55:                                # %if.else10.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB69_56:                              # %if.end11.i
	movl	%ebp, (%esp)
	calll	read_whole_line
	testl	%eax, %eax
	je	.LBB69_58
# BB#57:                                # %if.else15.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB69_58:                              # %while.cond.preheader.i34
	xorl	%eax, %eax
	movl	%eax, %edi
	movl	$0, 44(%esp)            # 4-byte Folded Spill
	jmp	.LBB69_59
.LBB69_166:                             # %sw.default
	movl	%esi, %ecx
	xorl	%edx, %edx
	jmp	.LBB69_167
.LBB69_2:                               # %sw.bb1
	movl	%esi, (%esp)
	movl	$.L.str207, 4(%esp)
	calll	fopen64
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB69_3
# BB#4:                                 # %if.end
	movl	%edi, (%esp)
	calll	fgetc
	movl	%eax, %ebx
	movl	%edi, (%esp)
	calll	fclose
	addl	$-48, %ebx
	cmpl	$9, %ebx
	ja	.LBB69_164
# BB#5:                                 # %if.then8
	movl	%esi, (%esp)
	movl	$.L.str207, 4(%esp)
	calll	fopen64
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB69_3
# BB#6:                                 # %while.cond.preheader.i
	movl	%edi, (%esp)
	calll	read_whole_line
	movl	%eax, %ebx
	movl	$0, 44(%esp)            # 4-byte Folded Spill
	testl	%ebx, %ebx
	movl	%edi, %esi
	movl	%esi, 64(%esp)          # 4-byte Spill
	je	.LBB69_49
# BB#7:                                 # %while.body.lr.ph.i
	movl	$0, 60(%esp)            # 4-byte Folded Spill
	movl	$0, 44(%esp)            # 4-byte Folded Spill
	.align	16, 0x90
.LBB69_8:                               # %while.body.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB69_31 Depth 2
                                        #     Child Loop BB69_14 Depth 2
	movl	%ebx, (%esp)
	calll	strlen
	testl	%eax, %eax
	je	.LBB69_48
# BB#9:                                 # %if.end.i.i
                                        #   in Loop: Header=BB69_8 Depth=1
	cmpb	$10, -1(%ebx,%eax)
	jne	.LBB69_11
# BB#10:                                # %if.then2.i.i
                                        #   in Loop: Header=BB69_8 Depth=1
	decl	%eax
	movb	$0, (%ebx,%eax)
.LBB69_11:                              # %if.end4.i.i
                                        #   in Loop: Header=BB69_8 Depth=1
	cmpb	$13, -1(%ebx,%eax)
	jne	.LBB69_13
# BB#12:                                # %if.then10.i.i
                                        #   in Loop: Header=BB69_8 Depth=1
	decl	%eax
	movb	$0, (%ebx,%eax)
.LBB69_13:                              # %for.cond.preheader.i.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%ebx, %ecx
	jmp	.LBB69_14
	.align	16, 0x90
.LBB69_17:                              # %for.inc.i.i
                                        #   in Loop: Header=BB69_14 Depth=2
	incl	%ecx
.LBB69_14:                              # %for.cond.i.i
                                        #   Parent Loop BB69_8 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB69_18
# BB#15:                                # %for.cond.i.i
                                        #   in Loop: Header=BB69_14 Depth=2
	cmpb	$9, %dl
	jne	.LBB69_17
# BB#16:                                # %if.then18.i.i
                                        #   in Loop: Header=BB69_14 Depth=2
	movb	$32, (%ecx)
	jmp	.LBB69_17
.LBB69_18:                              # %clean_line.exit.i
                                        #   in Loop: Header=BB69_8 Depth=1
	cmpl	$40, %eax
	jl	.LBB69_48
# BB#19:                                # %if.end7.i
                                        #   in Loop: Header=BB69_8 Depth=1
	leal	39(%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, %edi
	cmpb	$0, opt+250
	jne	.LBB69_20
	.align	16, 0x90
.LBB69_21:                              # %do.end.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%edi, 72(%esp)          # 4-byte Spill
	movl	%ebx, (%esp)
	movl	$.L.str63269, 4(%esp)
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_48
# BB#22:                                # %if.end18.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%ebx, 56(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %edi
	movl	$.L.str63269, 4(%esp)
	movl	$0, (%esp)
	decl	%edi
	testl	%edi, %edi
	movl	$0, %eax
	cmovsl	%eax, %edi
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_48
# BB#23:                                # %if.end28.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%edi, 76(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %edi
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_48
# BB#24:                                # %if.end34.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%edi, 68(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	$.L.str4211, 4(%esp)
	movl	$0, (%esp)
	leal	100(%eax), %edi
	cmpl	$71, %eax
	cmovgel	%eax, %edi
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_48
# BB#25:                                # %if.end44.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%edi, 52(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %ebp
	movl	$.L.str74280, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %ebx
	testl	%ebx, %ebx
	je	.LBB69_48
# BB#26:                                # %if.end50.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%ebx, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	cmpl	$12, %ebp
	movl	$0, %eax
	cmovel	%eax, %ebp
	leal	12(%ebp), %esi
	calll	strtol
	cmpb	$80, 2(%ebx)
	cmovnel	%ebp, %esi
	cmpb	$0, opt+250
	movl	76(%esp), %edx          # 4-byte Reload
	movl	68(%esp), %ebp          # 4-byte Reload
	movl	52(%esp), %ecx          # 4-byte Reload
	je	.LBB69_28
# BB#27:                                # %if.then68.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%eax, 20(%esp)
	movl	%esi, 16(%esp)
	movl	%ebp, 12(%esp)
	movl	%edx, 8(%esp)
	movl	%eax, 48(%esp)          # 4-byte Spill
	leal	1900(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str75281, (%esp)
	movl	%ecx, %ebx
	movl	%edx, %edi
	calll	debug_logprintf
	movl	%edi, %edx
	movl	%ebx, %ecx
	movl	48(%esp), %eax          # 4-byte Reload
.LBB69_28:                              # %do.end71.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	$0, 80(%esp)
	movl	%eax, 84(%esp)
	movl	%esi, 88(%esp)
	movl	%ebp, 92(%esp)
	movl	%edx, 96(%esp)
	movl	%ecx, 100(%esp)
	movl	$0, 104(%esp)
	movl	$0, 108(%esp)
	movl	$-1, 112(%esp)
	leal	80(%esp), %eax
	movl	%eax, (%esp)
	calll	mktime
	movl	%eax, %esi
	cmpb	$0, opt+250
	je	.LBB69_30
# BB#29:                                # %if.then78.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%esi, 4(%esp)
	movl	$.L.str68274, (%esp)
	calll	debug_logprintf
.LBB69_30:                              # %do.end81.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%esi, 68(%esp)          # 4-byte Spill
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %edi
	testl	%edi, %edi
	movl	64(%esp), %esi          # 4-byte Reload
	je	.LBB69_48
	jmp	.LBB69_31
.LBB69_20:                              # %if.then11.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%edi, 4(%esp)
	movl	$.L.str56262, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_21
	.align	16, 0x90
.LBB69_34:                              # %while.body93.i
                                        #   in Loop: Header=BB69_31 Depth=2
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %edi
.LBB69_31:                              # %while.cond87.i
                                        #   Parent Loop BB69_8 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testl	%edi, %edi
	je	.LBB69_48
# BB#32:                                # %land.rhs.i
                                        #   in Loop: Header=BB69_31 Depth=2
	movb	(%edi), %al
	cmpb	$60, %al
	je	.LBB69_35
# BB#33:                                # %land.rhs.i
                                        #   in Loop: Header=BB69_31 Depth=2
	testb	%al, %al
	je	.LBB69_34
# BB#38:                                # %if.else.i
                                        #   in Loop: Header=BB69_8 Depth=1
	calll	__errno_location
	movl	%eax, %ebp
	movl	$0, (%ebp)
	movl	%edi, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtoll
	movl	%edx, %ecx
	xorl	$2147483647, %ecx       # imm = 0x7FFFFFFF
	movl	%eax, %esi
	notl	%esi
	orl	%ecx, %esi
	jne	.LBB69_40
# BB#39:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB69_8 Depth=1
	xorl	%ecx, %ecx
	cmpl	$34, (%ebp)
	movl	$0, %ebp
	je	.LBB69_41
.LBB69_40:                              # %if.else122.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%eax, %ecx
	movl	%edx, %ebp
.LBB69_41:                              # %if.end124.i
                                        #   in Loop: Header=BB69_8 Depth=1
	cmpb	$0, opt+250
	jne	.LBB69_43
# BB#42:                                #   in Loop: Header=BB69_8 Depth=1
	movl	%ecx, 76(%esp)          # 4-byte Spill
	movl	$420, %esi              # imm = 0x1A4
	xorl	%ebx, %ebx
	jmp	.LBB69_44
.LBB69_35:                              # %if.then102.i
                                        #   in Loop: Header=BB69_8 Depth=1
	cmpb	$0, opt+250
	jne	.LBB69_37
# BB#36:                                #   in Loop: Header=BB69_8 Depth=1
	movl	$493, %esi              # imm = 0x1ED
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	$1, %ebx
	xorl	%ebp, %ebp
	jmp	.LBB69_44
.LBB69_43:                              # %if.then131.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%ebp, 4(%esp)
	movl	%ecx, (%esp)
	movl	%ecx, 76(%esp)          # 4-byte Spill
	calll	number_to_static_string
	movl	%eax, 4(%esp)
	movl	$.L.str76282, (%esp)
	calll	debug_logprintf
	xorl	%ebx, %ebx
	movl	$420, %esi              # imm = 0x1A4
	jmp	.LBB69_44
.LBB69_37:                              # %if.then108.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	$.L.str57263, (%esp)
	calll	debug_logprintf
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	$1, %ebx
	movl	$493, %esi              # imm = 0x1ED
	xorl	%ebp, %ebp
.LBB69_44:                              # %if.end136.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	$36, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	44(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	jne	.LBB69_46
# BB#45:                                # %if.then138.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%ebx, (%edi)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%edi)
	movl	%ebp, 12(%edi)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%edi)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 16(%edi)
	movl	%esi, 20(%edi)
	movl	$0, 24(%edi)
	movl	$0, 32(%edi)
	movl	$0, 28(%edi)
	movl	%edi, 44(%esp)          # 4-byte Spill
	jmp	.LBB69_47
.LBB69_46:                              # %if.else140.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%eax, 44(%esp)          # 4-byte Spill
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%edi, 32(%eax)
	movl	%ebx, (%edi)
	movl	72(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%edi)
	movl	%ebp, 12(%edi)
	movl	76(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 8(%edi)
	movl	68(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 16(%edi)
	movl	%esi, 20(%edi)
	movl	$0, 24(%edi)
	movl	%eax, 28(%edi)
	movl	$0, 32(%edi)
.LBB69_47:                              # %if.end146.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	%edi, 60(%esp)          # 4-byte Spill
	movl	64(%esp), %esi          # 4-byte Reload
.LBB69_48:                              # %while.cond.backedge.i
                                        #   in Loop: Header=BB69_8 Depth=1
	movl	%esi, (%esp)
	calll	read_whole_line
	movl	%eax, %ebx
	testl	%ebx, %ebx
	jne	.LBB69_8
.LBB69_49:                              # %while.end147.i
	movl	%esi, (%esp)
	jmp	.LBB69_50
.LBB69_164:                             # %if.else
	movl	%esi, %ecx
	movl	$1, %edx
.LBB69_167:                             # %sw.default
	calll	ftp_parse_unix_ls
	.align	16, 0x90
.LBB69_168:                             # %return
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB69_3:                               # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str1208, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
	jmp	.LBB69_168
	.align	16, 0x90
.LBB69_163:                             # %if.end315.i
                                        #   in Loop: Header=BB69_59 Depth=1
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
.LBB69_59:                              # %while.cond.outer.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB69_145 Depth 2
                                        #     Child Loop BB69_60 Depth 2
                                        #       Child Loop BB69_126 Depth 3
                                        #       Child Loop BB69_123 Depth 3
                                        #       Child Loop BB69_116 Depth 3
                                        #       Child Loop BB69_75 Depth 3
                                        #       Child Loop BB69_67 Depth 3
                                        #       Child Loop BB69_100 Depth 3
	movl	%edi, 40(%esp)          # 4-byte Spill
	jmp	.LBB69_60
	.align	16, 0x90
.LBB69_138:                             # %do.end294.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	.align	16, 0x90
.LBB69_60:                              # %while.cond.i
                                        #   Parent Loop BB69_59 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB69_126 Depth 3
                                        #       Child Loop BB69_123 Depth 3
                                        #       Child Loop BB69_116 Depth 3
                                        #       Child Loop BB69_75 Depth 3
                                        #       Child Loop BB69_67 Depth 3
                                        #       Child Loop BB69_100 Depth 3
	movl	%ebp, (%esp)
	calll	read_whole_line
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB69_143
# BB#61:                                # %while.body.i38
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%edi, (%esp)
	calll	strlen
	testl	%eax, %eax
	je	.LBB69_72
# BB#62:                                # %if.end.i.i42
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$10, -1(%edi,%eax)
	jne	.LBB69_64
# BB#63:                                # %if.then2.i.i43
                                        #   in Loop: Header=BB69_60 Depth=2
	decl	%eax
	movb	$0, (%edi,%eax)
.LBB69_64:                              # %if.end4.i.i48
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$13, -1(%edi,%eax)
	jne	.LBB69_66
# BB#65:                                # %if.then10.i.i49
                                        #   in Loop: Header=BB69_60 Depth=2
	decl	%eax
	movb	$0, (%edi,%eax)
.LBB69_66:                              # %for.cond.preheader.i.i51
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%edi, %ecx
	jmp	.LBB69_67
	.align	16, 0x90
.LBB69_70:                              # %for.inc.i.i56
                                        #   in Loop: Header=BB69_67 Depth=3
	incl	%ecx
.LBB69_67:                              # %for.cond.i.i53
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB69_71
# BB#68:                                # %for.cond.i.i53
                                        #   in Loop: Header=BB69_67 Depth=3
	cmpb	$9, %dl
	jne	.LBB69_70
# BB#69:                                # %if.then18.i.i54
                                        #   in Loop: Header=BB69_67 Depth=3
	movb	$32, (%ecx)
	jmp	.LBB69_70
.LBB69_71:                              # %clean_line.exit.i57
                                        #   in Loop: Header=BB69_60 Depth=2
	testl	%eax, %eax
	je	.LBB69_72
# BB#73:                                # %if.end21.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%edi, (%esp)
	movl	$.L.str53259, 4(%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	cmovel	%edi, %esi
	cmpb	$0, opt+250
	movl	%esi, %eax
	je	.LBB69_75
# BB#74:                                # %if.then28.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 4(%esp)
	movl	$.L.str54260, (%esp)
	calll	debug_logprintf
	movl	%esi, %eax
	jmp	.LBB69_75
	.align	16, 0x90
.LBB69_77:                              # %for.inc.i
                                        #   in Loop: Header=BB69_75 Depth=3
	incl	%eax
.LBB69_75:                              # %for.cond.i
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB69_79
# BB#76:                                # %for.cond.i
                                        #   in Loop: Header=BB69_75 Depth=3
	cmpb	$59, %cl
	jne	.LBB69_77
# BB#78:                                # %if.then38.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movb	$0, (%eax)
.LBB69_79:                              # %if.end39.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%edi, %ebx
	movl	%esi, (%esp)
	calll	strlen
	leal	-4(%eax,%esi), %edi
	movl	%edi, (%esp)
	movl	$.L.str55261, 4(%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB69_81
# BB#80:                                # %if.then81.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movb	$0, (%edi)
.LBB69_81:                              # %if.end82.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, %esi
	movb	$1, %al
	cmpb	$0, opt+250
	jne	.LBB69_82
	.align	16, 0x90
.LBB69_83:                              # %do.end92.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 56(%esp)          # 4-byte Spill
	cmpb	$0, (%edi)
	jne	.LBB69_86
# BB#84:                                # %if.then94.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$1, %ecx
	testb	%al, %al
	movl	%ebx, %esi
	jne	.LBB69_88
# BB#85:                                # %if.then100.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str57263, (%esp)
	calll	debug_logprintf
	movl	$1, %ecx
	jmp	.LBB69_88
.LBB69_86:                              # %if.else103.i
                                        #   in Loop: Header=BB69_60 Depth=2
	xorl	%ecx, %ecx
	testb	%al, %al
	movl	%ebx, %esi
	je	.LBB69_87
	.align	16, 0x90
.LBB69_88:                              # %if.end113.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%ecx, 52(%esp)          # 4-byte Spill
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	testl	%eax, %eax
	jne	.LBB69_109
# BB#89:                                # %do.body119.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$0, opt+250
	jne	.LBB69_90
	.align	16, 0x90
.LBB69_91:                              # %do.end126.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	calll	checking_free
	movl	%ebp, (%esp)
	calll	read_whole_line
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB69_92
# BB#94:                                # %if.end138.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	calll	strlen
	testl	%eax, %eax
	je	.LBB69_105
# BB#95:                                # %if.end.i338.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$10, -1(%esi,%eax)
	jne	.LBB69_97
# BB#96:                                # %if.then2.i339.i
                                        #   in Loop: Header=BB69_60 Depth=2
	decl	%eax
	movb	$0, (%esi,%eax)
.LBB69_97:                              # %if.end4.i344.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$13, -1(%esi,%eax)
	jne	.LBB69_99
# BB#98:                                # %if.then10.i345.i
                                        #   in Loop: Header=BB69_60 Depth=2
	decl	%eax
	movb	$0, (%esi,%eax)
.LBB69_99:                              # %for.cond.preheader.i347.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, %ecx
	jmp	.LBB69_100
	.align	16, 0x90
.LBB69_103:                             # %for.inc.i352.i
                                        #   in Loop: Header=BB69_100 Depth=3
	incl	%ecx
.LBB69_100:                             # %for.cond.i349.i
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB69_104
# BB#101:                               # %for.cond.i349.i
                                        #   in Loop: Header=BB69_100 Depth=3
	cmpb	$9, %dl
	jne	.LBB69_103
# BB#102:                               # %if.then18.i350.i
                                        #   in Loop: Header=BB69_100 Depth=3
	movb	$32, (%ecx)
	jmp	.LBB69_103
.LBB69_104:                             # %clean_line.exit354.i
                                        #   in Loop: Header=BB69_60 Depth=2
	testl	%eax, %eax
	je	.LBB69_105
# BB#108:                               # %if.end150.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	movl	$.L.str53259, 4(%esp)
	calll	strtok
.LBB69_109:                             # %do.body153.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 72(%esp)          # 4-byte Spill
	cmpb	$0, opt+250
	jne	.LBB69_110
	.align	16, 0x90
.LBB69_111:                             # %do.end160.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str63269, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB69_60
# BB#112:                               # %do.body166.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$0, opt+250
	jne	.LBB69_113
	.align	16, 0x90
.LBB69_114:                             # %do.end173.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	$.L.str63269, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB69_139
# BB#115:                               #   in Loop: Header=BB69_60 Depth=2
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB69_116:                             # %for.cond187.i
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movl	%ebx, %edi
	cmpl	$11, %edi
	jg	.LBB69_118
# BB#117:                               # %for.body190.i
                                        #   in Loop: Header=BB69_116 Depth=3
	movl	ftp_parse_vms_ls.months(,%edi,4), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	leal	1(%edi), %ebx
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB69_116
.LBB69_118:                             # %for.end199.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	movl	%edi, %eax
	movl	$715827883, %ecx        # imm = 0x2AAAAAAB
	imull	%ecx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	%edx
	addl	%eax, %edx
	imull	$12, %edx, %eax
	subl	%eax, %edi
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_60
# BB#119:                               # %if.end204.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %esi
	cmpb	$0, opt+250
	jne	.LBB69_120
	.align	16, 0x90
.LBB69_121:                             # %do.end214.i
                                        #   in Loop: Header=BB69_60 Depth=2
	leal	-1900(%esi), %eax
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%esi, 64(%esp)          # 4-byte Spill
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB69_60
# BB#122:                               # %if.end219.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, 76(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB69_123:                             # %for.cond221.i
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%esi), %al
	xorl	%ebp, %ebp
	testb	%al, %al
	je	.LBB69_126
# BB#124:                               # %for.cond221.i
                                        #   in Loop: Header=BB69_123 Depth=3
	incl	%esi
	cmpb	$58, %al
	jne	.LBB69_123
# BB#125:                               # %if.then234.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %ebp
	.align	16, 0x90
.LBB69_126:                             # %for.cond238.preheader.i
                                        #   Parent Loop BB69_59 Depth=1
                                        #     Parent Loop BB69_60 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	incl	%esi
	movb	-1(%esi), %al
	xorl	%ebx, %ebx
	testb	%al, %al
	je	.LBB69_129
# BB#127:                               # %for.cond238.i
                                        #   in Loop: Header=BB69_126 Depth=3
	cmpb	$58, %al
	jne	.LBB69_126
# BB#128:                               # %if.then251.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtol
	movl	%eax, %ebx
.LBB69_129:                             # %do.body255.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$0, opt+250
	movl	68(%esp), %ecx          # 4-byte Reload
	movl	76(%esp), %eax          # 4-byte Reload
	jne	.LBB69_130
	.align	16, 0x90
.LBB69_131:                             # %do.end262.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%ebx, 128(%esp)
	movl	%ebp, 132(%esp)
	movl	%eax, 136(%esp)
	movl	%ecx, 140(%esp)
	movl	%edi, 144(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 148(%esp)
	movl	$0, 152(%esp)
	movl	$0, 156(%esp)
	movl	$-1, 160(%esp)
	leal	128(%esp), %eax
	movl	%eax, (%esp)
	calll	mktime
	movl	%eax, %esi
	cmpb	$0, opt+250
	jne	.LBB69_132
	.align	16, 0x90
.LBB69_133:                             # %do.end272.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	testl	%eax, %eax
	movl	48(%esp), %ebp          # 4-byte Reload
	je	.LBB69_60
# BB#134:                               # %if.end277.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str69275, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	testl	%eax, %eax
	je	.LBB69_60
# BB#135:                               # %if.end282.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str70276, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %edi
	testl	%edi, %edi
	jne	.LBB69_144
# BB#136:                               # %do.body287.i
                                        #   in Loop: Header=BB69_60 Depth=2
	cmpb	$0, opt+250
	je	.LBB69_138
# BB#137:                               # %if.then292.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str71277, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_138
.LBB69_82:                              # %if.then89.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 4(%esp)
	movl	$.L.str56262, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	sete	%al
	jmp	.LBB69_83
.LBB69_110:                             # %if.then158.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%eax, 4(%esp)
	movl	$.L.str62268, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_111
.LBB69_87:                              # %if.then110.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str58264, (%esp)
	calll	debug_logprintf
	xorl	%ecx, %ecx
	jmp	.LBB69_88
.LBB69_90:                              # %if.then124.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str59265, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_91
.LBB69_113:                             # %if.then171.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 4(%esp)
	movl	$.L.str64270, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_114
.LBB69_120:                             # %if.then212.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	$.L.str66272, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_121
.LBB69_130:                             # %if.then260.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%ebx, 24(%esp)
	movl	%ebp, 20(%esp)
	movl	%eax, 16(%esp)
	movl	%ecx, 12(%esp)
	movl	%edi, 8(%esp)
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str67273, (%esp)
	movl	%ecx, %esi
	calll	debug_logprintf
	movl	%esi, %ecx
	movl	76(%esp), %eax          # 4-byte Reload
	jmp	.LBB69_131
.LBB69_132:                             # %if.then269.i
                                        #   in Loop: Header=BB69_60 Depth=2
	movl	%esi, 4(%esp)
	movl	$.L.str68274, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_133
.LBB69_144:                             # %if.end295.i
                                        #   in Loop: Header=BB69_59 Depth=1
	leal	1(%edi), %ebp
	movb	(%edi), %al
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB69_145:                             # %do.body.i.i
                                        #   Parent Loop BB69_59 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movsbl	%al, %eax
	cmpl	$67, %eax
	jg	.LBB69_148
# BB#146:                               # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$44, %eax
	jne	.LBB69_155
# BB#147:                               # %sw.bb.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	shll	$3, %ebx
	jmp	.LBB69_157
.LBB69_148:                             # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$81, %eax
	jg	.LBB69_152
# BB#149:                               # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$68, %eax
	je	.LBB69_154
# BB#150:                               # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$69, %eax
	jne	.LBB69_155
# BB#151:                               # %sw.bb6.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	orl	$1, %ebx
	jmp	.LBB69_157
.LBB69_152:                             # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$82, %eax
	jne	.LBB69_153
# BB#169:                               # %sw.bb1.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	orl	$4, %ebx
	jmp	.LBB69_157
.LBB69_153:                             # %do.body.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpl	$87, %eax
	je	.LBB69_154
.LBB69_155:                             # %do.body8.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	cmpb	$0, opt+250
	je	.LBB69_157
# BB#156:                               # %if.then.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	movl	$.L.str73279, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_157
.LBB69_154:                             # %sw.bb4.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	orl	$2, %ebx
.LBB69_157:                             # %do.cond.i.i
                                        #   in Loop: Header=BB69_145 Depth=2
	movb	(%ebp), %al
	incl	%ebp
	testb	%al, %al
	jne	.LBB69_145
# BB#158:                               # %vmsperms.exit.i
                                        #   in Loop: Header=BB69_59 Depth=1
	cmpb	$0, opt+250
	je	.LBB69_160
# BB#159:                               # %if.then302.i
                                        #   in Loop: Header=BB69_59 Depth=1
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$.L.str72278, (%esp)
	calll	debug_logprintf
.LBB69_160:                             # %do.end305.i
                                        #   in Loop: Header=BB69_59 Depth=1
	movl	$36, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	cmpl	$0, 44(%esp)            # 4-byte Folded Reload
	movl	48(%esp), %ebp          # 4-byte Reload
	jne	.LBB69_162
# BB#161:                               # %if.then307.i
                                        #   in Loop: Header=BB69_59 Depth=1
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%edi)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%edi)
	movl	$0, 12(%edi)
	movl	$0, 8(%edi)
	movl	%esi, 16(%edi)
	movl	%ebx, 20(%edi)
	movl	$0, 24(%edi)
	movl	$0, 32(%edi)
	movl	$0, 28(%edi)
	movl	%edi, 44(%esp)          # 4-byte Spill
	jmp	.LBB69_163
.LBB69_162:                             # %if.else309.i
                                        #   in Loop: Header=BB69_59 Depth=1
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%edi, 32(%eax)
	movl	52(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%edi)
	movl	56(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%edi)
	movl	$0, 12(%edi)
	movl	$0, 8(%edi)
	movl	%esi, 16(%edi)
	movl	%ebx, 20(%edi)
	movl	$0, 24(%edi)
	movl	%eax, 28(%edi)
	movl	$0, 32(%edi)
	jmp	.LBB69_163
.LBB69_72:                              # %if.then20.i
	movl	%edi, (%esp)
	jmp	.LBB69_142
.LBB69_105:                             # %do.body142.i
	cmpb	$0, opt+250
	jne	.LBB69_106
	.align	16, 0x90
.LBB69_107:                             # %do.end149.i
	movl	%esi, (%esp)
	jmp	.LBB69_142
.LBB69_92:                              # %do.body130.i
	cmpb	$0, opt+250
	je	.LBB69_143
# BB#93:                                # %if.then135.i
	movl	$.L.str60266, (%esp)
	calll	debug_logprintf
	movl	%ebp, (%esp)
	jmp	.LBB69_50
.LBB69_139:                             # %do.body178.i
	cmpb	$0, opt+250
	jne	.LBB69_140
	.align	16, 0x90
.LBB69_141:                             # %do.end185.i
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
.LBB69_142:                             # %do.end185.i
	calll	checking_free
.LBB69_143:                             # %while.end.i
	movl	%ebp, (%esp)
.LBB69_50:                              # %while.end147.i
	calll	fclose
	movl	44(%esp), %eax          # 4-byte Reload
	jmp	.LBB69_168
.LBB69_106:                             # %if.then147.i
	movl	$.L.str61267, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_107
.LBB69_140:                             # %if.then183.i
	movl	$.L.str65271, (%esp)
	calll	debug_logprintf
	jmp	.LBB69_141
.Ltmp69:
	.size	ftp_parse_ls, .Ltmp69-ftp_parse_ls
	.section	.rodata,"a",@progbits
	.align	4
.LJTI69_0:
	.long	.LBB69_166
	.long	.LBB69_51
	.long	.LBB69_2
	.long	.LBB69_164

	.text
	.align	16, 0x90
	.type	ftp_parse_unix_ls,@function
ftp_parse_unix_ls:                      # @ftp_parse_unix_ls
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$140, %esp
	movl	%edx, 20(%esp)          # 4-byte Spill
	movl	%ecx, %esi
	movl	%esi, (%esp)
	movl	$.L.str207, 4(%esp)
	calll	fopen64
	movl	%eax, 24(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB70_136
# BB#1:                                 # %while.cond.preheader
	movl	$0, 32(%esp)            # 4-byte Folded Spill
	movl	$0, 36(%esp)            # 4-byte Folded Spill
                                        # implicit-def: EAX
	movl	%eax, 68(%esp)          # 4-byte Spill
                                        # implicit-def: EAX
	movl	%eax, 72(%esp)          # 4-byte Spill
	jmp	.LBB70_2
	.align	16, 0x90
.LBB70_12:                              # %if.then7
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	calll	checking_free
	.align	16, 0x90
.LBB70_2:                               # %while.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB70_40 Depth 2
                                        #       Child Loop BB70_64 Depth 3
                                        #       Child Loop BB70_73 Depth 3
                                        #       Child Loop BB70_67 Depth 3
                                        #       Child Loop BB70_43 Depth 3
                                        #     Child Loop BB70_9 Depth 2
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	read_whole_line
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB70_134
# BB#3:                                 # %while.body
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	calll	strlen
	xorl	%ecx, %ecx
	testl	%eax, %eax
	je	.LBB70_11
# BB#4:                                 # %if.end.i
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$10, -1(%esi,%eax)
	jne	.LBB70_6
# BB#5:                                 # %if.then2.i
                                        #   in Loop: Header=BB70_2 Depth=1
	decl	%eax
	movb	$0, (%esi,%eax)
.LBB70_6:                               # %if.end4.i
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$13, -1(%esi,%eax)
	jne	.LBB70_8
# BB#7:                                 # %if.then10.i
                                        #   in Loop: Header=BB70_2 Depth=1
	decl	%eax
	movb	$0, (%esi,%eax)
.LBB70_8:                               # %for.cond.preheader.i
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, %ecx
	jmp	.LBB70_9
	.align	16, 0x90
.LBB70_15:                              # %for.inc.i
                                        #   in Loop: Header=BB70_9 Depth=2
	incl	%ecx
.LBB70_9:                               # %for.cond.i
                                        #   Parent Loop BB70_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB70_10
# BB#13:                                # %for.cond.i
                                        #   in Loop: Header=BB70_9 Depth=2
	cmpb	$9, %dl
	jne	.LBB70_15
# BB#14:                                # %if.then18.i
                                        #   in Loop: Header=BB70_9 Depth=2
	movb	$32, (%ecx)
	jmp	.LBB70_15
.LBB70_10:                              #   in Loop: Header=BB70_2 Depth=1
	movl	%eax, %ecx
.LBB70_11:                              # %clean_line.exit
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, 28(%esp)          # 4-byte Spill
	movl	%esi, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str77283, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	je	.LBB70_12
# BB#16:                                # %if.end8
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	movl	$.L.str53259, 4(%esp)
	calll	strtok
	movl	%esi, %ecx
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB70_18
# BB#17:                                # %if.then11
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, (%esp)
	calll	checking_free
	jmp	.LBB70_2
.LBB70_18:                              # %if.end12
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, %ebx
	movsbl	(%esi), %eax
	cmpl	$108, %eax
	jne	.LBB70_19
# BB#25:                                # %sw.bb28
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$2, %eax
	cmpb	$0, opt+250
	je	.LBB70_29
# BB#26:                                # %if.then35
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str80286, (%esp)
	calll	debug_logprintf
	movl	$2, %eax
	jmp	.LBB70_29
.LBB70_19:                              # %if.end12
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$100, %eax
	jne	.LBB70_20
# BB#23:                                # %sw.bb18
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$1, %eax
	cmpb	$0, opt+250
	je	.LBB70_29
# BB#24:                                # %if.then25
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str79285, (%esp)
	calll	debug_logprintf
	movl	$1, %eax
	jmp	.LBB70_29
.LBB70_20:                              # %if.end12
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$45, %eax
	jne	.LBB70_27
# BB#21:                                # %sw.bb
                                        #   in Loop: Header=BB70_2 Depth=1
	xorl	%eax, %eax
	cmpb	$0, opt+250
	je	.LBB70_29
# BB#22:                                # %if.then16
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str78284, (%esp)
	calll	debug_logprintf
	xorl	%eax, %eax
	jmp	.LBB70_29
.LBB70_27:                              # %sw.default
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$3, %eax
	cmpb	$0, opt+250
	jne	.LBB70_28
	.align	16, 0x90
.LBB70_29:                              # %sw.epilog
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$0, 20(%esp)            # 4-byte Folded Reload
	jne	.LBB70_30
# BB#33:                                # %if.else
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%eax, 44(%esp)          # 4-byte Spill
	leal	1(%esi), %edi
	movl	%edi, (%esp)
	calll	strlen
	xorl	%ecx, %ecx
	cmpl	$9, %eax
	jb	.LBB70_35
# BB#34:                                # %for.cond.preheader.i576
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$114, 7(%esi)
	sete	%al
	movzbl	%al, %eax
	shll	$2, %eax
	cmpb	$119, 8(%esi)
	sete	%cl
	movzbl	%cl, %ecx
	addl	%ecx, %ecx
	orl	%eax, %ecx
	movb	9(%esi), %dl
	cmpb	$115, %dl
	sete	%al
	cmpb	$120, %dl
	sete	%dl
	orb	%al, %dl
	movzbl	%dl, %eax
	orl	%ecx, %eax
	cmpb	$114, (%edi)
	sete	%cl
	movzbl	%cl, %ecx
	shll	$2, %ecx
	cmpb	$119, 2(%esi)
	sete	%dl
	movzbl	%dl, %edi
	addl	%edi, %edi
	orl	%ecx, %edi
	movb	3(%esi), %dl
	movb	6(%esi), %cl
	cmpb	$115, %dl
	sete	%ch
	cmpb	$120, %dl
	sete	%dl
	orb	%ch, %dl
	movzbl	%dl, %edx
	orl	%edi, %edx
	shll	$3, %edx
	cmpb	$114, 4(%esi)
	sete	%ch
	movzbl	%ch, %edi
	shll	$2, %edi
	cmpb	$119, 5(%esi)
	sete	%ch
	movzbl	%ch, %esi
	addl	%esi, %esi
	orl	%edi, %esi
	orl	%edx, %esi
	cmpb	$115, %cl
	sete	%dl
	cmpb	$120, %cl
	sete	%cl
	orb	%dl, %cl
	movzbl	%cl, %ecx
	orl	%esi, %ecx
	shll	$3, %ecx
	orl	%eax, %ecx
.LBB70_35:                              # %symperms.exit
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, opt+250
	jne	.LBB70_37
# BB#36:                                #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, 40(%esp)          # 4-byte Spill
	jmp	.LBB70_39
.LBB70_30:                              # %if.then48
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$1, %eax
	movl	%eax, 44(%esp)          # 4-byte Spill
	movl	$420, %ecx              # imm = 0x1A4
	movl	$493, %eax              # imm = 0x1ED
	cmovel	%eax, %ecx
	cmpb	$0, opt+250
	jne	.LBB70_32
# BB#31:                                #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, 40(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB70_39:                              # %if.end76
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ebx, 48(%esp)          # 4-byte Spill
	movl	$-1, %edi
	movl	%ebx, %esi
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	$0, 64(%esp)            # 4-byte Folded Spill
	movl	$0, 60(%esp)            # 4-byte Folded Spill
	movl	$0, 80(%esp)            # 4-byte Folded Spill
	jmp	.LBB70_40
	.align	16, 0x90
.LBB70_77:                              # %if.then236
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str88294, (%esp)
	calll	debug_logprintf
	movl	$0, 80(%esp)            # 4-byte Folded Spill
	movl	%ebx, %edi
	.align	16, 0x90
.LBB70_40:                              # %while.cond77
                                        #   Parent Loop BB70_2 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB70_64 Depth 3
                                        #       Child Loop BB70_73 Depth 3
                                        #       Child Loop BB70_67 Depth 3
                                        #       Child Loop BB70_43 Depth 3
	movl	%esi, %ebx
	movl	$.L.str53259, 4(%esp)
	movl	$0, (%esp)
	calll	strtok
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB70_41
# BB#42:                                # %while.body81
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	%ebx, 52(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	movl	%edi, %eax
	decl	%eax
	movl	%eax, 56(%esp)          # 4-byte Spill
	jns	.LBB70_53
	.align	16, 0x90
.LBB70_43:                              # %for.cond
                                        #   Parent Loop BB70_2 Depth=1
                                        #     Parent Loop BB70_40 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movl	%ebp, %ebx
	cmpl	$11, %ebx
	jg	.LBB70_45
# BB#44:                                # %for.body
                                        #   in Loop: Header=BB70_43 Depth=3
	movl	ftp_parse_unix_ls.months(,%ebx,4), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	leal	1(%ebx), %ebp
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB70_43
.LBB70_45:                              # %for.end
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpl	$12, %ebx
	movl	56(%esp), %edi          # 4-byte Reload
	movl	52(%esp), %ebp          # 4-byte Reload
	je	.LBB70_40
# BB#46:                                # %if.then93
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpl	48(%esp), %ebp          # 4-byte Folded Reload
	je	.LBB70_41
# BB#47:                                # %if.end97
                                        #   in Loop: Header=BB70_40 Depth=2
	calll	__errno_location
	movl	%eax, %edi
	movl	$0, (%edi)
	movl	%ebp, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtoll
	movl	%edx, %ecx
	xorl	$2147483647, %ecx       # imm = 0x7FFFFFFF
	movl	%eax, %ebp
	notl	%ebp
	orl	%ecx, %ebp
	jne	.LBB70_49
# BB#48:                                # %land.lhs.true
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	$0, 72(%esp)            # 4-byte Folded Spill
	cmpl	$34, (%edi)
	movl	$0, 68(%esp)            # 4-byte Folded Spill
	je	.LBB70_50
.LBB70_49:                              # %if.else107
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	%edx, 68(%esp)          # 4-byte Spill
.LBB70_50:                              # %do.body110
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	$5, %edi
	cmpb	$0, opt+250
	movl	%ebx, 60(%esp)          # 4-byte Spill
	je	.LBB70_40
# BB#51:                                # %do.end119
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 4(%esp)
	movl	$.L.str84290, (%esp)
	calll	debug_logprintf
	movl	$5, %edi
	cmpb	$0, opt+250
	movl	%ebx, 60(%esp)          # 4-byte Spill
	je	.LBB70_40
# BB#52:                                # %if.then125
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	ftp_parse_unix_ls.months(,%ebx,4), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str85291, (%esp)
	calll	debug_logprintf
	movl	$5, %edi
	movl	%ebx, 60(%esp)          # 4-byte Spill
	jmp	.LBB70_40
.LBB70_53:                              # %if.else130
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpl	$3, %edi
	je	.LBB70_82
# BB#54:                                # %if.else130
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpl	$4, %edi
	movl	56(%esp), %ebx          # 4-byte Reload
	jne	.LBB70_55
# BB#61:                                # %if.then156
                                        #   in Loop: Header=BB70_40 Depth=2
	movzbl	(%esi), %ecx
	movl	$0, 80(%esp)            # 4-byte Folded Spill
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB70_62
# BB#63:                                # %for.cond163.preheader
                                        #   in Loop: Header=BB70_40 Depth=2
	movsbl	%cl, %eax
	movzbl	%al, %edx
	xorl	%ebp, %ebp
	testb	$4, _sch_istable(%edx,%edx)
                                        # kill: CL<def> CL<kill> ECX<kill>
	je	.LBB70_65
	.align	16, 0x90
.LBB70_64:                              # %for.body170
                                        #   Parent Loop BB70_2 Depth=1
                                        #     Parent Loop BB70_40 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	imull	$10, %ebp, %ecx
	leal	-48(%ecx,%eax), %ebp
	movb	1(%esi), %cl
	incl	%esi
	movsbl	%cl, %eax
	movzbl	%al, %edx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB70_64
.LBB70_65:                              # %for.end176
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpb	$58, %cl
	jne	.LBB70_78
# BB#66:                                # %for.cond182.preheader
                                        #   in Loop: Header=BB70_40 Depth=2
	leal	1(%esi), %eax
	movb	1(%esi), %cl
	movsbl	%cl, %edx
	movzbl	%dl, %edi
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	testb	$4, _sch_istable(%edi,%edi)
	movl	$0, %edi
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	je	.LBB70_69
	.align	16, 0x90
.LBB70_67:                              # %for.body189
                                        #   Parent Loop BB70_2 Depth=1
                                        #     Parent Loop BB70_40 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	imull	$10, %edi, %ecx
	leal	-48(%ecx,%edx), %edi
	movb	1(%eax), %cl
	incl	%eax
	movsbl	%cl, %edx
	movzbl	%dl, %esi
	testb	$4, _sch_istable(%esi,%esi)
	jne	.LBB70_67
# BB#68:                                # %for.end196.loopexit
                                        #   in Loop: Header=BB70_40 Depth=2
	leal	-1(%eax), %esi
	movl	%edi, 84(%esp)          # 4-byte Spill
.LBB70_69:                              # %for.end196
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpb	$58, %cl
	jne	.LBB70_70
# BB#71:                                # %if.then200
                                        #   in Loop: Header=BB70_40 Depth=2
	movsbl	2(%esi), %eax
	addl	$2, %esi
	movzbl	%al, %ecx
	xorl	%edx, %edx
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB70_72
	.align	16, 0x90
.LBB70_73:                              # %for.body209
                                        #   Parent Loop BB70_2 Depth=1
                                        #     Parent Loop BB70_40 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	imull	$10, %edx, %ecx
	leal	-48(%ecx,%eax), %edx
	movsbl	1(%esi), %eax
	incl	%esi
	movzbl	%al, %ecx
	testb	$4, _sch_istable(%ecx,%ecx)
	jne	.LBB70_73
# BB#74:                                #   in Loop: Header=BB70_40 Depth=2
	movl	%edx, 88(%esp)          # 4-byte Spill
	jmp	.LBB70_75
.LBB70_55:                              # %if.else130
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpl	$5, %edi
	jne	.LBB70_124
# BB#56:                                # %if.then133
                                        #   in Loop: Header=BB70_40 Depth=2
	movsbl	(%esi), %ecx
	addl	$-48, %ecx
	movsbl	1(%esi), %eax
	testl	%eax, %eax
	je	.LBB70_57
# BB#58:                                # %if.then136
                                        #   in Loop: Header=BB70_40 Depth=2
	imull	$10, %ecx, %ecx
	leal	-48(%eax,%ecx), %eax
	movl	%eax, 64(%esp)          # 4-byte Spill
	jmp	.LBB70_59
.LBB70_62:                              #   in Loop: Header=BB70_40 Depth=2
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	xorl	%ebp, %ebp
	jmp	.LBB70_75
.LBB70_78:                              # %if.end219
                                        #   in Loop: Header=BB70_40 Depth=2
	movb	opt+250, %al
	testl	%ebp, %ebp
	jne	.LBB70_79
# BB#81:                                # %do.body231
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	testb	%al, %al
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	$0, 80(%esp)            # 4-byte Folded Spill
	jmp	.LBB70_76
.LBB70_57:                              #   in Loop: Header=BB70_40 Depth=2
	movl	%ecx, 64(%esp)          # 4-byte Spill
.LBB70_59:                              # %do.body145
                                        #   in Loop: Header=BB70_40 Depth=2
	cmpb	$0, opt+250
	movl	%ebx, %edi
	je	.LBB70_40
# BB#60:                                # %if.then150
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str86292, (%esp)
	calll	debug_logprintf
	movl	%ebx, %edi
	jmp	.LBB70_40
.LBB70_70:                              #   in Loop: Header=BB70_40 Depth=2
	movl	%eax, %esi
	jmp	.LBB70_75
.LBB70_79:                              # %do.body222
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	testb	%al, %al
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	%ebp, 80(%esp)          # 4-byte Spill
	movl	%ebx, %edi
	je	.LBB70_40
# BB#80:                                # %if.then227
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	%ebp, 4(%esp)
	movl	$.L.str87293, (%esp)
	calll	debug_logprintf
	movl	$0, 88(%esp)            # 4-byte Folded Spill
	movl	$0, 84(%esp)            # 4-byte Folded Spill
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movl	%ebp, 80(%esp)          # 4-byte Spill
	movl	%ebx, %edi
	jmp	.LBB70_40
.LBB70_72:                              #   in Loop: Header=BB70_40 Depth=2
	movl	$0, 88(%esp)            # 4-byte Folded Spill
.LBB70_75:                              # %if.end219.thread
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	%ebp, 76(%esp)          # 4-byte Spill
	cmpb	$0, opt+250
.LBB70_76:                              # %if.end219.thread
                                        #   in Loop: Header=BB70_40 Depth=2
	movl	%ebx, %edi
	je	.LBB70_40
	jmp	.LBB70_77
.LBB70_82:                              # %if.then243
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	movl	28(%esp), %edi          # 4-byte Reload
	addl	48(%esp), %edi          # 4-byte Folded Reload
	subl	%esi, %edi
	calll	strlen
	xorl	%ebp, %ebp
	cmpl	%edi, %eax
	jge	.LBB70_88
# BB#83:                                # %if.then248
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	$32, (%esi,%eax)
	xorl	%ebp, %ebp
	cmpl	$2, 44(%esp)            # 4-byte Folded Reload
	jne	.LBB70_88
# BB#84:                                # %if.then253
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	movl	$.L.str89295, 4(%esp)
	calll	strstr
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB70_41
# BB#85:                                # %if.end257
                                        #   in Loop: Header=BB70_2 Depth=1
	leal	4(%edi), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, %ebp
	cmpb	$0, opt+250
	jne	.LBB70_86
	.align	16, 0x90
.LBB70_87:                              # %do.end269
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	$0, (%edi)
.LBB70_88:                              # %cond.true
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$46, (%esi)
	jne	.LBB70_95
# BB#89:                                # %cond.end
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, 1(%esi)
	je	.LBB70_92
# BB#90:                                # %if.then333
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$46, 1(%esi)
	jne	.LBB70_95
# BB#91:                                # %cond.end363
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, 2(%esi)
	jne	.LBB70_95
.LBB70_92:                              # %do.body367
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, opt+250
	jne	.LBB70_94
# BB#93:                                #   in Loop: Header=BB70_2 Depth=1
	xorb	%cl, %cl
	xorl	%ebx, %ebx
	movl	$1, %edi
	jmp	.LBB70_104
.LBB70_95:                              # %if.end375
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	leal	1(%edi), %ebx
	movl	%ebx, (%esp)
	calll	checking_malloc
	movl	%ebx, 8(%esp)
	movl	%eax, %ebx
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	movl	$1, %esi
	testl	%edi, %edi
	movl	44(%esp), %eax          # 4-byte Reload
	je	.LBB70_118
# BB#96:                                # %if.then383
                                        #   in Loop: Header=BB70_2 Depth=1
	xorl	%esi, %esi
	testl	%eax, %eax
	jne	.LBB70_97
# BB#120:                               # %land.lhs.true433
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	40(%esp), %ecx          # 4-byte Reload
	testb	$73, %cl
	je	.LBB70_118
# BB#121:                               # %land.lhs.true437
                                        #   in Loop: Header=BB70_2 Depth=1
	xorl	%esi, %esi
	cmpb	$42, -1(%edi,%ebx)
	jne	.LBB70_118
# BB#122:                               # %if.then444
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	$0, -1(%ebx,%edi)
	xorl	%esi, %esi
	cmpb	$0, opt+250
	je	.LBB70_118
# BB#123:                               # %if.then453
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str96300, (%esp)
	jmp	.LBB70_117
.LBB70_41:                              #   in Loop: Header=BB70_2 Depth=1
	xorb	%cl, %cl
	xorl	%edi, %edi
	movl	%edi, %ebx
	xorl	%ebp, %ebp
	jmp	.LBB70_104
.LBB70_97:                              # %if.then383
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$2, %eax
	jne	.LBB70_98
# BB#114:                               # %land.lhs.true410
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$64, -1(%edi,%ebx)
	jne	.LBB70_102
# BB#115:                               # %if.then417
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	$0, -1(%ebx,%edi)
	xorl	%esi, %esi
	cmpb	$0, opt+250
	je	.LBB70_118
# BB#116:                               # %if.then426
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str95299, (%esp)
.LBB70_117:                             # %if.then426
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%eax, %esi
	calll	debug_logprintf
	movl	%esi, %eax
	xorl	%esi, %esi
	jmp	.LBB70_118
.LBB70_98:                              # %if.then383
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpl	$1, %eax
	jne	.LBB70_118
# BB#99:                                # %land.lhs.true387
                                        #   in Loop: Header=BB70_2 Depth=1
	xorl	%esi, %esi
	cmpb	$47, -1(%edi,%ebx)
	jne	.LBB70_118
# BB#100:                               # %if.then394
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	$0, -1(%ebx,%edi)
	xorl	%esi, %esi
	cmpb	$0, opt+250
	je	.LBB70_102
# BB#101:                               # %if.then403
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str94298, (%esp)
	movl	%eax, %esi
	calll	debug_logprintf
	movl	%esi, %eax
	xorl	%esi, %esi
	jmp	.LBB70_102
.LBB70_118:                             # %while.end
                                        #   in Loop: Header=BB70_2 Depth=1
	testl	%ebx, %ebx
	je	.LBB70_119
.LBB70_102:                             # %lor.lhs.false467
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%eax, 44(%esp)          # 4-byte Spill
	xorl	%edi, %edi
	movb	$1, %cl
	cmpl	$2, %eax
	jne	.LBB70_105
# BB#103:                               # %lor.lhs.false467
                                        #   in Loop: Header=BB70_2 Depth=1
	testl	%ebp, %ebp
	jne	.LBB70_105
	jmp	.LBB70_104
.LBB70_119:                             #   in Loop: Header=BB70_2 Depth=1
	movl	%eax, 44(%esp)          # 4-byte Spill
	xorb	%cl, %cl
	xorl	%edi, %edi
	movl	%edi, %ebx
	.align	16, 0x90
.LBB70_104:                             # %if.then474
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$1, %esi
.LBB70_105:                             # %do.body476
                                        #   in Loop: Header=BB70_2 Depth=1
	movb	%cl, 56(%esp)           # 1-byte Spill
	cmpb	$0, opt+250
	jne	.LBB70_106
	.align	16, 0x90
.LBB70_107:                             # %do.end490
                                        #   in Loop: Header=BB70_2 Depth=1
	orl	%edi, %esi
	movl	80(%esp), %edi          # 4-byte Reload
	je	.LBB70_125
# BB#108:                               # %do.body495
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, opt+250
	jne	.LBB70_109
	.align	16, 0x90
.LBB70_110:                             # %do.end502
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$1, 56(%esp)            # 1-byte Folded Reload
	movl	48(%esp), %esi          # 4-byte Reload
	jne	.LBB70_112
# BB#111:                               # %if.else506
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ebx, (%esp)
	calll	checking_free
.LBB70_112:                             # %if.end508
                                        #   in Loop: Header=BB70_2 Depth=1
	testl	%ebp, %ebp
	je	.LBB70_12
# BB#113:                               # %if.else512
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ebp, (%esp)
	calll	checking_free
	jmp	.LBB70_12
.LBB70_106:                             # %if.then481
                                        #   in Loop: Header=BB70_2 Depth=1
	cmpb	$0, 56(%esp)            # 1-byte Folded Reload
	movl	$.L.str6213, %eax
	cmovnel	%ebx, %eax
	movl	%eax, 4(%esp)
	movl	$.L.str97301, (%esp)
	calll	debug_logprintf
	jmp	.LBB70_107
.LBB70_109:                             # %if.then500
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str98302, (%esp)
	calll	debug_logprintf
	jmp	.LBB70_110
.LBB70_37:                              # %if.then72
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, 4(%esp)
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	$.L.str83289, (%esp)
	jmp	.LBB70_38
.LBB70_32:                              # %if.then61
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ecx, 4(%esp)
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	$.L.str82288, (%esp)
.LBB70_38:                              # %if.then72
                                        #   in Loop: Header=BB70_2 Depth=1
	calll	debug_logprintf
	jmp	.LBB70_39
.LBB70_125:                             # %if.end515
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$36, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	cmpl	$0, 36(%esp)            # 4-byte Folded Reload
	jne	.LBB70_127
# BB#126:                               # %if.then517
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esi)
	movl	%ebx, 4(%esi)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esi)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esi)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 20(%esi)
	movl	%ebp, 24(%esi)
	movl	$0, 32(%esi)
	movl	$0, 28(%esi)
	movl	%esi, 36(%esp)          # 4-byte Spill
	jmp	.LBB70_128
.LBB70_94:                              # %if.then372
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str93297, (%esp)
	calll	debug_logprintf
	xorl	%ebx, %ebx
	movl	$1, %edi
	xorb	%cl, %cl
	jmp	.LBB70_104
.LBB70_127:                             # %if.else520
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	32(%esp), %ecx          # 4-byte Reload
	movl	%esi, 32(%ecx)
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esi)
	movl	%ebx, 4(%esi)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esi)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esi)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 20(%esi)
	movl	%ebp, 24(%esi)
	movl	%ecx, 28(%esi)
	movl	$0, 32(%esi)
.LBB70_128:                             # %if.end526
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$0, (%esp)
	calll	time
	movl	%eax, 92(%esp)
	leal	92(%esp), %eax
	movl	%eax, (%esp)
	calll	localtime
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 96(%esp)
	movl	84(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 100(%esp)
	movl	76(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 104(%esp)
	movl	64(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 108(%esp)
	movl	60(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 112(%esp)
	testl	%edi, %edi
	jne	.LBB70_131
# BB#129:                               # %if.then531
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	20(%eax), %edi
	cmpl	16(%eax), %ecx
	jle	.LBB70_131
# BB#130:                               # %if.then535
                                        #   in Loop: Header=BB70_2 Depth=1
	decl	%edi
.LBB70_131:                             # %if.else542
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%edi, 116(%esp)
	cmpl	$1900, %edi             # imm = 0x76C
	jl	.LBB70_133
# BB#132:                               # %if.then548
                                        #   in Loop: Header=BB70_2 Depth=1
	addl	$-1900, %edi            # imm = 0xFFFFFFFFFFFFF894
	movl	%edi, 116(%esp)
.LBB70_133:                             # %if.end551
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$0, 120(%esp)
	movl	$0, 124(%esp)
	movl	$-1, 128(%esp)
	leal	96(%esp), %eax
	movl	%eax, (%esp)
	calll	mktime
	movl	%eax, 16(%esi)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	%esi, 32(%esp)          # 4-byte Spill
	jmp	.LBB70_2
.LBB70_28:                              # %if.then44
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	$.L.str81287, (%esp)
	calll	debug_logprintf
	movl	$3, %eax
	jmp	.LBB70_29
.LBB70_86:                              # %if.then266
                                        #   in Loop: Header=BB70_2 Depth=1
	movl	%ebp, 4(%esp)
	movl	$.L.str90296, (%esp)
	calll	debug_logprintf
	jmp	.LBB70_87
.LBB70_134:                             # %while.end553
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	movl	36(%esp), %eax          # 4-byte Reload
	jmp	.LBB70_135
.LBB70_136:                             # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str1208, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
.LBB70_135:                             # %return
	addl	$140, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB70_124:                             # %if.else461
	calll	abort
.Ltmp70:
	.size	ftp_parse_unix_ls, .Ltmp70-ftp_parse_unix_ls

	.globl	ftp_index
	.align	16, 0x90
	.type	ftp_index,@function
ftp_index:                              # @ftp_index
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	output_stream, %esi
	testl	%esi, %esi
	jne	.LBB71_3
# BB#1:                                 # %if.then
	movl	48(%esp), %edi
	movl	%edi, (%esp)
	movl	$.L.str3210, 4(%esp)
	calll	fopen64
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB71_2
.LBB71_3:                               # %if.end5
	movl	56(%esp), %edi
	movl	52(%esp), %ebp
	movl	40(%ebp), %eax
	testl	%eax, %eax
	je	.LBB71_9
# BB#4:                                 # %if.then7
	movl	%eax, (%esp)
	calll	url_escape
	movl	%eax, %ebx
	movl	44(%ebp), %eax
	testl	%eax, %eax
	je	.LBB71_7
# BB#5:                                 # %cond.end
	movl	%eax, (%esp)
	calll	url_escape
	movl	%eax, %ebp
	testl	%ebp, %ebp
	je	.LBB71_7
# BB#6:                                 # %if.end18.thread
	movl	%ebp, 8(%esp)
	movl	%ebx, (%esp)
	movl	$0, 16(%esp)
	movl	$.L.str5212, 12(%esp)
	movl	$.L.str4211, 4(%esp)
	calll	concat_strings
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	%ebx, (%esp)
	calll	checking_free
	movl	%ebp, (%esp)
	jmp	.LBB71_8
.LBB71_7:                               # %if.end18
	movl	%ebx, (%esp)
	movl	$0, 8(%esp)
	movl	$.L.str5212, 4(%esp)
	calll	concat_strings
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	%ebx, (%esp)
.LBB71_8:                               # %if.end18
	calll	checking_free
	movl	52(%esp), %ebp
	jmp	.LBB71_10
.LBB71_9:                               # %if.else23
	movl	$.L.str6213, (%esp)
	calll	checking_strdup
	movl	%eax, 20(%esp)          # 4-byte Spill
.LBB71_10:                              # %if.end25
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$51, 4(%esp)
	movl	$.L.str7214, (%esp)
	calll	fwrite
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$21, 4(%esp)
	movl	$.L.str8215, (%esp)
	calll	fwrite
	movl	$5, 8(%esp)
	movl	$.L.str9216, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	32(%ebp), %ecx
	movl	8(%ebp), %edx
	movl	12(%ebp), %ebx
	movl	%ebx, 16(%esp)
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$28, 4(%esp)
	movl	$.L.str10217, (%esp)
	calll	fwrite
	movl	$5, 8(%esp)
	movl	$.L.str9216, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	32(%ebp), %ecx
	movl	8(%ebp), %edx
	movl	12(%ebp), %ebx
	movl	%ebx, 16(%esp)
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$17, 4(%esp)
	movl	$.L.str11218, (%esp)
	calll	fwrite
	testl	%edi, %edi
	je	.LBB71_38
	.align	16, 0x90
.LBB71_11:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$2, 4(%esp)
	movl	$.L.str12219, (%esp)
	calll	fwrite
	movl	16(%edi), %eax
	cmpl	$-1, %eax
	jne	.LBB71_12
# BB#15:                                # %if.else51
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str28235, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	jmp	.LBB71_16
.LBB71_12:                              # %if.then39
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%eax, 24(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	localtime
	movl	%eax, %ebx
	movl	20(%ebx), %eax
	movl	$1900, %ecx             # imm = 0x76C
	addl	%ecx, %eax
	movl	12(%ebx), %ecx
	movl	16(%ebx), %edx
	movl	%ecx, 16(%esp)
	movl	ftp_parse_unix_ls.months(,%edx,4), %ecx
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str25232, 4(%esp)
	calll	fprintf
	movl	8(%ebx), %eax
	testl	%eax, %eax
	jne	.LBB71_13
# BB#14:                                # %if.else48
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$7, 4(%esp)
	movl	$.L.str27234, (%esp)
	calll	fwrite
	jmp	.LBB71_17
.LBB71_13:                              # %if.then45
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	4(%ebx), %ecx
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str26233, 4(%esp)
.LBB71_16:                              # %if.else51
                                        #   in Loop: Header=BB71_11 Depth=1
	calll	fprintf
.LBB71_17:                              # %if.end54
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	(%edi), %eax
	cmpl	$2, %eax
	jne	.LBB71_18
# BB#22:                                # %sw.bb60
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str31238, 4(%esp)
	jmp	.LBB71_24
.LBB71_18:                              # %if.end54
                                        #   in Loop: Header=BB71_11 Depth=1
	cmpl	$1, %eax
	jne	.LBB71_19
# BB#21:                                # %sw.bb57
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str30237, 4(%esp)
	jmp	.LBB71_24
.LBB71_19:                              # %if.end54
                                        #   in Loop: Header=BB71_11 Depth=1
	testl	%eax, %eax
	jne	.LBB71_23
# BB#20:                                # %sw.bb
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str29236, 4(%esp)
	jmp	.LBB71_24
.LBB71_23:                              # %sw.default
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str32239, 4(%esp)
.LBB71_24:                              # %sw.default
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	4(%edi), %eax
	movl	%eax, (%esp)
	calll	html_quote_string
	movl	%eax, %ebx
	movl	8(%ebp), %eax
	movl	12(%ebp), %ecx
	movl	%ecx, 16(%esp)
	movl	%eax, 12(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str33240, 4(%esp)
	calll	fprintf
	movl	32(%ebp), %eax
	cmpb	$47, (%eax)
	je	.LBB71_26
# BB#25:                                # %if.then72
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	$47, (%esp)
	calll	_IO_putc
	movl	32(%ebp), %eax
.LBB71_26:                              # %if.end74
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	movl	32(%ebp), %eax
	cmpb	$0, (%eax)
	je	.LBB71_28
# BB#27:                                # %if.then79
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	$47, (%esp)
	calll	_IO_putc
.LBB71_28:                              # %if.end81
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	fputs
	cmpl	$1, (%edi)
	jne	.LBB71_30
# BB#29:                                # %if.then86
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	$47, (%esp)
	calll	_IO_putc
.LBB71_30:                              # %if.end88
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str35241, 4(%esp)
	calll	fprintf
	cmpl	$1, (%edi)
	jne	.LBB71_32
# BB#31:                                # %if.then93
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	$47, (%esp)
	calll	_IO_putc
.LBB71_32:                              # %if.end95
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$5, 4(%esp)
	movl	$.L.str36242, (%esp)
	calll	fwrite
	movl	(%edi), %eax
	cmpl	$2, %eax
	jne	.LBB71_33
# BB#35:                                # %if.then108
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	24(%edi), %eax
	testl	%eax, %eax
	movl	$.L.str39245, %ecx
	cmovel	%ecx, %eax
	movl	%eax, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str38244, 4(%esp)
	jmp	.LBB71_36
.LBB71_33:                              # %if.end95
                                        #   in Loop: Header=BB71_11 Depth=1
	testl	%eax, %eax
	jne	.LBB71_37
# BB#34:                                # %if.then100
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str37243, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %ebp
	movl	8(%edi), %eax
	movl	12(%edi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
.LBB71_36:                              # %if.then108
                                        #   in Loop: Header=BB71_11 Depth=1
	calll	fprintf
.LBB71_37:                              # %if.end117
                                        #   in Loop: Header=BB71_11 Depth=1
	movl	%esi, 4(%esp)
	movl	$10, (%esp)
	calll	_IO_putc
	movl	%ebx, (%esp)
	calll	checking_free
	movl	32(%edi), %edi
	testl	%edi, %edi
	movl	52(%esp), %ebp
	jne	.LBB71_11
.LBB71_38:                              # %while.end
	movl	%esi, 12(%esp)
	movl	$1, 8(%esp)
	movl	$23, 4(%esp)
	movl	$.L.str40246, (%esp)
	calll	fwrite
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	cmpl	$0, output_stream
	je	.LBB71_39
# BB#40:                                # %if.else123
	movl	%esi, (%esp)
	calll	fflush
	jmp	.LBB71_41
.LBB71_39:                              # %if.then121
	movl	%esi, (%esp)
	calll	fclose
.LBB71_41:                              # %if.else123
	movl	$10, %eax
	.align	16, 0x90
.LBB71_42:                              # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB71_2:                               # %if.then2
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	$.L.str1208, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$24, %eax
	jmp	.LBB71_42
.Ltmp71:
	.size	ftp_index, .Ltmp71-ftp_index

	.globl	skey_response
	.align	16, 0x90
	.type	skey_response,@function
skey_response:                          # @skey_response
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$76, %esp
	calll	gen_md5_context_size
	addl	$15, %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	gen_md5_init
	addl	$16, %esp
	subl	$16, %esp
	movl	12(%ebp), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	16(%ebp), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	leal	-48(%ebp), %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_finish
	addl	$16, %esp
	movl	-40(%ebp), %eax
	xorl	%eax, -48(%ebp)
	movl	-44(%ebp), %ecx
	xorl	-36(%ebp), %ecx
	movl	%ecx, -44(%ebp)
	movl	-48(%ebp), %edx
	movl	%ecx, -28(%ebp)
	movl	%edx, -32(%ebp)
	movl	8(%ebp), %edi
	jmp	.LBB72_2
	.align	16, 0x90
.LBB72_1:                               # %while.body
                                        #   in Loop: Header=BB72_2 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	gen_md5_init
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	leal	-32(%ebp), %eax
	movl	%eax, (%esp)
	movl	$8, 4(%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_finish
	addl	$16, %esp
	movl	-40(%ebp), %eax
	xorl	%eax, -48(%ebp)
	movl	-44(%ebp), %ecx
	xorl	-36(%ebp), %ecx
	movl	%ecx, -44(%ebp)
	movl	-48(%ebp), %edx
	movl	%ecx, -28(%ebp)
	movl	%edx, -32(%ebp)
	decl	%edi
.LBB72_2:                               # %while.body
                                        # =>This Inner Loop Header: Depth=1
	testl	%edi, %edi
	jg	.LBB72_1
# BB#3:                                 # %while.end
	movl	%edx, -76(%ebp)         # 4-byte Spill
	movl	%ecx, -64(%ebp)         # 4-byte Spill
	movb	$0, skey_response.english
	movl	$0, -20(%ebp)
	movl	$0, -24(%ebp)
	movw	$0, -16(%ebp)
	movl	%edx, -24(%ebp)
	movl	%ecx, -20(%ebp)
	movl	%ecx, %eax
	shldl	$8, %edx, %eax
	movl	%eax, -72(%ebp)         # 4-byte Spill
	movl	%ecx, %eax
	shldl	$16, %edx, %eax
	movl	%eax, -80(%ebp)         # 4-byte Spill
	movl	%ecx, %eax
	shldl	$24, %edx, %eax
	movl	%eax, -84(%ebp)         # 4-byte Spill
	movl	%ecx, %eax
	shrl	$24, %eax
	movl	%eax, -52(%ebp)         # 4-byte Spill
	movl	%ecx, %eax
	shrl	$16, %eax
	movl	%eax, -60(%ebp)         # 4-byte Spill
	shrl	$8, %ecx
	movl	%ecx, -68(%ebp)         # 4-byte Spill
	xorl	%edi, %edi
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB72_4:                               # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ecx
	sarl	$31, %ecx
	shrl	$29, %ecx
	addl	%edi, %ecx
	movl	%ecx, %eax
	sarl	$3, %eax
	movzbl	-23(%ebp,%eax), %esi
	movzbl	-24(%ebp,%eax), %edx
	shll	$8, %edx
	orl	%esi, %edx
	shll	$8, %edx
	movzbl	-22(%ebp,%eax), %eax
	orl	%edx, %eax
	andl	$248, %ecx
	movl	%edi, %edx
	subl	%ecx, %edx
	movl	$22, %ecx
	subl	%edx, %ecx
                                        # kill: CL<def> CL<kill> ECX<kill>
	shrl	%cl, %eax
	andl	$3, %eax
	addl	%eax, %ebx
	addl	$2, %edi
	cmpl	$64, %edi
	jl	.LBB72_4
# BB#5:                                 # %for.end.i
	shll	$6, %ebx
	movl	%ebx, -56(%ebp)         # 4-byte Spill
	movb	%bl, -16(%ebp)
	movl	-76(%ebp), %ecx         # 4-byte Reload
	shll	$8, %ecx
	movl	-84(%ebp), %eax         # 4-byte Reload
	movzbl	%al, %eax
	orl	%eax, %ecx
	shrl	$3, %ecx
	andl	$8188, %ecx             # imm = 0x1FFC
	movl	Wp(%ecx), %ecx
	movl	%ecx, skey_response.english
	movl	$1, %edx
	testb	$-1, %ch
	movl	%edx, %esi
	je	.LBB72_8
# BB#6:                                 # %cond.false.i
	movl	$2, %esi
	testl	$16711680, %ecx         # imm = 0xFF0000
	je	.LBB72_8
# BB#7:                                 # %cond.false13.i
	cmpl	$16777215, %ecx         # imm = 0xFFFFFF
	seta	%cl
	movzbl	%cl, %esi
	addl	$3, %esi
.LBB72_8:                               # %cond.end17.i
	movb	$32, skey_response.english(%esi)
	shll	$8, %eax
	movl	-80(%ebp), %ecx         # 4-byte Reload
	movzbl	%cl, %edi
	orl	%edi, %eax
	andl	$8188, %eax             # imm = 0x1FFC
	movl	Wp(%eax), %eax
	movl	%eax, skey_response.english+1(%esi)
	cmpb	$0, skey_response.english+2(%esi)
	je	.LBB72_11
# BB#9:                                 # %cond.false26.i
	movl	$2, %edx
	cmpb	$0, skey_response.english+3(%esi)
	je	.LBB72_11
# BB#10:                                # %cond.false30.i
	cmpb	$1, skey_response.english+4(%esi)
	movl	$3, %edx
	sbbl	$-1, %edx
.LBB72_11:                              # %cond.end37.i
	incl	%esi
	movb	$32, skey_response.english(%edx,%esi)
	shll	$8, %edi
	movl	-72(%ebp), %eax         # 4-byte Reload
	movzbl	%al, %eax
	orl	%edi, %eax
	shll	$8, %eax
	movl	-64(%ebp), %ecx         # 4-byte Reload
	movzbl	%cl, %ebx
	orl	%ebx, %eax
	shrl	$5, %eax
	andl	$8188, %eax             # imm = 0x1FFC
	movl	Wp(%eax), %eax
	movl	%eax, skey_response.english+1(%edx,%esi)
	movl	$1, %eax
	cmpb	$0, skey_response.english+2(%edx,%esi)
	movl	$1, %edi
	je	.LBB72_14
# BB#12:                                # %cond.false48.i
	leal	(%edx,%esi), %ecx
	movl	$2, %edi
	cmpb	$0, skey_response.english+3(%ecx)
	je	.LBB72_14
# BB#13:                                # %cond.false52.i
	cmpb	$1, skey_response.english+4(%ecx)
	movl	$3, %edi
	sbbl	$-1, %edi
.LBB72_14:                              # %cond.end59.i
	leal	1(%edx,%esi), %esi
	movb	$32, skey_response.english(%edi,%esi)
	shll	$8, %ebx
	movl	-68(%ebp), %ecx         # 4-byte Reload
	movzbl	%cl, %ecx
	orl	%ecx, %ebx
	shrl	$2, %ebx
	andl	$8188, %ebx             # imm = 0x1FFC
	movl	Wp(%ebx), %edx
	movl	%edx, skey_response.english+1(%edi,%esi)
	cmpb	$0, skey_response.english+2(%edi,%esi)
	je	.LBB72_17
# BB#15:                                # %cond.false70.i
	leal	(%edi,%esi), %edx
	movl	$2, %eax
	cmpb	$0, skey_response.english+3(%edx)
	je	.LBB72_17
# BB#16:                                # %cond.false74.i
	cmpb	$1, skey_response.english+4(%edx)
	movl	$3, %eax
	sbbl	$-1, %eax
.LBB72_17:                              # %cond.end81.i
	leal	1(%edi,%esi), %ebx
	movb	$32, skey_response.english(%eax,%ebx)
	shll	$8, %ecx
	movl	-60(%ebp), %edx         # 4-byte Reload
	movzbl	%dl, %esi
	orl	%esi, %ecx
	andl	$4094, %ecx             # imm = 0xFFE
	movl	Wp(%ecx,%ecx), %ecx
	movl	%ecx, skey_response.english+1(%eax,%ebx)
	leal	(%eax,%ebx), %ecx
	movl	$1, %edi
	cmpb	$0, skey_response.english+2(%eax,%ebx)
	je	.LBB72_20
# BB#18:                                # %cond.false92.i
	movl	$2, %edi
	cmpb	$0, skey_response.english+3(%ecx)
	je	.LBB72_20
# BB#19:                                # %cond.false96.i
	cmpb	$1, skey_response.english+4(%ecx)
	movl	$3, %edi
	sbbl	$-1, %edi
.LBB72_20:                              # %cond.end103.i
	movb	$32, skey_response.english+1(%ecx,%edi)
	shll	$8, %esi
	addl	-52(%ebp), %esi         # 4-byte Folded Reload
	shll	$8, %esi
	movl	-56(%ebp), %eax         # 4-byte Reload
	andl	$192, %eax
	orl	%esi, %eax
	shrl	$4, %eax
	andl	$8188, %eax             # imm = 0x1FFC
	movl	Wp(%eax), %eax
	movl	%eax, skey_response.english+2(%ecx,%edi)
	movb	$0, skey_response.english+6(%ecx,%edi)
	cmpb	$0, opt+250
	jne	.LBB72_21
	.align	16, 0x90
.LBB72_22:                              # %btoe.exit
	movl	$skey_response.english, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB72_21:                              # %if.then.i
	subl	$16, %esp
	movl	$skey_response.english, 4(%esp)
	movl	$.L.str307, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB72_22
.Ltmp72:
	.size	skey_response, .Ltmp72-skey_response

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI73_0:
	.quad	4604930618986332160     # double 7.500000e-01
                                        #  (0x0)
.LCPI73_1:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
	.text
	.globl	hash_table_new
	.align	16, 0x90
	.type	hash_table_new,@function
hash_table_new:                         # @hash_table_new
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	$28, (%esp)
	movl	36(%esp), %eax
	testl	%eax, %eax
	movl	$hash_pointer, %edi
	cmovnel	%eax, %edi
	calll	checking_malloc
	movl	%eax, %esi
	movl	%edi, (%esi)
	movl	40(%esp), %eax
	testl	%eax, %eax
	movl	$cmp_pointer, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 4(%esi)
	movl	$0, 24(%esi)
	cvtsi2sd	32(%esp), %xmm0
	divsd	.LCPI73_0, %xmm0
	addsd	.LCPI73_1, %xmm0
	cvttsd2si	%xmm0, %ecx
	xorl	%eax, %eax
	.align	16, 0x90
.LBB73_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$70, %eax
	ja	.LBB73_4
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB73_1 Depth=1
	movl	prime_size.primes(,%eax,4), %edi
	incl	%eax
	cmpl	%ecx, %edi
	jl	.LBB73_1
# BB#3:                                 # %prime_size.exit
	movl	%eax, 24(%esi)
	movl	%edi, 12(%esi)
	xorps	%xmm0, %xmm0
	cvtsi2sd	%edi, %xmm0
	mulsd	.LCPI73_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 20(%esi)
	shll	$3, %edi
	movl	%edi, (%esp)
	calll	checking_malloc
	movl	%eax, 8(%esi)
	movl	%edi, 8(%esp)
	movl	%eax, (%esp)
	movl	$255, 4(%esp)
	calll	memset
	movl	$0, 16(%esi)
	movl	%esi, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.LBB73_4:                               # %for.end.i
	calll	abort
.Ltmp73:
	.size	hash_table_new, .Ltmp73-hash_table_new

	.globl	hash_pointer
	.align	16, 0x90
	.type	hash_pointer,@function
hash_pointer:                           # @hash_pointer
# BB#0:                                 # %entry
	imull	$4097, 4(%esp), %eax    # imm = 0x1001
	movl	%eax, %ecx
	shrl	$22, %ecx
	xorl	%eax, %ecx
	imull	$17, %ecx, %eax
	movl	%eax, %ecx
	shrl	$9, %ecx
	xorl	%eax, %ecx
	imull	$1025, %ecx, %eax       # imm = 0x401
	movl	%eax, %ecx
	shrl	$2, %ecx
	xorl	%eax, %ecx
	imull	$129, %ecx, %ecx
	movl	%ecx, %eax
	shrl	$12, %eax
	xorl	%ecx, %eax
	ret
.Ltmp74:
	.size	hash_pointer, .Ltmp74-hash_pointer

	.align	16, 0x90
	.type	cmp_pointer,@function
cmp_pointer:                            # @cmp_pointer
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	cmpl	8(%esp), %eax
	sete	%al
	movzbl	%al, %eax
	ret
.Ltmp75:
	.size	cmp_pointer, .Ltmp75-cmp_pointer

	.globl	hash_table_destroy
	.align	16, 0x90
	.type	hash_table_destroy,@function
hash_table_destroy:                     # @hash_table_destroy
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	16(%esp), %eax
	movl	8(%eax), %eax
	movl	%eax, (%esp)
	calll	checking_free
	addl	$12, %esp
	jmp	checking_free           # TAILCALL
.Ltmp76:
	.size	hash_table_destroy, .Ltmp76-hash_table_destroy

	.globl	hash_table_get
	.align	16, 0x90
	.type	hash_table_get,@function
hash_table_get:                         # @hash_table_get
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %ebx
	movl	8(%ebx), %edi
	movl	12(%ebx), %esi
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%ebx)
	xorl	%edx, %edx
	divl	%esi
	leal	(%edi,%edx,8), %ebp
	leal	-8(%edi,%esi,8), %esi
	movl	4(%ebx), %ebx
	jmp	.LBB77_1
	.align	16, 0x90
.LBB77_4:                               # %for.inc.i
                                        #   in Loop: Header=BB77_1 Depth=1
	cmpl	%esi, %ebp
	leal	8(%ebp), %ebp
	cmovel	%edi, %ebp
.LBB77_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%ebp), %eax
	cmpl	$-1, %eax
	je	.LBB77_2
# BB#3:                                 # %for.body.i
                                        #   in Loop: Header=BB77_1 Depth=1
	movl	%eax, 4(%esp)
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*%ebx
	testl	%eax, %eax
	je	.LBB77_4
# BB#5:                                 # %find_cell.exit
	xorl	%eax, %eax
	cmpl	$-1, (%ebp)
	je	.LBB77_7
# BB#6:                                 # %if.then
	movl	4(%ebp), %eax
	jmp	.LBB77_7
.LBB77_2:
	xorl	%eax, %eax
.LBB77_7:                               # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp77:
	.size	hash_table_get, .Ltmp77-hash_table_get

	.globl	hash_table_get_pair
	.align	16, 0x90
	.type	hash_table_get_pair,@function
hash_table_get_pair:                    # @hash_table_get_pair
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %ebx
	movl	8(%ebx), %ebp
	movl	12(%ebx), %esi
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%ebx)
	xorl	%edx, %edx
	divl	%esi
	leal	(%ebp,%edx,8), %edi
	leal	-8(%ebp,%esi,8), %esi
	movl	4(%ebx), %ebx
	jmp	.LBB78_1
	.align	16, 0x90
.LBB78_4:                               # %for.inc.i
                                        #   in Loop: Header=BB78_1 Depth=1
	cmpl	%esi, %edi
	leal	8(%edi), %edi
	cmovel	%ebp, %edi
.LBB78_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%edi), %eax
	cmpl	$-1, %eax
	je	.LBB78_2
# BB#3:                                 # %for.body.i
                                        #   in Loop: Header=BB78_1 Depth=1
	movl	%eax, 4(%esp)
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*%ebx
	testl	%eax, %eax
	je	.LBB78_4
# BB#5:                                 # %find_cell.exit
	movl	(%edi), %ecx
	xorl	%eax, %eax
	cmpl	$-1, %ecx
	movl	44(%esp), %edx
	je	.LBB78_10
# BB#6:                                 # %if.then
	movl	40(%esp), %eax
	testl	%eax, %eax
	je	.LBB78_8
# BB#7:                                 # %if.then1
	movl	%ecx, (%eax)
.LBB78_8:                               # %if.end
	movl	$1, %eax
	testl	%edx, %edx
	je	.LBB78_10
# BB#9:                                 # %if.then4
	movl	4(%edi), %eax
	movl	%eax, (%edx)
	movl	$1, %eax
	jmp	.LBB78_10
.LBB78_2:
	xorl	%eax, %eax
.LBB78_10:                              # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp78:
	.size	hash_table_get_pair, .Ltmp78-hash_table_get_pair

	.globl	hash_table_contains
	.align	16, 0x90
	.type	hash_table_contains,@function
hash_table_contains:                    # @hash_table_contains
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %edi
	movl	8(%edi), %esi
	movl	12(%edi), %ebp
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%edi)
	xorl	%edx, %edx
	divl	%ebp
	leal	(%esi,%edx,8), %ebx
	leal	-8(%esi,%ebp,8), %ebp
	movl	4(%edi), %edi
	jmp	.LBB79_1
	.align	16, 0x90
.LBB79_5:                               # %for.inc.i
                                        #   in Loop: Header=BB79_1 Depth=1
	cmpl	%ebp, %ebx
	leal	8(%ebx), %ebx
	cmovel	%esi, %ebx
.LBB79_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%ebx), %ecx
	movl	$-1, %eax
	cmpl	$-1, %ecx
	je	.LBB79_4
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB79_1 Depth=1
	movl	%ecx, 4(%esp)
	movl	36(%esp), %eax
	movl	%eax, (%esp)
	calll	*%edi
	testl	%eax, %eax
	je	.LBB79_5
# BB#3:                                 # %for.body.i.find_cell.exit_crit_edge
	movl	(%ebx), %eax
.LBB79_4:                               # %find_cell.exit
	cmpl	$-1, %eax
	setne	%al
	movzbl	%al, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp79:
	.size	hash_table_contains, .Ltmp79-hash_table_contains

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI80_0:
	.quad	4604930618986332160     # double 7.500000e-01
                                        #  (0x0)
	.text
	.globl	hash_table_put
	.align	16, 0x90
	.type	hash_table_put,@function
hash_table_put:                         # @hash_table_put
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %ebp
	movl	8(%ebp), %edi
	movl	12(%ebp), %ebx
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%ebp)
	xorl	%edx, %edx
	divl	%ebx
	leal	(%edi,%edx,8), %esi
	leal	-8(%edi,%ebx,8), %ebx
	movl	4(%ebp), %ebp
	jmp	.LBB80_1
	.align	16, 0x90
.LBB80_3:                               # %for.inc.i
                                        #   in Loop: Header=BB80_1 Depth=1
	leal	8(%esi), %eax
	cmpl	%ebx, %esi
	cmovel	%edi, %eax
	movl	%eax, %esi
.LBB80_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%esi), %eax
	cmpl	$-1, %eax
	je	.LBB80_5
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB80_1 Depth=1
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*%ebp
	testl	%eax, %eax
	je	.LBB80_3
# BB#4:                                 # %find_cell.exit
	cmpl	$-1, (%esi)
	jne	.LBB80_22
.LBB80_5:                               # %if.end
	movl	48(%esp), %ecx
	movl	16(%ecx), %eax
	cmpl	20(%ecx), %eax
	jl	.LBB80_21
# BB#6:                                 # %if.then5
	movl	12(%ecx), %esi
	movl	%esi, 12(%esp)          # 4-byte Spill
	movl	(%ecx), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	8(%ecx), %eax
	movl	%eax, 16(%esp)          # 4-byte Spill
	leal	(%eax,%esi,8), %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	24(%ecx), %eax
	movl	%ecx, %edx
	leal	(%esi,%esi), %ecx
	.align	16, 0x90
.LBB80_7:                               # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$70, %eax
	ja	.LBB80_23
# BB#8:                                 # %for.body.i.i
                                        #   in Loop: Header=BB80_7 Depth=1
	movl	prime_size.primes(,%eax,4), %ebx
	incl	%eax
	cmpl	%ecx, %ebx
	jl	.LBB80_7
# BB#9:                                 # %prime_size.exit.i
	movl	%edx, %edi
	movl	%eax, 24(%edi)
	movl	%ebx, 12(%edi)
	cvtsi2sd	%ebx, %xmm0
	mulsd	.LCPI80_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 20(%edi)
	leal	(,%ebx,8), %ebp
	movl	%ebp, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	%ebp, 8(%esp)
	movl	%esi, (%esp)
	movl	$255, 4(%esp)
	calll	memset
	movl	%esi, 8(%edi)
	cmpl	$0, 12(%esp)            # 4-byte Folded Reload
	jle	.LBB80_16
# BB#10:                                # %for.body.lr.ph.i
	leal	-8(%esi,%ebx,8), %ebp
	movl	16(%esp), %edi          # 4-byte Reload
	.align	16, 0x90
.LBB80_11:                              # %for.body.i14
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB80_13 Depth 2
	movl	(%edi), %eax
	cmpl	$-1, %eax
	je	.LBB80_15
# BB#12:                                # %if.then.i
                                        #   in Loop: Header=BB80_11 Depth=1
	movl	%eax, (%esp)
	calll	*24(%esp)               # 4-byte Folded Reload
	xorl	%edx, %edx
	divl	%ebx
	leal	(%esi,%edx,8), %eax
	cmpl	$-1, (%esi,%edx,8)
	je	.LBB80_14
	.align	16, 0x90
.LBB80_13:                              # %for.inc.i17
                                        #   Parent Loop BB80_11 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	%ebp, %eax
	leal	8(%eax), %eax
	cmovel	%esi, %eax
	cmpl	$-1, (%eax)
	jne	.LBB80_13
.LBB80_14:                              # %for.end.i
                                        #   in Loop: Header=BB80_11 Depth=1
	movsd	(%edi), %xmm0
	movsd	%xmm0, (%eax)
.LBB80_15:                              # %for.inc26.i
                                        #   in Loop: Header=BB80_11 Depth=1
	addl	$8, %edi
	cmpl	20(%esp), %edi          # 4-byte Folded Reload
	jb	.LBB80_11
.LBB80_16:                              # %grow_hash_table.exit
	movl	16(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	48(%esp), %ebp
	movl	8(%ebp), %edi
	movl	12(%ebp), %ebx
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%ebp)
	xorl	%edx, %edx
	divl	%ebx
	leal	(%edi,%edx,8), %esi
	leal	-8(%edi,%ebx,8), %ebx
	movl	4(%ebp), %ebp
	jmp	.LBB80_17
	.align	16, 0x90
.LBB80_19:                              # %for.inc.i38
                                        #   in Loop: Header=BB80_17 Depth=1
	leal	8(%esi), %eax
	cmpl	%ebx, %esi
	cmovel	%edi, %eax
	movl	%eax, %esi
.LBB80_17:                              # %for.cond.i31
                                        # =>This Inner Loop Header: Depth=1
	movl	(%esi), %eax
	cmpl	$-1, %eax
	je	.LBB80_20
# BB#18:                                # %for.body.i34
                                        #   in Loop: Header=BB80_17 Depth=1
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*%ebp
	testl	%eax, %eax
	je	.LBB80_19
.LBB80_20:                              # %if.end7.loopexit
	movl	48(%esp), %ecx
	movl	16(%ecx), %eax
.LBB80_21:                              # %if.end7
	incl	%eax
	movl	%eax, 16(%ecx)
.LBB80_22:                              # %if.end7
	movl	52(%esp), %eax
	movl	%eax, (%esi)
	movl	56(%esp), %eax
	movl	%eax, 4(%esi)
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB80_23:                              # %for.end.i.i
	calll	abort
.Ltmp80:
	.size	hash_table_put, .Ltmp80-hash_table_put

	.globl	hash_table_remove
	.align	16, 0x90
	.type	hash_table_remove,@function
hash_table_remove:                      # @hash_table_remove
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %ebp
	movl	8(%ebp), %ebx
	movl	12(%ebp), %edi
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*(%ebp)
	xorl	%edx, %edx
	divl	%edi
	leal	(%ebx,%edx,8), %esi
	leal	-8(%ebx,%edi,8), %edi
	movl	4(%ebp), %ebp
	jmp	.LBB81_1
	.align	16, 0x90
.LBB81_4:                               # %for.inc.i
                                        #   in Loop: Header=BB81_1 Depth=1
	cmpl	%edi, %esi
	leal	8(%esi), %esi
	cmovel	%ebx, %esi
.LBB81_1:                               # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%esi), %eax
	cmpl	$-1, %eax
	je	.LBB81_2
# BB#3:                                 # %for.body.i
                                        #   in Loop: Header=BB81_1 Depth=1
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax
	movl	%eax, (%esp)
	calll	*%ebp
	testl	%eax, %eax
	je	.LBB81_4
# BB#5:                                 # %find_cell.exit
	xorl	%eax, %eax
	cmpl	$-1, (%esi)
	je	.LBB81_14
# BB#6:                                 # %if.else
	movl	48(%esp), %ecx
	movl	(%ecx), %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	8(%ecx), %ebx
	movl	12(%ecx), %eax
	movl	%eax, 16(%esp)          # 4-byte Spill
	movl	$-1, (%esi)
	decl	16(%ecx)
	leal	-8(%ebx,%eax,8), %edi
	leal	8(%esi), %ebp
	cmpl	%edi, %esi
	cmovel	%ebx, %ebp
	movl	(%ebp), %esi
	movl	$1, %eax
	cmpl	$-1, %esi
	je	.LBB81_14
# BB#7:
	movl	%ebp, %ecx
	.align	16, 0x90
.LBB81_8:                               # %for.body
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB81_9 Depth 2
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	%esi, (%esp)
	calll	*20(%esp)               # 4-byte Folded Reload
	xorl	%edx, %edx
	divl	16(%esp)                # 4-byte Folded Reload
	leal	(%ebx,%edx,8), %eax
	movl	24(%esp), %edx          # 4-byte Reload
	jmp	.LBB81_9
	.align	16, 0x90
.LBB81_11:                              # %for.inc
                                        #   in Loop: Header=BB81_9 Depth=2
	leal	8(%eax), %ecx
	cmpl	%edi, %eax
	cmovel	%ebx, %ecx
	movl	%ecx, %eax
.LBB81_9:                               # %for.cond12
                                        #   Parent Loop BB81_8 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	(%eax), %ecx
	cmpl	$-1, %ecx
	je	.LBB81_12
# BB#10:                                # %for.body15
                                        #   in Loop: Header=BB81_9 Depth=2
	cmpl	%ecx, %esi
	je	.LBB81_13
	jmp	.LBB81_11
.LBB81_12:                              # %for.end
                                        #   in Loop: Header=BB81_8 Depth=1
	movsd	(%edx), %xmm0
	movsd	%xmm0, (%eax)
	movl	$-1, (%ebp)
.LBB81_13:                              # %for.inc28
                                        #   in Loop: Header=BB81_8 Depth=1
	cmpl	%edi, %edx
	leal	8(%edx), %ebp
	cmovel	%ebx, %ebp
	movl	(%ebp), %esi
	movl	$1, %eax
	cmpl	$-1, %esi
	movl	%ebp, %ecx
	jne	.LBB81_8
	jmp	.LBB81_14
.LBB81_2:
	xorl	%eax, %eax
.LBB81_14:                              # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp81:
	.size	hash_table_remove, .Ltmp81-hash_table_remove

	.globl	hash_table_clear
	.align	16, 0x90
	.type	hash_table_clear,@function
hash_table_clear:                       # @hash_table_clear
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	32(%esp), %esi
	movl	8(%esi), %eax
	movl	12(%esi), %ecx
	shll	$3, %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, (%esp)
	movl	$255, 4(%esp)
	calll	memset
	movl	$0, 16(%esi)
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp82:
	.size	hash_table_clear, .Ltmp82-hash_table_clear

	.globl	hash_table_for_each
	.align	16, 0x90
	.type	hash_table_for_each,@function
hash_table_for_each:                    # @hash_table_for_each
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %eax
	movl	8(%eax), %esi
	movl	12(%eax), %eax
	leal	(%esi,%eax,8), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	56(%esp), %ebx
	movl	52(%esp), %ebp
	jmp	.LBB83_1
	.align	16, 0x90
.LBB83_6:                               # %for.inc
                                        #   in Loop: Header=BB83_1 Depth=1
	addl	$8, %esi
.LBB83_1:                               # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB83_3 Depth 2
	cmpl	24(%esp), %esi          # 4-byte Folded Reload
	jae	.LBB83_7
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB83_1 Depth=1
	movl	(%esi), %edi
	cmpl	$-1, %edi
	je	.LBB83_6
	.align	16, 0x90
.LBB83_3:                               # %repeat
                                        #   Parent Loop BB83_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	4(%esi), %eax
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	*%ebp
	testl	%eax, %eax
	jne	.LBB83_7
# BB#4:                                 # %if.end
                                        #   in Loop: Header=BB83_3 Depth=2
	movl	(%esi), %eax
	cmpl	%edi, %eax
	je	.LBB83_6
# BB#5:                                 # %if.end
                                        #   in Loop: Header=BB83_3 Depth=2
	cmpl	$-1, %eax
	movl	%eax, %edi
	jne	.LBB83_3
	jmp	.LBB83_6
.LBB83_7:                               # %for.end
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp83:
	.size	hash_table_for_each, .Ltmp83-hash_table_for_each

	.globl	hash_table_iterate
	.align	16, 0x90
	.type	hash_table_iterate,@function
hash_table_iterate:                     # @hash_table_iterate
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movl	8(%eax), %edx
	movl	8(%esp), %ecx
	movl	%edx, 8(%ecx)
	movl	12(%eax), %edx
	shll	$3, %edx
	addl	8(%eax), %edx
	movl	%edx, 12(%ecx)
	ret
.Ltmp84:
	.size	hash_table_iterate, .Ltmp84-hash_table_iterate

	.globl	hash_table_iter_next
	.align	16, 0x90
	.type	hash_table_iter_next,@function
hash_table_iter_next:                   # @hash_table_iter_next
# BB#0:                                 # %entry
	pushl	%esi
	movl	8(%esp), %ecx
	movl	8(%ecx), %edx
	movl	12(%ecx), %esi
	.align	16, 0x90
.LBB85_1:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	xorl	%eax, %eax
	cmpl	%esi, %edx
	jae	.LBB85_4
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB85_1 Depth=1
	movl	(%edx), %eax
	addl	$8, %edx
	cmpl	$-1, %eax
	je	.LBB85_1
# BB#3:                                 # %if.then
	movl	%eax, (%ecx)
	movl	-4(%edx), %eax
	movl	%eax, 4(%ecx)
	movl	%edx, 8(%ecx)
	movl	$1, %eax
.LBB85_4:                               # %return
	popl	%esi
	ret
.Ltmp85:
	.size	hash_table_iter_next, .Ltmp85-hash_table_iter_next

	.globl	hash_table_count
	.align	16, 0x90
	.type	hash_table_count,@function
hash_table_count:                       # @hash_table_count
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movl	16(%eax), %eax
	ret
.Ltmp86:
	.size	hash_table_count, .Ltmp86-hash_table_count

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI87_0:
	.quad	4604930618986332160     # double 7.500000e-01
                                        #  (0x0)
.LCPI87_1:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
	.text
	.globl	make_string_hash_table
	.align	16, 0x90
	.type	make_string_hash_table,@function
make_string_hash_table:                 # @make_string_hash_table
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	$28, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	$hash_string, (%esi)
	movl	$cmp_string, 4(%esi)
	movl	$0, 24(%esi)
	cvtsi2sd	32(%esp), %xmm0
	divsd	.LCPI87_0, %xmm0
	addsd	.LCPI87_1, %xmm0
	cvttsd2si	%xmm0, %ecx
	xorl	%eax, %eax
	.align	16, 0x90
.LBB87_1:                               # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$70, %eax
	ja	.LBB87_4
# BB#2:                                 # %for.body.i.i
                                        #   in Loop: Header=BB87_1 Depth=1
	movl	prime_size.primes(,%eax,4), %edi
	incl	%eax
	cmpl	%ecx, %edi
	jl	.LBB87_1
# BB#3:                                 # %hash_table_new.exit
	movl	%eax, 24(%esi)
	movl	%edi, 12(%esi)
	xorps	%xmm0, %xmm0
	cvtsi2sd	%edi, %xmm0
	mulsd	.LCPI87_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 20(%esi)
	shll	$3, %edi
	movl	%edi, (%esp)
	calll	checking_malloc
	movl	%eax, 8(%esi)
	movl	%edi, 8(%esp)
	movl	%eax, (%esp)
	movl	$255, 4(%esp)
	calll	memset
	movl	$0, 16(%esi)
	movl	%esi, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.LBB87_4:                               # %for.end.i.i
	calll	abort
.Ltmp87:
	.size	make_string_hash_table, .Ltmp87-make_string_hash_table

	.align	16, 0x90
	.type	hash_string,@function
hash_string:                            # @hash_string
# BB#0:                                 # %entry
	pushl	%esi
	movl	8(%esp), %ecx
	movsbl	(%ecx), %eax
	testl	%eax, %eax
	je	.LBB88_4
# BB#1:                                 # %for.cond.preheader
	movb	1(%ecx), %dl
	testb	%dl, %dl
	je	.LBB88_4
# BB#2:                                 # %for.body.preheader
	addl	$2, %ecx
	.align	16, 0x90
.LBB88_3:                               # %for.body
                                        # =>This Inner Loop Header: Depth=1
	imull	$31, %eax, %esi
	movsbl	%dl, %eax
	addl	%esi, %eax
	movb	(%ecx), %dl
	incl	%ecx
	testb	%dl, %dl
	jne	.LBB88_3
.LBB88_4:                               # %if.end
	popl	%esi
	ret
.Ltmp88:
	.size	hash_string, .Ltmp88-hash_string

	.align	16, 0x90
	.type	cmp_string,@function
cmp_string:                             # @cmp_string
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	strcmp
	testl	%eax, %eax
	sete	%al
	movzbl	%al, %eax
	addl	$12, %esp
	ret
.Ltmp89:
	.size	cmp_string, .Ltmp89-cmp_string

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI90_0:
	.quad	4604930618986332160     # double 7.500000e-01
                                        #  (0x0)
.LCPI90_1:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
	.text
	.globl	make_nocase_string_hash_table
	.align	16, 0x90
	.type	make_nocase_string_hash_table,@function
make_nocase_string_hash_table:          # @make_nocase_string_hash_table
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	$28, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	$hash_string_nocase, (%esi)
	movl	$string_cmp_nocase, 4(%esi)
	movl	$0, 24(%esi)
	cvtsi2sd	32(%esp), %xmm0
	divsd	.LCPI90_0, %xmm0
	addsd	.LCPI90_1, %xmm0
	cvttsd2si	%xmm0, %ecx
	xorl	%eax, %eax
	.align	16, 0x90
.LBB90_1:                               # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$70, %eax
	ja	.LBB90_4
# BB#2:                                 # %for.body.i.i
                                        #   in Loop: Header=BB90_1 Depth=1
	movl	prime_size.primes(,%eax,4), %edi
	incl	%eax
	cmpl	%ecx, %edi
	jl	.LBB90_1
# BB#3:                                 # %hash_table_new.exit
	movl	%eax, 24(%esi)
	movl	%edi, 12(%esi)
	xorps	%xmm0, %xmm0
	cvtsi2sd	%edi, %xmm0
	mulsd	.LCPI90_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 20(%esi)
	shll	$3, %edi
	movl	%edi, (%esp)
	calll	checking_malloc
	movl	%eax, 8(%esi)
	movl	%edi, 8(%esp)
	movl	%eax, (%esp)
	movl	$255, 4(%esp)
	calll	memset
	movl	$0, 16(%esi)
	movl	%esi, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.LBB90_4:                               # %for.end.i.i
	calll	abort
.Ltmp90:
	.size	make_nocase_string_hash_table, .Ltmp90-make_nocase_string_hash_table

	.align	16, 0x90
	.type	hash_string_nocase,@function
hash_string_nocase:                     # @hash_string_nocase
# BB#0:                                 # %entry
	pushl	%esi
	movl	8(%esp), %ecx
	movzbl	(%ecx), %eax
	movzbl	_sch_tolower(%eax), %eax
	testl	%eax, %eax
	je	.LBB91_4
# BB#1:                                 # %for.cond.preheader
	movb	1(%ecx), %dl
	testb	%dl, %dl
	je	.LBB91_4
# BB#2:                                 # %for.body.preheader
	addl	$2, %ecx
	.align	16, 0x90
.LBB91_3:                               # %for.body
                                        # =>This Inner Loop Header: Depth=1
	imull	$31, %eax, %esi
	movzbl	%dl, %eax
	movzbl	_sch_tolower(%eax), %eax
	addl	%esi, %eax
	movb	(%ecx), %dl
	incl	%ecx
	testb	%dl, %dl
	jne	.LBB91_3
.LBB91_4:                               # %if.end
	popl	%esi
	ret
.Ltmp91:
	.size	hash_string_nocase, .Ltmp91-hash_string_nocase

	.align	16, 0x90
	.type	string_cmp_nocase,@function
string_cmp_nocase:                      # @string_cmp_nocase
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	strcasecmp
	testl	%eax, %eax
	sete	%al
	movzbl	%al, %eax
	addl	$12, %esp
	ret
.Ltmp92:
	.size	string_cmp_nocase, .Ltmp92-string_cmp_nocase

	.globl	address_list_get_bounds
	.align	16, 0x90
	.type	address_list_get_bounds,@function
address_list_get_bounds:                # @address_list_get_bounds
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movl	8(%eax), %ecx
	movl	8(%esp), %edx
	movl	%ecx, (%edx)
	movl	(%eax), %eax
	movl	12(%esp), %ecx
	movl	%eax, (%ecx)
	ret
.Ltmp93:
	.size	address_list_get_bounds, .Ltmp93-address_list_get_bounds

	.globl	address_list_address_at
	.align	16, 0x90
	.type	address_list_address_at,@function
address_list_address_at:                # @address_list_address_at
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	36(%esp), %eax
	movl	32(%esp), %ecx
	cmpl	%eax, 8(%ecx)
	jg	.LBB94_3
# BB#1:                                 # %land.lhs.true
	cmpl	%eax, (%ecx)
	jle	.LBB94_3
# BB#2:                                 # %cond.end
	imull	$24, %eax, %eax
	addl	4(%ecx), %eax
	addl	$28, %esp
	ret
.LBB94_3:                               # %cond.false
	movl	$.L__PRETTY_FUNCTION__.address_list_address_at, 12(%esp)
	movl	$92, 8(%esp)
	movl	$.L.str1338, 4(%esp)
	movl	$.L.str337, (%esp)
	calll	__assert_fail
.Ltmp94:
	.size	address_list_address_at, .Ltmp94-address_list_address_at

	.globl	address_list_contains
	.align	16, 0x90
	.type	address_list_contains,@function
address_list_contains:                  # @address_list_contains
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	36(%esp), %eax
	movl	(%eax), %ecx
	movl	32(%esp), %edx
	cmpl	$10, %ecx
	jne	.LBB95_1
# BB#6:                                 # %for.cond8.preheader
	movl	(%edx), %ecx
	movl	%ecx, 8(%esp)           # 4-byte Spill
	movl	$20, %edi
	movl	$-1, %esi
	.align	16, 0x90
.LBB95_7:                               # %for.cond8
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ebx
	incl	%esi
	xorb	%cl, %cl
	cmpl	8(%esp), %esi           # 4-byte Folded Reload
	jge	.LBB95_14
# BB#8:                                 # %for.body11
                                        #   in Loop: Header=BB95_7 Depth=1
	leal	24(%ebx), %edi
	movl	4(%edx), %ebp
	cmpl	$10, -20(%ebp,%ebx)
	jne	.LBB95_7
# BB#9:                                 # %land.lhs.true17
                                        #   in Loop: Header=BB95_7 Depth=1
	movl	(%ebp,%ebx), %ecx
	cmpl	20(%eax), %ecx
	jne	.LBB95_7
# BB#10:                                # %land.lhs.true20
                                        #   in Loop: Header=BB95_7 Depth=1
	movl	-16(%ebp,%ebx), %ecx
	cmpl	4(%eax), %ecx
	jne	.LBB95_7
# BB#11:                                # %land.lhs.true28
                                        #   in Loop: Header=BB95_7 Depth=1
	movl	-12(%ebp,%ebx), %ecx
	cmpl	8(%eax), %ecx
	jne	.LBB95_7
# BB#12:                                # %land.lhs.true36
                                        #   in Loop: Header=BB95_7 Depth=1
	movl	-8(%ebp,%ebx), %ecx
	cmpl	12(%eax), %ecx
	jne	.LBB95_7
# BB#13:                                # %land.rhs
                                        #   in Loop: Header=BB95_7 Depth=1
	movl	-4(%ebp,%ebx), %ebx
	movb	$1, %cl
	cmpl	16(%eax), %ebx
	jne	.LBB95_7
	jmp	.LBB95_14
.LBB95_1:                               # %entry
	cmpl	$2, %ecx
	jne	.LBB95_15
# BB#2:                                 # %for.cond.preheader
	movl	%edx, %ecx
	movl	(%ecx), %edx
	movl	%ecx, %ebp
	movl	$4, %edi
	movl	$-1, %esi
	.align	16, 0x90
.LBB95_3:                               # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ebx
	incl	%esi
	xorb	%cl, %cl
	cmpl	%edx, %esi
	jge	.LBB95_14
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB95_3 Depth=1
	leal	24(%ebx), %edi
	movl	4(%ebp), %ecx
	cmpl	$2, -4(%ecx,%ebx)
	jne	.LBB95_3
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB95_3 Depth=1
	movl	(%ecx,%ebx), %ebx
	movb	$1, %cl
	cmpl	4(%eax), %ebx
	jne	.LBB95_3
.LBB95_14:                              # %return
	movzbl	%cl, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB95_15:                              # %sw.default
	calll	abort
.Ltmp95:
	.size	address_list_contains, .Ltmp95-address_list_contains

	.globl	address_list_set_faulty
	.align	16, 0x90
	.type	address_list_set_faulty,@function
address_list_set_faulty:                # @address_list_set_faulty
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	36(%esp), %ecx
	movl	32(%esp), %eax
	cmpl	%ecx, 8(%eax)
	jne	.LBB96_4
# BB#1:                                 # %cond.end
	incl	%ecx
	movl	%ecx, 8(%eax)
	cmpl	(%eax), %ecx
	jl	.LBB96_3
# BB#2:                                 # %if.then
	movl	$0, 8(%eax)
.LBB96_3:                               # %if.end
	addl	$28, %esp
	ret
.LBB96_4:                               # %cond.false
	movl	$.L__PRETTY_FUNCTION__.address_list_set_faulty, 12(%esp)
	movl	$141, 8(%esp)
	movl	$.L.str1338, 4(%esp)
	movl	$.L.str2339, (%esp)
	calll	__assert_fail
.Ltmp96:
	.size	address_list_set_faulty, .Ltmp96-address_list_set_faulty

	.globl	address_list_set_connected
	.align	16, 0x90
	.type	address_list_set_connected,@function
address_list_set_connected:             # @address_list_set_connected
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movb	$1, 12(%eax)
	ret
.Ltmp97:
	.size	address_list_set_connected, .Ltmp97-address_list_set_connected

	.globl	address_list_connected_p
	.align	16, 0x90
	.type	address_list_connected_p,@function
address_list_connected_p:               # @address_list_connected_p
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movzbl	12(%eax), %eax
	ret
.Ltmp98:
	.size	address_list_connected_p, .Ltmp98-address_list_connected_p

	.globl	address_list_release
	.align	16, 0x90
	.type	address_list_release,@function
address_list_release:                   # @address_list_release
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	32(%esp), %esi
	movl	16(%esi), %eax
	decl	%eax
	movl	%eax, 16(%esi)
	cmpb	$0, opt+250
	jne	.LBB99_1
	.align	16, 0x90
.LBB99_2:                               # %do.end
	testl	%eax, %eax
	jle	.LBB99_3
# BB#6:                                 # %if.end14
	addl	$24, %esp
	popl	%esi
	ret
.LBB99_3:                               # %do.body6
	cmpb	$0, opt+250
	jne	.LBB99_4
	.align	16, 0x90
.LBB99_5:                               # %do.end13
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	addl	$24, %esp
	popl	%esi
	jmp	checking_free           # TAILCALL
.LBB99_1:                               # %if.then
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$8, 4(%esp)
	movl	$.L.str3340, (%esp)
	calll	debug_logprintf
	movl	16(%esi), %eax
	jmp	.LBB99_2
.LBB99_4:                               # %if.then11
	movl	%esi, 8(%esp)
	movl	$8, 4(%esp)
	movl	$.L.str4341, (%esp)
	calll	debug_logprintf
	jmp	.LBB99_5
.Ltmp99:
	.size	address_list_release, .Ltmp99-address_list_release

	.globl	print_address
	.align	16, 0x90
	.type	print_address,@function
print_address:                          # @print_address
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %ecx
	movl	(%ecx), %eax
	addl	$4, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$64, 12(%esp)
	movl	$print_address.buf, 8(%esp)
	calll	inet_ntop
	testl	%eax, %eax
	jne	.LBB100_2
# BB#1:                                 # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	$.L.str5342, 8(%esp)
	movl	$64, 4(%esp)
	movl	$print_address.buf, (%esp)
	calll	snprintf
.LBB100_2:                              # %if.end
	movl	$print_address.buf, %eax
	addl	$28, %esp
	ret
.Ltmp100:
	.size	print_address, .Ltmp100-print_address

	.globl	is_valid_ipv6_address
	.align	16, 0x90
	.type	is_valid_ipv6_address,@function
is_valid_ipv6_address:                  # @is_valid_ipv6_address
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	xorb	%bl, %bl
	movl	32(%esp), %ebp
	cmpl	36(%esp), %ebp
	je	.LBB101_30
# BB#1:                                 # %if.end
	movl	$0, 8(%esp)             # 4-byte Folded Spill
	cmpb	$58, (%ebp)
	jne	.LBB101_2
# BB#3:                                 # %if.then3
	incl	%ebp
	xorb	%bl, %bl
	cmpl	36(%esp), %ebp
	je	.LBB101_30
# BB#4:                                 # %lor.lhs.false
	xorb	%bl, %bl
	movl	$0, 8(%esp)             # 4-byte Folded Spill
	cmpb	$58, (%ebp)
	movl	$0, (%esp)              # 4-byte Folded Spill
	jne	.LBB101_30
	jmp	.LBB101_5
.LBB101_2:
	movl	$0, (%esp)              # 4-byte Folded Spill
	.align	16, 0x90
.LBB101_5:                              # %while.cond.outer.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB101_6 Depth 2
                                        #       Child Loop BB101_7 Depth 3
	movl	(%esp), %eax            # 4-byte Reload
	orl	$1, %eax
	movl	%eax, 4(%esp)           # 4-byte Spill
	movb	$1, %bl
	xorl	%esi, %esi
	movl	%ebp, %eax
	.align	16, 0x90
.LBB101_6:                              # %while.cond.outer
                                        #   Parent Loop BB101_5 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB101_7 Depth 3
	movb	%bl, %bh
	movl	%eax, %ecx
	leal	1(%ecx), %eax
	jmp	.LBB101_7
	.align	16, 0x90
.LBB101_17:                             # %if.end38
                                        #   in Loop: Header=BB101_7 Depth=3
	leal	1(%ecx), %ebp
	addl	4(%esp), %ecx           # 4-byte Folded Reload
	incl	%eax
	movl	%ecx, 8(%esp)           # 4-byte Spill
	movl	%ebp, %ecx
.LBB101_7:                              # %while.cond
                                        #   Parent Loop BB101_5 Depth=1
                                        #     Parent Loop BB101_6 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	leal	-1(%eax), %edx
	cmpl	36(%esp), %edx
	jae	.LBB101_23
# BB#8:                                 # %while.body
                                        #   in Loop: Header=BB101_7 Depth=3
	movsbl	(%edx), %edx
	movzbl	%dl, %edi
	testb	$1, _sch_istable+1(%edi,%edi)
	jne	.LBB101_9
# BB#13:                                # %if.end29
                                        #   in Loop: Header=BB101_7 Depth=3
	xorb	%bl, %bl
	cmpb	$46, %dl
	je	.LBB101_20
# BB#14:                                # %if.end29
                                        #   in Loop: Header=BB101_7 Depth=3
	cmpb	$58, %dl
	jne	.LBB101_30
# BB#15:                                # %if.then32
                                        #   in Loop: Header=BB101_7 Depth=3
	xorb	%bl, %bl
	testb	$1, %bh
	je	.LBB101_18
# BB#16:                                # %if.then34
                                        #   in Loop: Header=BB101_7 Depth=3
	cmpl	$0, 8(%esp)             # 4-byte Folded Reload
	jne	.LBB101_30
	jmp	.LBB101_17
.LBB101_9:                              # %if.then18
                                        #   in Loop: Header=BB101_6 Depth=2
	movl	%esi, %ecx
	shll	$4, %ecx
	cmpb	$64, %dl
	jg	.LBB101_11
# BB#10:                                # %cond.true
                                        #   in Loop: Header=BB101_6 Depth=2
	addl	$-48, %edx
	movl	%edx, %esi
	jmp	.LBB101_12
.LBB101_11:                             # %cond.false
                                        #   in Loop: Header=BB101_6 Depth=2
	movzbl	_sch_toupper(%edi), %esi
	addl	$-55, %esi
.LBB101_12:                             # %cond.end
                                        #   in Loop: Header=BB101_6 Depth=2
	orl	%ecx, %esi
	xorb	%bl, %bl
	cmpl	$65535, %esi            # imm = 0xFFFF
	jbe	.LBB101_6
	jmp	.LBB101_30
.LBB101_18:                             # %if.else
                                        #   in Loop: Header=BB101_5 Depth=1
	cmpl	%eax, 36(%esp)
	je	.LBB101_30
# BB#19:                                # %if.else
                                        #   in Loop: Header=BB101_5 Depth=1
	movl	(%esp), %edx            # 4-byte Reload
	leal	2(%edx), %ecx
	cmpl	$14, %edx
	movl	%ecx, (%esp)            # 4-byte Spill
	movl	%eax, %ebp
	jle	.LBB101_5
	jmp	.LBB101_30
.LBB101_20:                             # %land.lhs.true
	cmpl	$12, (%esp)             # 4-byte Folded Reload
	jg	.LBB101_30
# BB#21:                                # %land.lhs.true54
	movl	%ebp, %ecx
	movl	36(%esp), %edx
	calll	is_valid_ipv4_address
	xorb	%bl, %bl
	testb	%al, %al
	je	.LBB101_30
# BB#22:                                # %while.end.thread
	addl	$4, (%esp)              # 4-byte Folded Spill
	.align	16, 0x90
.LBB101_26:                             # %if.end68
	cmpl	$0, 8(%esp)             # 4-byte Folded Reload
	je	.LBB101_27
# BB#28:                                # %if.then71
	movl	$16, %eax
	xorb	%bl, %bl
	cmpl	$16, (%esp)             # 4-byte Folded Reload
	je	.LBB101_30
	jmp	.LBB101_29
.LBB101_27:
	movl	(%esp), %eax            # 4-byte Reload
.LBB101_29:                             # %if.end76
	cmpl	$16, %eax
	sete	%bl
	.align	16, 0x90
.LBB101_30:                             # %return
	movzbl	%bl, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB101_23:                             # %while.end
	testb	$1, %bh
	jne	.LBB101_26
# BB#24:                                # %if.then62
	xorb	%bl, %bl
	cmpl	$14, (%esp)             # 4-byte Folded Reload
	jg	.LBB101_30
# BB#25:                                # %if.end66
	addl	$2, (%esp)              # 4-byte Folded Spill
	jmp	.LBB101_26
.Ltmp101:
	.size	is_valid_ipv6_address, .Ltmp101-is_valid_ipv6_address

	.align	16, 0x90
	.type	is_valid_ipv4_address,@function
is_valid_ipv4_address:                  # @is_valid_ipv4_address
# BB#0:                                 # %while.cond
	pushl	%ebx
	pushl	%esi
	pushl	%eax
	movl	%edx, %esi
	xorb	%bl, %bl
	cmpl	%esi, %ecx
	jae	.LBB102_4
# BB#1:                                 # %while.body
	movsbl	(%ecx), %eax
	movb	%al, %dl
	addb	$-48, %dl
	xorb	%bl, %bl
	cmpb	$9, %dl
	ja	.LBB102_4
# BB#2:                                 # %if.then
	addl	$-48, %eax
	xorb	%dl, %dl
	cmpl	$256, %eax              # imm = 0x100
	jge	.LBB102_3
# BB#5:
	incl	%ecx
	movb	$0, 3(%esp)             # 1-byte Folded Spill
	.align	16, 0x90
.LBB102_6:                              # %while.cond.1
                                        # =>This Inner Loop Header: Depth=1
	xorb	%bl, %bl
	cmpl	%esi, %ecx
	jae	.LBB102_4
# BB#7:                                 # %while.body.1
                                        #   in Loop: Header=BB102_6 Depth=1
	movsbl	(%ecx), %ebx
	movb	%bl, %dh
	addb	$-48, %dh
	cmpb	$10, %dh
	jae	.LBB102_8
# BB#9:                                 # %if.then.1
                                        #   in Loop: Header=BB102_6 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%ebx), %eax
	xorb	%bl, %bl
	cmpl	$255, %eax
	jg	.LBB102_4
# BB#10:                                # %if.end.1
                                        #   in Loop: Header=BB102_6 Depth=1
	incl	%ecx
	testb	$1, %dl
	je	.LBB102_6
	jmp	.LBB102_11
.LBB102_8:                              # %if.else.1
                                        #   in Loop: Header=BB102_6 Depth=1
	cmpb	$46, %bl
	setne	%dh
	orb	%dl, %dh
	incl	%ecx
	xorl	%eax, %eax
	movb	$1, %dl
	xorb	%bl, %bl
	testb	$1, %dh
	jne	.LBB102_4
	jmp	.LBB102_6
.LBB102_3:
	xorb	%bl, %bl
	.align	16, 0x90
.LBB102_4:                              # %return
	movzbl	%bl, %eax
	addl	$4, %esp
	popl	%esi
	popl	%ebx
	ret
.LBB102_11:
	xorb	%bh, %bh
	.align	16, 0x90
.LBB102_12:                             # %while.cond.2
                                        # =>This Inner Loop Header: Depth=1
	xorb	%bl, %bl
	cmpl	%esi, %ecx
	jae	.LBB102_4
# BB#13:                                # %while.body.2
                                        #   in Loop: Header=BB102_12 Depth=1
	movsbl	(%ecx), %edx
	movb	%dl, %bl
	addb	$-48, %bl
	cmpb	$10, %bl
	jae	.LBB102_14
# BB#15:                                # %if.then.2
                                        #   in Loop: Header=BB102_12 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%edx), %eax
	xorb	%bl, %bl
	cmpl	$255, %eax
	jg	.LBB102_4
# BB#16:                                # %if.end.2
                                        #   in Loop: Header=BB102_12 Depth=1
	incl	%ecx
	testb	$1, 3(%esp)             # 1-byte Folded Reload
	je	.LBB102_12
	jmp	.LBB102_17
.LBB102_14:                             # %if.else.2
                                        #   in Loop: Header=BB102_12 Depth=1
	cmpb	$46, %dl
	setne	%dl
	orb	3(%esp), %dl            # 1-byte Folded Reload
	incl	%ecx
	xorl	%eax, %eax
	movb	$1, 3(%esp)             # 1-byte Folded Spill
	xorb	%bl, %bl
	testb	$1, %dl
	jne	.LBB102_4
	jmp	.LBB102_12
	.align	16, 0x90
.LBB102_19:                             # %if.else.3
                                        #   in Loop: Header=BB102_17 Depth=1
	cmpb	$46, %dl
	setne	%dl
	orb	%bh, %dl
	incl	%ecx
	xorl	%eax, %eax
	movb	$1, %bh
	xorb	%bl, %bl
	testb	$1, %dl
	jne	.LBB102_4
	.align	16, 0x90
.LBB102_17:                             # %while.cond.3
                                        # =>This Inner Loop Header: Depth=1
	xorb	%bl, %bl
	cmpl	%esi, %ecx
	jae	.LBB102_4
# BB#18:                                # %while.body.3
                                        #   in Loop: Header=BB102_17 Depth=1
	movsbl	(%ecx), %edx
	movb	%dl, %bl
	addb	$-48, %bl
	cmpb	$10, %bl
	jae	.LBB102_19
# BB#20:                                # %if.then.3
                                        #   in Loop: Header=BB102_17 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%edx), %eax
	xorb	%bl, %bl
	cmpl	$255, %eax
	jg	.LBB102_4
# BB#21:                                # %if.end.3
                                        #   in Loop: Header=BB102_17 Depth=1
	incl	%ecx
	testb	$1, %bh
	je	.LBB102_17
	.align	16, 0x90
.LBB102_22:                             # %while.cond.4
                                        # =>This Inner Loop Header: Depth=1
	movb	$1, %bl
	cmpl	%esi, %ecx
	jae	.LBB102_4
# BB#23:                                # %while.body.4
                                        #   in Loop: Header=BB102_22 Depth=1
	movsbl	(%ecx), %edx
	movb	%dl, %bh
	addb	$-48, %bh
	xorb	%bl, %bl
	cmpb	$9, %bh
	ja	.LBB102_4
# BB#24:                                # %if.then.4
                                        #   in Loop: Header=BB102_22 Depth=1
	imull	$10, %eax, %eax
	leal	-48(%eax,%edx), %eax
	incl	%ecx
	xorb	%bl, %bl
	cmpl	$255, %eax
	jg	.LBB102_4
	jmp	.LBB102_22
.Ltmp102:
	.size	is_valid_ipv4_address, .Ltmp102-is_valid_ipv4_address

	.globl	lookup_host
	.align	16, 0x90
	.type	lookup_host,@function
lookup_host:                            # @lookup_host
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$108, %esp
	movsd	opt+188, %xmm0
	movsd	%xmm0, 24(%esp)         # 8-byte Spill
	movl	128(%esp), %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	addl	%esi, %edi
	movl	%esi, %ecx
	movl	%edi, %edx
	calll	is_valid_ipv4_address
	movl	132(%esp), %ebp
	movl	%ebp, %ecx
	andl	$1, %ecx
	movl	%ecx, 40(%esp)          # 4-byte Spill
	testb	%al, %al
	jne	.LBB103_2
# BB#1:                                 # %lor.lhs.false
	movl	%edi, 4(%esp)
	movl	128(%esp), %eax
	movl	%eax, (%esp)
	calll	is_valid_ipv6_address
	xorb	%bh, %bh
	testb	%al, %al
	je	.LBB103_3
.LBB103_2:                              # %if.then
	movb	$1, %bh
.LBB103_3:                              # %if.end
	xorb	%cl, %cl
	movl	%ebp, %esi
	andl	$2, %esi
	jne	.LBB103_16
# BB#4:                                 # %lor.lhs.false8
	testb	%bh, %bh
	jne	.LBB103_5
# BB#6:                                 # %if.end11
	xorb	%cl, %cl
	cmpb	$0, opt+88
	je	.LBB103_16
# BB#7:                                 # %if.then13
	movl	%ebp, %ecx
	movl	host_name_addresses_map, %eax
	testb	$4, %cl
	je	.LBB103_8
# BB#13:                                # %if.else
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB103_16
# BB#14:                                # %if.end.i104
	movl	128(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB103_16
# BB#15:                                # %if.then2.i
	movl	%eax, (%esp)
	calll	address_list_release
	movl	host_name_addresses_map, %eax
	movl	128(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_remove
	movb	$1, %cl
	jmp	.LBB103_16
.LBB103_5:
	movb	$1, %bl
	movb	$0, 39(%esp)            # 1-byte Folded Spill
	jmp	.LBB103_19
.LBB103_8:                              # %if.then16
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB103_16
# BB#9:                                 # %if.end.i
	movl	128(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movl	%eax, %edi
	movb	$1, %cl
	testl	%edi, %edi
	je	.LBB103_16
# BB#10:                                # %do.body.i
	cmpb	$0, opt+250
	jne	.LBB103_11
	.align	16, 0x90
.LBB103_12:                             # %cache_query.exit
	incl	16(%edi)
	jmp	.LBB103_79
.LBB103_16:                             # %if.end22
	cmpl	$0, 40(%esp)            # 4-byte Folded Reload
	setne	%al
	movb	$1, %bl
	orb	%bh, %al
	jne	.LBB103_17
# BB#18:                                # %if.then25
	movb	%cl, 39(%esp)           # 1-byte Spill
	movl	$5, 8(%esp)
	movl	$.L.str6343, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	128(%esp), %eax
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	xorb	%bl, %bl
	jmp	.LBB103_19
.LBB103_17:
	movb	%cl, 39(%esp)           # 1-byte Spill
.LBB103_19:                             # %if.end28
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 64(%esp)
	movaps	%xmm0, 48(%esp)
	movl	$1, 56(%esp)
	movw	opt+334, %ax
	testb	%al, %al
	je	.LBB103_21
# BB#20:                                # %if.then30
	movl	$2, 52(%esp)
	jmp	.LBB103_24
.LBB103_21:                             # %if.else31
	cmpw	$256, %ax               # imm = 0x100
	jae	.LBB103_22
# BB#23:                                # %if.else35
	movl	$0, 52(%esp)
	jmp	.LBB103_24
.LBB103_22:                             # %if.then33
	movl	$10, 52(%esp)
.LBB103_24:                             # %if.end38
	movl	$4, %eax
	testl	%esi, %esi
	movsd	24(%esp), %xmm0         # 8-byte Reload
	je	.LBB103_26
# BB#25:                                # %if.then41
	movl	$1, 48(%esp)
	movl	$5, %eax
.LBB103_26:                             # %if.end42
	cmpb	$1, %bh
	jne	.LBB103_28
# BB#27:                                # %if.then44
	movl	%eax, 48(%esp)
	xorps	%xmm0, %xmm0
.LBB103_28:                             # %if.end47
	movl	128(%esp), %eax
	movl	%eax, 88(%esp)
	movl	$0, 92(%esp)
	leal	48(%esp), %eax
	movl	%eax, 96(%esp)
	leal	44(%esp), %eax
	movl	%eax, 100(%esp)
	leal	88(%esp), %eax
	movl	%eax, 12(%esp)
	movsd	%xmm0, (%esp)
	movl	$getaddrinfo_with_timeout_callback, 8(%esp)
	calll	run_with_timeout
	cmpb	$1, %al
	jne	.LBB103_33
# BB#29:                                # %getaddrinfo_with_timeout.exit.thread
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-11, %ebp
	jmp	.LBB103_30
.LBB103_33:                             # %getaddrinfo_with_timeout.exit
	movl	104(%esp), %ebp
	testl	%ebp, %ebp
	jne	.LBB103_30
# BB#34:                                # %lor.lhs.false49
	xorl	%ebp, %ebp
	movl	44(%esp), %esi
	testl	%esi, %esi
	je	.LBB103_30
# BB#35:
	movl	%esi, %eax
	.align	16, 0x90
.LBB103_36:                             # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%eax), %ecx
	orl	$8, %ecx
	cmpl	$10, %ecx
	jne	.LBB103_38
# BB#37:                                # %if.then.i109
                                        #   in Loop: Header=BB103_36 Depth=1
	incl	%ebp
.LBB103_38:                             # %for.inc.i
                                        #   in Loop: Header=BB103_36 Depth=1
	movl	28(%eax), %eax
	testl	%eax, %eax
	jne	.LBB103_36
# BB#39:                                # %for.end.i
	testl	%ebp, %ebp
	je	.LBB103_40
# BB#44:                                # %for.body11.i.preheader
	movl	$20, (%esp)
	calll	checking_malloc0
	movl	%eax, %edi
	imull	$24, %ebp, %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, 4(%edi)
	movl	%ebp, (%edi)
	movl	$1, 16(%edi)
	.align	16, 0x90
.LBB103_45:                             # %for.body11.i
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%esi), %ecx
	cmpl	$2, %ecx
	jne	.LBB103_46
# BB#48:                                # %if.then17.i
                                        #   in Loop: Header=BB103_45 Depth=1
	movl	20(%esi), %ecx
	movl	$2, (%eax)
	movl	4(%ecx), %ecx
	movl	%ecx, 4(%eax)
	jmp	.LBB103_49
.LBB103_46:                             # %for.body11.i
                                        #   in Loop: Header=BB103_45 Depth=1
	cmpl	$10, %ecx
	jne	.LBB103_50
# BB#47:                                # %if.then14.i
                                        #   in Loop: Header=BB103_45 Depth=1
	movl	20(%esi), %ecx
	movl	$10, (%eax)
	movsd	8(%ecx), %xmm0
	movsd	16(%ecx), %xmm1
	movsd	%xmm1, 12(%eax)
	movsd	%xmm0, 4(%eax)
	movl	24(%ecx), %ecx
	movl	%ecx, 20(%eax)
.LBB103_49:                             # %if.then17.i
                                        #   in Loop: Header=BB103_45 Depth=1
	addl	$24, %eax
.LBB103_50:                             # %for.inc24.i
                                        #   in Loop: Header=BB103_45 Depth=1
	movl	28(%esi), %esi
	testl	%esi, %esi
	jne	.LBB103_45
# BB#51:                                # %for.end26.i
	subl	4(%edi), %eax
	sarl	$3, %eax
	imull	$-1431655765, %eax, %eax # imm = 0xFFFFFFFFAAAAAAAB
	cmpl	%ebp, %eax
	jne	.LBB103_80
# BB#52:                                # %address_list_from_addrinfo.exit
	movl	44(%esp), %eax
	movl	%eax, (%esp)
	calll	freeaddrinfo
	testl	%edi, %edi
	je	.LBB103_53
# BB#54:                                # %if.end65
	movl	(%edi), %eax
	cmpl	$2, %eax
	jl	.LBB103_57
# BB#55:                                # %if.end65
	movl	opt+336, %ecx
	cmpl	$2, %ecx
	je	.LBB103_57
# BB#56:                                # %if.then69
	movl	$cmp_prefer_ipv4, %edx
	testl	%ecx, %ecx
	movl	$cmp_prefer_ipv6, %ecx
	cmovel	%edx, %ecx
	movl	4(%edi), %edx
	movl	%ecx, 12(%esp)
	movl	%eax, 4(%esp)
	movl	%edx, (%esp)
	movl	$24, 8(%esp)
	calll	stable_sort
.LBB103_57:                             # %if.end73
	testb	%bl, %bl
	jne	.LBB103_69
# BB#58:                                # %if.then77
	movl	(%edi), %eax
	cmpl	$3, %eax
	movl	$3, %ecx
	cmovlel	%eax, %ecx
	testl	%ecx, %ecx
	jle	.LBB103_66
# BB#59:                                # %for.body.lr.ph
	notl	%eax
	cmpl	$-5, %eax
	movl	$-4, %ebp
	cmovgl	%eax, %ebp
	notl	%ebp
	leal	-1(%ecx), %eax
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	%ecx, 24(%esp)          # 4-byte Spill
	xorl	%esi, %esi
	movl	$4, %ebx
	.align	16, 0x90
.LBB103_60:                             # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%edi), %ecx
	movl	-4(%ecx,%ebx), %eax
	addl	%ebx, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$64, 12(%esp)
	movl	$print_address.buf, 8(%esp)
	calll	inet_ntop
	testl	%eax, %eax
	jne	.LBB103_62
# BB#61:                                # %if.then.i117
                                        #   in Loop: Header=BB103_60 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	$.L.str5342, 8(%esp)
	movl	$64, 4(%esp)
	movl	$print_address.buf, (%esp)
	calll	snprintf
.LBB103_62:                             # %print_address.exit
                                        #   in Loop: Header=BB103_60 Depth=1
	movl	$print_address.buf, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	cmpl	40(%esp), %esi          # 4-byte Folded Reload
	jge	.LBB103_64
# BB#63:                                # %if.then90
                                        #   in Loop: Header=BB103_60 Depth=1
	movl	$.L.str9346, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB103_64:                             # %for.inc
                                        #   in Loop: Header=BB103_60 Depth=1
	addl	$24, %ebx
	incl	%esi
	cmpl	%esi, %ebp
	jne	.LBB103_60
# BB#65:                                # %for.cond.for.end_crit_edge
	movl	(%edi), %eax
	movl	24(%esp), %ecx          # 4-byte Reload
.LBB103_66:                             # %for.end
	cmpl	%eax, %ecx
	je	.LBB103_68
# BB#67:                                # %if.then94
	movl	$.L.str10347, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB103_68:                             # %if.end95
	movl	$.L.str11348, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB103_69:                             # %if.end96
	cmpb	$1, 39(%esp)            # 1-byte Folded Reload
	jne	.LBB103_79
# BB#70:                                # %if.then98
	movl	host_name_addresses_map, %ebx
	testl	%ebx, %ebx
	jne	.LBB103_72
# BB#71:                                # %if.then.i121
	movl	$0, (%esp)
	calll	make_nocase_string_hash_table
	movl	%eax, %ebx
	movl	%ebx, host_name_addresses_map
.LBB103_72:                             # %if.end.i125
	incl	16(%edi)
	movl	128(%esp), %eax
	movl	%eax, (%esp)
	calll	xstrdup_lower
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	hash_table_put
	cmpb	$0, opt+250
	je	.LBB103_79
# BB#73:                                # %if.then4.i
	movl	128(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str14351, (%esp)
	calll	debug_logprintf
	cmpl	$0, (%edi)
	jle	.LBB103_78
# BB#74:
	xorl	%esi, %esi
	movl	$4, %ebx
	.align	16, 0x90
.LBB103_75:                             # %for.body.i128
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%edi), %ecx
	movl	-4(%ecx,%ebx), %eax
	addl	%ebx, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$64, 12(%esp)
	movl	$print_address.buf, 8(%esp)
	calll	inet_ntop
	testl	%eax, %eax
	jne	.LBB103_77
# BB#76:                                # %if.then.i.i
                                        #   in Loop: Header=BB103_75 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	$.L.str5342, 8(%esp)
	movl	$64, 4(%esp)
	movl	$print_address.buf, (%esp)
	calll	snprintf
.LBB103_77:                             # %print_address.exit.i
                                        #   in Loop: Header=BB103_75 Depth=1
	movl	$print_address.buf, 4(%esp)
	movl	$.L.str15352, (%esp)
	calll	debug_logprintf
	addl	$24, %ebx
	incl	%esi
	cmpl	(%edi), %esi
	jl	.LBB103_75
.LBB103_78:                             # %for.end.i130
	movl	$.L.str11348, (%esp)
	calll	debug_logprintf
	jmp	.LBB103_79
.LBB103_30:                             # %if.then51
	xorl	%edi, %edi
	cmpl	$0, 40(%esp)            # 4-byte Folded Reload
	jne	.LBB103_79
# BB#31:                                # %if.then53
	movl	$5, 8(%esp)
	movl	$.L.str7344, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	cmpl	$-11, %ebp
	jne	.LBB103_32
# BB#41:                                # %cond.false
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	jmp	.LBB103_42
.LBB103_32:                             # %cond.true
	movl	%ebp, (%esp)
	calll	gai_strerror
.LBB103_42:                             # %cond.end
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	jmp	.LBB103_43
.LBB103_40:                             # %address_list_from_addrinfo.exit.thread
	movl	%esi, (%esp)
	calll	freeaddrinfo
.LBB103_53:                             # %if.then63
	movl	$5, 8(%esp)
	movl	$.L.str8345, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
.LBB103_43:                             # %cond.end
	movl	$0, (%esp)
	calll	logprintf
	xorl	%edi, %edi
.LBB103_79:                             # %return
	movl	%edi, %eax
	addl	$108, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB103_11:                             # %if.then5.i
	movl	%edi, 8(%esp)
	movl	128(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str17354, (%esp)
	calll	debug_logprintf
	jmp	.LBB103_12
.LBB103_80:                             # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.address_list_from_addrinfo, 12(%esp)
	movl	$215, 8(%esp)
	movl	$.L.str1338, 4(%esp)
	movl	$.L.str16353, (%esp)
	calll	__assert_fail
.Ltmp103:
	.size	lookup_host, .Ltmp103-lookup_host

	.align	16, 0x90
	.type	cmp_prefer_ipv4,@function
cmp_prefer_ipv4:                        # @cmp_prefer_ipv4
# BB#0:                                 # %entry
	movl	8(%esp), %eax
	cmpl	$2, (%eax)
	setne	%al
	movzbl	%al, %ecx
	movl	4(%esp), %eax
	cmpl	$2, (%eax)
	setne	%al
	movzbl	%al, %eax
	subl	%ecx, %eax
	ret
.Ltmp104:
	.size	cmp_prefer_ipv4, .Ltmp104-cmp_prefer_ipv4

	.align	16, 0x90
	.type	cmp_prefer_ipv6,@function
cmp_prefer_ipv6:                        # @cmp_prefer_ipv6
# BB#0:                                 # %entry
	movl	8(%esp), %eax
	cmpl	$10, (%eax)
	setne	%al
	movzbl	%al, %ecx
	movl	4(%esp), %eax
	cmpl	$10, (%eax)
	setne	%al
	movzbl	%al, %eax
	subl	%ecx, %eax
	ret
.Ltmp105:
	.size	cmp_prefer_ipv6, .Ltmp105-cmp_prefer_ipv6

	.globl	accept_domain
	.align	16, 0x90
	.type	accept_domain,@function
accept_domain:                          # @accept_domain
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %eax
	movl	8(%eax), %edi
	testl	%edi, %edi
	je	.LBB106_18
# BB#1:                                 # %cond.end
	movl	opt+80, %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB106_9
# BB#2:                                 # %if.then
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, 16(%esp)          # 4-byte Spill
	xorl	%ecx, %ecx
	.align	16, 0x90
.LBB106_3:                              # %for.cond.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB106_5 Depth 2
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	20(%esp), %eax          # 4-byte Reload
	movl	(%eax,%ecx,4), %ebp
	xorb	%cl, %cl
	testl	%ebp, %ebp
	je	.LBB106_17
# BB#4:                                 # %for.body.i
                                        #   in Loop: Header=BB106_3 Depth=1
	movl	%ebp, (%esp)
	calll	strlen
	movl	16(%esp), %ecx          # 4-byte Reload
	jmp	.LBB106_5
	.align	16, 0x90
.LBB106_7:                              # %for.inc.i
                                        #   in Loop: Header=BB106_5 Depth=2
	decl	%ecx
	decl	%eax
.LBB106_5:                              # %for.cond3.i
                                        #   Parent Loop BB106_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ecx, %edx
	orl	%eax, %edx
	js	.LBB106_8
# BB#6:                                 # %for.body5.i
                                        #   in Loop: Header=BB106_5 Depth=2
	movzbl	(%edi,%ecx), %edx
	movzbl	(%ebp,%eax), %esi
	movb	_sch_tolower(%esi), %bl
	cmpb	_sch_tolower(%edx), %bl
	je	.LBB106_7
.LBB106_8:                              # %for.end.i
                                        #   in Loop: Header=BB106_3 Depth=1
	movl	24(%esp), %ecx          # 4-byte Reload
	incl	%ecx
	cmpl	$-1, %eax
	jne	.LBB106_3
.LBB106_9:                              # %if.end3
	movb	$1, %cl
	movl	opt+84, %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB106_17
# BB#10:                                # %if.then5
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, 16(%esp)          # 4-byte Spill
	xorl	%edx, %edx
	.align	16, 0x90
.LBB106_11:                             # %for.cond.i15
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB106_13 Depth 2
	movl	20(%esp), %eax          # 4-byte Reload
	movl	(%eax,%edx,4), %ebp
	movb	$1, %cl
	testl	%ebp, %ebp
	je	.LBB106_17
# BB#12:                                # %for.body.i17
                                        #   in Loop: Header=BB106_11 Depth=1
	movl	%edx, 24(%esp)          # 4-byte Spill
	movl	%ebp, (%esp)
	calll	strlen
	movl	16(%esp), %ecx          # 4-byte Reload
	jmp	.LBB106_13
	.align	16, 0x90
.LBB106_15:                             # %for.inc.i31
                                        #   in Loop: Header=BB106_13 Depth=2
	decl	%ecx
	decl	%eax
.LBB106_13:                             # %for.cond3.i20
                                        #   Parent Loop BB106_11 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ecx, %edx
	orl	%eax, %edx
	js	.LBB106_16
# BB#14:                                # %for.body5.i28
                                        #   in Loop: Header=BB106_13 Depth=2
	movzbl	(%edi,%ecx), %edx
	movzbl	(%ebp,%eax), %esi
	movb	_sch_tolower(%esi), %bl
	cmpb	_sch_tolower(%edx), %bl
	je	.LBB106_15
.LBB106_16:                             # %for.end.i34
                                        #   in Loop: Header=BB106_11 Depth=1
	movl	24(%esp), %edx          # 4-byte Reload
	incl	%edx
	xorb	%cl, %cl
	cmpl	$-1, %eax
	jne	.LBB106_11
.LBB106_17:                             # %return
	movzbl	%cl, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB106_18:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.accept_domain, 12(%esp)
	movl	$824, 8(%esp)           # imm = 0x338
	movl	$.L.str1338, 4(%esp)
	movl	$.L.str12349, (%esp)
	calll	__assert_fail
.Ltmp106:
	.size	accept_domain, .Ltmp106-accept_domain

	.globl	sufmatch
	.align	16, 0x90
	.type	sufmatch,@function
sufmatch:                               # @sufmatch
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	36(%esp), %edi
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, 4(%esp)           # 4-byte Spill
	xorl	%edx, %edx
	.align	16, 0x90
.LBB107_1:                              # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB107_3 Depth 2
	movl	32(%esp), %eax
	movl	(%eax,%edx,4), %ebp
	xorb	%cl, %cl
	testl	%ebp, %ebp
	je	.LBB107_7
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB107_1 Depth=1
	movl	%edx, 8(%esp)           # 4-byte Spill
	movl	%ebp, (%esp)
	calll	strlen
	movl	4(%esp), %ecx           # 4-byte Reload
	jmp	.LBB107_3
	.align	16, 0x90
.LBB107_5:                              # %for.inc
                                        #   in Loop: Header=BB107_3 Depth=2
	decl	%ecx
	decl	%eax
.LBB107_3:                              # %for.cond3
                                        #   Parent Loop BB107_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ecx, %edx
	orl	%eax, %edx
	js	.LBB107_6
# BB#4:                                 # %for.body5
                                        #   in Loop: Header=BB107_3 Depth=2
	movzbl	(%edi,%ecx), %edx
	movzbl	(%ebp,%eax), %esi
	movb	_sch_tolower(%esi), %bl
	cmpb	_sch_tolower(%edx), %bl
	je	.LBB107_5
.LBB107_6:                              # %for.end
                                        #   in Loop: Header=BB107_1 Depth=1
	movl	8(%esp), %edx           # 4-byte Reload
	incl	%edx
	movb	$1, %cl
	cmpl	$-1, %eax
	jne	.LBB107_1
.LBB107_7:                              # %return
	movzbl	%cl, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp107:
	.size	sufmatch, .Ltmp107-sufmatch

	.globl	host_cleanup
	.align	16, 0x90
	.type	host_cleanup,@function
host_cleanup:                           # @host_cleanup
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$36, %esp
	movl	host_name_addresses_map, %eax
	testl	%eax, %eax
	je	.LBB108_6
# BB#1:                                 # %if.then
	leal	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB108_2
	.align	16, 0x90
.LBB108_4:                              # %cond.end
                                        #   in Loop: Header=BB108_2 Depth=1
	movl	4(%edi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	%edi, (%esp)
	calll	checking_free
.LBB108_2:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	je	.LBB108_5
# BB#3:                                 # %for.body
                                        #   in Loop: Header=BB108_2 Depth=1
	movl	16(%esp), %eax
	movl	20(%esp), %edi
	movl	%eax, (%esp)
	calll	checking_free
	cmpl	$1, 16(%edi)
	je	.LBB108_4
# BB#7:                                 # %cond.false
	movl	$.L__PRETTY_FUNCTION__.host_cleanup, 12(%esp)
	movl	$874, 8(%esp)           # imm = 0x36A
	movl	$.L.str1338, 4(%esp)
	movl	$.L.str13350, (%esp)
	calll	__assert_fail
.LBB108_5:                              # %for.end
	movl	host_name_addresses_map, %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	$0, host_name_addresses_map
.LBB108_6:                              # %if.end
	addl	$36, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp108:
	.size	host_cleanup, .Ltmp108-host_cleanup

	.align	16, 0x90
	.type	getaddrinfo_with_timeout_callback,@function
getaddrinfo_with_timeout_callback:      # @getaddrinfo_with_timeout_callback
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	32(%esp), %esi
	movl	(%esi), %eax
	movl	4(%esi), %ecx
	movl	8(%esi), %edx
	movl	12(%esi), %edi
	movl	%edi, 12(%esp)
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	getaddrinfo
	movl	%eax, 16(%esi)
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp109:
	.size	getaddrinfo_with_timeout_callback, .Ltmp109-getaddrinfo_with_timeout_callback

	.globl	map_html_tags
	.align	16, 0x90
	.type	map_html_tags,@function
map_html_tags:                          # @map_html_tags
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$604, %esp              # imm = 0x25C
	movl	628(%esp), %eax
	testl	%eax, %eax
	je	.LBB110_169
# BB#1:                                 # %do.body
	movl	624(%esp), %edi
	leal	(%edi,%eax), %ecx
	movl	%ecx, 100(%esp)         # 4-byte Spill
	movl	640(%esp), %ecx
	leal	348(%esp), %edx
	movl	%edx, 320(%esp)
	movl	$256, 324(%esp)         # imm = 0x100
	movl	$0, 328(%esp)
	movb	$0, 332(%esp)
	movl	%edx, 336(%esp)
	leal	3(%edi,%eax), %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	$256, 340(%esp)         # imm = 0x100
	movl	%ecx, %eax
	andl	$1, %eax
	movl	%eax, 32(%esp)          # 4-byte Spill
	andl	$2, %ecx
	leal	2(%ecx,%ecx), %eax
	movl	%eax, 80(%esp)          # 4-byte Spill
	movl	$8, 64(%esp)            # 4-byte Folded Spill
	movb	$0, 51(%esp)            # 1-byte Folded Spill
	leal	128(%esp), %eax
	movl	%eax, 72(%esp)          # 4-byte Spill
	jmp	.LBB110_2
	.align	16, 0x90
.LBB110_155:                            #   in Loop: Header=BB110_2 Depth=1
	movl	68(%esp), %edi          # 4-byte Reload
	.align	16, 0x90
.LBB110_2:                              # %look_for_tag
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB110_99 Depth 2
                                        #       Child Loop BB110_100 Depth 3
                                        #         Child Loop BB110_130 Depth 4
                                        #         Child Loop BB110_141 Depth 4
                                        #           Child Loop BB110_142 Depth 5
                                        #         Child Loop BB110_136 Depth 4
                                        #         Child Loop BB110_117 Depth 4
                                        #         Child Loop BB110_109 Depth 4
                                        #       Child Loop BB110_151 Depth 3
                                        #     Child Loop BB110_91 Depth 2
                                        #     Child Loop BB110_85 Depth 2
                                        #     Child Loop BB110_105 Depth 2
                                        #     Child Loop BB110_172 Depth 2
                                        #     Child Loop BB110_13 Depth 2
                                        #       Child Loop BB110_18 Depth 3
                                        #       Child Loop BB110_17 Depth 3
                                        #     Child Loop BB110_34 Depth 2
	movl	100(%esp), %esi         # 4-byte Reload
	movl	%esi, %eax
	subl	%edi, %eax
	movl	$0, 328(%esp)
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$60, 4(%esp)
	calll	memchr
	testl	%eax, %eax
	je	.LBB110_165
# BB#3:                                 # %if.end8
                                        #   in Loop: Header=BB110_2 Depth=1
	leal	1(%eax), %edx
	cmpl	%esi, %edx
	jae	.LBB110_165
# BB#4:                                 # %do.end12
                                        #   in Loop: Header=BB110_2 Depth=1
	movb	(%edx), %cl
	cmpb	$47, %cl
	jne	.LBB110_5
# BB#83:                                # %if.then45
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%edx, 68(%esp)          # 4-byte Spill
	movl	%eax, 56(%esp)          # 4-byte Spill
	leal	2(%eax), %ebx
	movl	$1, %eax
	cmpl	%esi, %ebx
	jae	.LBB110_165
	jmp	.LBB110_84
.LBB110_5:                              # %do.end12
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%eax, 56(%esp)          # 4-byte Spill
	xorl	%eax, %eax
	cmpb	$33, %cl
	movl	%edx, %ebx
	movl	%edx, 68(%esp)          # 4-byte Spill
	jne	.LBB110_84
# BB#6:                                 # %if.then15
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	$0, 32(%esp)            # 4-byte Folded Reload
	movl	56(%esp), %ebx          # 4-byte Reload
	movl	68(%esp), %edx          # 4-byte Reload
	jne	.LBB110_32
# BB#7:                                 # %if.then15
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	36(%esp), %edx          # 4-byte Folded Reload
	jae	.LBB110_32
# BB#8:                                 # %land.lhs.true20
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpb	$45, 2(%ebx)
	jne	.LBB110_32
# BB#9:                                 # %land.lhs.true24
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpb	$45, 3(%ebx)
	je	.LBB110_10
.LBB110_32:                             # %if.else
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	%esi, %edx
	je	.LBB110_82
# BB#33:                                # %if.end.i
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%esi, %edi
	addl	$2, %ebx
	movl	$2, %ecx
	movb	$33, %ah
	xorb	%al, %al
	movl	%ebx, %ebp
	jmp	.LBB110_34
.LBB110_84:                             # %if.end54
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%eax, 52(%esp)          # 4-byte Spill
	xorl	%esi, %esi
	.align	16, 0x90
.LBB110_85:                             # %while.cond
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%ebx,%esi), %al
	cmpb	$33, %al
	jl	.LBB110_90
# BB#86:                                # %switch.early.test
                                        #   in Loop: Header=BB110_85 Depth=2
	cmpb	$47, %al
	je	.LBB110_90
# BB#87:                                # %switch.early.test
                                        #   in Loop: Header=BB110_85 Depth=2
	movb	%al, %cl
	addb	$-61, %cl
	cmpb	$2, %cl
	jb	.LBB110_90
# BB#88:                                # %switch.early.test
                                        #   in Loop: Header=BB110_85 Depth=2
	cmpb	$127, %al
	je	.LBB110_90
# BB#89:                                # %do.body73
                                        #   in Loop: Header=BB110_85 Depth=2
	leal	1(%ebx,%esi), %eax
	incl	%esi
	cmpl	100(%esp), %eax         # 4-byte Folded Reload
	jb	.LBB110_85
	jmp	.LBB110_165
.LBB110_90:                             # %while.end
                                        #   in Loop: Header=BB110_2 Depth=1
	leal	1(%ebx,%esi), %ecx
	movl	%ecx, 76(%esp)          # 4-byte Spill
	leal	(%ebx,%esi), %edi
	testl	%esi, %esi
	je	.LBB110_2
	jmp	.LBB110_91
	.align	16, 0x90
.LBB110_93:                             # %do.body93.while.cond85_crit_edge
                                        #   in Loop: Header=BB110_91 Depth=2
	movb	(%ecx), %al
	incl	%ecx
	movl	%ecx, 76(%esp)          # 4-byte Spill
.LBB110_91:                             # %while.cond85
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	%al, %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	je	.LBB110_94
# BB#92:                                # %do.body93
                                        #   in Loop: Header=BB110_91 Depth=2
	movl	76(%esp), %ecx          # 4-byte Reload
	cmpl	100(%esp), %ecx         # 4-byte Folded Reload
	jae	.LBB110_165
	jmp	.LBB110_93
.LBB110_94:                             # %do.end101
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	$0, 52(%esp)            # 4-byte Folded Reload
	je	.LBB110_96
# BB#95:                                # %do.end101
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpb	$62, %al
	movl	68(%esp), %edi          # 4-byte Reload
	jne	.LBB110_2
.LBB110_96:                             # %if.end108
                                        #   in Loop: Header=BB110_2 Depth=1
	addl	%ebx, %esi
	movl	%esi, (%esp)
	movl	644(%esp), %ecx
	movl	%ebx, %edx
	calll	name_allowed
	decl	76(%esp)                # 4-byte Folded Spill
	testb	%al, %al
	je	.LBB110_97
# BB#98:                                # %if.else111
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%esi, (%esp)
	movl	$1, 4(%esp)
	leal	320(%esp), %ecx
	movl	%ebx, %edx
	calll	convert_and_copy
	xorb	%cl, %cl
	movl	$0, 60(%esp)            # 4-byte Folded Spill
	jmp	.LBB110_99
	.align	16, 0x90
.LBB110_39:                             # %if.then9.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$3, %ecx
	.align	16, 0x90
.LBB110_34:                             # %while.cond.i493
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	%ah, %dl
	cmpl	$2, %ecx
	jb	.LBB110_81
# BB#35:                                # %while.body.i494
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	%edi, %ebp
	movl	$1, %esi
	cmovel	%esi, %ecx
	leal	-2(%ecx), %esi
	cmpl	$10, %esi
	movb	%dl, %ah
	ja	.LBB110_34
# BB#36:                                # %while.body.i494
                                        #   in Loop: Header=BB110_34 Depth=2
	jmpl	*.LJTI110_0(,%esi,4)
.LBB110_37:                             # %sw.bb6.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$1, %ecx
	cmpb	$33, %dl
	jmp	.LBB110_38
.LBB110_40:                             # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movsbl	%dl, %esi
	cmpl	$61, %esi
	jg	.LBB110_49
# BB#41:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$31, %esi
	jg	.LBB110_44
# BB#42:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$13, %esi
	ja	.LBB110_52
# BB#43:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$9728, %ecx             # imm = 0x2600
	btl	%esi, %ecx
	jb	.LBB110_39
	jmp	.LBB110_52
.LBB110_57:                             # %sw.bb40.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$5, %ecx
	movb	$45, %ah
	cmpb	$45, %dl
	je	.LBB110_34
# BB#58:                                # %if.else45.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$3, %ecx
	cmpb	$33, %dl
	movb	%dl, %ah
	jl	.LBB110_34
# BB#59:                                # %switch.early.test144.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$3, %ecx
	cmpb	$47, %dl
	movb	%dl, %ah
	je	.LBB110_34
# BB#60:                                # %switch.early.test144.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	%dl, %ah
	addb	$-61, %ah
	cmpb	$2, %ah
	movb	%dl, %ah
	jb	.LBB110_34
# BB#61:                                # %switch.early.test144.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$127, %dl
	movb	%dl, %ah
	je	.LBB110_34
# BB#62:                                # %if.then65.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$4, %ecx
	jmp	.LBB110_34
.LBB110_70:                             # %sw.bb96.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$45, %dl
	jne	.LBB110_71
# BB#73:                                # %cond.end102.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$6, %ecx
	jmp	.LBB110_34
.LBB110_74:                             # %sw.bb104.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$1, %ecx
	cmpb	$45, %dl
	movb	%dl, %ah
	jne	.LBB110_34
	jmp	.LBB110_75
.LBB110_76:                             # %sw.bb110.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$8, %ecx
	movb	$45, %ah
	cmpb	$45, %dl
	je	.LBB110_34
.LBB110_75:                             # %sw.bb106.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$7, %ecx
	jmp	.LBB110_34
.LBB110_77:                             # %sw.bb116.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$45, %dl
	jne	.LBB110_78
# BB#79:                                # %cond.end122.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$9, %ecx
	jmp	.LBB110_34
.LBB110_80:                             # %sw.bb124.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$7, %ecx
	cmpb	$45, %dl
.LBB110_38:                             # %sw.bb6.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	%dl, %ah
	jne	.LBB110_34
	jmp	.LBB110_39
.LBB110_63:                             # %sw.bb70.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$34, %dl
	je	.LBB110_65
# BB#64:                                # %sw.bb70.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$39, %dl
	jne	.LBB110_175
.LBB110_65:                             # %cond.end.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$11, %ecx
	movb	%dl, %al
	jmp	.LBB110_34
.LBB110_66:                             # %sw.bb78.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$12, %ecx
	cmpb	%al, %dl
	movb	%dl, %ah
	je	.LBB110_34
# BB#67:                                # %if.else84.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	(%ebp), %ah
	incl	%ebp
	movl	$11, %ecx
	jmp	.LBB110_34
.LBB110_68:                             # %sw.bb87.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	%al, %dl
	je	.LBB110_39
	jmp	.LBB110_69
.LBB110_49:                             # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$62, %esi
	jne	.LBB110_52
# BB#50:                                # %sw.bb17.i
                                        #   in Loop: Header=BB110_34 Depth=2
	xorl	%ecx, %ecx
	movb	%dl, %ah
	jmp	.LBB110_34
.LBB110_44:                             # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$44, %esi
	jg	.LBB110_51
# BB#45:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$32, %esi
	je	.LBB110_39
# BB#46:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$34, %esi
	je	.LBB110_48
# BB#47:                                # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpl	$39, %esi
	jne	.LBB110_52
.LBB110_48:                             # %sw.bb18.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$10, %ecx
	movb	%dl, %ah
	jmp	.LBB110_34
.LBB110_51:                             # %sw.bb12.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$5, %ecx
	cmpl	$45, %esi
	movb	%dl, %ah
	je	.LBB110_34
.LBB110_52:                             # %sw.default.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$33, %dl
	jl	.LBB110_56
# BB#53:                                # %switch.early.test.i
                                        #   in Loop: Header=BB110_34 Depth=2
	cmpb	$47, %dl
	je	.LBB110_56
# BB#54:                                # %switch.early.test.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movb	%dl, %cl
	addb	$-61, %cl
	cmpb	$2, %cl
	jb	.LBB110_56
# BB#55:                                # %switch.early.test.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$4, %ecx
	cmpb	$127, %dl
	movb	%dl, %ah
	jne	.LBB110_34
.LBB110_56:                             # %if.else38.i
                                        #   in Loop: Header=BB110_34 Depth=2
	movl	$1, %ecx
	movb	%dl, %ah
	jmp	.LBB110_34
.LBB110_81:                             # %while.end.i
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	$1, %ecx
	movl	%ebp, %edx
	cmovel	%ebx, %edx
	movl	%edi, %esi
	.align	16, 0x90
.LBB110_82:                             # %if.end36
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	%esi, %edx
	movl	%edx, %edi
	jne	.LBB110_2
	jmp	.LBB110_165
.LBB110_97:                             #   in Loop: Header=BB110_2 Depth=1
	movl	$0, 60(%esp)            # 4-byte Folded Spill
	movb	$1, %cl
	jmp	.LBB110_99
.LBB110_10:                             #   in Loop: Header=BB110_2 Depth=1
	addl	$3, %ebx
	jmp	.LBB110_13
	.align	16, 0x90
.LBB110_11:                             # %while.cond.i.loopexit
                                        #   in Loop: Header=BB110_13 Depth=2
	addl	$-2, %eax
	movl	%eax, %ebx
	jmp	.LBB110_13
	.align	16, 0x90
.LBB110_12:                             # %while.cond.i.loopexit2
                                        #   in Loop: Header=BB110_13 Depth=2
	decl	%ebx
	.align	16, 0x90
.LBB110_13:                             # %while.cond.i
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB110_18 Depth 3
                                        #       Child Loop BB110_17 Depth 3
	movl	%ebx, %eax
	leal	3(%eax), %ebx
	xorl	%ecx, %ecx
	cmpl	%esi, %ebx
	jae	.LBB110_31
# BB#14:                                # %while.body.i
                                        #   in Loop: Header=BB110_13 Depth=2
	movsbl	(%ebx), %ecx
	cmpl	$62, %ecx
	jne	.LBB110_15
# BB#22:                                # %sw.bb.i
                                        #   in Loop: Header=BB110_13 Depth=2
	cmpb	$45, 2(%eax)
	jne	.LBB110_13
# BB#23:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB110_13 Depth=2
	cmpb	$45, 1(%eax)
	jne	.LBB110_13
	jmp	.LBB110_24
.LBB110_15:                             # %while.body.i
                                        #   in Loop: Header=BB110_13 Depth=2
	cmpl	$45, %ecx
	jne	.LBB110_13
# BB#16:                                # %at_dash.i.preheader
                                        #   in Loop: Header=BB110_13 Depth=2
	leal	4(%eax), %ebx
	addl	$5, %eax
	.align	16, 0x90
.LBB110_17:                             # %at_dash.i
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_13 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	cmpb	$45, -3(%eax)
	je	.LBB110_18
# BB#25:                                # %if.else.i
                                        #   in Loop: Header=BB110_17 Depth=3
	xorl	%ecx, %ecx
	cmpl	%esi, %eax
	jae	.LBB110_31
# BB#26:                                # %if.end30.i
                                        #   in Loop: Header=BB110_17 Depth=3
	addl	$2, %ebx
	movsbl	(%eax), %ecx
	addl	$2, %eax
	cmpl	$45, %ecx
	je	.LBB110_17
# BB#27:                                # %if.end30.i
                                        #   in Loop: Header=BB110_13 Depth=2
	cmpl	$62, %ecx
	jne	.LBB110_11
# BB#28:                                # %sw.bb33.i
                                        #   in Loop: Header=BB110_13 Depth=2
	leal	-2(%eax), %ebx
	cmpb	$45, -3(%eax)
	jne	.LBB110_13
	jmp	.LBB110_29
	.align	16, 0x90
.LBB110_18:                             # %at_dash_dash.i
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_13 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	xorl	%ecx, %ecx
	cmpl	%ebx, %esi
	je	.LBB110_31
# BB#19:                                # %if.end20.i
                                        #   in Loop: Header=BB110_18 Depth=3
	movsbl	(%ebx), %eax
	incl	%ebx
	cmpl	$45, %eax
	je	.LBB110_18
# BB#20:                                # %if.end20.i
                                        #   in Loop: Header=BB110_13 Depth=2
	cmpl	$62, %eax
	jne	.LBB110_12
# BB#21:                                #   in Loop: Header=BB110_2 Depth=1
	movl	%ebx, %ecx
	jmp	.LBB110_31
.LBB110_24:                             # %if.then.i
                                        #   in Loop: Header=BB110_2 Depth=1
	addl	$4, %eax
	jmp	.LBB110_30
	.align	16, 0x90
.LBB110_160:                            # %do.end399
                                        #   in Loop: Header=BB110_99 Depth=2
	imull	$24, 60(%esp), %ecx     # 4-byte Folded Reload
	movl	%ecx, 64(%esp)          # 4-byte Spill
	movl	328(%esp), %eax
	movl	72(%esp), %edx          # 4-byte Reload
	movl	%eax, 16(%edx,%ecx)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	leal	320(%esp), %eax
	movl	%eax, %ecx
	movl	96(%esp), %edx          # 4-byte Reload
	calll	convert_and_copy
	movl	328(%esp), %eax
	movl	72(%esp), %ecx          # 4-byte Reload
	movl	64(%esp), %edx          # 4-byte Reload
	movl	%eax, 20(%ecx,%edx)
	movl	92(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	leal	320(%esp), %ecx
	movl	%ebp, %edx
	calll	convert_and_copy
	movl	72(%esp), %eax          # 4-byte Reload
	movl	64(%esp), %ecx          # 4-byte Reload
	movl	%esi, 8(%eax,%ecx)
	subl	%esi, %ebx
	movl	%ebx, 12(%eax,%ecx)
	xorb	%cl, %cl
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, 64(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB110_99:                             # %while.body114.outer526
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB110_100 Depth 3
                                        #         Child Loop BB110_130 Depth 4
                                        #         Child Loop BB110_141 Depth 4
                                        #           Child Loop BB110_142 Depth 5
                                        #         Child Loop BB110_136 Depth 4
                                        #         Child Loop BB110_117 Depth 4
                                        #         Child Loop BB110_109 Depth 4
                                        #       Child Loop BB110_151 Depth 3
	movb	%cl, 84(%esp)           # 1-byte Spill
	movl	76(%esp), %ecx          # 4-byte Reload
	.align	16, 0x90
.LBB110_100:                            # %while.cond116
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        # =>    This Loop Header: Depth=3
                                        #         Child Loop BB110_130 Depth 4
                                        #         Child Loop BB110_141 Depth 4
                                        #           Child Loop BB110_142 Depth 5
                                        #         Child Loop BB110_136 Depth 4
                                        #         Child Loop BB110_117 Depth 4
                                        #         Child Loop BB110_109 Depth 4
	movl	%ecx, %ebx
	movzbl	(%ebx), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB110_101
# BB#102:                               # %do.end132
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$47, %dl
	movl	100(%esp), %esi         # 4-byte Reload
	je	.LBB110_105
# BB#103:                               # %do.end132
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$62, %dl
	je	.LBB110_104
# BB#108:                               # %while.cond173.preheader
                                        #   in Loop: Header=BB110_100 Depth=3
	leal	2(%ebx), %esi
	leal	1(%ebx), %eax
	xorl	%ebp, %ebp
                                        # kill: DL<def> DL<kill> EDX<kill>
	jmp	.LBB110_109
.LBB110_101:                            # %do.body124
                                        #   in Loop: Header=BB110_100 Depth=3
	incl	%ebx
	cmpl	100(%esp), %ebx         # 4-byte Folded Reload
	movl	%ebx, %ecx
	jb	.LBB110_100
	jmp	.LBB110_165
	.align	16, 0x90
.LBB110_114:                            # %do.body195.while.cond173_crit_edge
                                        #   in Loop: Header=BB110_109 Depth=4
	incl	%esi
	incl	%eax
	incl	%ebp
	movb	(%edx), %dl
.LBB110_109:                            # %while.cond173
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	cmpb	$33, %dl
	jl	.LBB110_115
# BB#110:                               # %switch.early.test488
                                        #   in Loop: Header=BB110_109 Depth=4
	cmpb	$47, %dl
	je	.LBB110_115
# BB#111:                               # %switch.early.test488
                                        #   in Loop: Header=BB110_109 Depth=4
	movb	%dl, %ch
	addb	$-61, %ch
	cmpb	$2, %ch
	jb	.LBB110_115
# BB#112:                               # %switch.early.test488
                                        #   in Loop: Header=BB110_109 Depth=4
	cmpb	$127, %dl
	je	.LBB110_115
# BB#113:                               # %do.body195
                                        #   in Loop: Header=BB110_109 Depth=4
	leal	1(%ebx,%ebp), %edx
	cmpl	100(%esp), %edx         # 4-byte Folded Reload
	jae	.LBB110_165
	jmp	.LBB110_114
.LBB110_115:                            # %while.end202
                                        #   in Loop: Header=BB110_100 Depth=3
	leal	(%ebx,%ebp), %edi
	testl	%ebp, %ebp
	jne	.LBB110_117
	jmp	.LBB110_116
	.align	16, 0x90
.LBB110_119:                            # %do.body216.while.cond208_crit_edge
                                        #   in Loop: Header=BB110_117 Depth=4
	incl	%esi
	movb	(%eax), %dl
	incl	%eax
.LBB110_117:                            # %while.cond208
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	movzbl	%dl, %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	je	.LBB110_120
# BB#118:                               # %do.body216
                                        #   in Loop: Header=BB110_117 Depth=4
	cmpl	100(%esp), %eax         # 4-byte Folded Reload
	jae	.LBB110_165
	jmp	.LBB110_119
.LBB110_120:                            # %do.end224
                                        #   in Loop: Header=BB110_100 Depth=3
	movl	%ebp, 88(%esp)          # 4-byte Spill
	leal	-1(%eax), %ecx
	cmpb	$33, %dl
	jge	.LBB110_121
# BB#124:                               # %lor.lhs.false
                                        #   in Loop: Header=BB110_100 Depth=3
	movl	$1, 92(%esp)            # 4-byte Folded Spill
	cmpb	$47, %dl
	je	.LBB110_125
# BB#126:                               # %lor.lhs.false
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$62, %dl
	movl	%ebx, %ebp
	movl	%ebx, %esi
	movl	%ebx, 96(%esp)          # 4-byte Spill
	movl	%edi, %ebx
	je	.LBB110_148
# BB#127:                               # %lor.lhs.false
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$61, %dl
	je	.LBB110_129
	jmp	.LBB110_128
.LBB110_121:                            # %switch.early.test489
                                        #   in Loop: Header=BB110_100 Depth=3
	movl	%ebx, 96(%esp)          # 4-byte Spill
	cmpb	$61, %dl
	jne	.LBB110_122
.LBB110_129:                            # %do.body257
                                        #   in Loop: Header=BB110_100 Depth=3
	movl	100(%esp), %esi         # 4-byte Reload
	jmp	.LBB110_130
	.align	16, 0x90
.LBB110_132:                            # %do.body273
                                        #   in Loop: Header=BB110_130 Depth=4
	incl	%eax
.LBB110_130:                            # %do.body257
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	cmpl	%esi, %eax
	jae	.LBB110_165
# BB#131:                               # %while.cond265
                                        #   in Loop: Header=BB110_130 Depth=4
	movzbl	(%eax), %edx
	movzwl	_sch_istable(%edx,%edx), %ebx
	testb	$64, %bl
	jne	.LBB110_132
# BB#133:                               # %do.end281
                                        #   in Loop: Header=BB110_100 Depth=3
                                        # kill: DL<def> DL<kill> EDX<kill>
	cmpb	$34, %dl
	je	.LBB110_140
# BB#134:                               # %do.end281
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$39, %dl
	jne	.LBB110_135
.LBB110_140:                            # %if.then289
                                        #   in Loop: Header=BB110_100 Depth=3
	leal	1(%eax), %ebp
	xorb	%bh, %bh
	cmpl	%esi, %ebp
	jae	.LBB110_165
	.align	16, 0x90
.LBB110_141:                            # %while.cond297.outer
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        # =>      This Loop Header: Depth=4
                                        #           Child Loop BB110_142 Depth 5
	movb	%bh, %ch
	movb	%ch, %dh
	xorb	$1, %dh
	movl	%ebp, %edi
	.align	16, 0x90
.LBB110_142:                            # %while.cond297
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        #         Parent Loop BB110_141 Depth=4
                                        # =>        This Inner Loop Header: Depth=5
	movb	(%edi), %bl
	cmpb	%dl, %bl
	je	.LBB110_147
# BB#143:                               # %while.body302
                                        #   in Loop: Header=BB110_142 Depth=5
	cmpb	$10, %bl
	sete	%cl
	movb	$1, %bh
	testb	%dh, %cl
	jne	.LBB110_141
# BB#144:                               # %if.else309
                                        #   in Loop: Header=BB110_142 Depth=5
	cmpb	$62, %bl
	sete	%cl
	testb	%cl, %ch
	jne	.LBB110_146
# BB#145:                               # %do.body319
                                        #   in Loop: Header=BB110_142 Depth=5
	incl	%edi
	cmpl	%esi, %edi
	jb	.LBB110_142
	jmp	.LBB110_165
.LBB110_125:                            #   in Loop: Header=BB110_100 Depth=3
	movl	%ebx, %ebp
	movl	%ebx, %esi
	movl	%ebx, 96(%esp)          # 4-byte Spill
	movl	%edi, %ebx
	jmp	.LBB110_148
.LBB110_122:                            # %switch.early.test489
                                        #   in Loop: Header=BB110_100 Depth=3
	movl	$1, 92(%esp)            # 4-byte Folded Spill
	cmpb	$127, %dl
	movl	96(%esp), %eax          # 4-byte Reload
	movl	%eax, %ebp
	movl	%eax, %esi
	movl	%edi, %ebx
	jne	.LBB110_148
	jmp	.LBB110_123
.LBB110_135:                            #   in Loop: Header=BB110_100 Depth=3
	xorl	%esi, %esi
	leal	1(%eax), %edi
                                        # kill: DL<def> DL<kill> EDX<def>
	jmp	.LBB110_136
.LBB110_146:                            # %while.end326
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	%dl, %bl
	jne	.LBB110_2
.LBB110_147:                            # %do.body332
                                        #   in Loop: Header=BB110_100 Depth=3
	leal	1(%edi), %ecx
	cmpl	%esi, %ecx
	movl	%eax, %esi
	movl	%ecx, %ebx
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, 92(%esp)          # 4-byte Spill
	jae	.LBB110_165
	jmp	.LBB110_148
	.align	16, 0x90
.LBB110_139:                            # %do.body359.while.cond346_crit_edge
                                        #   in Loop: Header=BB110_136 Depth=4
	incl	%esi
	movzbl	(%edi), %edx
	incl	%edi
	movzwl	_sch_istable(%edx,%edx), %ebx
.LBB110_136:                            # %while.cond346
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        #       Parent Loop BB110_100 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	testb	$64, %bl
	jne	.LBB110_154
# BB#137:                               # %while.cond346
                                        #   in Loop: Header=BB110_136 Depth=4
	cmpb	$62, %dl
	je	.LBB110_154
# BB#138:                               # %do.body359
                                        #   in Loop: Header=BB110_136 Depth=4
	cmpl	100(%esp), %edi         # 4-byte Folded Reload
	jae	.LBB110_165
	jmp	.LBB110_139
.LBB110_154:                            # %while.end366
                                        #   in Loop: Header=BB110_100 Depth=3
	leal	(%eax,%esi), %ecx
	movl	$2, 92(%esp)            # 4-byte Folded Spill
	testl	%esi, %esi
	movl	%eax, %ebp
	movl	%ecx, %edi
	movl	%eax, %esi
	movl	%ecx, %ebx
	je	.LBB110_155
.LBB110_148:                            # %if.end374
                                        #   in Loop: Header=BB110_100 Depth=3
	cmpb	$0, 84(%esp)            # 1-byte Folded Reload
	jne	.LBB110_100
# BB#149:                               # %if.end377
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	%ecx, 76(%esp)          # 4-byte Spill
	movl	96(%esp), %edx          # 4-byte Reload
	movl	88(%esp), %eax          # 4-byte Reload
	addl	%edx, %eax
	movl	%eax, 88(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	648(%esp), %ecx
	calll	name_allowed
	xorb	%cl, %cl
	testb	%al, %al
	je	.LBB110_99
# BB#150:                               # %do.body381
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	60(%esp), %eax          # 4-byte Reload
	leal	1(%eax), %edx
	movl	64(%esp), %ecx          # 4-byte Reload
	.align	16, 0x90
.LBB110_151:                            # %while.cond382
                                        #   Parent Loop BB110_2 Depth=1
                                        #     Parent Loop BB110_99 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movl	%ecx, %eax
	leal	(%eax,%eax), %ecx
	cmpl	%edx, %eax
	jl	.LBB110_151
# BB#152:                               # %while.end386
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	%edx, 44(%esp)          # 4-byte Spill
	movl	64(%esp), %ecx          # 4-byte Reload
	cmpl	%ecx, %eax
	je	.LBB110_153
# BB#156:                               # %if.then389
                                        #   in Loop: Header=BB110_99 Depth=2
	testb	$1, 51(%esp)            # 1-byte Folded Reload
	jne	.LBB110_157
# BB#158:                               # %if.else393
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	%eax, 84(%esp)          # 4-byte Spill
	imull	$24, %eax, %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, %ecx
	movl	%ecx, 40(%esp)          # 4-byte Spill
	imull	$24, 64(%esp), %eax     # 4-byte Folded Reload
	movl	%eax, 8(%esp)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	memcpy
	movb	$1, 51(%esp)            # 1-byte Folded Spill
	movl	40(%esp), %eax          # 4-byte Reload
	jmp	.LBB110_159
.LBB110_153:                            #   in Loop: Header=BB110_99 Depth=2
	movl	%ecx, 84(%esp)          # 4-byte Spill
	jmp	.LBB110_160
.LBB110_157:                            # %if.then391
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	%eax, 84(%esp)          # 4-byte Spill
	imull	$24, %eax, %eax
	movl	%eax, 4(%esp)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_realloc
.LBB110_159:                            # %if.else393
                                        #   in Loop: Header=BB110_99 Depth=2
	movl	%eax, 72(%esp)          # 4-byte Spill
	jmp	.LBB110_160
	.align	16, 0x90
.LBB110_107:                            # %do.body153
                                        #   in Loop: Header=BB110_105 Depth=2
	movb	%cl, 84(%esp)           # 1-byte Spill
.LBB110_105:                            # %do.body137
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	incl	%ebx
	cmpl	%esi, %ebx
	jae	.LBB110_165
# BB#106:                               # %while.cond145
                                        #   in Loop: Header=BB110_105 Depth=2
	movzbl	(%ebx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	movb	84(%esp), %cl           # 1-byte Reload
	jne	.LBB110_107
# BB#161:                               # %do.end161
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpb	$62, %al
	movl	68(%esp), %edi          # 4-byte Reload
	movl	52(%esp), %eax          # 4-byte Reload
	jne	.LBB110_2
	jmp	.LBB110_162
.LBB110_104:                            #   in Loop: Header=BB110_2 Depth=1
	movl	52(%esp), %eax          # 4-byte Reload
	movb	84(%esp), %cl           # 1-byte Reload
.LBB110_162:                            # %while.end409
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%ebx, %ebp
	testb	%cl, %cl
	movl	56(%esp), %edi          # 4-byte Reload
	jne	.LBB110_163
# BB#170:                               # %if.end419
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	320(%esp), %edx
	movl	%edx, 104(%esp)
	movl	%eax, 108(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 112(%esp)
	testl	%eax, %eax
	movl	%eax, %ebx
	jle	.LBB110_174
# BB#171:                               # %for.body.preheader
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	72(%esp), %eax          # 4-byte Reload
	leal	20(%eax), %eax
	xorl	%ecx, %ecx
	jmp	.LBB110_172
	.align	16, 0x90
.LBB110_173:                            # %for.body.for.body_crit_edge
                                        #   in Loop: Header=BB110_172 Depth=2
	addl	$24, %eax
	movl	320(%esp), %edx
.LBB110_172:                            # %for.body
                                        #   Parent Loop BB110_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	addl	-4(%eax), %edx
	movl	%edx, -20(%eax)
	movl	320(%esp), %edx
	addl	(%eax), %edx
	movl	%edx, -16(%eax)
	incl	%ecx
	cmpl	%ecx, %ebx
	jne	.LBB110_173
.LBB110_174:                            # %for.end
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 116(%esp)
	movl	%edi, 120(%esp)
	incl	%ebp
	movl	%ebp, 124(%esp)
	movl	636(%esp), %eax
	movl	%eax, 4(%esp)
	leal	104(%esp), %eax
	movl	%eax, (%esp)
	calll	*632(%esp)
	jmp	.LBB110_164
.LBB110_163:                            # %do.body412
                                        #   in Loop: Header=BB110_2 Depth=1
	incl	%ebp
.LBB110_164:                            # %do.body412
                                        #   in Loop: Header=BB110_2 Depth=1
	cmpl	%esi, %ebp
	movl	%ebp, %edi
	jb	.LBB110_2
	jmp	.LBB110_165
.LBB110_29:                             # %if.then38.i
                                        #   in Loop: Header=BB110_2 Depth=1
	decl	%eax
.LBB110_30:                             # %if.then38.i
                                        #   in Loop: Header=BB110_2 Depth=1
	movl	%eax, %ecx
.LBB110_31:                             # %find_comment_end.exit
                                        #   in Loop: Header=BB110_2 Depth=1
	testl	%ecx, %ecx
	cmovnel	%ecx, %edx
	jmp	.LBB110_82
.LBB110_116:                            #   in Loop: Header=BB110_2 Depth=1
	movl	68(%esp), %edi          # 4-byte Reload
	jmp	.LBB110_2
.LBB110_128:                            #   in Loop: Header=BB110_2 Depth=1
	movl	68(%esp), %edi          # 4-byte Reload
	jmp	.LBB110_2
.LBB110_123:                            #   in Loop: Header=BB110_2 Depth=1
	movl	68(%esp), %edi          # 4-byte Reload
	jmp	.LBB110_2
.LBB110_165:                            # %do.body445
	cmpb	$0, 332(%esp)
	je	.LBB110_167
# BB#166:                               # %if.then449
	movl	320(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
.LBB110_167:                            # %if.end451
	movl	336(%esp), %eax
	movl	%eax, 320(%esp)
	movl	340(%esp), %eax
	movl	%eax, 324(%esp)
	movl	$0, 328(%esp)
	movb	$0, 332(%esp)
	testb	$1, 51(%esp)            # 1-byte Folded Reload
	je	.LBB110_169
# BB#168:                               # %if.then460
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
.LBB110_169:                            # %if.end461
	addl	$604, %esp              # imm = 0x25C
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB110_175:                            # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.advance_declaration, 12(%esp)
	movl	$560, 8(%esp)           # imm = 0x230
	movl	$.L.str1372, 4(%esp)
	movl	$.L.str2373, (%esp)
	calll	__assert_fail
.LBB110_71:                             # %cond.false101.i
	movl	$.L__PRETTY_FUNCTION__.advance_declaration, 12(%esp)
	movl	$579, 8(%esp)           # imm = 0x243
	jmp	.LBB110_72
.LBB110_78:                             # %cond.false121.i
	movl	$.L__PRETTY_FUNCTION__.advance_declaration, 12(%esp)
	movl	$606, 8(%esp)           # imm = 0x25E
.LBB110_72:                             # %cond.false101.i
	movl	$.L.str1372, 4(%esp)
	movl	$.L.str4375, (%esp)
	calll	__assert_fail
.LBB110_69:                             # %cond.false93.i
	movl	$.L__PRETTY_FUNCTION__.advance_declaration, 12(%esp)
	movl	$574, 8(%esp)           # imm = 0x23E
	movl	$.L.str1372, 4(%esp)
	movl	$.L.str3374, (%esp)
	calll	__assert_fail
.Ltmp110:
	.size	map_html_tags, .Ltmp110-map_html_tags
	.section	.rodata,"a",@progbits
	.align	4
.LJTI110_0:
	.long	.LBB110_37
	.long	.LBB110_40
	.long	.LBB110_57
	.long	.LBB110_70
	.long	.LBB110_74
	.long	.LBB110_76
	.long	.LBB110_77
	.long	.LBB110_80
	.long	.LBB110_63
	.long	.LBB110_66
	.long	.LBB110_68

	.text
	.align	16, 0x90
	.type	name_allowed,@function
name_allowed:                           # @name_allowed
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%ecx, %esi
	movb	$1, %al
	testl	%esi, %esi
	je	.LBB111_2
# BB#1:                                 # %do.body
	movl	8(%ebp), %edi
	subl	%edx, %edi
	leal	16(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%edx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%edi,%ebx)
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	testl	%eax, %eax
	setne	%al
.LBB111_2:                              # %return
	movzbl	%al, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp111:
	.size	name_allowed, .Ltmp111-name_allowed

	.align	16, 0x90
	.type	convert_and_copy,@function
convert_and_copy:                       # @convert_and_copy
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	%edx, %edi
	movl	8(%ecx), %eax
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	%ecx, %ebx
	movl	68(%esp), %eax
	movl	64(%esp), %esi
	movl	%eax, %ebp
	andl	$4, %ebp
	je	.LBB112_6
	.align	16, 0x90
.LBB112_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %eax
	cmpl	%esi, %eax
	jae	.LBB112_3
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB112_1 Depth=1
	leal	1(%eax), %edi
	movzbl	(%eax), %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB112_1
	.align	16, 0x90
.LBB112_3:                              # %while.cond5
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, %ecx
	cmpl	%eax, %ecx
	jbe	.LBB112_5
# BB#4:                                 # %land.rhs8
                                        #   in Loop: Header=BB112_3 Depth=1
	leal	-1(%ecx), %esi
	movzbl	-1(%ecx), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB112_3
.LBB112_5:
	movl	%ecx, %esi
	movl	%eax, %edi
.LBB112_6:                              # %if.end
	movl	%esi, %eax
	subl	%edi, %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	32(%esp), %ecx          # 4-byte Reload
	leal	(%ecx,%eax), %ecx
	movl	4(%ebx), %eax
	movl	68(%esp), %edx
	testb	$2, %dl
	je	.LBB112_7
# BB#11:
	movl	%ebp, 36(%esp)          # 4-byte Spill
	movl	%eax, %edx
	.align	16, 0x90
.LBB112_12:                             # %while.cond27
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, %ebp
	leal	(%ebp,%ebp), %edx
	cmpl	%ecx, %ebp
	jl	.LBB112_12
# BB#13:                                # %while.end31
	cmpl	%eax, %ebp
	jne	.LBB112_15
# BB#14:                                # %while.end31.do.end_crit_edge
	movl	%ebx, 28(%esp)          # 4-byte Spill
	movl	(%ebx), %eax
	movl	%ebx, %edx
	movl	32(%esp), %ecx          # 4-byte Reload
	jmp	.LBB112_19
.LBB112_7:
	movl	%eax, %edx
	.align	16, 0x90
.LBB112_8:                              # %while.cond154
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, %esi
	leal	(%esi,%esi), %edx
	cmpl	%ecx, %esi
	jl	.LBB112_8
# BB#9:                                 # %while.end159
	cmpl	%eax, %esi
	jne	.LBB112_106
# BB#10:                                # %while.end159.do.end183_crit_edge
	movl	(%ebx), %ebp
	movl	%ebx, 40(%esp)          # 4-byte Spill
	movl	32(%esp), %eax          # 4-byte Reload
	jmp	.LBB112_110
.LBB112_15:                             # %if.then35
	cmpb	$0, 12(%ebx)
	je	.LBB112_17
# BB#16:                                # %if.then37
	movl	(%ebx), %eax
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, (%ebx)
	jmp	.LBB112_18
.LBB112_106:                            # %if.then163
	cmpb	$0, 12(%ebx)
	je	.LBB112_108
# BB#107:                               # %if.then166
	movl	(%ebx), %eax
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, (%ebx)
	jmp	.LBB112_109
.LBB112_17:                             # %if.else
	movl	%ebp, (%esp)
	calll	checking_malloc
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	(%ebx), %edx
	movl	4(%ebx), %ecx
	movl	%ecx, 8(%esp)
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	calll	memcpy
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%ebx)
	movb	$1, 12(%ebx)
.LBB112_18:                             # %if.end46
	movl	%ebp, 4(%ebx)
	movl	8(%ebx), %ecx
	movl	%ebx, %edx
	movl	%ebx, 28(%esp)          # 4-byte Spill
.LBB112_19:                             # %do.end
	movl	%edx, 20(%esp)          # 4-byte Spill
	addl	%eax, %ecx
	movl	36(%esp), %ebp          # 4-byte Reload
	jmp	.LBB112_20
	.align	16, 0x90
.LBB112_95:                             # %if.else80
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	%al, (%ecx)
	incl	%ecx
	.align	16, 0x90
.LBB112_20:                             # %while.cond51
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB112_57 Depth 2
                                        #     Child Loop BB112_29 Depth 2
	cmpl	%esi, %edi
	jae	.LBB112_96
# BB#21:                                # %while.body54
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	(%edi), %al
	cmpb	$10, %al
	je	.LBB112_94
# BB#22:                                # %while.body54
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpb	$13, %al
	jne	.LBB112_23
.LBB112_94:                             # %land.lhs.true
                                        #   in Loop: Header=BB112_20 Depth=1
	incl	%edi
	testl	%ebp, %ebp
	jne	.LBB112_20
	jmp	.LBB112_95
.LBB112_23:                             # %while.body54
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpb	$38, %al
	jne	.LBB112_24
# BB#25:                                # %if.then58
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	%ecx, 40(%esp)          # 4-byte Spill
	leal	1(%edi), %ecx
	movb	$38, %al
	cmpl	%esi, %ecx
	je	.LBB112_93
# BB#26:                                # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movsbl	1(%edi), %ecx
	movb	$38, %al
	cmpl	$96, %ecx
	jg	.LBB112_34
# BB#27:                                # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$35, %ecx
	jne	.LBB112_93
# BB#28:                                # %sw.bb.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$2, %edx
	xorl	%ecx, %ecx
	movl	$3, %ebp
	cmpb	$120, 2(%edi)
	jne	.LBB112_57
	jmp	.LBB112_29
.LBB112_24:                             # %while.body54.if.else80_crit_edge
                                        #   in Loop: Header=BB112_20 Depth=1
	incl	%edi
	jmp	.LBB112_95
.LBB112_34:                             # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$102, %ecx
	jg	.LBB112_44
# BB#35:                                # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$97, %ecx
	jne	.LBB112_93
# BB#36:                                # %sw.bb137.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	4(%edi), %ebx
	cmpl	%esi, %ebx
	je	.LBB112_39
# BB#37:                                # %lor.lhs.false141.i
                                        #   in Loop: Header=BB112_20 Depth=1
	jae	.LBB112_82
# BB#38:                                # %land.lhs.true145.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movzbl	(%ebx), %eax
	testb	$-116, _sch_istable(%eax,%eax)
	jne	.LBB112_82
.LBB112_39:                             # %land.lhs.true153.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpb	$109, 2(%edi)
	jne	.LBB112_82
# BB#40:                                # %land.lhs.true158.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpb	$112, 3(%edi)
	jne	.LBB112_82
# BB#41:                                # %if.then163.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$38, %ecx
	cmpl	%esi, %ebx
	jae	.LBB112_43
# BB#42:                                # %land.lhs.true167.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	5(%edi), %eax
	cmpb	$59, 4(%edi)
	cmovel	%eax, %ebx
	movl	$38, %ecx
.LBB112_43:                             # %land.lhs.true167.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	%ebx, %edi
	jmp	.LBB112_75
	.align	16, 0x90
.LBB112_56:                             # %cond.end.i
                                        #   in Loop: Header=BB112_29 Depth=2
	addl	%eax, %ecx
	incl	%ebp
.LBB112_29:                             # %for.cond.i
                                        #   Parent Loop BB112_20 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	(%edi,%ebp), %ebx
	cmpl	$255, %ecx
	jg	.LBB112_62
# BB#30:                                # %for.cond.i
                                        #   in Loop: Header=BB112_29 Depth=2
	cmpl	%esi, %ebx
	jae	.LBB112_62
# BB#31:                                # %land.rhs.i
                                        #   in Loop: Header=BB112_29 Depth=2
	movsbl	(%edi,%ebp), %eax
	movzbl	%al, %edx
	testb	$1, _sch_istable+1(%edx,%edx)
	je	.LBB112_62
# BB#32:                                # %for.body.i
                                        #   in Loop: Header=BB112_29 Depth=2
	shll	$4, %ecx
	cmpb	$64, %al
	jg	.LBB112_55
# BB#33:                                # %cond.true.i
                                        #   in Loop: Header=BB112_29 Depth=2
	addl	$-48, %eax
	jmp	.LBB112_56
.LBB112_55:                             # %cond.false.i
                                        #   in Loop: Header=BB112_29 Depth=2
	movzbl	_sch_toupper(%edx), %eax
	addl	$-55, %eax
	jmp	.LBB112_56
	.align	16, 0x90
.LBB112_60:                             # %for.body39.i
                                        #   in Loop: Header=BB112_57 Depth=2
	imull	$10, %ecx, %ecx
	leal	-48(%ecx,%eax), %ecx
	incl	%edx
.LBB112_57:                             # %for.cond25.i
                                        #   Parent Loop BB112_20 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	(%edi,%edx), %ebx
	cmpl	$255, %ecx
	jg	.LBB112_61
# BB#58:                                # %for.cond25.i
                                        #   in Loop: Header=BB112_57 Depth=2
	cmpl	%esi, %ebx
	jae	.LBB112_61
# BB#59:                                # %land.rhs31.i
                                        #   in Loop: Header=BB112_57 Depth=2
	movsbl	(%edi,%edx), %eax
	movzbl	%al, %ebp
	testb	$4, _sch_istable(%ebp,%ebp)
	jne	.LBB112_60
.LBB112_61:                             # %if.end47.i.loopexit
                                        #   in Loop: Header=BB112_20 Depth=1
	addl	$-2, %edx
	jmp	.LBB112_63
.LBB112_44:                             # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$103, %ecx
	jne	.LBB112_45
# BB#68:                                # %sw.bb67.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	3(%edi), %edx
	cmpl	%esi, %edx
	je	.LBB112_71
# BB#69:                                # %lor.lhs.false71.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	jae	.LBB112_93
# BB#70:                                # %land.lhs.true75.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movzbl	(%edx), %ecx
	movb	$38, %al
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB112_93
.LBB112_71:                             # %land.lhs.true83.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$116, 2(%edi)
	jne	.LBB112_93
# BB#72:                                # %if.then88.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$62, %ecx
	cmpl	%esi, %edx
	jae	.LBB112_74
# BB#73:                                # %land.lhs.true92.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	4(%edi), %eax
	cmpb	$59, 3(%edi)
	cmovel	%eax, %edx
	movl	$62, %ecx
	jmp	.LBB112_74
.LBB112_45:                             # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$108, %ecx
	jne	.LBB112_46
# BB#76:                                # %sw.bb102.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	3(%edi), %edx
	cmpl	%esi, %edx
	je	.LBB112_79
# BB#77:                                # %lor.lhs.false106.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	jae	.LBB112_93
# BB#78:                                # %land.lhs.true110.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movzbl	(%edx), %ecx
	movb	$38, %al
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB112_93
.LBB112_79:                             # %land.lhs.true118.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$116, 2(%edi)
	jne	.LBB112_93
# BB#80:                                # %if.then123.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$60, %ecx
	cmpl	%esi, %edx
	jae	.LBB112_74
# BB#81:                                # %land.lhs.true127.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	4(%edi), %eax
	cmpb	$59, 3(%edi)
	cmovel	%eax, %edx
	movl	$60, %ecx
	jmp	.LBB112_74
.LBB112_62:                             # %if.end47.i.loopexit1
                                        #   in Loop: Header=BB112_20 Depth=1
	addl	$-3, %ebp
	movl	%ebp, %edx
.LBB112_63:                             # %if.end47.i.loopexit1
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	36(%esp), %ebp          # 4-byte Reload
	movb	$38, %al
	testl	%edx, %edx
	je	.LBB112_93
# BB#64:                                # %if.end50.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	testl	%ecx, %ecx
	je	.LBB112_93
# BB#65:                                # %if.end50.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$127, %ecx
	ja	.LBB112_93
# BB#66:                                # %if.end55.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	%esi, %ebx
	jae	.LBB112_67
# BB#90:                                # %land.lhs.true58.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	1(%ebx), %edi
	cmpb	$59, (%ebx)
	cmovnel	%ebx, %edi
	jmp	.LBB112_91
.LBB112_82:                             # %if.else176.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	5(%edi), %edx
	cmpl	%esi, %edx
	je	.LBB112_85
# BB#83:                                # %lor.lhs.false180.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	jae	.LBB112_93
# BB#84:                                # %land.lhs.true184.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movzbl	(%edx), %ecx
	movb	$38, %al
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB112_93
.LBB112_85:                             # %land.lhs.true192.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$112, 2(%edi)
	jne	.LBB112_93
# BB#86:                                # %land.lhs.true197.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$111, 3(%edi)
	jne	.LBB112_93
# BB#87:                                # %land.lhs.true202.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$115, (%ebx)
	jne	.LBB112_93
# BB#88:                                # %if.then207.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$39, %ecx
	cmpl	%esi, %edx
	jae	.LBB112_74
# BB#89:                                # %land.lhs.true211.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	6(%edi), %eax
	cmpb	$59, 5(%edi)
	cmovel	%eax, %edx
	movl	$39, %ecx
	jmp	.LBB112_74
.LBB112_46:                             # %if.end.i
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$113, %ecx
	jne	.LBB112_93
# BB#47:                                # %sw.bb222.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	5(%edi), %edx
	cmpl	%esi, %edx
	je	.LBB112_50
# BB#48:                                # %lor.lhs.false226.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	jae	.LBB112_93
# BB#49:                                # %land.lhs.true230.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movzbl	(%edx), %ecx
	movb	$38, %al
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB112_93
.LBB112_50:                             # %land.lhs.true238.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$117, 2(%edi)
	jne	.LBB112_93
# BB#51:                                # %land.lhs.true243.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$111, 3(%edi)
	jne	.LBB112_93
# BB#52:                                # %land.lhs.true248.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	$38, %al
	cmpb	$116, 4(%edi)
	jne	.LBB112_93
# BB#53:                                # %if.then253.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	$34, %ecx
	cmpl	%esi, %edx
	jae	.LBB112_74
# BB#54:                                # %land.lhs.true257.i
                                        #   in Loop: Header=BB112_20 Depth=1
	leal	6(%edi), %eax
	cmpb	$59, 5(%edi)
	cmovel	%eax, %edx
	movl	$34, %ecx
.LBB112_74:                             # %land.lhs.true92.i
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	%edx, %edi
	.align	16, 0x90
.LBB112_75:                             # %if.then62
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	40(%esp), %eax          # 4-byte Reload
	movb	%cl, (%eax)
	movl	%eax, %ecx
	incl	%ecx
	jmp	.LBB112_20
.LBB112_67:                             #   in Loop: Header=BB112_20 Depth=1
	movl	%ebx, %edi
.LBB112_91:                             # %decode_entity.exit
                                        #   in Loop: Header=BB112_20 Depth=1
	cmpl	$-1, %ecx
	jne	.LBB112_75
# BB#92:                                # %decode_entity.exit.if.else65_crit_edge
                                        #   in Loop: Header=BB112_20 Depth=1
	movb	(%edi), %al
.LBB112_93:                             # %if.else65
                                        #   in Loop: Header=BB112_20 Depth=1
	movl	40(%esp), %ecx          # 4-byte Reload
	movb	%al, (%ecx)
	incl	%edi
	incl	%ecx
	jmp	.LBB112_20
.LBB112_96:                             # %while.end85
	movl	28(%esp), %edx          # 4-byte Reload
	movl	(%edx), %edi
	movl	8(%edx), %eax
	addl	%edi, %eax
	movl	%ecx, %esi
	subl	%eax, %ecx
	cmpl	24(%esp), %ecx          # 4-byte Folded Reload
	jg	.LBB112_124
# BB#97:                                # %cond.end
	subl	%edi, %esi
	movl	%esi, 40(%esp)          # 4-byte Spill
	movl	%esi, 8(%edx)
	leal	1(%esi), %ecx
	movl	4(%edx), %eax
	movl	%edx, %ebx
	movl	%eax, %edx
	.align	16, 0x90
.LBB112_98:                             # %while.cond109
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, %esi
	leal	(%esi,%esi), %edx
	cmpl	%ecx, %esi
	jl	.LBB112_98
# BB#99:                                # %while.end114
	cmpl	%eax, %esi
	je	.LBB112_100
# BB#101:                               # %if.then118
	cmpb	$0, 12(%ebx)
	je	.LBB112_103
# BB#102:                               # %if.then121
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	checking_realloc
	movl	%eax, %edi
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%edi, (%eax)
	jmp	.LBB112_104
.LBB112_100:
	movl	%ebx, %ebp
	movl	40(%esp), %ecx          # 4-byte Reload
	jmp	.LBB112_105
.LBB112_108:                            # %if.else171
	movl	%esi, (%esp)
	calll	checking_malloc
	movl	%eax, %ebp
	movl	(%ebx), %eax
	movl	4(%ebx), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	memcpy
	movl	%ebp, (%ebx)
	movb	$1, 12(%ebx)
.LBB112_109:                            # %if.end180
	movl	%esi, 4(%ebx)
	movl	8(%ebx), %eax
	movl	%ebx, 40(%esp)          # 4-byte Spill
.LBB112_110:                            # %do.end183
	movl	24(%esp), %esi          # 4-byte Reload
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	addl	%ebp, %eax
	movl	%eax, (%esp)
	calll	memcpy
	movl	8(%ebx), %ecx
	leal	(%ecx,%esi), %eax
	movl	%eax, 8(%ebx)
	leal	1(%ecx,%esi), %edx
	movl	4(%ebx), %ecx
	movl	%ebx, %ebp
	movl	%ecx, %edi
	.align	16, 0x90
.LBB112_111:                            # %while.cond198
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ebx
	leal	(%ebx,%ebx), %edi
	cmpl	%edx, %ebx
	jl	.LBB112_111
# BB#112:                               # %while.end203
	cmpl	%ecx, %ebx
	movl	40(%esp), %esi          # 4-byte Reload
	jne	.LBB112_114
# BB#113:                               # %while.end203.do.end227_crit_edge
	movl	(%esi), %edi
	jmp	.LBB112_118
.LBB112_114:                            # %if.then207
	cmpb	$0, 12(%ebp)
	je	.LBB112_116
# BB#115:                               # %if.then210
	movl	(%esi), %eax
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, %edi
	movl	%edi, (%esi)
	jmp	.LBB112_117
.LBB112_116:                            # %if.else215
	movl	%ebx, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	(%ebp), %eax
	movl	4(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	movl	%edi, (%ebp)
	movb	$1, 12(%ebp)
.LBB112_117:                            # %if.end224
	movl	%ebx, 4(%ebp)
	movl	8(%ebp), %eax
.LBB112_118:                            # %do.end227
	leal	1(%eax), %ecx
	movl	%ecx, 8(%ebp)
	movb	$0, (%edi,%eax)
	jmp	.LBB112_119
.LBB112_103:                            # %if.else126
	movl	%esi, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	(%ebx), %eax
	movl	4(%ebx), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	movl	%edi, (%ebx)
	movb	$1, 12(%ebx)
.LBB112_104:                            # %if.end135
	movl	%esi, 4(%ebx)
	movl	8(%ebx), %ecx
	movl	%ebx, %ebp
.LBB112_105:                            # %do.end138
	leal	1(%ecx), %eax
	movl	%eax, 8(%ebp)
	movb	$0, (%edi,%ecx)
.LBB112_119:                            # %if.end233
	movl	68(%esp), %eax
	testb	$1, %al
	movl	32(%esp), %edx          # 4-byte Reload
	je	.LBB112_123
# BB#120:                               # %if.then236
	movl	(%ebp), %ecx
	movb	(%ecx,%edx), %al
	testb	%al, %al
	je	.LBB112_123
# BB#121:                               # %for.body.preheader
	leal	1(%edx,%ecx), %ecx
	.align	16, 0x90
.LBB112_122:                            # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%al, %eax
	movb	_sch_tolower(%eax), %al
	movb	%al, -1(%ecx)
	movb	(%ecx), %al
	incl	%ecx
	testb	%al, %al
	jne	.LBB112_122
.LBB112_123:                            # %if.end244
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB112_124:                            # %cond.false
	movl	$.L__PRETTY_FUNCTION__.convert_and_copy, 12(%esp)
	movl	$411, 8(%esp)           # imm = 0x19B
	movl	$.L.str1372, 4(%esp)
	movl	$.L.str371, (%esp)
	calll	__assert_fail
.Ltmp112:
	.size	convert_and_copy, .Ltmp112-convert_and_copy

	.globl	get_urls_html
	.align	16, 0x90
	.type	get_urls_html,@function
get_urls_html:                          # @get_urls_html
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	80(%esp), %ebx
	movl	%ebx, (%esp)
	calll	read_file
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB113_1
# BB#2:                                 # %do.body
	movl	84(%esp), %edi
	cmpb	$0, opt+250
	jne	.LBB113_3
	.align	16, 0x90
.LBB113_4:                              # %do.end
	movl	(%esi), %eax
	movl	%eax, 32(%esp)
	movl	$0, 56(%esp)
	movl	$0, 52(%esp)
	movl	$0, 36(%esp)
	testl	%edi, %edi
	cmovel	opt+164, %edi
	movl	%edi, 40(%esp)
	movl	%ebx, 44(%esp)
	movb	$0, 48(%esp)
	movl	interesting_tags, %eax
	testl	%eax, %eax
	jne	.LBB113_21
# BB#5:                                 # %if.then11
	movl	$22, (%esp)
	calll	make_nocase_string_hash_table
	movl	%eax, interesting_tags
	movl	known_tags+4, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$known_tags, 8(%esp)
	calll	hash_table_put
	xorl	%edi, %edi
	.align	16, 0x90
.LBB113_6:                              # %for.body.for.body_crit_edge.i
                                        # =>This Inner Loop Header: Depth=1
	movl	known_tags+16(%edi), %eax
	movl	interesting_tags, %ecx
	leal	known_tags+12(%edi), %edx
	movl	%edx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	hash_table_put
	addl	$12, %edi
	cmpl	$252, %edi
	jne	.LBB113_6
# BB#7:                                 # %for.end.i
	movl	opt+96, %edi
	testl	%edi, %edi
	je	.LBB113_11
# BB#8:                                 # %for.cond1.preheader.i
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB113_11
# BB#9:                                 # %for.body3.i.preheader
	addl	$4, %edi
	.align	16, 0x90
.LBB113_10:                             # %for.body3.i
                                        # =>This Inner Loop Header: Depth=1
	movl	interesting_tags, %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	hash_table_remove
	movl	(%edi), %eax
	addl	$4, %edi
	testl	%eax, %eax
	jne	.LBB113_10
.LBB113_11:                             # %if.end.i
	cmpl	$0, opt+92
	je	.LBB113_18
# BB#12:                                # %if.then8.i
	movl	$0, (%esp)
	calll	make_nocase_string_hash_table
	movl	%eax, %edi
	movl	opt+92, %ebp
	movl	(%ebp), %ecx
	movl	interesting_tags, %eax
	testl	%ecx, %ecx
	je	.LBB113_17
# BB#13:                                # %for.body12.i.preheader
	addl	$4, %ebp
	.align	16, 0x90
.LBB113_14:                             # %for.body12.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	testl	%eax, %eax
	je	.LBB113_16
# BB#15:                                # %if.end16.i
                                        #   in Loop: Header=BB113_14 Depth=1
	movl	-4(%ebp), %ecx
	movl	%eax, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%edi, (%esp)
	calll	hash_table_put
.LBB113_16:                             # %for.inc17.i
                                        #   in Loop: Header=BB113_14 Depth=1
	movl	(%ebp), %ecx
	addl	$4, %ebp
	movl	interesting_tags, %eax
	testl	%ecx, %ecx
	jne	.LBB113_14
.LBB113_17:                             # %for.end19.i
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	%edi, interesting_tags
.LBB113_18:                             # %if.end20.i
	movl	$10, (%esp)
	calll	make_nocase_string_hash_table
	movl	%eax, interesting_attributes
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	movl	$.L.str13389, 4(%esp)
	calll	hash_table_put
	movl	interesting_attributes, %eax
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	movl	$.L.str14390, 4(%esp)
	calll	hash_table_put
	movl	interesting_attributes, %eax
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	movl	$.L.str15391, 4(%esp)
	calll	hash_table_put
	movl	interesting_attributes, %eax
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	movl	$.L.str16392, 4(%esp)
	calll	hash_table_put
	movl	interesting_attributes, %eax
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	movl	$.L.str17393, 4(%esp)
	calll	hash_table_put
	movl	$-252, %edi
	.align	16, 0x90
.LBB113_19:                             # %for.body31.i
                                        # =>This Inner Loop Header: Depth=1
	movl	interesting_attributes, %eax
	movl	tag_url_attributes+256(%edi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$.L.str6382, 8(%esp)
	calll	hash_table_put
	addl	$12, %edi
	jne	.LBB113_19
# BB#20:                                # %if.end12.loopexit
	movl	interesting_tags, %eax
.LBB113_21:                             # %if.end12
	movl	88(%esp), %edi
	movl	(%esi), %ecx
	movl	4(%esi), %edx
	cmpb	$0, opt+332
	setne	%bl
	movl	interesting_attributes, %ebp
	movl	%eax, 20(%esp)
	movl	%ebp, 24(%esp)
	movzbl	%bl, %eax
	orl	$2, %eax
	movl	%eax, 16(%esp)
	leal	32(%esp), %eax
	movl	%eax, 12(%esp)
	movl	%edx, 4(%esp)
	movl	%ecx, (%esp)
	movl	$collect_tags_mapper, 8(%esp)
	calll	map_html_tags
	cmpb	$0, opt+250
	jne	.LBB113_22
	.align	16, 0x90
.LBB113_23:                             # %do.end28
	testl	%edi, %edi
	je	.LBB113_25
# BB#24:                                # %if.then30
	movb	48(%esp), %al
	movb	%al, (%edi)
.LBB113_25:                             # %if.end33
	movl	36(%esp), %eax
	testl	%eax, %eax
	je	.LBB113_27
# BB#26:                                # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB113_27:                             # %if.end38
	movl	%esi, (%esp)
	calll	read_file_free
	movl	52(%esp), %eax
	jmp	.LBB113_28
.LBB113_1:                              # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	$.L.str376, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
.LBB113_28:                             # %return
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB113_3:                              # %if.then5
	movl	4(%esi), %eax
	movl	%eax, %ecx
	sarl	$31, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$.L.str1377, (%esp)
	calll	debug_logprintf
	jmp	.LBB113_4
.LBB113_22:                             # %if.then23
	movzbl	48(%esp), %eax
	movl	%eax, 8(%esp)
	movl	80(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str2378, (%esp)
	calll	debug_logprintf
	jmp	.LBB113_23
.Ltmp113:
	.size	get_urls_html, .Ltmp113-get_urls_html

	.align	16, 0x90
	.type	collect_tags_mapper,@function
collect_tags_mapper:                    # @collect_tags_mapper
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	32(%esp), %esi
	movl	(%esi), %eax
	movl	interesting_tags, %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	hash_table_get
	testl	%eax, %eax
	je	.LBB114_2
# BB#1:                                 # %cond.end
	movl	36(%esp), %ecx
	movl	(%eax), %edx
	movl	%ecx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%edx, (%esp)
	calll	*8(%eax)
	addl	$24, %esp
	popl	%esi
	ret
.LBB114_2:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.collect_tags_mapper, 12(%esp)
	movl	$576, 8(%esp)           # imm = 0x240
	movl	$.L.str5381, 4(%esp)
	movl	$.L.str4380, (%esp)
	calll	__assert_fail
.Ltmp114:
	.size	collect_tags_mapper, .Ltmp114-collect_tags_mapper

	.globl	get_urls_file
	.align	16, 0x90
	.type	get_urls_file,@function
get_urls_file:                          # @get_urls_file
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	64(%esp), %esi
	movl	%esi, (%esp)
	calll	read_file
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB115_1
# BB#2:                                 # %do.body
	cmpb	$0, opt+250
	jne	.LBB115_3
	.align	16, 0x90
.LBB115_4:                              # %do.end
	movl	(%edi), %ebx
	movl	%edi, 28(%esp)          # 4-byte Spill
	movl	4(%edi), %edi
	addl	%ebx, %edi
	xorl	%eax, %eax
	jmp	.LBB115_5
.LBB115_1:                              # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str376, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
	jmp	.LBB115_23
.LBB115_3:                              # %if.then5
	movl	4(%edi), %eax
	movl	%eax, %ecx
	sarl	$31, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str1377, (%esp)
	calll	debug_logprintf
	jmp	.LBB115_4
	.align	16, 0x90
.LBB115_20:                             #   in Loop: Header=BB115_5 Depth=1
	movl	%esi, %ebx
.LBB115_5:                              # %while.cond.outer.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB115_6 Depth 2
                                        #       Child Loop BB115_7 Depth 3
                                        #         Child Loop BB115_11 Depth 4
                                        #         Child Loop BB115_9 Depth 4
	movl	%eax, 32(%esp)          # 4-byte Spill
	jmp	.LBB115_6
	.align	16, 0x90
.LBB115_21:                             # %if.else60
                                        #   in Loop: Header=BB115_6 Depth=2
	movl	36(%esp), %ecx          # 4-byte Reload
	movl	%eax, 28(%ecx)
	movl	%esi, %ebx
.LBB115_6:                              # %while.cond.outer
                                        #   Parent Loop BB115_5 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB115_7 Depth 3
                                        #         Child Loop BB115_11 Depth 4
                                        #         Child Loop BB115_9 Depth 4
	movl	%eax, 36(%esp)          # 4-byte Spill
	jmp	.LBB115_7
	.align	16, 0x90
.LBB115_18:                             # %if.then52
                                        #   in Loop: Header=BB115_7 Depth=3
	movl	$5, 8(%esp)
	movl	$.L.str3379, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %ebp
	movl	40(%esp), %eax
	movl	%eax, (%esp)
	calll	url_error
	movl	%eax, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	64(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	%ebx, (%esp)
	calll	checking_free
	movl	%esi, %ebx
	.align	16, 0x90
.LBB115_7:                              # %while.cond
                                        #   Parent Loop BB115_5 Depth=1
                                        #     Parent Loop BB115_6 Depth=2
                                        # =>    This Loop Header: Depth=3
                                        #         Child Loop BB115_11 Depth 4
                                        #         Child Loop BB115_9 Depth 4
	cmpl	%edi, %ebx
	jae	.LBB115_22
# BB#8:                                 # %while.body
                                        #   in Loop: Header=BB115_7 Depth=3
	movl	%edi, %eax
	subl	%ebx, %eax
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$10, 4(%esp)
	calll	memchr
	testl	%eax, %eax
	leal	1(%eax), %esi
	cmovel	%edi, %esi
	.align	16, 0x90
.LBB115_9:                              # %while.cond17
                                        #   Parent Loop BB115_5 Depth=1
                                        #     Parent Loop BB115_6 Depth=2
                                        #       Parent Loop BB115_7 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	movl	%ebx, %eax
	cmpl	%esi, %eax
	movl	%esi, %edx
	jae	.LBB115_11
# BB#10:                                # %land.rhs
                                        #   in Loop: Header=BB115_9 Depth=4
	leal	1(%eax), %ebx
	movzbl	(%eax), %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	movl	%esi, %edx
	jne	.LBB115_9
	.align	16, 0x90
.LBB115_11:                             # %while.cond26
                                        #   Parent Loop BB115_5 Depth=1
                                        #     Parent Loop BB115_6 Depth=2
                                        #       Parent Loop BB115_7 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	movl	%edx, %ecx
	cmpl	%eax, %ecx
	jbe	.LBB115_13
# BB#12:                                # %land.rhs29
                                        #   in Loop: Header=BB115_11 Depth=4
	leal	-1(%ecx), %edx
	movzbl	-1(%ecx), %ebx
	testb	$64, _sch_istable(%ebx,%ebx)
	jne	.LBB115_11
.LBB115_13:                             # %while.end40
                                        #   in Loop: Header=BB115_7 Depth=3
	cmpl	%ecx, %eax
	movl	%esi, %ebx
	je	.LBB115_7
# BB#14:                                # %if.end44
                                        #   in Loop: Header=BB115_7 Depth=3
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, %ebp
	movl	opt+164, %eax
	testl	%eax, %eax
	je	.LBB115_15
# BB#16:                                # %if.then47
                                        #   in Loop: Header=BB115_7 Depth=3
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	uri_merge
	movl	%eax, %ebx
	movl	%ebp, (%esp)
	calll	checking_free
	jmp	.LBB115_17
.LBB115_15:                             #   in Loop: Header=BB115_7 Depth=3
	movl	%ebp, %ebx
.LBB115_17:                             # %if.end49
                                        #   in Loop: Header=BB115_7 Depth=3
	leal	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	url_parse
	movl	%eax, %ebp
	testl	%ebp, %ebp
	je	.LBB115_18
# BB#19:                                # %if.end55
                                        #   in Loop: Header=BB115_6 Depth=2
	movl	%ebx, (%esp)
	calll	checking_free
	movl	$32, (%esp)
	calll	checking_malloc0
	movl	%ebp, (%eax)
	cmpl	$0, 32(%esp)            # 4-byte Folded Reload
	jne	.LBB115_21
	jmp	.LBB115_20
.LBB115_22:                             # %while.end62
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	read_file_free
	movl	32(%esp), %eax          # 4-byte Reload
.LBB115_23:                             # %return
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp115:
	.size	get_urls_file, .Ltmp115-get_urls_file

	.globl	cleanup_html_url
	.align	16, 0x90
	.type	cleanup_html_url,@function
cleanup_html_url:                       # @cleanup_html_url
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	interesting_tags, %eax
	testl	%eax, %eax
	je	.LBB116_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	hash_table_destroy
.LBB116_2:                              # %if.end
	movl	interesting_attributes, %eax
	testl	%eax, %eax
	je	.LBB116_4
# BB#3:                                 # %if.then2
	movl	%eax, (%esp)
	calll	hash_table_destroy
.LBB116_4:                              # %if.end3
	addl	$12, %esp
	ret
.Ltmp116:
	.size	cleanup_html_url, .Ltmp116-cleanup_html_url

	.align	16, 0x90
	.type	tag_find_urls,@function
tag_find_urls:                          # @tag_find_urls
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	xorl	%ecx, %ecx
	movl	$tag_url_attributes-8, %edx
	movl	68(%esp), %ebx
	.align	16, 0x90
.LBB117_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$20, %ecx
	ja	.LBB117_18
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB117_1 Depth=1
	incl	%ecx
	movl	64(%esp), %eax
	cmpl	%eax, 8(%edx)
	leal	12(%edx), %edx
	jne	.LBB117_1
# BB#3:                                 # %for.end
	testl	%ecx, %ecx
	je	.LBB117_18
# BB#4:                                 # %for.cond4.preheader
	cmpl	$0, 8(%ebx)
	jle	.LBB117_17
# BB#5:                                 # %for.body6.lr.ph
	decl	%ecx
	movl	%ecx, 28(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	.align	16, 0x90
.LBB117_6:                              # %for.body6
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB117_7 Depth 2
	movl	%edx, 32(%esp)          # 4-byte Spill
	imull	$24, %ebp, %esi
	movl	%esi, 40(%esp)          # 4-byte Spill
	movl	12(%ebx), %eax
	movl	4(%eax,%esi), %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	%edx, %esi
	movl	%ecx, %edi
	jmp	.LBB117_7
	.align	16, 0x90
.LBB117_15:                             # %for.inc33
                                        #   in Loop: Header=BB117_7 Depth=2
	addl	$12, %esi
	incl	%edi
.LBB117_7:                              # %for.cond8
                                        #   Parent Loop BB117_6 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	$20, %edi
	jg	.LBB117_16
# BB#8:                                 # %land.rhs
                                        #   in Loop: Header=BB117_7 Depth=2
	movl	64(%esp), %eax
	cmpl	%eax, -4(%esi)
	jne	.LBB117_16
# BB#9:                                 # %for.body13
                                        #   in Loop: Header=BB117_7 Depth=2
	movl	12(%ebx), %eax
	movl	40(%esp), %ecx          # 4-byte Reload
	movl	(%eax,%ecx), %eax
	movl	(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB117_15
# BB#10:                                # %if.then18
                                        #   in Loop: Header=BB117_7 Depth=2
	movl	72(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	movl	36(%esp), %ecx          # 4-byte Reload
	movl	%ebx, %edx
	calll	append_url
	testl	%eax, %eax
	je	.LBB117_15
# BB#11:                                # %if.then20
                                        #   in Loop: Header=BB117_7 Depth=2
	movl	$2097114, %ecx          # imm = 0x1FFFDA
	btl	%edi, %ecx
	jae	.LBB117_13
# BB#12:                                # %if.then24
                                        #   in Loop: Header=BB117_7 Depth=2
	orb	$16, 8(%eax)
.LBB117_13:                             # %if.end25
                                        #   in Loop: Header=BB117_7 Depth=2
	movl	$82789, %ecx            # imm = 0x14365
	btl	%edi, %ecx
	jae	.LBB117_15
# BB#14:                                # %if.then28
                                        #   in Loop: Header=BB117_7 Depth=2
	orb	$32, 8(%eax)
	jmp	.LBB117_15
.LBB117_16:                             # %for.inc36
                                        #   in Loop: Header=BB117_6 Depth=1
	incl	%ebp
	cmpl	8(%ebx), %ebp
	movl	28(%esp), %ecx          # 4-byte Reload
	movl	32(%esp), %edx          # 4-byte Reload
	jl	.LBB117_6
.LBB117_17:                             # %for.end38
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB117_18:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.tag_find_urls, 12(%esp)
	movl	$370, 8(%esp)           # imm = 0x172
	movl	$.L.str5381, 4(%esp)
	movl	$.L.str52428, (%esp)
	calll	__assert_fail
.Ltmp117:
	.size	tag_find_urls, .Ltmp117-tag_find_urls

	.align	16, 0x90
	.type	tag_handle_base,@function
tag_handle_base:                        # @tag_handle_base
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	36(%esp), %eax
	movl	8(%eax), %edi
	movl	$-1, %ebp
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB118_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	incl	%ebp
	cmpl	%edi, %ebp
	jge	.LBB118_11
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB118_1 Depth=1
	movl	36(%esp), %eax
	movl	12(%eax), %esi
	movl	(%esi,%ebx), %eax
	movl	%eax, (%esp)
	movl	$.L.str7383, 4(%esp)
	addl	$24, %ebx
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB118_1
# BB#3:                                 # %find_attr.exit
	movl	-20(%esi,%ebx), %edi
	testl	%edi, %edi
	je	.LBB118_11
# BB#4:                                 # %if.end
	movl	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	movl	%edi, %ecx
	movl	36(%esp), %edx
	calll	append_url
	testl	%eax, %eax
	je	.LBB118_11
# BB#5:                                 # %if.end4
	orb	$9, 8(%eax)
	movl	40(%esp), %esi
	movl	4(%esi), %eax
	testl	%eax, %eax
	je	.LBB118_7
# BB#6:                                 # %if.then7
	movl	%eax, (%esp)
	calll	checking_free
.LBB118_7:                              # %if.end9
	movl	8(%esi), %eax
	testl	%eax, %eax
	je	.LBB118_9
# BB#8:                                 # %if.then11
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	uri_merge
	jmp	.LBB118_10
.LBB118_9:                              # %if.else
	movl	%edi, (%esp)
	calll	checking_strdup
.LBB118_10:                             # %if.else
	movl	%eax, 4(%esi)
.LBB118_11:                             # %if.end17
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp118:
	.size	tag_handle_base, .Ltmp118-tag_handle_base

	.align	16, 0x90
	.type	tag_handle_form,@function
tag_handle_form:                        # @tag_handle_form
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	36(%esp), %eax
	movl	8(%eax), %ebp
	movl	$-1, %edi
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB119_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	incl	%edi
	cmpl	%ebp, %edi
	jge	.LBB119_6
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB119_1 Depth=1
	movl	36(%esp), %eax
	movl	12(%eax), %esi
	movl	(%esi,%ebx), %eax
	movl	%eax, (%esp)
	movl	$.L.str17393, 4(%esp)
	addl	$24, %ebx
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB119_1
# BB#3:                                 # %find_attr.exit
	movl	-20(%esi,%ebx), %ecx
	testl	%ecx, %ecx
	je	.LBB119_6
# BB#4:                                 # %if.then
	movl	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	movl	36(%esp), %edx
	calll	append_url
	testl	%eax, %eax
	je	.LBB119_6
# BB#5:                                 # %if.then3
	orb	$1, 8(%eax)
.LBB119_6:                              # %if.end4
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp119:
	.size	tag_handle_form, .Ltmp119-tag_handle_form

	.align	16, 0x90
	.type	tag_handle_link,@function
tag_handle_link:                        # @tag_handle_link
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %ebp
	movl	8(%ebp), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	$-1, %edi
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB120_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	incl	%edi
	cmpl	24(%esp), %edi          # 4-byte Folded Reload
	jge	.LBB120_13
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB120_1 Depth=1
	movl	12(%ebp), %esi
	movl	(%esi,%ebx), %eax
	movl	%eax, (%esp)
	movl	$.L.str7383, 4(%esp)
	addl	$24, %ebx
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB120_1
# BB#3:                                 # %find_attr.exit
	movl	-20(%esi,%ebx), %ecx
	testl	%ecx, %ecx
	je	.LBB120_13
# BB#4:                                 # %if.then
	movl	56(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	movl	%ebp, %edx
	calll	append_url
	movl	%eax, 20(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB120_13
# BB#5:                                 # %if.then3
	movl	8(%ebp), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	xorl	%ebx, %ebx
	movl	$-1, %edi
	.align	16, 0x90
.LBB120_6:                              # %for.cond.i17
                                        # =>This Inner Loop Header: Depth=1
	incl	%edi
	cmpl	24(%esp), %edi          # 4-byte Folded Reload
	jge	.LBB120_12
# BB#7:                                 # %for.body.i22
                                        #   in Loop: Header=BB120_6 Depth=1
	movl	12(%ebp), %esi
	movl	(%esi,%ebx), %eax
	addl	$24, %ebx
	movl	%eax, (%esp)
	movl	$.L.str13389, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB120_6
# BB#8:                                 # %find_attr.exit26
	movl	-20(%esi,%ebx), %esi
	testl	%esi, %esi
	je	.LBB120_12
# BB#9:                                 # %land.lhs.true
	movl	%esi, (%esp)
	movl	$.L.str50426, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB120_11
# BB#10:                                # %lor.lhs.false
	movl	%esi, (%esp)
	movl	$.L.str51427, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB120_11
.LBB120_12:                             # %if.else
	movl	20(%esp), %eax          # 4-byte Reload
	orb	$32, 8(%eax)
	jmp	.LBB120_13
.LBB120_11:                             # %if.then9
	movl	20(%esp), %eax          # 4-byte Reload
	orb	$16, 8(%eax)
.LBB120_13:                             # %if.end12
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp120:
	.size	tag_handle_link, .Ltmp120-tag_handle_link

	.align	16, 0x90
	.type	tag_handle_meta,@function
tag_handle_meta:                        # @tag_handle_meta
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %eax
	movl	8(%eax), %ebx
	xorl	%esi, %esi
	movl	$-1, %edi
	movl	$0, 24(%esp)            # 4-byte Folded Spill
	.align	16, 0x90
.LBB121_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	incl	%edi
	cmpl	%ebx, %edi
	jge	.LBB121_4
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB121_1 Depth=1
	movl	52(%esp), %eax
	movl	12(%eax), %ebp
	movl	(%ebp,%esi), %eax
	addl	$24, %esi
	movl	%eax, (%esp)
	movl	$.L.str15391, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB121_1
# BB#3:                                 # %if.then.i
	movl	-20(%ebp,%esi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
.LBB121_4:                              # %find_attr.exit
	xorl	%ebp, %ebp
	movl	$-1, %esi
	.align	16, 0x90
.LBB121_5:                              # %for.cond.i110
                                        # =>This Inner Loop Header: Depth=1
	incl	%esi
	cmpl	%ebx, %esi
	jge	.LBB121_26
# BB#6:                                 # %for.body.i115
                                        #   in Loop: Header=BB121_5 Depth=1
	movl	52(%esp), %eax
	movl	12(%eax), %edi
	movl	(%edi,%ebp), %eax
	addl	$24, %ebp
	movl	%eax, (%esp)
	movl	$.L.str14390, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB121_5
# BB#7:                                 # %find_attr.exit119
	movl	-20(%edi,%ebp), %eax
	testl	%eax, %eax
	je	.LBB121_26
# BB#8:                                 # %land.lhs.true
	movl	%eax, (%esp)
	movl	$.L.str40416, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB121_9
.LBB121_26:                             # %if.else
	movl	24(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	je	.LBB121_41
# BB#27:                                # %land.lhs.true69
	movl	%eax, (%esp)
	movl	$.L.str41417, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB121_41
# BB#28:
	xorl	%edi, %edi
	movl	$-1, %esi
	.align	16, 0x90
.LBB121_29:                             # %for.cond.i138
                                        # =>This Inner Loop Header: Depth=1
	incl	%esi
	cmpl	%ebx, %esi
	jge	.LBB121_41
# BB#30:                                # %for.body.i143
                                        #   in Loop: Header=BB121_29 Depth=1
	movl	52(%esp), %eax
	movl	12(%eax), %ebp
	movl	(%ebp,%edi), %eax
	addl	$24, %edi
	movl	%eax, (%esp)
	movl	$.L.str16392, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB121_29
# BB#31:                                # %find_attr.exit147
	movl	-20(%ebp,%edi), %edi
	testl	%edi, %edi
	je	.LBB121_41
# BB#32:                                # %if.end77
	movl	%edi, (%esp)
	movl	$.L.str42418, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB121_40
# BB#33:                                # %while.cond82.preheader
	cmpb	$0, (%edi)
	je	.LBB121_41
	.align	16, 0x90
.LBB121_34:                             # %while.body84
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, (%esp)
	movl	$44, 4(%esp)
	calll	strchr
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB121_35
# BB#36:                                # %if.else89
                                        #   in Loop: Header=BB121_34 Depth=1
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %esi
	addl	%edi, %esi
	jmp	.LBB121_37
.LBB121_35:                             # %if.then87
                                        #   in Loop: Header=BB121_34 Depth=1
	incl	%esi
.LBB121_37:                             # %if.end92
                                        #   in Loop: Header=BB121_34 Depth=1
	movl	%esi, %eax
	subl	%edi, %eax
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$.L.str43419, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB121_38
# BB#39:                                # %if.then95
                                        #   in Loop: Header=BB121_34 Depth=1
	movl	56(%esp), %eax
	movb	$1, 16(%eax)
.LBB121_38:                             # %while.cond82.backedge
                                        #   in Loop: Header=BB121_34 Depth=1
	cmpb	$0, (%esi)
	movl	%esi, %edi
	jne	.LBB121_34
	jmp	.LBB121_41
.LBB121_9:
	movl	$-1, %ebp
	.align	16, 0x90
.LBB121_10:                             # %for.cond.i124
                                        # =>This Inner Loop Header: Depth=1
	incl	%ebp
	cmpl	%ebx, %ebp
	jge	.LBB121_41
# BB#11:                                # %for.body.i129
                                        #   in Loop: Header=BB121_10 Depth=1
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$.L.str16392, 4(%esp)
	addl	$24, %edi
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB121_10
# BB#12:                                # %find_attr.exit133
	movl	-20(%edi), %ecx
	testl	%ecx, %ecx
	je	.LBB121_41
# BB#13:                                # %for.cond.preheader
	movb	(%ecx), %al
	movsbl	%al, %edx
	movzbl	%dl, %esi
	xorl	%ebx, %ebx
	jmp	.LBB121_15
	.align	16, 0x90
.LBB121_14:                             # %for.body
                                        #   in Loop: Header=BB121_15 Depth=1
	imull	$10, %ebx, %eax
	leal	-48(%eax,%edx), %ebx
	movb	1(%ecx), %al
	incl	%ecx
	movsbl	%al, %edx
	movzbl	%dl, %esi
.LBB121_15:                             # %for.body
                                        # =>This Inner Loop Header: Depth=1
	testb	$4, _sch_istable(%esi,%esi)
	jne	.LBB121_14
# BB#16:                                # %for.end
	cmpb	$59, %al
	jne	.LBB121_41
# BB#17:                                # %while.cond.preheader
	addl	$3, %ecx
	.align	16, 0x90
.LBB121_18:                             # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-2(%ecx), %eax
	incl	%ecx
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB121_18
# BB#19:                                # %while.end
	cmpb	$85, _sch_toupper(%eax)
	jne	.LBB121_41
# BB#20:                                # %land.lhs.true30
	movzbl	-2(%ecx), %eax
	cmpb	$82, _sch_toupper(%eax)
	jne	.LBB121_41
# BB#21:                                # %land.lhs.true37
	movzbl	-1(%ecx), %eax
	cmpb	$76, _sch_toupper(%eax)
	jne	.LBB121_41
# BB#22:                                # %land.lhs.true45
	cmpb	$61, (%ecx)
	jne	.LBB121_41
	.align	16, 0x90
.LBB121_23:                             # %while.cond53
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%ecx), %eax
	incl	%ecx
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB121_23
# BB#24:                                # %while.end62
	movl	56(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	movl	52(%esp), %edx
	calll	append_url
	testl	%eax, %eax
	je	.LBB121_41
# BB#25:                                # %if.then65
	movl	8(%eax), %ecx
	movl	%ebx, 12(%eax)
	orl	$96, %ecx
	movl	%ecx, 8(%eax)
	jmp	.LBB121_41
.LBB121_40:                             # %if.then80
	movl	56(%esp), %eax
	movb	$1, 16(%eax)
.LBB121_41:                             # %if.end101
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp121:
	.size	tag_handle_meta, .Ltmp121-tag_handle_meta

	.align	16, 0x90
	.type	append_url,@function
append_url:                             # @append_url
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, 20(%esp)          # 4-byte Spill
	movl	%ecx, %esi
	movl	%esi, (%esp)
	calll	url_has_scheme
	movb	%al, 27(%esp)           # 1-byte Spill
	movl	52(%esp), %ebx
	movl	4(%ebx), %edi
	testl	%edi, %edi
	jne	.LBB122_9
# BB#1:                                 # %cond.end
	movl	8(%ebx), %edi
	testl	%edi, %edi
	je	.LBB122_2
.LBB122_9:                              # %if.else
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	uri_merge
	movl	%eax, %ebp
	cmpb	$0, opt+250
	jne	.LBB122_10
	.align	16, 0x90
.LBB122_11:                             # %do.end35
	movl	%ebp, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB122_12
# BB#15:                                # %if.end48
	movl	%ebp, (%esp)
	calll	checking_free
	.align	16, 0x90
.LBB122_16:                             # %do.body50
	cmpb	$0, opt+250
	jne	.LBB122_17
	.align	16, 0x90
.LBB122_18:                             # %do.end58
	movl	$32, (%esp)
	calll	checking_malloc0
	movl	%edi, (%eax)
	imull	$24, 48(%esp), %ecx
	movl	20(%esp), %edx          # 4-byte Reload
	movl	12(%edx), %edx
	movl	8(%edx,%ecx), %edi
	subl	(%ebx), %edi
	movl	%edi, 20(%eax)
	movl	12(%edx,%ecx), %ecx
	movl	%ecx, 24(%eax)
	cmpb	$0, 27(%esp)            # 1-byte Folded Reload
	je	.LBB122_19
# BB#21:                                # %if.then69
	orb	$4, 8(%eax)
	jmp	.LBB122_22
.LBB122_12:                             # %do.body39
	cmpb	$0, opt+250
	jne	.LBB122_13
	.align	16, 0x90
.LBB122_14:                             # %do.end47
	movl	%ebp, (%esp)
	calll	checking_free
	xorl	%eax, %eax
	jmp	.LBB122_26
.LBB122_19:                             # %land.lhs.true
	cmpb	$47, (%esi)
	je	.LBB122_22
# BB#20:                                # %if.then66
	orb	$2, 8(%eax)
.LBB122_22:                             # %if.end72
	movl	24(%ebx), %ecx
	testl	%ecx, %ecx
	je	.LBB122_24
# BB#23:                                # %if.then74
	movl	%eax, 28(%ecx)
	jmp	.LBB122_25
.LBB122_24:                             # %if.else77
	movl	%eax, 20(%ebx)
.LBB122_25:                             # %if.end79
	movl	%eax, 24(%ebx)
	.align	16, 0x90
.LBB122_26:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB122_2:                              # %do.body
	cmpb	$0, opt+250
	jne	.LBB122_3
	.align	16, 0x90
.LBB122_4:                              # %do.end
	cmpb	$0, 27(%esp)            # 1-byte Folded Reload
	je	.LBB122_5
# BB#6:                                 # %if.end12
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %edi
	testl	%edi, %edi
	jne	.LBB122_16
# BB#7:                                 # %do.body16
	xorl	%eax, %eax
	cmpb	$0, opt+250
	je	.LBB122_26
# BB#8:                                 # %if.then21
	movl	12(%ebx), %eax
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str46422, (%esp)
	calll	debug_logprintf
	xorl	%eax, %eax
	jmp	.LBB122_26
.LBB122_5:                              # %if.then9
	movl	$5, 8(%esp)
	movl	$.L.str45421, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	12(%ebx), %ecx
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
	jmp	.LBB122_26
.LBB122_10:                             # %if.then32
	movl	12(%ebx), %eax
	movl	%ebp, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str47423, (%esp)
	calll	debug_logprintf
	jmp	.LBB122_11
.LBB122_17:                             # %if.then55
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str49425, (%esp)
	calll	debug_logprintf
	jmp	.LBB122_18
.LBB122_13:                             # %if.then44
	movl	12(%ebx), %eax
	movl	%ebp, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str48424, (%esp)
	calll	debug_logprintf
	jmp	.LBB122_14
.LBB122_3:                              # %if.then7
	movl	12(%ebx), %eax
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str44420, (%esp)
	calll	debug_logprintf
	jmp	.LBB122_4
.Ltmp122:
	.size	append_url, .Ltmp122-append_url

	.globl	extract_param
	.align	16, 0x90
	.type	extract_param,@function
extract_param:                          # @extract_param
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	24(%esp), %eax
	movl	(%eax), %edi
	movb	36(%esp), %cl
	movl	28(%esp), %esi
	.align	16, 0x90
.LBB123_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %eax
	leal	1(%eax), %edi
	movzbl	(%eax), %ebx
	testb	$64, _sch_istable(%ebx,%ebx)
	jne	.LBB123_1
# BB#2:                                 # %while.end
	testb	%bl, %bl
	je	.LBB123_3
# BB#4:                                 # %if.end
	movl	%eax, (%esi)
	movl	$-1, %ebp
	.align	16, 0x90
.LBB123_5:                              # %while.cond4
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %ebx
	movzbl	(%edi,%ebx), %eax
	testl	%eax, %eax
	je	.LBB123_9
# BB#6:                                 # %land.lhs.true
                                        #   in Loop: Header=BB123_5 Depth=1
	cmpb	$61, %al
	je	.LBB123_9
# BB#7:                                 # %land.lhs.true
                                        #   in Loop: Header=BB123_5 Depth=1
	movzwl	_sch_istable(%eax,%eax), %ebp
	andl	$64, %ebp
	testw	%bp, %bp
	jne	.LBB123_9
# BB#8:                                 # %land.lhs.true
                                        #   in Loop: Header=BB123_5 Depth=1
	leal	1(%ebx), %ebp
	cmpb	%cl, %al
	jne	.LBB123_5
.LBB123_9:                              # %while.end22
	addl	%ebx, %edi
	movl	%edi, 4(%esi)
	xorb	%ch, %ch
	cmpl	$-1, %ebx
	je	.LBB123_37
	.align	16, 0x90
.LBB123_10:                             # %while.cond29
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%edi), %eax
	incl	%edi
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB123_10
# BB#11:                                # %while.end38
	leal	-1(%edi), %esi
	cmpb	%cl, %al
	je	.LBB123_13
# BB#12:                                # %while.end38
	testb	%al, %al
	jne	.LBB123_14
.LBB123_13:                             # %if.then44
	movl	32(%esp), %eax
	movl	$0, 4(%eax)
	movl	$0, (%eax)
	cmpb	%cl, (%esi)
	cmovnel	%esi, %edi
	.align	16, 0x90
.LBB123_36:                             # %if.end164
	movl	24(%esp), %eax
	movl	%edi, (%eax)
	movb	$1, %ch
	jmp	.LBB123_37
.LBB123_3:                              # %if.then
	movl	24(%esp), %ecx
	movl	%eax, (%ecx)
	xorb	%ch, %ch
	.align	16, 0x90
.LBB123_37:                             # %return
	movzbl	%ch, %eax
	addl	$4, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB123_14:                             # %if.end52
	xorb	%ch, %ch
	cmpb	$61, %al
	jne	.LBB123_37
	.align	16, 0x90
.LBB123_15:                             # %while.cond59
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%esi), %eax
	incl	%esi
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB123_15
# BB#16:                                # %while.end68
	cmpb	$34, %al
	jne	.LBB123_29
# BB#17:                                # %if.then72
	movb	%cl, %dh
	incl	%esi
	movl	32(%esp), %eax
	movl	%esi, (%eax)
	.align	16, 0x90
.LBB123_18:                             # %while.cond75
                                        # =>This Inner Loop Header: Depth=1
	movb	(%esi), %al
	incl	%esi
	testb	%al, %al
	setne	%ah
	cmpb	$34, %al
	je	.LBB123_20
# BB#19:                                # %while.cond75
                                        #   in Loop: Header=BB123_18 Depth=1
	testb	%ah, %ah
	jne	.LBB123_18
.LBB123_20:                             # %while.end85
	xorb	%ch, %ch
	testb	%al, %al
	je	.LBB123_37
# BB#21:                                # %if.end88
	leal	-1(%esi), %eax
	movl	32(%esp), %ecx
	movl	%eax, 4(%ecx)
	.align	16, 0x90
.LBB123_22:                             # %while.cond91
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%esi), %eax
	incl	%esi
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB123_22
# BB#23:
	movb	%al, %dl
	jmp	.LBB123_24
	.align	16, 0x90
.LBB123_26:                             # %while.cond101.while.cond101_crit_edge
                                        #   in Loop: Header=BB123_24 Depth=1
	movb	(%esi), %dl
	incl	%esi
.LBB123_24:                             # %while.cond101
                                        # =>This Inner Loop Header: Depth=1
	testb	%dl, %dl
	setne	%al
	cmpb	%dh, %dl
	je	.LBB123_27
# BB#25:                                # %while.cond101
                                        #   in Loop: Header=BB123_24 Depth=1
	cmpb	$1, %al
	je	.LBB123_26
.LBB123_27:                             # %while.end112
	leal	-1(%esi), %edi
	cmpb	%dh, %dl
	cmovel	%esi, %edi
	je	.LBB123_36
# BB#28:                                # %while.end112
	xorb	%ch, %ch
	testb	%dl, %dl
	je	.LBB123_36
	jmp	.LBB123_37
.LBB123_29:                             # %if.else123
	movl	32(%esp), %eax
	movl	%esi, (%eax)
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB123_30:                             # %while.cond125
                                        # =>This Inner Loop Header: Depth=1
	movb	(%esi,%ebx), %al
	incl	%ebx
	cmpb	%cl, %al
	je	.LBB123_32
# BB#31:                                # %while.cond125
                                        #   in Loop: Header=BB123_30 Depth=1
	testb	%al, %al
	jne	.LBB123_30
.LBB123_32:                             # %while.end136
	leal	-2(%esi,%ebx), %eax
	leal	(%esi,%ebx), %ecx
	movl	%ecx, (%esp)            # 4-byte Spill
	leal	-1(%esi,%ebx), %edi
	movl	$1, %ebp
	subl	%ebx, %ebp
	.align	16, 0x90
.LBB123_33:                             # %while.cond138
                                        # =>This Inner Loop Header: Depth=1
	leal	1(%eax), %edx
	movl	32(%esp), %ecx
	movl	%edx, 4(%ecx)
	testl	%ebp, %ebp
	je	.LBB123_35
# BB#34:                                # %land.rhs143
                                        #   in Loop: Header=BB123_33 Depth=1
	incl	%ebp
	movzbl	(%eax), %edx
	decl	%eax
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB123_33
.LBB123_35:                             # %while.end156
	movb	36(%esp), %al
	cmpb	%al, -1(%esi,%ebx)
	cmovel	(%esp), %edi            # 4-byte Folded Reload
	jmp	.LBB123_36
.Ltmp123:
	.size	extract_param, .Ltmp123-extract_param

	.globl	http_loop
	.align	16, 0x90
	.type	http_loop,@function
http_loop:                              # @http_loop
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$508, %esp              # imm = 0x1FC
	movl	536(%esp), %esi
	testl	%esi, %esi
	je	.LBB124_7
# BB#1:                                 # %lor.lhs.false
	cmpl	$0, (%esi)
	jne	.LBB124_166
# BB#2:                                 # %cond.end
	movl	opt+104, %ecx
	testl	%ecx, %ecx
	je	.LBB124_7
# BB#3:                                 # %if.then
	cmpb	$45, (%ecx)
	jne	.LBB124_5
# BB#4:                                 # %land.lhs.true5
	xorl	%eax, %eax
	cmpb	$0, 1(%ecx)
	je	.LBB124_6
.LBB124_5:                              # %cond.false8
	movl	%ecx, (%esp)
	calll	checking_strdup
.LBB124_6:                              # %cond.end9
	movl	%eax, (%esi)
.LBB124_7:                              # %if.end
	movl	532(%esp), %eax
	movl	$0, (%eax)
	cmpb	$0, opt+296
	je	.LBB124_13
# BB#8:                                 # %if.then11
	movl	wget_cookie_jar, %eax
	testl	%eax, %eax
	jne	.LBB124_10
# BB#9:                                 # %if.then.i
	calll	cookie_jar_new
	movl	%eax, wget_cookie_jar
.LBB124_10:                             # %if.end.i
	movl	opt+300, %ecx
	testl	%ecx, %ecx
	je	.LBB124_13
# BB#11:                                # %land.lhs.true.i
	movb	cookies_loaded_p.b, %dl
	testb	%dl, %dl
	jne	.LBB124_13
# BB#12:                                # %if.then3.i
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	cookie_jar_load
	movb	$1, cookies_loaded_p.b
.LBB124_13:                             # %if.end12
	cmpb	$0, opt+129
	je	.LBB124_16
# BB#14:                                # %land.lhs.true15
	movl	528(%esp), %eax
	movl	16(%eax), %eax
	movl	%eax, (%esp)
	calll	has_wildcards_p
	cmpb	$1, %al
	jne	.LBB124_16
# BB#15:                                # %if.then18
	movl	$5, 8(%esp)
	movl	$.L.str2433, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB124_16:                             # %if.end20
	movl	544(%esp), %esi
	movl	540(%esp), %eax
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 480(%esp)
	movaps	%xmm0, 464(%esp)
	movaps	%xmm0, 448(%esp)
	movaps	%xmm0, 432(%esp)
	movaps	%xmm0, 416(%esp)
	movl	$0, 504(%esp)
	movl	$0, 500(%esp)
	movl	$0, 496(%esp)
	movl	%eax, 480(%esp)
	movl	opt+104, %eax
	testl	%eax, %eax
	je	.LBB124_18
# BB#17:                                # %if.then23
	movl	%eax, (%esp)
	calll	checking_strdup
	jmp	.LBB124_20
.LBB124_18:                             # %if.else
	xorb	%cl, %cl
	cmpb	$0, opt+340
	movb	$0, %al
	jne	.LBB124_23
# BB#19:                                # %if.then27
	movl	528(%esp), %eax
	movl	%eax, (%esp)
	calll	url_file_name
.LBB124_20:                             # %if.then27
	movl	%eax, 484(%esp)
	movl	%eax, (%esp)
	calll	file_exists_p
	movb	$1, %cl
	testb	%al, %al
	movb	$1, %al
	je	.LBB124_23
# BB#21:                                # %land.lhs.true38
	movb	$1, %cl
	cmpb	$0, opt+42
	je	.LBB124_22
# BB#36:                                # %land.lhs.true38
	movl	opt+104, %eax
	testl	%eax, %eax
	movb	$1, %al
	jne	.LBB124_23
# BB#37:                                # %if.then43
	movl	$5, 8(%esp)
	movl	$.L.str3434, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	484(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	orb	$2, (%esi)
	movl	484(%esp), %eax
	movl	%eax, (%esp)
	calll	has_html_suffix_p
	cmpb	$1, %al
	jne	.LBB124_152
# BB#38:                                # %if.then48
	orb	$1, (%esi)
	jmp	.LBB124_152
.LBB124_22:
	movb	$1, %al
.LBB124_23:                             # %if.end51
	movb	%al, 46(%esp)           # 1-byte Spill
	movl	$0, (%esi)
	movb	$1, %bl
	movb	opt+340, %al
	cmpb	$0, opt+57
	jne	.LBB124_25
# BB#24:                                # %land.lhs.true53
	testb	%al, %al
	sete	%dl
	orb	%dl, %cl
	xorb	$1, %cl
	movb	%cl, %bl
.LBB124_25:                             # %if.end59
	cmpb	$0, opt+251
	je	.LBB124_28
# BB#26:                                # %if.end59
	testb	%al, %al
	jne	.LBB124_28
# BB#27:                                # %land.lhs.true64
	movl	528(%esp), %eax
	movl	%eax, (%esp)
	calll	url_file_name
	movl	%eax, (%esp)
	calll	file_exists_p
	movb	$1, %bh
	testb	%al, %al
	jne	.LBB124_29
.LBB124_28:                             # %land.lhs.true64
	movb	%bl, %bh
.LBB124_29:                             # %do.body.preheader
	andb	$1, %bh
	movb	%bh, 59(%esp)           # 1-byte Spill
	movl	$-1, 48(%esp)           # 4-byte Folded Spill
	xorl	%ebp, %ebp
	xorb	%cl, %cl
	leal	448(%esp), %eax
	movl	%eax, 40(%esp)          # 4-byte Spill
	movb	%cl, 58(%esp)           # 1-byte Spill
	movb	$0, 47(%esp)            # 1-byte Folded Spill
	.align	16, 0x90
.LBB124_30:                             # %do.body
                                        # =>This Inner Loop Header: Depth=1
	leal	1(%ebp), %eax
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	sleep_between_retrievals
	movl	$0, (%esp)
	calll	time
	movl	%eax, (%esp)
	calll	datetime_str
	movl	%eax, %esi
	cmpb	$0, opt+57
	je	.LBB124_33
# BB#31:                                # %land.lhs.true74
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$1, 58(%esp)            # 1-byte Folded Reload
	jne	.LBB124_33
# BB#32:                                # %if.then76
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str4435, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB124_33:                             # %if.end78
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$0, opt
	je	.LBB124_41
# BB#34:                                # %if.then80
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	528(%esp), %eax
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %edi
	testl	%ebp, %ebp
	jle	.LBB124_39
# BB#35:                                # %if.then84
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str5436, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	60(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	leal	64(%esp), %ebx
	movl	%ebx, (%esp)
	calll	sprintf
	movl	%edi, 16(%esp)
	movl	%ebx, 12(%esp)
	movb	59(%esp), %bh           # 1-byte Reload
	movl	%esi, 8(%esp)
	movl	$.L.str6437, 4(%esp)
	jmp	.LBB124_40
.LBB124_39:                             # %if.else88
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%edi, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str7438, 4(%esp)
.LBB124_40:                             # %if.else88
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$1, (%esp)
	calll	logprintf
	movl	%edi, (%esp)
	calll	checking_free
.LBB124_41:                             # %if.end90
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	%bh, %bh
	movl	544(%esp), %esi
	je	.LBB124_44
# BB#42:                                # %land.lhs.true93
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$1, 58(%esp)            # 1-byte Folded Reload
	jne	.LBB124_44
# BB#43:                                # %if.then95
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	(%esi), %eax
	orl	$4, %eax
	jmp	.LBB124_45
.LBB124_44:                             # %if.else97
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	(%esi), %eax
	andl	$-5, %eax
.LBB124_45:                             # %if.end98
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%eax, (%esi)
	cmpb	$0, opt+116
	je	.LBB124_51
# BB#46:                                # %land.lhs.true101
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$1, 46(%esp)            # 1-byte Folded Reload
	je	.LBB124_51
# BB#47:                                # %land.lhs.true104
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	484(%esp), %eax
	leal	320(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	jne	.LBB124_51
# BB#48:                                # %land.lhs.true109
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	336(%esp), %eax
	movl	$61440, %ecx            # imm = 0xF000
	andl	%ecx, %eax
	cmpl	$32768, %eax            # imm = 0x8000
	jne	.LBB124_51
# BB#49:                                # %if.then113
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	364(%esp), %eax
	movl	368(%esp), %ecx
	jmp	.LBB124_50
.LBB124_51:                             # %if.else114
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%ebp, %ebp
	jle	.LBB124_53
# BB#52:                                # %if.then117
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
.LBB124_50:                             # %if.then113
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%ecx, 436(%esp)
	movl	%eax, 432(%esp)
	jmp	.LBB124_54
.LBB124_53:                             # %if.else119
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$0, 436(%esp)
	movl	$0, 432(%esp)
.LBB124_54:                             # %if.end122
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%ebp, %ebp
	setg	%cl
	movl	548(%esp), %edi
	testl	%edi, %edi
	setne	%al
	andb	%cl, %al
	movl	(%esi), %ecx
	movl	%ecx, %edx
	orl	$8, %edx
	andl	$-9, %ecx
	cmpb	$0, opt+146
	sete	%ah
	orb	%al, %ah
	cmovnel	%edx, %ecx
	movl	%ecx, (%esi)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	528(%esp), %ecx
	leal	416(%esp), %edx
	calll	gethttp
	movl	%eax, %edi
	movl	$0, (%esp)
	calll	time
	movl	%eax, (%esp)
	calll	datetime_str
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	448(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_56
# BB#55:                                # %if.then139
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	532(%esp), %ecx
	movl	%eax, (%ecx)
.LBB124_56:                             # %if.end142
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$23, %edi
	jg	.LBB124_59
# BB#57:                                # %if.end142
                                        #   in Loop: Header=BB124_30 Depth=1
	leal	-1(%edi), %eax
	cmpl	$8, %eax
	ja	.LBB124_64
# BB#58:                                # %if.end142
                                        #   in Loop: Header=BB124_30 Depth=1
	jmpl	*.LJTI124_1(,%eax,4)
.LBB124_59:                             # %if.end142
                                        #   in Loop: Header=BB124_30 Depth=1
	leal	-24(%edi), %eax
	cmpl	$29, %eax
	ja	.LBB124_64
# BB#60:                                # %if.end142
                                        #   in Loop: Header=BB124_30 Depth=1
	jmpl	*.LJTI124_0(,%eax,4)
.LBB124_65:                             # %sw.epilog
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	544(%esp), %edi
	movl	(%edi), %eax
	testb	$2, %al
	movl	48(%esp), %ebx          # 4-byte Reload
	jne	.LBB124_77
# BB#66:                                # %if.then160
                                        #   in Loop: Header=BB124_30 Depth=1
	xorl	%esi, %esi
	cmpl	$0, opt
	jne	.LBB124_68
# BB#67:                                # %if.then164
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	528(%esp), %eax
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %esi
	movl	%esi, 8(%esp)
	movl	$.L.str12443, 4(%esp)
	movl	$2, (%esp)
	calll	logprintf
	movl	(%edi), %eax
.LBB124_68:                             # %if.end166
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%ebx, 48(%esp)          # 4-byte Spill
	testb	$4, %al
	movl	60(%esp), %edx          # 4-byte Reload
	movb	59(%esp), %bh           # 1-byte Reload
	je	.LBB124_70
# BB#69:                                # %land.lhs.true169
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	460(%esp), %eax
	movl	$-500, %ecx             # imm = 0xFFFFFFFFFFFFFE0C
	addl	%ecx, %eax
	movb	$1, 58(%esp)            # 1-byte Folded Spill
	cmpl	$2, %eax
	movl	%edx, %ebp
	jb	.LBB124_149
	jmp	.LBB124_70
.LBB124_77:                             # %if.end196
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$1, 58(%esp)            # 1-byte Folded Reload
	jne	.LBB124_78
# BB#82:                                # %if.then198
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	452(%esp), %eax
	cmpb	$0, opt+251
	jne	.LBB124_83
# BB#85:                                # %if.else205
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%eax, %eax
	je	.LBB124_90
	jmp	.LBB124_86
.LBB124_83:                             # %land.lhs.true201
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%eax, %eax
	jne	.LBB124_86
# BB#84:                                # %if.then203
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str15446, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	jmp	.LBB124_90
.LBB124_86:                             # %if.then208
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%eax, (%esp)
	calll	http_atotm
	movl	%eax, %ebx
	cmpl	$-1, %ebx
	jne	.LBB124_88
# BB#87:                                # %if.then213
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str16447, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB124_88:                             # %if.end215
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$4, (%edi)
	je	.LBB124_90
# BB#89:                                # %if.end215
                                        #   in Loop: Header=BB124_30 Depth=1
	movb	$1, 47(%esp)            # 1-byte Folded Spill
.LBB124_90:                             # %if.end221
                                        #   in Loop: Header=BB124_30 Depth=1
	movb	$1, 58(%esp)            # 1-byte Folded Spill
	cmpb	$0, 59(%esp)            # 1-byte Folded Reload
	je	.LBB124_78
# BB#91:                                # %if.then223
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpb	$0, opt+251
	je	.LBB124_103
# BB#92:                                # %if.then225
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$0, 492(%esp)
	je	.LBB124_102
# BB#93:                                # %if.then227
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$0, 452(%esp)
	je	.LBB124_102
# BB#94:                                # %if.then227
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$-1, %ebx
	je	.LBB124_102
# BB#95:                                # %if.then233
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	%ebx, 504(%esp)
	jge	.LBB124_96
# BB#100:                               # %if.else251
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str19450, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	jmp	.LBB124_101
.LBB124_78:                             #   in Loop: Header=BB124_30 Depth=1
	movl	%ebx, %esi
	movl	$-1, %ebx
	cmpl	$-1, %esi
	je	.LBB124_126
# BB#79:                                # %land.lhs.true283
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	424(%esp), %eax
	movl	428(%esp), %ecx
	movl	420(%esp), %edx
	xorl	%ecx, %edx
	movl	416(%esp), %edi
	xorl	%eax, %edi
	orl	%edx, %edi
	je	.LBB124_116
# BB#80:                                # %lor.lhs.false288
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$0, 440(%esp)
	je	.LBB124_114
# BB#81:                                #   in Loop: Header=BB124_30 Depth=1
	movl	%esi, %ebx
	jmp	.LBB124_126
.LBB124_114:                            # %lor.lhs.false288
                                        #   in Loop: Header=BB124_30 Depth=1
	andl	%ecx, %eax
	cmpl	$-1, %eax
	jne	.LBB124_115
.LBB124_116:                            # %if.then295
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	opt+104, %edi
	testl	%edi, %edi
	jne	.LBB124_117
# BB#118:                               # %if.else302
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	484(%esp), %edi
	jmp	.LBB124_119
.LBB124_117:                            # %if.then298
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpb	$0, output_stream_regular
	movl	$0, %eax
	cmovel	%eax, %edi
.LBB124_119:                            # %if.end304
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%edi, %edi
	je	.LBB124_120
# BB#121:                               # %if.then306
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	$1, 47(%esp)            # 1-byte Folded Reload
	je	.LBB124_125
# BB#122:                               # %land.lhs.true310
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	452(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_125
# BB#123:                               # %land.lhs.true313
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpb	$0, (%eax)
	je	.LBB124_125
# BB#124:                               # %if.then317
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%eax, (%esp)
	calll	http_atotm
	cmpl	$-1, %eax
	cmovnel	%eax, %esi
.LBB124_125:                            # %if.then317
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%esi, %ebx
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	touch
	jmp	.LBB124_126
.LBB124_120:                            #   in Loop: Header=BB124_30 Depth=1
	movl	%esi, %ebx
	jmp	.LBB124_126
.LBB124_96:                             # %if.then236
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	424(%esp), %eax
	movl	428(%esp), %ecx
	movl	%eax, %edx
	andl	%ecx, %edx
	cmpl	$-1, %edx
	je	.LBB124_98
# BB#97:                                # %lor.lhs.false239
                                        #   in Loop: Header=BB124_30 Depth=1
	xorl	496(%esp), %eax
	xorl	500(%esp), %ecx
	orl	%eax, %ecx
	je	.LBB124_98
# BB#99:                                # %if.else246
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str18449, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	496(%esp), %eax
	movl	500(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB124_101:                            # %if.end253
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$.L.str8439, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB124_102:                            # %if.end255
                                        #   in Loop: Header=BB124_30 Depth=1
	movb	$1, 489(%esp)
.LBB124_103:                            # %if.end256
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%ebx, 48(%esp)          # 4-byte Spill
	cmpb	$0, opt+57
	je	.LBB124_107
# BB#104:                               # %if.then258
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	(%edi), %eax
	andl	$1, %eax
	cmpb	$0, opt+15
	je	.LBB124_111
# BB#105:                               # %if.then260
                                        #   in Loop: Header=BB124_30 Depth=1
	testl	%eax, %eax
	je	.LBB124_108
# BB#106:                               # %if.then263
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str20451, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB124_107:                            # %if.end277
                                        #   in Loop: Header=BB124_30 Depth=1
	andb	$-5, (%edi)
	xorl	%ebp, %ebp
	movb	$1, 46(%esp)            # 1-byte Folded Spill
	movb	$1, 58(%esp)            # 1-byte Folded Spill
	movb	59(%esp), %bh           # 1-byte Reload
	jmp	.LBB124_149
.LBB124_115:                            #   in Loop: Header=BB124_30 Depth=1
	movl	%esi, %ebx
.LBB124_126:                            # %if.end326
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%ebx, 48(%esp)          # 4-byte Spill
	movl	464(%esp), %eax
	movl	468(%esp), %ecx
	movsd	472(%esp), %xmm0
	movsd	%xmm0, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	retr_rate
	movl	%eax, %edi
	movsd	total_download_time, %xmm0
	addsd	472(%esp), %xmm0
	movsd	%xmm0, total_download_time
	movl	428(%esp), %edx
	movl	416(%esp), %ecx
	movl	420(%esp), %eax
	movl	%eax, %ebx
	xorl	%edx, %ebx
	movl	424(%esp), %esi
	movl	%ecx, %ebp
	xorl	%esi, %ebp
	orl	%ebx, %ebp
	je	.LBB124_127
# BB#132:                               # %if.else361
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	$0, 440(%esp)
	jne	.LBB124_144
# BB#133:                               # %if.then365
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%esi, %ebx
	andl	%edx, %ebx
	cmpl	$-1, %ebx
	je	.LBB124_134
# BB#137:                               # %if.else394
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	%esi, %ecx
	setae	%bl
	cmpl	%edx, %eax
	setge	%dl
	je	.LBB124_139
# BB#138:                               # %if.else394
                                        #   in Loop: Header=BB124_30 Depth=1
	movb	%dl, %bl
.LBB124_139:                            # %if.else394
                                        #   in Loop: Header=BB124_30 Depth=1
	testb	%bl, %bl
	movb	59(%esp), %bh           # 1-byte Reload
	jne	.LBB124_142
# BB#140:                               # %if.then399
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str28459, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 16(%esp)
	jmp	.LBB124_147
.LBB124_144:                            # %if.else410
                                        #   in Loop: Header=BB124_30 Depth=1
	andl	%edx, %esi
	cmpl	$-1, %esi
	movb	59(%esp), %bh           # 1-byte Reload
	jne	.LBB124_146
# BB#145:                               # %if.then414
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str29460, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	444(%esp), %ecx
	movl	%ecx, 20(%esp)
	movl	%eax, 16(%esp)
	jmp	.LBB124_147
.LBB124_146:                            # %if.else418
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str30461, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, %ebp
	movl	424(%esp), %eax
	movl	428(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	444(%esp), %ecx
	movl	%ecx, 24(%esp)
	movl	%eax, 20(%esp)
	movl	%ebp, 16(%esp)
.LBB124_147:                            # %if.else418
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	%edi, 12(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB124_148:                            # %if.else418
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	opt+8, %eax
	movl	%eax, 4(%esp)
	movl	60(%esp), %esi          # 4-byte Reload
	movl	%esi, (%esp)
	calll	printwhat
	movl	%esi, %ebp
.LBB124_149:                            # %do.cond
                                        #   in Loop: Header=BB124_30 Depth=1
	movl	opt+8, %eax
	movl	$41, %edi
	testl	%eax, %eax
	je	.LBB124_30
# BB#150:                               # %do.cond
                                        #   in Loop: Header=BB124_30 Depth=1
	cmpl	%eax, %ebp
	jl	.LBB124_30
	jmp	.LBB124_153
.LBB124_61:                             # %sw.bb149
	movl	$5, 8(%esp)
	movl	$.L.str10441, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$4, %edi
	jmp	.LBB124_153
.LBB124_62:                             # %sw.bb151
	movl	$6, %edi
	movl	532(%esp), %eax
	cmpl	$0, (%eax)
	jne	.LBB124_153
# BB#63:                                # %if.then153
	movl	$5, 8(%esp)
	movl	$.L.str11442, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	460(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$34, %edi
	jmp	.LBB124_153
.LBB124_64:                             # %sw.default
	calll	abort
.LBB124_151:                            # %sw.bb143
	movl	$.L.str8439, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	$5, 8(%esp)
	movl	$.L.str9440, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	484(%esp), %ebx
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	cmpl	$31, %edi
	jne	.LBB124_153
	jmp	.LBB124_152
.LBB124_142:                            # %if.else403
	xorl	432(%esp), %ecx
	xorl	436(%esp), %eax
	orl	%ecx, %eax
	jne	.LBB124_143
	.align	16, 0x90
.LBB124_152:                            # %if.then430
	movl	484(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	536(%esp), %ecx
	movl	%eax, (%ecx)
	movl	$31, %edi
	leal	448(%esp), %eax
	movl	%eax, 40(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB124_153:                            # %if.end433
	movl	40(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.LBB124_155
# BB#154:                               # %if.else.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_155:                            # %if.end.i446
	movl	452(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_157
# BB#156:                               # %if.else4.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_157:                            # %if.end6.i
	movl	456(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_159
# BB#158:                               # %if.else9.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_159:                            # %if.end11.i
	movl	444(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_161
# BB#160:                               # %if.else14.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_161:                            # %if.end16.i
	movl	484(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_163
# BB#162:                               # %if.else19.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_163:                            # %if.end21.i
	movl	492(%esp), %eax
	testl	%eax, %eax
	je	.LBB124_165
# BB#164:                               # %if.else24.i
	movl	%eax, (%esp)
	calll	checking_free
.LBB124_165:                            # %free_hstat.exit
	movl	40(%esp), %eax          # 4-byte Reload
	movl	$0, (%eax)
	movl	%edi, %eax
	addl	$508, %esp              # imm = 0x1FC
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB124_70:                             # %if.else178
	cmpb	$0, opt+57
	je	.LBB124_74
# BB#71:                                # %if.then180
	testl	%esi, %esi
	jne	.LBB124_73
# BB#72:                                # %if.then182
	movl	528(%esp), %eax
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %esi
.LBB124_73:                             # %if.end184
	movl	%esi, (%esp)
	calll	nonexisting_url
	movl	$5, 8(%esp)
	movl	$.L.str13444, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	jmp	.LBB124_75
.LBB124_166:                            # %cond.false
	movl	$.L__PRETTY_FUNCTION__.http_loop, 12(%esp)
	movl	$2343, 8(%esp)          # imm = 0x927
	movl	$.L.str1432, 4(%esp)
	movl	$.L.str431, (%esp)
	calll	__assert_fail
.LBB124_98:                             # %if.then243
	movl	$5, 8(%esp)
	movl	$.L.str17448, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	492(%esp), %ecx
	movl	%ecx, 8(%esp)
	jmp	.LBB124_110
.LBB124_111:                            # %if.else268
	testl	%eax, %eax
	je	.LBB124_113
# BB#112:                               # %if.then271
	movl	$5, 8(%esp)
	movl	$.L.str22453, 4(%esp)
	jmp	.LBB124_109
.LBB124_108:                            # %if.else265
	movl	$5, 8(%esp)
	movl	$.L.str21452, 4(%esp)
	jmp	.LBB124_109
.LBB124_127:                            # %if.then333
	movl	544(%esp), %edx
	testb	$2, (%edx)
	je	.LBB124_130
# BB#128:                               # %if.then336
	movl	$5, 8(%esp)
	movl	$.L.str24455, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	484(%esp), %ebp
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, %ebx
	movl	424(%esp), %eax
	movl	428(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 24(%esp)
	movl	%ebx, 20(%esp)
	movl	%ebp, 16(%esp)
	movl	%edi, 12(%esp)
	movl	52(%esp), %ebx          # 4-byte Reload
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	528(%esp), %eax
	movl	(%eax), %edi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, %esi
	movl	424(%esp), %eax
	movl	428(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	484(%esp), %ecx
	movl	60(%esp), %edx          # 4-byte Reload
	movl	%edx, 28(%esp)
	movl	%ecx, 24(%esp)
	movl	%eax, 20(%esp)
	movl	%esi, 16(%esp)
	movl	%edi, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	$.L.str25456, 4(%esp)
	jmp	.LBB124_129
.LBB124_134:                            # %if.then369
	movl	544(%esp), %edx
	testb	$2, (%edx)
	je	.LBB124_130
# BB#135:                               # %if.then372
	movl	$5, 8(%esp)
	movl	$.L.str26457, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	484(%esp), %ebx
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	%eax, 20(%esp)
	movl	%ebx, 16(%esp)
	movl	%edi, 12(%esp)
	movl	52(%esp), %edi          # 4-byte Reload
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	528(%esp), %eax
	movl	(%eax), %esi
	movl	416(%esp), %eax
	movl	420(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movl	484(%esp), %ecx
	movl	60(%esp), %edx          # 4-byte Reload
	movl	%edx, 24(%esp)
	movl	%ecx, 20(%esp)
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%edi, 8(%esp)
	movl	$.L.str27458, 4(%esp)
.LBB124_129:                            # %if.then336
	movl	$2, (%esp)
	calll	logprintf
	movl	416(%esp), %ecx
	movl	420(%esp), %eax
.LBB124_130:                            # %if.end348
	incl	opt+244
	movl	total_downloaded_bytes+4, %edx
	addl	total_downloaded_bytes, %ecx
	movl	%ecx, total_downloaded_bytes
	adcl	%eax, %edx
	movl	%edx, total_downloaded_bytes+4
	movl	484(%esp), %eax
	movl	544(%esp), %ecx
	testb	$32, (%ecx)
	je	.LBB124_136
# BB#131:                               # %if.then354
	movl	%eax, 4(%esp)
	movl	$2, (%esp)
	calll	downloaded_file
	jmp	.LBB124_152
.LBB124_143:                            # %if.then408
	calll	abort
.LBB124_74:                             # %if.else186
	movl	$5, 8(%esp)
	movl	$.L.str14445, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	456(%esp), %eax
	movl	460(%esp), %ebx
	movl	%eax, (%esp)
	calll	escnonprint
	movl	%eax, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
.LBB124_75:                             # %if.else186
	movl	$1, (%esp)
	calll	logprintf
	movl	$.L.str8439, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	$34, %edi
	testl	%esi, %esi
	je	.LBB124_153
# BB#76:                                # %if.else194
	movl	%esi, (%esp)
	calll	checking_free
	movl	$34, %edi
	jmp	.LBB124_153
.LBB124_113:                            # %if.else273
	movl	$5, 8(%esp)
	movl	$.L.str23454, 4(%esp)
.LBB124_109:                            # %if.else265
	movl	$0, (%esp)
	calll	dcgettext
.LBB124_110:                            # %if.else265
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	jmp	.LBB124_152
.LBB124_136:                            # %if.else357
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	downloaded_file
	jmp	.LBB124_152
.Ltmp124:
	.size	http_loop, .Ltmp124-http_loop
	.section	.rodata,"a",@progbits
	.align	4
.LJTI124_0:
	.long	.LBB124_151
	.long	.LBB124_148
	.long	.LBB124_151
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_148
	.long	.LBB124_148
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_153
	.long	.LBB124_152
	.long	.LBB124_65
	.long	.LBB124_148
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_148
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_153
	.long	.LBB124_153
	.long	.LBB124_64
	.long	.LBB124_148
	.long	.LBB124_153
.LJTI124_1:
	.long	.LBB124_153
	.long	.LBB124_148
	.long	.LBB124_148
	.long	.LBB124_61
	.long	.LBB124_153
	.long	.LBB124_62
	.long	.LBB124_64
	.long	.LBB124_64
	.long	.LBB124_148

	.text
	.align	16, 0x90
	.type	gethttp,@function
gethttp:                                # @gethttp
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$572, %esp              # imm = 0x23C
	movl	%edx, -536(%ebp)        # 4-byte Spill
	movl	%ecx, -544(%ebp)        # 4-byte Spill
	movl	8(%ebp), %eax
	movl	(%eax), %edi
	cmpb	$0, opt+144
	sete	%bh
	cmpb	$0, opt+14
	movl	$0, 4(%edx)
	movl	$0, (%edx)
	movl	$-1, 12(%edx)
	movl	$-1, 8(%edx)
	movl	$-1, 24(%edx)
	movl	$0, 32(%edx)
	movl	$0, 28(%edx)
	movl	$0, 40(%edx)
	movl	$0, 36(%edx)
	setne	%bl
	subl	$16, %esp
	movl	$20, (%esp)
	calll	checking_malloc0
	addl	$16, %esp
	movl	%eax, %esi
	movl	%esi, -520(%ebp)        # 4-byte Spill
	movl	$8, 16(%esi)
	subl	$16, %esp
	movl	$96, (%esp)
	calll	checking_malloc
	addl	$16, %esp
	movl	%eax, 8(%esi)
	orb	%bh, %bl
	movl	12(%ebp), %edx
	testl	%edx, %edx
	setne	-545(%ebp)              # 1-byte Folded Spill
	movl	$.L.str37468, %esi
	andl	$4, %edi
	movl	%edi, -532(%ebp)        # 4-byte Spill
	jne	.LBB125_2
# BB#1:                                 # %if.else
	movl	$.L.str38469, %eax
	movl	opt+316, %ecx
	orl	opt+312, %ecx
	movl	$.L.str36467, %esi
	cmovnel	%eax, %esi
.LBB125_2:                              # %if.end11
	orb	%bl, -545(%ebp)         # 1-byte Folded Spill
	movl	-536(%ebp), %eax        # 4-byte Reload
	leal	28(%eax), %eax
	movl	%eax, -584(%ebp)        # 4-byte Spill
	movl	%edx, %eax
	testl	%eax, %eax
	je	.LBB125_4
# BB#3:                                 # %if.then13
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	jmp	.LBB125_5
.LBB125_4:                              # %if.else15
	subl	$16, %esp
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_full_path
.LBB125_5:                              # %if.else15
	addl	$16, %esp
	movl	-520(%ebp), %ebx        # 4-byte Reload
	movl	%esi, (%ebx)
	movl	%eax, 4(%ebx)
	movl	-536(%ebp), %eax        # 4-byte Reload
	movl	64(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str39470, %edx
	calll	request_set_header
	addl	$16, %esp
	movl	8(%ebp), %eax
	testb	$8, (%eax)
	je	.LBB125_7
# BB#6:                                 # %if.then20
	subl	$16, %esp
	movl	$0, 4(%esp)
	movl	$.L.str41472, (%esp)
	movl	%ebx, %ecx
	movl	$.L.str40471, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_7:                              # %if.end21
	movl	-536(%ebp), %edi        # 4-byte Reload
	movl	16(%edi), %eax
	movl	20(%edi), %ecx
	movl	%eax, %edx
	orl	%ecx, %edx
	movl	-544(%ebp), %esi        # 4-byte Reload
	je	.LBB125_9
# BB#8:                                 # %if.then23
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str43474, (%esp)
	calll	aprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str42473, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_9:                              # %do.body
	movl	opt+256, %eax
	testl	%eax, %eax
	je	.LBB125_10
# BB#11:                                # %if.else31
	cmpb	$0, (%eax)
	je	.LBB125_14
# BB#12:                                # %if.then33
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	jmp	.LBB125_13
.LBB125_10:                             # %if.then29
	movl	version_string, %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str45476, (%esp)
	calll	aprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
.LBB125_13:                             # %if.then33
	movl	%ebx, %ecx
	movl	$.L.str44475, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_14:                             # %do.end
	subl	$16, %esp
	movl	$0, 4(%esp)
	movl	$.L.str47478, (%esp)
	movl	%ebx, %ecx
	movl	$.L.str46477, %edx
	calll	request_set_header
	addl	$16, %esp
	movl	40(%esi), %eax
	movl	%eax, -124(%ebp)
	movl	44(%esi), %eax
	movl	%eax, -128(%ebp)
	movl	8(%esi), %eax
	subl	$16, %esp
	leal	-128(%ebp), %ecx
	movl	%ecx, 8(%esp)
	leal	-124(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	calll	search_netrc
	addl	$16, %esp
	movl	-124(%ebp), %esi
	testl	%esi, %esi
	jne	.LBB125_16
# BB#15:                                # %cond.false
	movl	opt+132, %esi
	testl	%esi, %esi
	cmovel	opt+108, %esi
.LBB125_16:                             # %cond.end42
	movl	%esi, -124(%ebp)
	movl	-128(%ebp), %edi
	testl	%edi, %edi
	jne	.LBB125_18
# BB#17:                                # %cond.false46
	movl	opt+136, %edi
	testl	%edi, %edi
	cmovel	opt+112, %edi
.LBB125_18:                             # %cond.end52
	movl	%ebx, -520(%ebp)        # 4-byte Spill
	movl	%edi, -128(%ebp)
	movb	$0, -565(%ebp)          # 1-byte Folded Spill
	testl	%esi, %esi
	je	.LBB125_32
# BB#19:                                # %cond.end52
	testl	%edi, %edi
	je	.LBB125_32
# BB#20:                                # %land.lhs.true56
	movb	$0, -565(%ebp)          # 1-byte Folded Spill
	movl	-544(%ebp), %eax        # 4-byte Reload
	cmpl	$0, 40(%eax)
	jne	.LBB125_32
# BB#21:                                # %if.then59
	cmpb	$0, opt+341
	je	.LBB125_26
# BB#22:                                # %do.body.i
	cmpb	$0, opt+250
	je	.LBB125_25
# BB#23:                                # %if.then3.i
	subl	$16, %esp
	movl	$.L.str142, (%esp)
	jmp	.LBB125_24
.LBB125_26:                             # %if.else.i
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	8(%eax), %ebx
	movl	basic_authed_hosts, %eax
	testl	%eax, %eax
	je	.LBB125_30
# BB#27:                                # %land.lhs.true.i
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_contains
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_30
# BB#28:                                # %do.body7.i
	cmpb	$0, opt+250
	je	.LBB125_25
# BB#29:                                # %if.then12.i
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str143, (%esp)
.LBB125_24:                             # %if.then3.i
	calll	debug_logprintf
	addl	$16, %esp
.LBB125_25:                             # %if.then27.i
	movl	%esi, %ecx
	movl	%edi, %edx
	calll	basic_authentication_encode
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	-520(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str63494, %edx
	calll	request_set_header
	addl	$16, %esp
	movb	$1, -565(%ebp)          # 1-byte Folded Spill
	jmp	.LBB125_32
.LBB125_30:                             # %do.body16.i
	movb	$0, -565(%ebp)          # 1-byte Folded Spill
	cmpb	$0, opt+250
	jne	.LBB125_31
	.align	16, 0x90
.LBB125_32:                             # %if.end63
	movl	-544(%ebp), %edi        # 4-byte Reload
	movl	4(%edi), %eax
	movl	12(%edi), %ecx
	movl	%ecx, -500(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	scheme_default_port
	addl	$16, %esp
	movl	%eax, %esi
	movl	8(%edi), %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$58, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movl	12(%edi), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%ebx, 4(%esp)
	cmpl	%esi, -500(%ebp)        # 4-byte Folded Reload
	setne	%cl
	movzbl	%cl, %ecx
	testl	%eax, %eax
	setne	%al
	movzbl	%al, %eax
	shll	$2, %eax
	movl	gethttp.hfmt(%eax,%ecx,8), %eax
	movl	%eax, (%esp)
	calll	aprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	-520(%ebp), %ebx        # 4-byte Reload
	movl	%ebx, %ecx
	movl	$.L.str52483, %edx
	calll	request_set_header
	addl	$16, %esp
	cmpb	$0, -545(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_34
# BB#33:                                # %if.then75
	subl	$16, %esp
	movl	$0, 4(%esp)
	movl	$.L.str54485, (%esp)
	movl	%ebx, %ecx
	movl	$.L.str53484, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_34:                             # %if.end76
	cmpb	$0, opt+296
	movl	12(%ebp), %edi
	je	.LBB125_36
# BB#35:                                # %if.then78
	movl	-544(%ebp), %edx        # 4-byte Reload
	movl	8(%edx), %eax
	movl	12(%edx), %ecx
	movl	16(%edx), %esi
	movl	wget_cookie_jar, %edx
	subl	$32, %esp
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 16(%esp)
	calll	cookie_header
	addl	$32, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str55486, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_36:                             # %if.end82
	xorl	%esi, %esi
	movl	opt+312, %eax
	orl	opt+316, %eax
	movl	$0, -508(%ebp)          # 4-byte Folded Spill
	je	.LBB125_44
# BB#37:                                # %if.then86
	subl	$16, %esp
	movl	$0, 4(%esp)
	movl	$.L.str57488, (%esp)
	movl	%ebx, %ecx
	movl	$.L.str56487, %edx
	calll	request_set_header
	addl	$16, %esp
	movl	opt+312, %eax
	testl	%eax, %eax
	je	.LBB125_39
# BB#38:                                # %if.then88
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	jmp	.LBB125_42
.LBB125_39:                             # %if.else91
	movl	opt+316, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	file_size
	addl	$16, %esp
	movl	%eax, %esi
	andl	%edx, %eax
	cmpl	$-1, %eax
	jne	.LBB125_40
# BB#41:                                # %if.then95
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str58489, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -500(%ebp)        # 4-byte Spill
	movl	%edi, %esi
	movl	opt+316, %edi
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, %edi
	movl	-500(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	xorl	%esi, %esi
.LBB125_42:                             # %if.then95
	xorl	%eax, %eax
	jmp	.LBB125_43
.LBB125_40:
	movl	%edx, %eax
.LBB125_43:                             # %if.end100
	movl	%eax, -508(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str59490, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB125_44:                             # %if.end103
	movl	%esi, -528(%ebp)        # 4-byte Spill
	movl	opt+140, %eax
	testl	%eax, %eax
	je	.LBB125_48
# BB#45:                                # %for.cond.preheader
	movl	(%eax), %edx
	testl	%edx, %edx
	je	.LBB125_48
# BB#46:
	movl	$4, %esi
	.align	16, 0x90
.LBB125_47:                             # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, %ecx
	calll	request_set_user_header
	movl	opt+140, %eax
	movl	(%eax,%esi), %edx
	addl	$4, %esi
	testl	%edx, %edx
	jne	.LBB125_47
.LBB125_48:                             # %retry_with_auth.preheader
	movl	$.L.str67498, %eax
	testl	%edi, %edi
	movl	$.L.str68499, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, -576(%ebp)        # 4-byte Spill
	xorb	%al, %al
	movb	$0, -553(%ebp)          # 1-byte Folded Spill
	movb	%al, %bl
	movl	$-1, -516(%ebp)         # 4-byte Folded Spill
	movl	-544(%ebp), %edx        # 4-byte Reload
	jmp	.LBB125_49
	.align	16, 0x90
.LBB125_336:                            # %if.end528
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
	movb	$1, %al
	movl	12(%ebp), %edi
	movl	-524(%ebp), %edx        # 4-byte Reload
.LBB125_49:                             # %retry_with_auth
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB125_304 Depth 2
                                        #     Child Loop BB125_209 Depth 2
                                        #     Child Loop BB125_218 Depth 2
                                        #     Child Loop BB125_189 Depth 2
                                        #     Child Loop BB125_187 Depth 2
                                        #     Child Loop BB125_183 Depth 2
                                        #     Child Loop BB125_168 Depth 2
                                        #     Child Loop BB125_152 Depth 2
                                        #       Child Loop BB125_153 Depth 3
                                        #       Child Loop BB125_161 Depth 3
                                        #     Child Loop BB125_77 Depth 2
                                        #     Child Loop BB125_108 Depth 2
                                        #     Child Loop BB125_198 Depth 2
                                        #     Child Loop BB125_196 Depth 2
	movb	%al, -554(%ebp)         # 1-byte Spill
	movb	%bl, -540(%ebp)         # 1-byte Spill
	testl	%edi, %edi
	movl	-520(%ebp), %ebx        # 4-byte Reload
	je	.LBB125_57
# BB#50:                                # %if.then111
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	opt+172, %ecx
	testl	%ecx, %ecx
	je	.LBB125_52
# BB#51:                                # %if.then111
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	opt+176, %edx
	testl	%edx, %edx
	jne	.LBB125_53
.LBB125_52:                             # %if.else116
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	40(%edi), %ecx
	movl	44(%edi), %edx
.LBB125_53:                             # %if.end119
                                        #   in Loop: Header=BB125_49 Depth=1
	xorl	%eax, %eax
	testl	%ecx, %ecx
	je	.LBB125_56
# BB#54:                                # %if.end119
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%edx, %edx
	je	.LBB125_56
# BB#55:                                # %if.then123
                                        #   in Loop: Header=BB125_49 Depth=1
	calll	basic_authentication_encode
.LBB125_56:                             # %if.end125
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str60491, %edx
	calll	request_set_header
	addl	$16, %esp
	movl	%edi, %edx
.LBB125_57:                             # %if.end126
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, -545(%ebp)          # 1-byte Folded Reload
	movl	-516(%ebp), %edi        # 4-byte Reload
	jne	.LBB125_58
# BB#59:                                # %if.then128
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	pconn_active.b, %al
	testb	%al, %al
	jne	.LBB125_61
# BB#60:                                #   in Loop: Header=BB125_49 Depth=1
	movl	%edx, -524(%ebp)        # 4-byte Spill
	jmp	.LBB125_91
.LBB125_58:                             #   in Loop: Header=BB125_49 Depth=1
	movl	%edx, -524(%ebp)        # 4-byte Spill
	.align	16, 0x90
.LBB125_91:                             # %if.end155
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%edi, %edi
	jns	.LBB125_96
# BB#92:                                # %if.then158
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-524(%ebp), %ecx        # 4-byte Reload
	movl	8(%ecx), %eax
	movl	12(%ecx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	connect_to_host
	addl	$16, %esp
	movl	%eax, %edi
	cmpl	$-100, %edi
	je	.LBB125_93
# BB#94:                                # %if.else165
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%edi, %edi
	js	.LBB125_95
.LBB125_96:                             # %if.end175
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%ebx, %ecx
	movl	%edi, %edx
	calll	request_send
	testl	%eax, %eax
	movl	-528(%ebp), %esi        # 4-byte Reload
	js	.LBB125_119
# BB#97:                                # %if.then179
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	opt+312, %ecx
	testl	%ecx, %ecx
	jne	.LBB125_98
# BB#102:                               # %if.else192
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, %ebx
	movl	opt+316, %esi
	testl	%esi, %esi
	je	.LBB125_101
# BB#103:                               # %if.else192
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%ebx, %ecx
	orl	-508(%ebp), %ecx        # 4-byte Folded Reload
	je	.LBB125_101
# BB#104:                               # %if.then197
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	jne	.LBB125_105
	.align	16, 0x90
.LBB125_106:                            # %do.end.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$.L.str133, 4(%esp)
	calll	fopen64
	addl	$16, %esp
	movl	%eax, -504(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	movl	%ebx, %esi
	je	.LBB125_119
# BB#107:                               #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, -516(%ebp)        # 4-byte Spill
	movl	$0, -500(%ebp)          # 4-byte Folded Spill
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB125_108:                            # %while.cond.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	feof
	addl	$16, %esp
	testl	%eax, %eax
	movl	-508(%ebp), %edi        # 4-byte Reload
	jne	.LBB125_124
# BB#109:                               # %while.cond.i
                                        #   in Loop: Header=BB125_108 Depth=2
	cmpl	%esi, -500(%ebp)        # 4-byte Folded Reload
	setae	%al
	cmpl	%edi, %ebx
	setge	%cl
	je	.LBB125_111
# BB#110:                               # %while.cond.i
                                        #   in Loop: Header=BB125_108 Depth=2
	movb	%cl, %al
.LBB125_111:                            # %while.cond.i
                                        #   in Loop: Header=BB125_108 Depth=2
	testb	%al, %al
	jne	.LBB125_124
# BB#112:                               # %while.body.i
                                        #   in Loop: Header=BB125_108 Depth=2
	movl	%edi, -508(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	$8192, 8(%esp)          # imm = 0x2000
	movl	$1, 4(%esp)
	movl	$post_file.chunk, (%esp)
	calll	fread
	addl	$16, %esp
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB125_113
# BB#114:                               # %if.end12.i
                                        #   in Loop: Header=BB125_108 Depth=2
	movl	%esi, %ecx
	subl	-500(%ebp), %ecx        # 4-byte Folded Reload
	movl	-508(%ebp), %esi        # 4-byte Reload
	sbbl	%ebx, %esi
	cmpl	%edi, %ecx
	seta	%dl
	subl	$32, %esp
	movl	-516(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	movl	%edi, %eax
	sarl	$31, %eax
	cmpl	%eax, %esi
	setg	%dh
	je	.LBB125_116
# BB#115:                               # %if.end12.i
                                        #   in Loop: Header=BB125_108 Depth=2
	movb	%dh, %dl
.LBB125_116:                            # %if.end12.i
                                        #   in Loop: Header=BB125_108 Depth=2
	testb	%dl, %dl
	cmovnel	%edi, %ecx
	movl	%ecx, 8(%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	movl	$post_file.chunk, 4(%esp)
	movl	%ecx, %eax
	sarl	$31, %eax
	addl	%ecx, -500(%ebp)        # 4-byte Folded Spill
	adcl	%eax, %ebx
	calll	fd_write
	addl	$32, %esp
	testl	%eax, %eax
	movl	-528(%ebp), %esi        # 4-byte Reload
	jns	.LBB125_108
	jmp	.LBB125_117
.LBB125_98:                             # %do.body182
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	jne	.LBB125_99
	.align	16, 0x90
.LBB125_100:                            # %do.end189
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$32, %esp
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%edi, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	addl	$32, %esp
.LBB125_101:                            # %if.end201
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%eax, %eax
	js	.LBB125_119
	.align	16, 0x90
.LBB125_131:                            # %if.end215
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str66497, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	-576(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	8(%ebp), %eax
	andb	$-3, (%eax)
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$65536, 12(%esp)        # imm = 0x10000
	movl	$512, 8(%esp)           # imm = 0x200
	movl	$response_head_terminator, 4(%esp)
	calll	fd_read_hunk
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB125_132
# BB#149:                               # %do.body252
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, -516(%ebp)        # 4-byte Spill
	cmpb	$0, opt+250
	jne	.LBB125_150
	.align	16, 0x90
.LBB125_151:                            # %do.end259
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	$8, (%esp)
	calll	checking_malloc0
	addl	$16, %esp
	movl	%eax, %ecx
	movl	%ecx, -500(%ebp)        # 4-byte Spill
	movl	%esi, (%ecx)
	xorl	%ebx, %ebx
	cmpb	$0, (%esi)
	movl	%ebx, -504(%ebp)        # 4-byte Spill
	movl	%esi, %edi
	movl	%esi, -572(%ebp)        # 4-byte Spill
	movl	$16, %eax
	je	.LBB125_173
	jmp	.LBB125_152
	.align	16, 0x90
.LBB125_166:                            #   in Loop: Header=BB125_152 Depth=2
	movl	%esi, %ebx
	movl	-512(%ebp), %eax        # 4-byte Reload
	movl	%eax, -504(%ebp)        # 4-byte Spill
	movl	$16, %eax
	movl	-500(%ebp), %ecx        # 4-byte Reload
.LBB125_152:                            # %do.body.i1246
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB125_153 Depth 3
                                        #       Child Loop BB125_161 Depth 3
	movl	-504(%ebp), %edx        # 4-byte Reload
	leal	1(%edx), %edx
	cmpl	%edx, %ebx
	movl	%ebx, %esi
	jge	.LBB125_155
	.align	16, 0x90
.LBB125_153:                            # %while.body5.i
                                        #   Parent Loop BB125_49 Depth=1
                                        #     Parent Loop BB125_152 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	addl	%ebx, %ebx
	cmpl	$16, %ebx
	cmovll	%eax, %ebx
	cmpl	%edx, %ebx
	jl	.LBB125_153
# BB#154:                               # %while.end.i1248
                                        #   in Loop: Header=BB125_152 Depth=2
	xorl	%esi, %esi
	testl	%ebx, %ebx
	jne	.LBB125_156
.LBB125_155:                            # %while.end.do.end_crit_edge.i
                                        #   in Loop: Header=BB125_152 Depth=2
	movl	%edx, -512(%ebp)        # 4-byte Spill
	movl	4(%ecx), %eax
	jmp	.LBB125_157
.LBB125_156:                            # %if.then10.i
                                        #   in Loop: Header=BB125_152 Depth=2
	movl	%edx, -512(%ebp)        # 4-byte Spill
	movl	4(%ecx), %eax
	subl	$16, %esp
	movl	%ecx, %esi
	leal	(,%ebx,4), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	addl	$16, %esp
	movl	%eax, 4(%esi)
	movl	%ebx, %esi
.LBB125_157:                            # %do.end.i1252
                                        #   in Loop: Header=BB125_152 Depth=2
	movl	-504(%ebp), %ecx        # 4-byte Reload
	movl	%edi, (%eax,%ecx,4)
	movb	(%edi), %al
	testb	%al, %al
	je	.LBB125_167
# BB#158:                               # %do.end.i1252
                                        #   in Loop: Header=BB125_152 Depth=2
	cmpb	$10, %al
	je	.LBB125_167
# BB#159:                               # %do.end.i1252
                                        #   in Loop: Header=BB125_152 Depth=2
	cmpb	$13, %al
	jne	.LBB125_161
# BB#160:                               # %land.lhs.true.i1253
                                        #   in Loop: Header=BB125_152 Depth=2
	cmpb	$10, 1(%edi)
	je	.LBB125_167
	.align	16, 0x90
.LBB125_161:                            # %do.body32.i
                                        #   Parent Loop BB125_49 Depth=1
                                        #     Parent Loop BB125_152 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$10, 4(%esp)
	calll	strchr
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_162
# BB#163:                               # %if.else.i1255
                                        #   in Loop: Header=BB125_161 Depth=3
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	%eax, %edi
	jmp	.LBB125_164
.LBB125_162:                            # %if.then35.i
                                        #   in Loop: Header=BB125_161 Depth=3
	incl	%eax
	movl	%eax, %edi
.LBB125_164:                            # %do.cond.i
                                        #   in Loop: Header=BB125_161 Depth=3
	movb	(%edi), %al
	cmpb	$9, %al
	je	.LBB125_161
# BB#165:                               # %do.cond.i
                                        #   in Loop: Header=BB125_161 Depth=3
	cmpb	$32, %al
	je	.LBB125_161
	jmp	.LBB125_166
.LBB125_167:                            # %do.body47.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-504(%ebp), %eax        # 4-byte Reload
	leal	2(%eax), %eax
	cmpl	%eax, %esi
	movl	$16, %ecx
	jge	.LBB125_170
	.align	16, 0x90
.LBB125_168:                            # %while.body53.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	addl	%esi, %esi
	cmpl	$16, %esi
	cmovll	%ecx, %esi
	cmpl	%eax, %esi
	jl	.LBB125_168
# BB#169:                               # %while.end59.i
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%esi, %esi
	jne	.LBB125_171
.LBB125_170:                            # %while.end59.do.end68_crit_edge.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	4(%ecx), %eax
	jmp	.LBB125_172
.LBB125_171:                            # %if.then61.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-500(%ebp), %edi        # 4-byte Reload
	movl	4(%edi), %eax
	subl	$16, %esp
	shll	$2, %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%edi, %ecx
	addl	$16, %esp
	movl	%eax, 4(%ecx)
.LBB125_172:                            # %do.end68.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-504(%ebp), %edx        # 4-byte Reload
	movl	$0, 4(%eax,%edx,4)
.LBB125_173:                            # %resp_new.exit
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	4(%ecx), %eax
	testl	%eax, %eax
	jne	.LBB125_175
# BB#174:                               # %if.then.i1258
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%ecx, -500(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str130, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, %esi
	movl	$200, %eax
	jmp	.LBB125_201
.LBB125_175:                            # %if.end4.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	4(%eax), %esi
	testl	%esi, %esi
	je	.LBB125_176
# BB#177:                               # %if.end10.i1261
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%ecx, -500(%ebp)        # 4-byte Spill
	movl	(%eax), %edi
	movl	%esi, %eax
	subl	%edi, %eax
	cmpl	$4, %eax
	jl	.LBB125_178
# BB#179:                               # %lor.lhs.false.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str68499, 4(%esp)
	calll	strncmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_178
# BB#180:                               # %if.end14.i
                                        #   in Loop: Header=BB125_49 Depth=1
	leal	4(%edi), %ecx
	cmpl	%esi, %ecx
	jae	.LBB125_189
# BB#181:                               # %land.lhs.true.i1264
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$47, (%ecx)
	jne	.LBB125_189
# BB#182:                               # %if.then18.i1265
                                        #   in Loop: Header=BB125_49 Depth=1
	addl	$5, %edi
	.align	16, 0x90
.LBB125_183:                            # %while.cond.i1266
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	%esi, %edi
	jae	.LBB125_184
# BB#185:                               # %land.rhs.i
                                        #   in Loop: Header=BB125_183 Depth=2
	movzbl	(%edi), %ecx
	incl	%edi
	testb	$4, _sch_istable(%ecx,%ecx)
	jne	.LBB125_183
# BB#186:                               # %land.lhs.true29.i
                                        #   in Loop: Header=BB125_49 Depth=1
	leal	-1(%edi), %eax
	cmpb	$46, %cl
	cmovel	%edi, %eax
	jmp	.LBB125_187
.LBB125_176:                            #   in Loop: Header=BB125_49 Depth=1
	movl	%ecx, -500(%ebp)        # 4-byte Spill
	.align	16, 0x90
.LBB125_178:                            #   in Loop: Header=BB125_49 Depth=1
	xorl	%esi, %esi
	movl	$-1, %eax
	.align	16, 0x90
.LBB125_201:                            # %resp_status.exit
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%eax, -512(%ebp)        # 4-byte Spill
	cmpb	$0, opt+248
	jne	.LBB125_216
# BB#202:                               # %if.then263
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	$.L.str73504, %eax
	testl	%esi, %esi
	je	.LBB125_204
# BB#203:                               # %cond.true265
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	escnonprint
	addl	$16, %esp
.LBB125_204:                            # %cond.end268
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, -552(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	-512(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	$.L.str72503, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	jmp	.LBB125_205
.LBB125_216:                            # %if.else270
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, -552(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	$.L.str8439, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	-500(%ebp), %eax        # 4-byte Reload
	movl	4(%eax), %ecx
	testl	%ecx, %ecx
	je	.LBB125_205
# BB#217:                               # %for.cond.preheader.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	4(%ecx), %eax
	xorl	%esi, %esi
	jmp	.LBB125_218
	.align	16, 0x90
.LBB125_225:                            # %if.end22.i
                                        #   in Loop: Header=BB125_218 Depth=2
	calll	print_response_line
	movl	-500(%ebp), %eax        # 4-byte Reload
	movl	4(%eax), %ecx
	movl	8(%ecx,%esi), %eax
	addl	$4, %esi
.LBB125_218:                            # %for.cond.preheader.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testl	%eax, %eax
	je	.LBB125_205
# BB#219:                               # %for.body.i1272
                                        #   in Loop: Header=BB125_218 Depth=2
	movl	(%ecx,%esi), %ecx
	cmpl	%eax, %ecx
	jae	.LBB125_220
# BB#221:                               # %land.lhs.true.i1274
                                        #   in Loop: Header=BB125_218 Depth=2
	leal	-1(%eax), %edi
	cmpb	$10, -1(%eax)
	cmovnel	%eax, %edi
	jmp	.LBB125_222
.LBB125_220:                            #   in Loop: Header=BB125_218 Depth=2
	movl	%eax, %edi
.LBB125_222:                            # %if.end12.i1275
                                        #   in Loop: Header=BB125_218 Depth=2
	cmpl	%edi, %ecx
	jae	.LBB125_223
# BB#224:                               # %land.lhs.true15.i
                                        #   in Loop: Header=BB125_218 Depth=2
	leal	-1(%edi), %edx
	cmpb	$13, -1(%edi)
	cmovnel	%edi, %edx
	jmp	.LBB125_225
.LBB125_223:                            #   in Loop: Header=BB125_218 Depth=2
	movl	%edi, %edx
	jmp	.LBB125_225
.LBB125_205:                            # %if.end271
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-536(%ebp), %edx        # 4-byte Reload
	cmpl	$0, 68(%edx)
	jne	.LBB125_237
# BB#206:                               # %if.then273
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+340
	je	.LBB125_235
# BB#207:                               # %lor.lhs.false275
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-96(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-92(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str75506, %edx
	calll	resp_header_locate
	addl	$16, %esp
	cmpl	$-1, %eax
	je	.LBB125_235
# BB#208:                               # %lor.lhs.false277
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-96(%ebp), %esi
	movl	-92(%ebp), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	leal	-384(%ebp), %edi
	movl	%edi, (%esp)
	subl	%eax, %esi
	cmpl	$255, %esi
	movl	$255, %eax
	cmovgl	%eax, %esi
	movl	%esi, 8(%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, -384(%ebp,%esi)
	movl	%edi, -72(%ebp)
	.align	16, 0x90
.LBB125_209:                            # %while.cond.i1289
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	subl	$16, %esp
	leal	-88(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-80(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-72(%ebp), %eax
	movl	%eax, (%esp)
	movl	$59, 12(%esp)
	calll	extract_param
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB125_235
# BB#210:                               # %while.body.i1294
                                        #   in Loop: Header=BB125_209 Depth=2
	movl	-80(%ebp), %eax
	movl	-76(%ebp), %ecx
	subl	%eax, %ecx
	cmpl	$8, %ecx
	jne	.LBB125_209
# BB#211:                               # %land.lhs.true.i1297
                                        #   in Loop: Header=BB125_209 Depth=2
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$8, 8(%esp)
	movl	$.L.str128, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_209
# BB#212:                               # %land.lhs.true3.i
                                        #   in Loop: Header=BB125_209 Depth=2
	movl	-88(%ebp), %esi
	testl	%esi, %esi
	je	.LBB125_209
# BB#213:                               # %if.then.i1302
                                        #   in Loop: Header=BB125_209 Depth=2
	movl	-84(%ebp), %ebx
	movl	%ebx, -504(%ebp)        # 4-byte Spill
	subl	%esi, %ebx
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$47, 4(%esp)
	calll	memrchr
	addl	$16, %esp
	movl	%eax, %edi
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$92, 4(%esp)
	testl	%edi, %edi
	sete	%bl
	calll	memrchr
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_226
# BB#214:                               # %if.then.i1302
                                        #   in Loop: Header=BB125_209 Depth=2
	testb	%bl, %bl
	je	.LBB125_215
.LBB125_226:                            # %if.else.i1304
                                        #   in Loop: Header=BB125_209 Depth=2
	testl	%eax, %eax
	sete	%cl
	testb	%bl, %cl
	jne	.LBB125_229
# BB#227:                               # %if.then28.i
                                        #   in Loop: Header=BB125_209 Depth=2
	testl	%edi, %edi
	cmovel	%eax, %edi
	jmp	.LBB125_228
.LBB125_215:                            # %if.then23.i
                                        #   in Loop: Header=BB125_209 Depth=2
	cmpl	%eax, %edi
	cmovbel	%eax, %edi
.LBB125_228:                            # %if.then28.i
                                        #   in Loop: Header=BB125_209 Depth=2
	incl	%edi
	movl	%edi, -88(%ebp)
	movl	%edi, %esi
.LBB125_229:                            # %if.end36.i
                                        #   in Loop: Header=BB125_209 Depth=2
	movl	-504(%ebp), %ebx        # 4-byte Reload
	cmpl	%ebx, %esi
	je	.LBB125_209
# BB#230:                               # %if.end41.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	opt+44, %edi
	subl	$16, %esp
	testl	%edi, %edi
	jne	.LBB125_231
# BB#234:                               # %if.else71.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	strdupdelim
	jmp	.LBB125_236
.LBB125_235:                            # %if.then281
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_file_name
.LBB125_236:                            # %if.then281
                                        #   in Loop: Header=BB125_49 Depth=1
	addl	$16, %esp
	movl	-536(%ebp), %edx        # 4-byte Reload
	movl	%eax, 68(%edx)
	.align	16, 0x90
.LBB125_237:                            # %if.end285
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, 72(%edx)
	jne	.LBB125_249
# BB#238:                               # %land.lhs.true287
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%edx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	%edx, %esi
	calll	file_exists_p
	movl	%esi, %edx
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB125_249
# BB#239:                               # %if.then291
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	opt+104, %eax
	movb	opt+42, %cl
	testl	%eax, %eax
	je	.LBB125_240
	.align	16, 0x90
.LBB125_243:                            # %if.else304
                                        #   in Loop: Header=BB125_49 Depth=1
	orb	opt+116, %cl
	orb	opt+251, %cl
	jne	.LBB125_249
# BB#244:                               # %lor.lhs.false313
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+32
	jne	.LBB125_249
# BB#245:                               # %lor.lhs.false313
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%eax, %eax
	jne	.LBB125_249
# BB#246:                               # %if.then318
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%edx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	movl	%edx, %esi
	calll	unique_name
	addl	$16, %esp
	movl	%eax, %edi
	movl	68(%esi), %eax
	cmpl	%eax, %edi
	je	.LBB125_248
# BB#247:                               # %if.then324
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB125_248:                            # %if.end326
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, %edx
	movl	%edi, 68(%edx)
.LBB125_249:                            # %if.end330
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$1, 72(%edx)
	cmpb	$0, opt+251
	je	.LBB125_260
# BB#250:                               # %land.lhs.true334
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, 73(%edx)
	jne	.LBB125_260
# BB#251:                               # %if.then336
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%edx), %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %edi
	leal	21(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	cmpb	$0, opt+252
	je	.LBB125_252
# BB#253:                               # %if.end347
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movw	$103, 4(%esi,%edi)
	movl	$1769107246, (%esi,%edi) # imm = 0x69726F2E
	subl	$16, %esp
	leal	-480(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	testl	%eax, %eax
	movl	$0, %eax
	cmovnel	%eax, %esi
	je	.LBB125_254
# BB#255:                               # %if.end347.if.then349_crit_edge
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-536(%ebp), %eax        # 4-byte Reload
	movl	68(%eax), %ebx
	jmp	.LBB125_256
.LBB125_61:                             # %if.then128
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	pconn+12, %al
	testb	%al, %al
	je	.LBB125_63
# BB#62:                                #   in Loop: Header=BB125_49 Depth=1
	movl	%edx, -524(%ebp)        # 4-byte Spill
	jmp	.LBB125_91
.LBB125_252:                            #   in Loop: Header=BB125_49 Depth=1
	xorl	%esi, %esi
.LBB125_256:                            # %if.then349
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-480(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	testl	%eax, %eax
	movl	-536(%ebp), %eax        # 4-byte Reload
	jne	.LBB125_258
# BB#257:                               # %if.then354
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%eax), %esi
	jmp	.LBB125_258
.LBB125_254:                            #   in Loop: Header=BB125_49 Depth=1
	movl	-536(%ebp), %eax        # 4-byte Reload
.LBB125_258:                            # %if.end357
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%esi, %esi
	je	.LBB125_260
# BB#259:                               # %if.then360
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	%eax, %esi
	calll	checking_strdup
	movl	%esi, %ecx
	addl	$16, %esp
	movl	%eax, 76(%ecx)
	movsd	-436(%ebp), %xmm0
	movsd	%xmm0, 80(%ecx)
	movl	-408(%ebp), %eax
	movl	%eax, 88(%ecx)
.LBB125_260:                            # %if.end363
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+14
	movl	-516(%ebp), %ebx        # 4-byte Reload
	jne	.LBB125_261
# BB#262:                               # %land.lhs.true365
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-68(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-64(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str59490, %edx
	calll	resp_header_locate
	addl	$16, %esp
	cmpl	$-1, %eax
	je	.LBB125_261
# BB#263:                               # %if.then369
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-68(%ebp), %esi
	movl	-64(%ebp), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	leal	-384(%ebp), %ebx
	movl	%ebx, (%esp)
	subl	%eax, %esi
	cmpl	$255, %esi
	movl	$255, %eax
	cmovgl	%eax, %esi
	movl	%esi, 8(%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, -384(%ebp,%esi)
	calll	__errno_location
	movl	%eax, %edi
	movl	$0, (%edi)
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$10, 8(%esp)
	movl	$0, 4(%esp)
	calll	strtoll
	addl	$16, %esp
	movl	%edx, %esi
	xorl	$2147483647, %edx       # imm = 0x7FFFFFFF
	movl	%eax, %ecx
	notl	%ecx
	orl	%edx, %ecx
	jne	.LBB125_266
# BB#264:                               # %land.lhs.true375
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpl	$34, (%edi)
	je	.LBB125_265
.LBB125_266:                            # %if.end387
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%eax, %edi
	cmpl	$-1, %edi
	sete	%al
	cmpl	$-2, %esi
	setg	%cl
	cmpl	$-1, %esi
	je	.LBB125_268
# BB#267:                               # %if.end387
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	%cl, %al
.LBB125_268:                            # %if.end387
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%al, %al
	movl	$-1, %eax
	cmovel	%eax, %esi
	cmovel	%eax, %edi
	movl	%edi, %eax
	andl	%esi, %eax
	cmpl	$-1, %eax
	sete	%al
	xorb	%dl, %dl
	orb	-545(%ebp), %al         # 1-byte Folded Reload
	movl	-516(%ebp), %ebx        # 4-byte Reload
	jne	.LBB125_269
# BB#270:                               # %if.then392
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-60(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-56(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str54485, %edx
	calll	resp_header_locate
	addl	$16, %esp
	cmpl	$-1, %eax
	jne	.LBB125_275
# BB#271:                               # %if.else395
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-52(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-48(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str53484, %edx
	calll	resp_header_locate
	addl	$16, %esp
	xorb	%dl, %dl
	cmpl	$-1, %eax
	je	.LBB125_272
# BB#273:                               # %if.end407
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, -504(%ebp)        # 4-byte Spill
	movl	-52(%ebp), %esi
	movl	-48(%ebp), %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%edi, %ebx
	leal	-384(%ebp), %edi
	movl	%edi, (%esp)
	subl	%eax, %esi
	cmpl	$255, %esi
	movl	$255, %eax
	cmovgl	%eax, %esi
	movl	%esi, 8(%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, -384(%ebp,%esi)
	movl	-504(%ebp), %esi        # 4-byte Reload
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	%ebx, %edi
	movl	-516(%ebp), %ebx        # 4-byte Reload
	movl	$.L.str54485, 4(%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_274
.LBB125_275:                            # %if.then409
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-524(%ebp), %eax        # 4-byte Reload
	movl	8(%eax), %ecx
	movl	%ecx, -564(%ebp)        # 4-byte Spill
	movl	12(%eax), %eax
	movl	%eax, -560(%ebp)        # 4-byte Spill
	movb	pconn_active.b, %al
	cmpb	$1, %al
	jne	.LBB125_281
# BB#276:                               # %if.then.i1348
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$1, %dl
	movl	pconn, %eax
	cmpl	%ebx, %eax
	je	.LBB125_277
# BB#278:                               # %if.else.i1350
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	jne	.LBB125_279
	.align	16, 0x90
.LBB125_280:                            # %invalidate_persistent.exit.i1353
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
.LBB125_281:                            # %if.end2.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, -504(%ebp)        # 4-byte Spill
	movl	%ebx, %esi
	movb	-553(%ebp), %bl         # 1-byte Reload
	andb	$1, %bl
	movb	$1, pconn_active.b
	movl	%esi, pconn
	subl	$16, %esp
	movl	-564(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, pconn+4
	movl	-560(%ebp), %eax        # 4-byte Reload
	movl	%eax, pconn+8
	movb	%bl, pconn+12
	movb	$0, pconn+13
	movb	$1, %dl
	cmpb	$0, opt+250
	jne	.LBB125_282
	.align	16, 0x90
.LBB125_283:                            # %if.then7.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, %ebx
	movl	-532(%ebp), %eax        # 4-byte Reload
	movl	-504(%ebp), %esi        # 4-byte Reload
	jmp	.LBB125_284
.LBB125_261:                            #   in Loop: Header=BB125_49 Depth=1
	xorb	%dl, %dl
	movl	$-1, %edi
	movl	$-1, %esi
	movl	-532(%ebp), %eax        # 4-byte Reload
	.align	16, 0x90
.LBB125_284:                            # %if.end413
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-512(%ebp), %ecx        # 4-byte Reload
	cmpl	$401, %ecx              # imm = 0x191
	jne	.LBB125_339
# BB#285:                               # %if.then416
                                        #   in Loop: Header=BB125_49 Depth=1
	testl	%eax, %eax
	jne	.LBB125_294
# BB#286:                               # %if.then416
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	%dl, %al
	xorb	$1, %al
	testb	%al, %al
	jne	.LBB125_294
# BB#287:                               # %land.lhs.true421
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	%ebx, %ecx
	movl	%ebx, %esi
	movb	%dl, %bl
	movl	%edi, %edx
	calll	skip_short_body
	movb	%bl, %cl
	movl	%esi, %ebx
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB125_294
# BB#288:                               # %do.body425
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%cl, %cl
	jne	.LBB125_301
# BB#289:                               # %if.then427
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_299
# BB#290:                               # %if.then427
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_299
# BB#291:                               # %if.then433
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	movl	%ebx, %eax
	je	.LBB125_293
# BB#292:                               # %if.then.i1358
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %eax
.LBB125_293:                            # %invalidate_persistent.exit1360
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_301
.LBB125_294:                            # %do.body439
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_299
# BB#295:                               # %do.body439
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_299
# BB#296:                               # %if.then445
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	jne	.LBB125_297
	.align	16, 0x90
.LBB125_298:                            # %invalidate_persistent.exit1364
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_300
.LBB125_299:                            # %if.else446
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
.LBB125_300:                            # %if.else446
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	$-1, -516(%ebp)         # 4-byte Folded Spill
.LBB125_301:                            # %if.end449
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$0, pconn+13
	cmpb	$0, -554(%ebp)          # 1-byte Folded Reload
	movl	-520(%ebp), %ebx        # 4-byte Reload
	movl	-500(%ebp), %ecx        # 4-byte Reload
	jne	.LBB125_338
# BB#302:                               # %land.lhs.true451
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpl	$0, -124(%ebp)
	je	.LBB125_338
# BB#303:                               # %land.lhs.true453
                                        #   in Loop: Header=BB125_49 Depth=1
	xorl	%esi, %esi
	cmpl	$0, -128(%ebp)
	je	.LBB125_338
	jmp	.LBB125_304
	.align	16, 0x90
.LBB125_313:                            # %for.inc468
                                        #   in Loop: Header=BB125_304 Depth=2
	incl	%esi
	movl	-520(%ebp), %ebx        # 4-byte Reload
	movl	-500(%ebp), %ecx        # 4-byte Reload
.LBB125_304:                            # %for.cond456
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	subl	$16, %esp
	leal	-488(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-484(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	$.L.str77508, %edx
	calll	resp_header_locate
	addl	$16, %esp
	movl	%eax, %esi
	cmpl	$-1, %esi
	je	.LBB125_337
# BB#305:                               # %for.body460
                                        #   in Loop: Header=BB125_304 Depth=2
	movl	-484(%ebp), %ebx
	movl	-488(%ebp), %edi
	subl	%ebx, %edi
	cmpl	$5, %edi
	jb	.LBB125_313
# BB#306:                               # %land.lhs.true.i1370
                                        #   in Loop: Header=BB125_304 Depth=2
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str79510, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_309
# BB#307:                               # %land.lhs.true2.i
                                        #   in Loop: Header=BB125_304 Depth=2
	cmpl	$5, %edi
	je	.LBB125_314
# BB#308:                               # %lor.lhs.false.i1375
                                        #   in Loop: Header=BB125_304 Depth=2
	movzbl	5(%ebx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB125_314
.LBB125_309:                            # %lor.rhs.i
                                        #   in Loop: Header=BB125_304 Depth=2
	cmpl	$6, %edi
	jb	.LBB125_313
# BB#310:                               # %land.lhs.true15.i1377
                                        #   in Loop: Header=BB125_304 Depth=2
	subl	$16, %esp
	movl	%ebx, (%esp)
	movl	$6, 8(%esp)
	movl	$.L.str120, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_313
# BB#311:                               # %land.rhs.i1378
                                        #   in Loop: Header=BB125_304 Depth=2
	cmpl	$6, %edi
	je	.LBB125_314
# BB#312:                               # %known_authentication_scheme_p.exit
                                        #   in Loop: Header=BB125_304 Depth=2
	movzbl	6(%ebx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	je	.LBB125_313
.LBB125_314:                            # %for.end470
                                        #   in Loop: Header=BB125_49 Depth=1
	leal	16(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%edi,%esi)
	cmpb	$0, -565(%ebp)          # 1-byte Folded Reload
	movl	-520(%ebp), %ebx        # 4-byte Reload
	je	.LBB125_318
# BB#315:                               # %lor.lhs.false476
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str79510, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_318
# BB#316:                               # %land.lhs.true479
                                        #   in Loop: Header=BB125_49 Depth=1
	movzbl	5(%esi), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB125_338
# BB#317:                               # %land.lhs.true479
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%al, %al
	je	.LBB125_338
.LBB125_318:                            # %if.then490
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_full_path
	addl	$16, %esp
	movl	%eax, %edi
	movzbl	(%esi), %eax
	movzbl	_sch_toupper(%eax), %ecx
	movl	-128(%ebp), %edx
	movl	-124(%ebp), %eax
	cmpl	$68, %ecx
	jne	.LBB125_319
# BB#322:                               # %sw.bb2.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	(%ebx), %ecx
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%edx, (%esp)
	movl	%esi, %ecx
	movl	%eax, %edx
	calll	digest_authentication_encode
	addl	$16, %esp
	jmp	.LBB125_323
.LBB125_319:                            # %if.then490
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpl	$66, %ecx
	jne	.LBB125_321
# BB#320:                               # %sw.bb.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%eax, %ecx
	calll	basic_authentication_encode
.LBB125_323:                            # %create_authorization_line.exit
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$2, 4(%esp)
	movl	%ebx, %ecx
	movl	$.L.str63494, %edx
	calll	request_set_header
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str80511, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_326
# BB#324:                               # %land.lhs.true496
                                        #   in Loop: Header=BB125_49 Depth=1
	movzbl	4(%esi), %eax
	movb	$1, %bl
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB125_336
# BB#325:                               # %land.lhs.true496
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%al, %al
	je	.LBB125_336
.LBB125_326:                            # %if.else508
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-544(%ebp), %eax        # 4-byte Reload
	cmpl	$0, 40(%eax)
	jne	.LBB125_335
# BB#327:                               # %land.lhs.true511
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str79510, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_335
# BB#328:                               # %land.lhs.true514
                                        #   in Loop: Header=BB125_49 Depth=1
	movzbl	5(%esi), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB125_330
# BB#329:                               # %land.lhs.true514
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%al, %al
	jne	.LBB125_335
.LBB125_330:                            # %if.then525
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	8(%eax), %esi
	movl	basic_authed_hosts, %eax
	testl	%eax, %eax
	jne	.LBB125_332
# BB#331:                               # %if.then.i1386
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	$1, (%esp)
	calll	make_nocase_string_hash_table
	addl	$16, %esp
	movl	%eax, basic_authed_hosts
.LBB125_332:                            # %if.end.i1388
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_contains
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_335
# BB#333:                               # %if.then3.i1390
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	basic_authed_hosts, %ebx
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 8(%esp)
	calll	hash_table_put
	addl	$16, %esp
	cmpb	$0, opt+250
	jne	.LBB125_334
	.align	16, 0x90
.LBB125_335:                            # %if.then7.i1391
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	-540(%ebp), %bl         # 1-byte Reload
	jmp	.LBB125_336
.LBB125_269:                            #   in Loop: Header=BB125_49 Depth=1
	movl	-532(%ebp), %eax        # 4-byte Reload
	jmp	.LBB125_284
.LBB125_265:                            #   in Loop: Header=BB125_49 Depth=1
	xorb	%dl, %dl
	movl	$-1, %edi
	movl	$-1, %esi
	movl	-532(%ebp), %eax        # 4-byte Reload
	movl	-516(%ebp), %ebx        # 4-byte Reload
	jmp	.LBB125_284
.LBB125_150:                            # %if.then257
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str71502, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB125_151
.LBB125_124:                            # %while.end.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	cmpl	%esi, -500(%ebp)        # 4-byte Folded Reload
	setae	%cl
	cmpl	%edi, %ebx
	setge	%al
	je	.LBB125_126
# BB#125:                               # %while.end.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	%al, %cl
.LBB125_126:                            # %while.end.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	%cl, -504(%ebp)         # 1-byte Spill
	calll	fclose
	addl	$16, %esp
	cmpb	$0, -504(%ebp)          # 1-byte Folded Reload
	je	.LBB125_127
# BB#128:                               # %if.end31.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-500(%ebp), %eax        # 4-byte Reload
	xorl	%esi, %eax
	xorl	%edi, %ebx
	orl	%eax, %ebx
	jne	.LBB125_543
# BB#129:                               # %do.body37.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, -508(%ebp)        # 4-byte Spill
	cmpb	$0, opt+250
	movl	-516(%ebp), %edi        # 4-byte Reload
	je	.LBB125_131
# BB#130:                               # %if.then42.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	$.L.str135, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB125_131
.LBB125_99:                             # %if.then187
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	$.L.str65496, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	opt+312, %ecx
	jmp	.LBB125_100
.LBB125_240:                            # %if.then291
                                        #   in Loop: Header=BB125_49 Depth=1
	testb	%cl, %cl
	je	.LBB125_243
	jmp	.LBB125_241
.LBB125_63:                             # %if.then128
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	12(%edx), %eax
	movl	pconn+8, %ecx
	cmpl	%eax, %ecx
	jne	.LBB125_64
# BB#65:                                # %if.end10.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	8(%edx), %esi
	movl	%edx, -524(%ebp)        # 4-byte Spill
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_72
# BB#66:                                # %if.end16.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	pconn, %eax
	subl	$16, %esp
	leal	-120(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	$1, 8(%esp)
	calll	socket_ip_address
	addl	$16, %esp
	testb	%al, %al
	je	.LBB125_67
# BB#70:                                # %if.end19.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	calll	lookup_host
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB125_542
# BB#71:                                # %if.end23.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	leal	-120(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	address_list_contains
	addl	$16, %esp
	movb	%al, -500(%ebp)         # 1-byte Spill
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	address_list_release
	addl	$16, %esp
	cmpb	$0, -500(%ebp)          # 1-byte Folded Reload
	je	.LBB125_91
.LBB125_72:                             # %if.end29.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	pconn, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	test_socket_open
	addl	$16, %esp
	testb	%al, %al
	je	.LBB125_67
# BB#73:                                # %if.then132
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	pconn+12, %al
	movb	%al, -553(%ebp)         # 1-byte Spill
	movl	pconn, %edi
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str61492, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	escnonprint
	addl	$16, %esp
	movl	pconn+8, %ecx
	subl	$16, %esp
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	cmpb	$0, opt+250
	je	.LBB125_75
# BB#74:                                # %if.then141
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	$.L.str62493, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
.LBB125_75:                             # %do.end143
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, pconn+13
	je	.LBB125_91
# BB#76:                                # %if.then145
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, -516(%ebp)        # 4-byte Spill
	movl	12(%ebx), %eax
	movl	%eax, -504(%ebp)        # 4-byte Spill
	movl	$-12, %edi
	movl	$-1, -500(%ebp)         # 4-byte Folded Spill
	.align	16, 0x90
.LBB125_77:                             # %for.cond.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	-500(%ebp), %eax        # 4-byte Reload
	incl	%eax
	movl	%eax, -500(%ebp)        # 4-byte Spill
	cmpl	-504(%ebp), %eax        # 4-byte Folded Reload
	jge	.LBB125_78
# BB#79:                                # %for.body.i
                                        #   in Loop: Header=BB125_77 Depth=2
	movl	-520(%ebp), %eax        # 4-byte Reload
	movl	8(%eax), %ebx
	movl	12(%ebx,%edi), %esi
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str63494, (%esp)
	addl	$12, %edi
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_77
# BB#80:                                # %if.then.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, %edx
	movl	8(%ebx,%edx), %eax
	cmpl	$3, %eax
	movl	%ebx, %ecx
	jne	.LBB125_81
# BB#85:                                # %sw.bb2.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	%ecx, %ebx
	movl	%ebx, -512(%ebp)        # 4-byte Spill
	movl	%edx, %esi
	calll	checking_free
	addl	$16, %esp
	movl	4(%ebx,%esi), %eax
	movl	%esi, %ebx
	jmp	.LBB125_86
.LBB125_272:                            #   in Loop: Header=BB125_49 Depth=1
	movl	-532(%ebp), %eax        # 4-byte Reload
	jmp	.LBB125_284
.LBB125_277:                            #   in Loop: Header=BB125_49 Depth=1
	movl	-532(%ebp), %eax        # 4-byte Reload
	jmp	.LBB125_284
.LBB125_64:                             #   in Loop: Header=BB125_49 Depth=1
	movl	%edx, -524(%ebp)        # 4-byte Spill
	jmp	.LBB125_91
.LBB125_274:                            #   in Loop: Header=BB125_49 Depth=1
	movl	-532(%ebp), %eax        # 4-byte Reload
	xorb	%dl, %dl
	jmp	.LBB125_284
.LBB125_184:                            #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, %eax
	.align	16, 0x90
.LBB125_187:                            # %while.cond36.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%eax, %ecx
	cmpl	%esi, %ecx
	jae	.LBB125_189
# BB#188:                               # %land.rhs39.i
                                        #   in Loop: Header=BB125_187 Depth=2
	leal	1(%ecx), %eax
	movzbl	(%ecx), %edx
	testb	$4, _sch_istable(%edx,%edx)
	jne	.LBB125_187
	.align	16, 0x90
.LBB125_189:                            # %while.cond51.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ecx, %eax
	cmpl	%esi, %eax
	jae	.LBB125_191
# BB#190:                               # %land.rhs54.i
                                        #   in Loop: Header=BB125_189 Depth=2
	leal	1(%eax), %ecx
	movzbl	(%eax), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB125_189
.LBB125_191:                            # %while.end64.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%esi, %ecx
	subl	%eax, %ecx
	cmpl	$3, %ecx
	jl	.LBB125_178
# BB#192:                               # %lor.lhs.false70.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movsbl	(%eax), %ecx
	movl	%ecx, %edx
	movzbl	%dl, %edx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB125_178
# BB#193:                               # %lor.lhs.false78.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movsbl	1(%eax), %edx
	movzbl	%dl, %edi
	testb	$4, _sch_istable(%edi,%edi)
	je	.LBB125_178
# BB#194:                               # %lor.lhs.false86.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movsbl	2(%eax), %ebx
	movzbl	%bl, %edi
	testb	$4, _sch_istable(%edi,%edi)
	je	.LBB125_178
# BB#195:                               # %if.end95.i
                                        #   in Loop: Header=BB125_49 Depth=1
	imull	$10, %edx, %edx
	imull	$100, %ecx, %ecx
	addl	%edx, %ecx
	leal	-5328(%ebx,%ecx), %edi
	addl	$3, %eax
	.align	16, 0x90
.LBB125_196:                            # %while.cond109.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%eax, %ecx
	cmpl	%esi, %ecx
	jae	.LBB125_198
# BB#197:                               # %land.rhs112.i
                                        #   in Loop: Header=BB125_196 Depth=2
	leal	1(%ecx), %eax
	movzbl	(%ecx), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB125_196
	.align	16, 0x90
.LBB125_198:                            # %while.cond123.i
                                        #   Parent Loop BB125_49 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%esi, %eax
	cmpl	%eax, %ecx
	jae	.LBB125_200
# BB#199:                               # %land.rhs126.i
                                        #   in Loop: Header=BB125_198 Depth=2
	leal	-1(%eax), %esi
	movzbl	-1(%eax), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB125_198
.LBB125_200:                            # %while.end137.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, %esi
	movl	%edi, %eax
	jmp	.LBB125_201
.LBB125_231:                            # %if.then43.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edi, (%esp)
	subl	%esi, %ebx
	movl	%ebx, -504(%ebp)        # 4-byte Spill
	calll	strlen
	addl	$16, %esp
	movb	-1(%eax,%edi), %cl
	movb	%cl, -564(%ebp)         # 1-byte Spill
	cmpb	$47, %cl
	setne	%cl
	movzbl	%cl, %edi
	addl	%eax, %edi
	leal	1(%ebx,%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_malloc
	addl	$16, %esp
	movl	%ebx, %edx
	movl	-536(%ebp), %ebx        # 4-byte Reload
	movl	%eax, 68(%ebx)
	movl	opt+44, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	leal	(%edi,%edx), %eax
	movl	%eax, -560(%ebp)        # 4-byte Spill
	calll	strcpy
	movl	%ebx, %ecx
	addl	$16, %esp
	cmpb	$47, -564(%ebp)         # 1-byte Folded Reload
	je	.LBB125_233
# BB#232:                               # %if.then59.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%ecx), %eax
	movb	$47, -1(%edi,%eax)
.LBB125_233:                            # %if.end62.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	68(%ecx), %eax
	subl	$16, %esp
	movl	-504(%ebp), %edx        # 4-byte Reload
	movl	%edx, 8(%esp)
	movl	%esi, 4(%esp)
	addl	%edi, %eax
	movl	%eax, (%esp)
	movl	%ecx, %esi
	calll	memcpy
	movl	%esi, %edx
	addl	$16, %esp
	movl	68(%edx), %eax
	movl	-560(%ebp), %ecx        # 4-byte Reload
	movb	$0, (%eax,%ecx)
	jmp	.LBB125_237
.LBB125_67:                             # %if.then18.i
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpb	$0, opt+250
	jne	.LBB125_68
	.align	16, 0x90
.LBB125_69:                             # %invalidate_persistent.exit.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movb	$0, pconn_active.b
	movl	pconn, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_91
.LBB125_297:                            # %if.then.i1362
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ebx
	jmp	.LBB125_298
.LBB125_105:                            # %if.then.i1222
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str132, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB125_106
.LBB125_282:                            # %if.then7.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str127, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movb	$1, %dl
	jmp	.LBB125_283
.LBB125_279:                            # %if.then.i.i1352
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %eax
	jmp	.LBB125_280
.LBB125_334:                            # %if.then7.i1391
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str111542, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB125_335
.LBB125_78:                             #   in Loop: Header=BB125_49 Depth=1
	movl	-516(%ebp), %edi        # 4-byte Reload
	movl	-520(%ebp), %ebx        # 4-byte Reload
	jmp	.LBB125_91
.LBB125_81:                             # %if.then.i
                                        #   in Loop: Header=BB125_49 Depth=1
	cmpl	$2, %eax
	jne	.LBB125_82
# BB#84:                                # %sw.bb1.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	4(%ecx,%edx), %eax
	movl	%edx, %ebx
	movl	%ecx, -512(%ebp)        # 4-byte Spill
.LBB125_86:                             # %sw.bb2.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	jmp	.LBB125_87
.LBB125_68:                             # %if.then.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	pconn, %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB125_69
.LBB125_82:                             # %if.then.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	%edx, %ebx
	movl	%ecx, -512(%ebp)        # 4-byte Spill
	cmpl	$1, %eax
	jne	.LBB125_88
# BB#83:                                # %sw.bb.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
.LBB125_87:                             # %sw.bb2.i.i
                                        #   in Loop: Header=BB125_49 Depth=1
	calll	checking_free
	addl	$16, %esp
.LBB125_88:                             # %release_header.exit.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-520(%ebp), %esi        # 4-byte Reload
	movl	12(%esi), %eax
	leal	-1(%eax), %ecx
	cmpl	%ecx, -500(%ebp)        # 4-byte Folded Reload
	jge	.LBB125_90
# BB#89:                                # %if.then5.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-512(%ebp), %edx        # 4-byte Reload
	leal	12(%edx,%ebx), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	addl	%ebx, %edx
	movl	%edx, (%esp)
	imull	$12, %eax, %eax
	subl	%ebx, %eax
	addl	$-12, %eax
	movl	%eax, 8(%esp)
	calll	memmove
	addl	$16, %esp
	movl	12(%esi), %eax
.LBB125_90:                             # %if.then5.i
                                        #   in Loop: Header=BB125_49 Depth=1
	movl	-516(%ebp), %edi        # 4-byte Reload
	movl	%esi, %ebx
	decl	%eax
	movl	%eax, 12(%ebx)
	jmp	.LBB125_91
.LBB125_337:                            # %if.then472
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str78509, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
.LBB125_338:                            # %if.end532
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str81512, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	%ebx, %ecx
	calll	request_free
	movl	$50, %eax
	.align	16, 0x90
.LBB125_541:                            # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB125_321:                            # %sw.default.i
	calll	abort
.LBB125_132:                            # %if.then222
	calll	__errno_location
	cmpl	$0, (%eax)
	je	.LBB125_133
# BB#142:                               # %if.else238
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str70501, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_errstr
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	pconn_active.b, %al
	testb	%al, %al
	movl	-520(%ebp), %esi        # 4-byte Reload
	je	.LBB125_147
# BB#143:                               # %if.else238
	movl	pconn, %eax
	cmpl	%eax, %edi
	jne	.LBB125_147
# BB#144:                               # %if.then247
	cmpb	$0, opt+250
	je	.LBB125_146
# BB#145:                               # %if.then.i1240
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %edi
.LBB125_146:                            # %invalidate_persistent.exit1242
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_148
.LBB125_339:                            # %if.else534
	movl	%edi, %eax
	movb	%dl, -545(%ebp)         # 1-byte Spill
	movl	%esi, -504(%ebp)        # 4-byte Spill
	movl	%ecx, %edi
	testb	$1, -540(%ebp)          # 1-byte Folded Reload
	je	.LBB125_341
# BB#340:                               # %if.then536
	movb	$1, pconn+13
.LBB125_341:                            # %if.end538
	movl	%eax, -524(%ebp)        # 4-byte Spill
	movl	-520(%ebp), %ecx        # 4-byte Reload
	calll	request_free
	movl	-536(%ebp), %esi        # 4-byte Reload
	movl	%edi, %eax
	movl	%eax, 44(%esi)
	cmpl	$-1, %eax
	jne	.LBB125_343
# BB#342:                               # %if.then542
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str82513, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	%eax, 40(%esi)
	movl	-552(%ebp), %esi        # 4-byte Reload
	jmp	.LBB125_347
.LBB125_93:                             # %if.then164
	movl	%ebx, %ecx
	calll	request_free
	movl	$1, %eax
	jmp	.LBB125_541
.LBB125_95:                             # %if.then168
	movl	%ebx, %ecx
	calll	request_free
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	retryable_socket_connect_error
	addl	$16, %esp
	testb	%al, %al
	sete	%al
	movzbl	%al, %eax
	imull	$2, %eax, %eax
	addl	$3, %eax
	jmp	.LBB125_541
.LBB125_147:                            # %if.else248
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
.LBB125_148:                            # %if.end249
	movl	%esi, %ecx
	calll	request_free
	movl	$30, %eax
	jmp	.LBB125_541
.LBB125_343:                            # %if.else546
	movl	-552(%ebp), %esi        # 4-byte Reload
	cmpb	$0, (%esi)
	je	.LBB125_344
# BB#345:                               # %if.else552
	subl	$16, %esp
	movl	%esi, (%esp)
	jmp	.LBB125_346
.LBB125_117:                            # %if.then22.i1228
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	addl	$16, %esp
	jmp	.LBB125_118
.LBB125_133:                            # %if.then226
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str69500, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	addl	$16, %esp
	movb	pconn_active.b, %al
	testb	%al, %al
	movl	-520(%ebp), %esi        # 4-byte Reload
	je	.LBB125_140
# BB#134:                               # %if.then226
	movl	pconn, %eax
	cmpl	%eax, %edi
	jne	.LBB125_140
# BB#135:                               # %if.then234
	cmpb	$0, opt+250
	je	.LBB125_137
# BB#136:                               # %if.then.i1236
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %edi
.LBB125_137:                            # %invalidate_persistent.exit1238
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_141
.LBB125_140:                            # %if.else235
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
.LBB125_141:                            # %if.end236
	movl	%esi, %ecx
	calll	request_free
	movl	$29, %eax
	jmp	.LBB125_541
.LBB125_344:                            # %if.then548
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str83514, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
.LBB125_346:                            # %if.else552
	calll	checking_strdup
	addl	$16, %esp
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	%eax, 40(%ecx)
.LBB125_347:                            # %if.end556
	testl	%esi, %esi
	je	.LBB125_349
# BB#348:                               # %if.else559
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB125_349:                            # %if.end560
	subl	$16, %esp
	leal	-44(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-40(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str56487, %edx
	calll	resp_header_locate
	addl	$16, %esp
	xorl	%esi, %esi
	xorb	%cl, %cl
	cmpl	$-1, %eax
	movl	$0, %edi
	je	.LBB125_356
# BB#350:                               # %resp_header_strdup.exit
	movl	-40(%ebp), %eax
	movl	-44(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB125_351
# BB#352:                               # %if.then563
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$59, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB125_356
	.align	16, 0x90
.LBB125_353:                            # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	cmpl	%edi, %ecx
	jbe	.LBB125_355
# BB#354:                               # %land.rhs
                                        #   in Loop: Header=BB125_353 Depth=1
	leal	-1(%ecx), %eax
	movzbl	-1(%ecx), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB125_353
.LBB125_355:                            # %while.end
	movb	$0, (%ecx)
	movb	$1, %cl
	jmp	.LBB125_356
.LBB125_351:
	xorb	%cl, %cl
	xorl	%edi, %edi
.LBB125_356:                            # %if.end577
	movb	%cl, -528(%ebp)         # 1-byte Spill
	subl	$16, %esp
	leal	-36(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-32(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str84515, %edx
	calll	resp_header_locate
	addl	$16, %esp
	cmpl	$-1, %eax
	je	.LBB125_358
# BB#357:                               # %if.end.i1404
	movl	-32(%ebp), %eax
	movl	-36(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, %esi
.LBB125_358:                            # %resp_header_strdup.exit1406
	movl	%ebx, -516(%ebp)        # 4-byte Spill
	movl	-536(%ebp), %eax        # 4-byte Reload
	movl	%esi, 32(%eax)
	subl	$16, %esp
	leal	-28(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	-500(%ebp), %ecx        # 4-byte Reload
	movl	$.L.str85516, %edx
	calll	resp_header_locate
	addl	$16, %esp
	movl	%eax, %ecx
	xorl	%eax, %eax
	cmpl	$-1, %ecx
	je	.LBB125_360
# BB#359:                               # %if.end.i1412
	movl	-24(%ebp), %eax
	movl	-28(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
.LBB125_360:                            # %resp_header_strdup.exit1414
	movl	%edi, -520(%ebp)        # 4-byte Spill
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	%eax, 36(%ecx)
	cmpb	$0, opt+296
	movl	-500(%ebp), %ebx        # 4-byte Reload
	je	.LBB125_365
# BB#361:                               # %if.then583
	movl	%ebx, %ecx
	cmpl	$0, wget_cookie_jar
	je	.LBB125_544
# BB#362:                               # %for.cond592.preheader
	subl	$16, %esp
	leal	-496(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-492(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	%ecx, %ebx
	jmp	.LBB125_364
	.align	16, 0x90
.LBB125_363:                            # %do.body598
                                        #   in Loop: Header=BB125_364 Depth=1
	movl	-492(%ebp), %eax
	movl	-496(%ebp), %edi
	subl	%eax, %edi
	leal	16(%edi), %ecx
	andl	$-16, %ecx
	movl	%esp, %ebx
	subl	%ecx, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%edi,%ebx)
	movl	-544(%ebp), %edx        # 4-byte Reload
	movl	8(%edx), %eax
	movl	12(%edx), %ecx
	movl	16(%edx), %edi
	movl	wget_cookie_jar, %edx
	subl	$32, %esp
	movl	%ebx, 16(%esp)
	movl	-500(%ebp), %ebx        # 4-byte Reload
	movl	%edi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edx, (%esp)
	calll	cookie_handle_set_cookie
	addl	$32, %esp
	subl	$16, %esp
	leal	-496(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-492(%ebp), %eax
	movl	%eax, 4(%esp)
	incl	%esi
	movl	%esi, (%esp)
.LBB125_364:                            # %do.body598
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, %ecx
	movl	$.L.str87518, %edx
	calll	resp_header_locate
	addl	$16, %esp
	movl	%eax, %esi
	cmpl	$-1, %esi
	jne	.LBB125_363
.LBB125_365:                            # %if.end617
	subl	$16, %esp
	leal	-20(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	movl	%ebx, %ecx
	movl	$.L.str88519, %edx
	calll	resp_header_locate
	addl	$16, %esp
	xorl	%edi, %edi
	cmpl	$-1, %eax
	je	.LBB125_366
# BB#367:                               # %if.then620
	movl	-20(%ebp), %eax
	movl	-16(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	leal	-384(%ebp), %edi
	movl	%edi, -580(%ebp)        # 4-byte Spill
	movl	%edi, (%esp)
	subl	%ecx, %eax
	cmpl	$255, %eax
	movl	$255, %esi
	cmovlel	%eax, %esi
	movl	%esi, 8(%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, -384(%ebp,%esi)
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str110541, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_371
# BB#368:                               # %entry.if.end11_crit_edge.i
	movzbl	-384(%ebp), %eax
	movzwl	_sch_istable(%eax,%eax), %ecx
                                        # kill: AL<def> AL<kill> EAX<kill>
	movl	-504(%ebp), %esi        # 4-byte Reload
	jmp	.LBB125_369
.LBB125_371:                            # %if.then.i1434
	leal	-378(%ebp), %eax
	leal	-379(%ebp), %edx
	cmpb	$58, -379(%ebp)
	cmovel	%eax, %edx
	decl	%edx
	.align	16, 0x90
.LBB125_372:                            # %while.cond.i1437
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%edx), %eax
	incl	%edx
	movzwl	_sch_istable(%eax,%eax), %ecx
	testb	$64, %cl
	jne	.LBB125_372
# BB#373:                               # %while.end.i1439
	movl	%edx, -580(%ebp)        # 4-byte Spill
	xorl	%edi, %edi
	testb	%al, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	movl	-504(%ebp), %esi        # 4-byte Reload
	je	.LBB125_374
.LBB125_369:                            # %if.end11.i
	xorl	%edi, %edi
	testb	$4, %cl
	je	.LBB125_370
# BB#375:                               # %for.cond.preheader.i1440
	movsbl	%al, %ebx
	movzbl	%bl, %ecx
	xorl	%edi, %edi
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB125_376
# BB#377:
	xorl	%edx, %edx
	xorl	%ecx, %ecx
	movl	-580(%ebp), %esi        # 4-byte Reload
	.align	16, 0x90
.LBB125_378:                            # %for.body.i1447
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, %eax
	movl	$10, %edx
	mull	%edx
	imull	$10, %ecx, %ecx
	addl	%edx, %ecx
	addl	$-48, %ebx
	movl	%ebx, %edx
	sarl	$31, %edx
	addl	%eax, %ebx
	adcl	%ecx, %edx
	movb	1(%esi), %al
	movb	%al, -508(%ebp)         # 1-byte Spill
	incl	%esi
	movsbl	%al, %eax
	movzbl	%al, %ecx
	testb	$4, _sch_istable(%ecx,%ecx)
	movl	%edx, %ecx
	movl	%ebx, %edx
	movl	%eax, %ebx
	jne	.LBB125_378
	jmp	.LBB125_379
.LBB125_370:
	movl	%edi, -508(%ebp)        # 4-byte Spill
	jmp	.LBB125_393
.LBB125_31:                             # %if.then21.i
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str144, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movb	$0, -565(%ebp)          # 1-byte Folded Spill
	jmp	.LBB125_32
.LBB125_374:
	movl	%edi, -508(%ebp)        # 4-byte Spill
	jmp	.LBB125_393
.LBB125_376:
	xorl	%edx, %edx
	xorl	%ecx, %ecx
	movl	-580(%ebp), %esi        # 4-byte Reload
	movb	%al, -508(%ebp)         # 1-byte Spill
.LBB125_379:                            # %for.end.i
	movl	%edx, -544(%ebp)        # 4-byte Spill
	movl	%ecx, -540(%ebp)        # 4-byte Spill
	cmpb	$45, -508(%ebp)         # 1-byte Folded Reload
	jne	.LBB125_366
# BB#380:                               # %lor.lhs.false.i1448
	movzbl	1(%esi), %eax
	xorl	%edi, %edi
	testb	$4, _sch_istable(%eax,%eax)
	je	.LBB125_366
# BB#381:                               # %if.end40.i
	incl	%esi
	movl	%esi, %edi
	movsbl	%al, %ecx
	movzbl	%cl, %edx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB125_382
# BB#383:
	xorl	%eax, %eax
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB125_384:                            # %for.body49.i
                                        # =>This Inner Loop Header: Depth=1
	movl	$10, %edx
	mull	%edx
	movl	%eax, -508(%ebp)        # 4-byte Spill
	imull	$10, %ebx, %esi
	addl	%edx, %esi
	addl	$-48, %ecx
	movl	%ecx, %ebx
	sarl	$31, %ebx
	movl	%ecx, %eax
	addl	-508(%ebp), %eax        # 4-byte Folded Reload
	adcl	%esi, %ebx
	movb	1(%edi), %dl
	incl	%edi
	movsbl	%dl, %ecx
	movzbl	%cl, %esi
	testb	$4, _sch_istable(%esi,%esi)
	jne	.LBB125_384
	jmp	.LBB125_385
.LBB125_113:                            # %while.end.thread.i
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	addl	$16, %esp
.LBB125_127:                            # %if.then29.i
	calll	__errno_location
	movl	$22, (%eax)
.LBB125_118:                            # %if.then22.i1228
	movl	-516(%ebp), %edi        # 4-byte Reload
.LBB125_119:                            # %do.body205
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_138
# BB#120:                               # %do.body205
	movl	pconn, %eax
	cmpl	%eax, %edi
	jne	.LBB125_138
# BB#121:                               # %if.then211
	cmpb	$0, opt+250
	jne	.LBB125_122
	.align	16, 0x90
.LBB125_123:                            # %if.then.i1232
	movl	-520(%ebp), %esi        # 4-byte Reload
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_139
.LBB125_138:                            # %if.else212
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	-520(%ebp), %esi        # 4-byte Reload
.LBB125_139:                            # %if.end213
	movl	%esi, %ecx
	calll	request_free
	movl	$52, %eax
	jmp	.LBB125_541
.LBB125_122:                            # %if.then.i1232
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %edi
	jmp	.LBB125_123
.LBB125_543:                            # %cond.false35.i
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.post_file, 12(%esp)
	movl	$481, 8(%esp)           # imm = 0x1E1
	movl	$.L.str1432, 4(%esp)
	movl	$.L.str134549, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB125_241:                            # %if.then296
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3434, 4(%esp)
	movl	$0, (%esp)
	movl	%edx, %esi
	calll	dcgettext
	addl	$16, %esp
	movl	68(%esi), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	8(%ebp), %edi
	orb	$2, (%edi)
	movl	68(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	has_html_suffix_p
	addl	$16, %esp
	movb	%al, %cl
	movl	$38, %eax
	testb	%cl, %cl
	je	.LBB125_541
# BB#242:                               # %if.then301
	orb	$1, (%edi)
	movl	$38, %eax
	jmp	.LBB125_541
.LBB125_542:                            # %if.then150
	movl	%ebx, %ecx
	calll	request_free
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str64495, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	-524(%ebp), %ecx        # 4-byte Reload
	movl	8(%ecx), %ecx
	movl	exec_name, %edx
	subl	$16, %esp
	movl	%ecx, 12(%esp)
	movl	%edx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	$1, %eax
	jmp	.LBB125_541
.LBB125_544:                            # %cond.false590
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.gethttp, 12(%esp)
	movl	$2056, 8(%esp)          # imm = 0x808
	movl	$.L.str1432, 4(%esp)
	movl	$.L.str86517, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB125_382:
	movb	%al, %dl
	xorl	%eax, %eax
	xorl	%ebx, %ebx
.LBB125_385:                            # %for.end57.i
	cmpb	$47, %dl
	jne	.LBB125_386
# BB#387:                               # %lor.lhs.false61.i
	movl	%edi, %edx
	movzbl	1(%edx), %ecx
	xorl	%edi, %edi
	testb	$4, _sch_istable(%ecx,%ecx)
	movl	%edi, -508(%ebp)        # 4-byte Spill
	movl	-504(%ebp), %esi        # 4-byte Reload
	je	.LBB125_393
# BB#388:                               # %if.end70.i
	cmpb	$42, %cl
	je	.LBB125_392
# BB#389:                               # %for.cond76.preheader.i
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB125_392
# BB#390:                               # %for.body83.i.preheader
	addl	$2, %edx
	.align	16, 0x90
.LBB125_391:                            # %for.body83.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%edx), %ecx
	incl	%edx
	testb	$4, _sch_istable(%ecx,%ecx)
	jne	.LBB125_391
.LBB125_392:                            # %if.then626
	movl	$1, %ecx
	movl	-544(%ebp), %edi        # 4-byte Reload
	subl	%edi, %ecx
	movl	$0, %esi
	movl	-540(%ebp), %edx        # 4-byte Reload
	sbbl	%edx, %esi
	addl	%eax, %ecx
	movl	%ecx, -524(%ebp)        # 4-byte Spill
	adcl	%ebx, %esi
	movl	%edx, -508(%ebp)        # 4-byte Spill
	jmp	.LBB125_393
.LBB125_386:
	xorl	%edi, %edi
.LBB125_366:
	movl	%edi, -508(%ebp)        # 4-byte Spill
	movl	-504(%ebp), %esi        # 4-byte Reload
.LBB125_393:                            # %if.end629
	movl	-500(%ebp), %eax        # 4-byte Reload
	movl	4(%eax), %eax
	testl	%eax, %eax
	je	.LBB125_395
# BB#394:                               # %if.else.i1455
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB125_395:                            # %resp_free.exit
	subl	$16, %esp
	movl	-500(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-512(%ebp), %eax        # 4-byte Reload
	leal	-200(%eax), %eax
	cmpl	$99, %eax
	movl	8(%ebp), %ecx
	ja	.LBB125_397
# BB#396:                               # %if.then635
	orb	$2, (%ecx)
.LBB125_397:                            # %if.end637
	movl	%edi, -500(%ebp)        # 4-byte Spill
	movl	%esi, -504(%ebp)        # 4-byte Spill
	movl	-512(%ebp), %edx        # 4-byte Reload
	leal	-301(%edx), %eax
	cmpl	$3, %eax
	movl	-536(%ebp), %eax        # 4-byte Reload
	jb	.LBB125_400
# BB#398:                               # %if.end637
	cmpl	$307, %edx              # imm = 0x133
	je	.LBB125_400
# BB#399:                               # %if.end637
	cmpl	$300, %edx              # imm = 0x12C
	jne	.LBB125_403
.LBB125_400:                            # %if.then652
	cmpl	$300, %edx              # imm = 0x12C
	jne	.LBB125_407
# BB#401:                               # %land.lhs.true655
	cmpl	$0, 32(%eax)
	je	.LBB125_402
.LBB125_407:                            # %if.else660
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str89520, 4(%esp)
	movl	$0, (%esp)
	movl	%eax, %edi
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	32(%edi), %eax
	movl	%edi, %ebx
	subl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_409
# BB#408:                               # %cond.true664
	movl	%eax, (%esp)
	calll	escnonprint_uri
	jmp	.LBB125_410
.LBB125_409:                            # %cond.false667
	movl	$5, 8(%esp)
	movl	$.L.str90521, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
.LBB125_410:                            # %cond.false667
	addl	$16, %esp
	movl	%eax, %edi
	movl	$.L.str73504, %eax
	cmpl	$0, 32(%ebx)
	je	.LBB125_412
# BB#411:                               # %cond.true673
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str91522, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
.LBB125_412:                            # %cond.end676
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	cmpl	$0, -532(%ebp)          # 4-byte Folded Reload
	movl	-516(%ebp), %esi        # 4-byte Reload
	movl	-524(%ebp), %edx        # 4-byte Reload
	movl	-520(%ebp), %edi        # 4-byte Reload
	jne	.LBB125_416
# BB#413:                               # %cond.end676
	movb	-545(%ebp), %al         # 1-byte Reload
	xorb	$1, %al
	testb	%al, %al
	jne	.LBB125_416
# BB#414:                               # %land.lhs.true682
	subl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	movl	%esi, %ecx
	calll	skip_short_body
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB125_416
# BB#415:                               # %do.body686
	cmpb	$0, -545(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_422
.LBB125_416:                            # %if.then688
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_421
# BB#417:                               # %if.then688
	movl	pconn, %eax
	cmpl	%eax, %esi
	jne	.LBB125_421
# BB#418:                               # %if.then694
	cmpb	$0, opt+250
	je	.LBB125_420
# BB#419:                               # %if.then.i1458
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %esi
.LBB125_420:                            # %invalidate_persistent.exit1460
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_422
.LBB125_421:                            # %if.else707
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	fd_close
	addl	$16, %esp
.LBB125_422:                            # %if.end710
	movl	$6, %eax
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_541
# BB#423:                               # %if.else713
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$6, %eax
	jmp	.LBB125_541
.LBB125_402:                            # %if.then658
	orb	$2, (%ecx)
.LBB125_403:                            # %if.end716
	movl	%ecx, %esi
	movl	%eax, %ebx
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_406
# BB#404:                               # %lor.lhs.false718
	subl	$16, %esp
	movl	-520(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	movl	$9, 8(%esp)
	movl	$.L.str92523, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_406
# BB#405:                               # %lor.lhs.false722
	subl	$16, %esp
	movl	-520(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	movl	$21, 8(%esp)
	movl	$.L.str93524, 4(%esp)
	calll	strncasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_406
# BB#424:                               # %if.else728
	movl	(%esi), %eax
	andl	$-2, %eax
	jmp	.LBB125_425
.LBB125_406:                            # %if.then726
	movl	(%esi), %eax
	orl	$1, %eax
.LBB125_425:                            # %if.end730
	movl	%eax, (%esi)
	cmpb	$0, opt+289
	je	.LBB125_437
# BB#426:                               # %land.lhs.true733
	testb	$1, %al
	je	.LBB125_437
# BB#427:                               # %if.then736
	movl	68(%ebx), %edi
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$46, 4(%esp)
	calll	strrchr
	addl	$16, %esp
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB125_430
# BB#428:                               # %lor.lhs.false742
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$.L.str94525, 4(%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_437
# BB#429:                               # %lor.lhs.false746
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$.L.str95526, 4(%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_437
.LBB125_430:                            # %if.then750
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	leal	30(%esi), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	checking_realloc
	addl	$16, %esp
	movl	%eax, 68(%ebx)
	movw	$108, 4(%eax,%esi)
	movl	$1836345390, (%eax,%esi) # imm = 0x6D74682E
	movb	opt+116, %al
	orb	opt+42, %al
	orb	opt+251, %al
	jne	.LBB125_436
# BB#431:                               # %lor.lhs.false770
	cmpb	$0, opt+32
	jne	.LBB125_436
# BB#432:                               # %lor.lhs.false770
	movl	opt+104, %eax
	testl	%eax, %eax
	jne	.LBB125_436
# BB#433:                               # %land.lhs.true775
	movl	68(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	file_exists_p
	addl	$16, %esp
	testb	%al, %al
	je	.LBB125_436
# BB#434:
	movl	$1, %edi
	.align	16, 0x90
.LBB125_435:                            # %do.body781
                                        # =>This Inner Loop Header: Depth=1
	movl	68(%ebx), %eax
	subl	$16, %esp
	movl	%edi, 8(%esp)
	addl	%esi, %eax
	movl	%eax, (%esp)
	movl	$.L.str96527, 4(%esp)
	calll	sprintf
	addl	$16, %esp
	movl	68(%ebx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	incl	%edi
	calll	file_exists_p
	addl	$16, %esp
	testb	%al, %al
	jne	.LBB125_435
.LBB125_436:                            # %if.end789
	movl	8(%ebp), %eax
	orb	$32, (%eax)
.LBB125_437:                            # %if.end792
	movl	-512(%ebp), %eax        # 4-byte Reload
	cmpl	$416, %eax              # imm = 0x1A0
	jne	.LBB125_446
# BB#438:                               # %if.then795
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str97528, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	movl	-504(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%ebx)
	movl	-524(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%ebx)
	movl	$0, 24(%ebx)
	movl	8(%ebp), %eax
	orb	$2, (%eax)
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_440
# BB#439:                               # %if.else802
	subl	$16, %esp
	movl	-520(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB125_440:                            # %do.body804
	movb	pconn_active.b, %al
	testb	%al, %al
	movl	-516(%ebp), %ecx        # 4-byte Reload
	je	.LBB125_445
# BB#441:                               # %do.body804
	movl	pconn, %eax
	cmpl	%eax, %ecx
	jne	.LBB125_445
# BB#442:                               # %if.then810
	cmpb	$0, opt+250
	je	.LBB125_444
# BB#443:                               # %if.then.i1466
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ecx
.LBB125_444:                            # %invalidate_persistent.exit1468
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	movl	$38, %eax
	jmp	.LBB125_541
.LBB125_446:                            # %if.end815
	movl	%eax, %ecx
	movl	-500(%ebp), %edi        # 4-byte Reload
	movl	%edi, %eax
	movl	-508(%ebp), %esi        # 4-byte Reload
	orl	%esi, %eax
	je	.LBB125_460
# BB#447:                               # %land.lhs.true818
	movl	16(%ebx), %eax
	xorl	%edi, %eax
	movl	20(%ebx), %ecx
	xorl	%esi, %ecx
	orl	%eax, %ecx
	jne	.LBB125_461
	jmp	.LBB125_448
.LBB125_445:                            # %if.else811
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$38, %eax
	jmp	.LBB125_541
.LBB125_460:                            # %lor.lhs.false822
	cmpl	$206, %ecx
	jne	.LBB125_448
.LBB125_461:                            # %if.then827
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_463
# BB#462:                               # %if.else830
	subl	$16, %esp
	movl	-520(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB125_463:                            # %do.body832
	movb	pconn_active.b, %al
	testb	%al, %al
	movl	-516(%ebp), %ecx        # 4-byte Reload
	je	.LBB125_468
# BB#464:                               # %do.body832
	movl	pconn, %eax
	cmpl	%eax, %ecx
	jne	.LBB125_468
# BB#465:                               # %if.then838
	cmpb	$0, opt+250
	je	.LBB125_467
# BB#466:                               # %if.then.i1470
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ecx
.LBB125_467:                            # %invalidate_persistent.exit1472
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	movl	$44, %eax
	jmp	.LBB125_541
.LBB125_448:                            # %if.end843
	movl	-524(%ebp), %edx        # 4-byte Reload
	movl	%edx, %eax
	addl	%edi, %eax
	movl	%eax, -512(%ebp)        # 4-byte Spill
	movl	-504(%ebp), %edi        # 4-byte Reload
	movl	%edi, %ecx
	adcl	%esi, %ecx
	movl	%ecx, %esi
	andl	%edi, %edx
	movl	%edx, -540(%ebp)        # 4-byte Spill
	movl	$-1, %eax
	cmpl	$-1, %edx
	cmovel	%eax, %ecx
	movl	%ecx, 12(%ebx)
	movl	-512(%ebp), %ecx        # 4-byte Reload
	cmovnel	%ecx, %eax
	movl	%ecx, %edi
	movl	%eax, 8(%ebx)
	cmpl	$0, opt
	je	.LBB125_479
# BB#449:                               # %if.then853
	movl	8(%ebp), %eax
	testb	$2, (%eax)
	je	.LBB125_479
# BB#450:                               # %if.then856
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str98529, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$16, %esp
	cmpl	$-1, -540(%ebp)         # 4-byte Folded Reload
	jne	.LBB125_451
# BB#471:                               # %if.else883
	cmpb	$0, opt+14
	je	.LBB125_473
# BB#472:                               # %cond.true886
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str102533, 4(%esp)
	jmp	.LBB125_474
.LBB125_468:                            # %if.else839
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$44, %eax
	jmp	.LBB125_541
.LBB125_479:                            # %if.end899
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	movl	-516(%ebp), %ebx        # 4-byte Reload
	movl	-520(%ebp), %esi        # 4-byte Reload
	jne	.LBB125_482
	jmp	.LBB125_480
.LBB125_451:                            # %if.then860
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	cmpl	$1024, %edi             # imm = 0x400
	setb	%bl
	testl	%esi, %esi
	movl	%esi, %edi
	sets	%al
	je	.LBB125_453
# BB#452:                               # %if.then860
	movb	%al, %bl
.LBB125_453:                            # %if.then860
	calll	logputs
	addl	$16, %esp
	testb	%bl, %bl
	jne	.LBB125_455
# BB#454:                               # %if.then866
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	-512(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	human_readable
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str99530, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB125_455:                            # %if.end869
	movl	-500(%ebp), %eax        # 4-byte Reload
	orl	-508(%ebp), %eax        # 4-byte Folded Reload
	movl	-516(%ebp), %ebx        # 4-byte Reload
	je	.LBB125_476
# BB#456:                               # %if.then871
	cmpl	$1024, -524(%ebp)       # 4-byte Folded Reload
                                        # imm = 0x400
	setb	%al
	movl	-504(%ebp), %esi        # 4-byte Reload
	testl	%esi, %esi
	sets	%cl
	je	.LBB125_458
# BB#457:                               # %if.then871
	movb	%cl, %al
.LBB125_458:                            # %if.then871
	subl	$16, %esp
	testb	%al, %al
	jne	.LBB125_469
# BB#459:                               # %if.then874
	movl	$5, 8(%esp)
	movl	$.L.str100531, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -512(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%esi, %edi
	movl	-524(%ebp), %esi        # 4-byte Reload
	movl	%esi, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	movl	%eax, -544(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	human_readable
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	-544(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	-512(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	jmp	.LBB125_470
.LBB125_473:                            # %cond.false888
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str90521, 4(%esp)
.LBB125_474:                            # %cond.false888
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	-516(%ebp), %ebx        # 4-byte Reload
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	jmp	.LBB125_475
.LBB125_469:                            # %if.else878
	movl	$5, 8(%esp)
	movl	$.L.str101532, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%esi, %ecx
	movl	%eax, %esi
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	-524(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	number_to_static_string
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
.LBB125_470:                            # %if.else878
	movl	$0, (%esp)
	calll	logprintf
.LBB125_475:                            # %cond.end890
	addl	$16, %esp
.LBB125_476:                            # %if.end892
	cmpb	$1, -528(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_478
# BB#477:                               # %if.end899.thread
	subl	$16, %esp
	movl	-520(%ebp), %esi        # 4-byte Reload
	movl	%esi, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str103534, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB125_480:                            # %if.else902
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_free
	jmp	.LBB125_481
.LBB125_478:                            # %if.end899.thread1529
	subl	$16, %esp
	movl	$.L.str8439, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB125_481:                            # %if.else902
	addl	$16, %esp
.LBB125_482:                            # %if.end903
	movl	8(%ebp), %eax
	testb	$2, (%eax)
	movl	-532(%ebp), %ecx        # 4-byte Reload
	je	.LBB125_484
# BB#483:                               # %if.end903
	testl	%ecx, %ecx
	je	.LBB125_494
.LBB125_484:                            # %if.then909
	movl	-536(%ebp), %eax        # 4-byte Reload
	movl	$0, 4(%eax)
	movl	$0, (%eax)
	movl	$0, 24(%eax)
	testl	%ecx, %ecx
	movl	-504(%ebp), %eax        # 4-byte Reload
	je	.LBB125_491
# BB#485:                               # %do.body918
	movl	$39, %eax
	cmpb	$0, -545(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_541
	jmp	.LBB125_486
.LBB125_494:                            # %if.end967
	movl	output_stream, %eax
	testl	%eax, %eax
	jne	.LBB125_519
# BB#495:                               # %if.then969
	movl	-536(%ebp), %esi        # 4-byte Reload
	movl	68(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	mkalldirs
	addl	$16, %esp
	cmpb	$0, opt+253
	je	.LBB125_497
# BB#496:                               # %if.then973
	movl	68(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	rotate_backups
	addl	$16, %esp
.LBB125_497:                            # %if.end975
	movl	16(%esi), %eax
	orl	20(%esi), %eax
	movl	%esi, %ecx
	je	.LBB125_506
# BB#498:                               # %if.then978
	movl	68(%ecx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$.L.str104535, 4(%esp)
	jmp	.LBB125_499
.LBB125_491:                            # %if.else932
	cmpb	$1, -545(%ebp)          # 1-byte Folded Reload
	movl	-524(%ebp), %edx        # 4-byte Reload
	jne	.LBB125_486
# BB#492:                               # %land.lhs.true935
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	%ebx, %ecx
	calll	skip_short_body
	addl	$16, %esp
	movb	%al, %cl
	movl	$39, %eax
	testb	%cl, %cl
	jne	.LBB125_541
.LBB125_486:                            # %if.then920
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_493
# BB#487:                               # %if.then920
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_493
# BB#488:                               # %if.then926
	cmpb	$0, opt+250
	je	.LBB125_490
# BB#489:                               # %if.then.i1474
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ebx
.LBB125_490:                            # %invalidate_persistent.exit1476
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	movl	$39, %eax
	jmp	.LBB125_541
.LBB125_506:                            # %if.else981
	movb	opt+116, %al
	orb	opt+42, %al
	orb	opt+251, %al
	jne	.LBB125_509
# BB#507:                               # %lor.lhs.false990
	cmpb	$0, opt+32
	jne	.LBB125_509
# BB#508:                               # %lor.lhs.false990
	movl	opt+104, %eax
	testl	%eax, %eax
	je	.LBB125_510
.LBB125_509:                            # %if.then995
	movl	68(%ecx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$.L.str105536, 4(%esp)
.LBB125_499:                            # %if.then978
	calll	fopen64
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB125_519
# BB#500:                               # %if.end1022.if.then1024_crit_edge
	calll	__errno_location
	jmp	.LBB125_501
.LBB125_493:                            # %if.else927
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$39, %eax
	jmp	.LBB125_541
.LBB125_510:                            # %if.else998
	movl	68(%ecx), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	fopen_excl
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB125_511
.LBB125_519:                            # %if.end1041
	movl	%eax, -512(%ebp)        # 4-byte Spill
	cmpl	$0, opt
	je	.LBB125_524
# BB#520:                               # %if.then1043
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str108539, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	68(%ecx), %ecx
	cmpb	$45, (%ecx)
	jne	.LBB125_522
# BB#521:                               # %land.lhs.true1049
	movl	$.L.str109540, %edx
	cmpb	$0, 1(%ecx)
	je	.LBB125_523
.LBB125_522:                            # %cond.false1054
	movl	%ecx, %edx
.LBB125_523:                            # %cond.end1056
	subl	$16, %esp
	movl	%edx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB125_524:                            # %if.end1058
	cmpb	$0, opt+249
	je	.LBB125_527
# BB#525:                               # %land.lhs.true1061
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	16(%ecx), %eax
	orl	20(%ecx), %eax
	jne	.LBB125_527
# BB#526:                               # %if.then1065
	subl	$16, %esp
	movl	-572(%ebp), %edi        # 4-byte Reload
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	-512(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$1, 4(%esp)
	calll	fwrite
	addl	$16, %esp
.LBB125_527:                            # %if.end1068
	subl	$16, %esp
	movl	-572(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-536(%ebp), %edi        # 4-byte Reload
	movl	16(%edi), %eax
	movl	20(%edi), %ecx
	movl	%ecx, 4(%edi)
	movl	%eax, (%edi)
	movl	$0, 52(%edi)
	movl	$0, 48(%edi)
	subl	$48, %esp
	leal	56(%edi), %edx
	movl	%edx, 32(%esp)
	movl	%edi, 28(%esp)
	leal	48(%edi), %edx
	movl	%edx, 24(%esp)
	movl	%ecx, 20(%esp)
	movl	%eax, 16(%esp)
	testl	%eax, %eax
	setne	%al
	testl	%ecx, %ecx
	setg	%cl
	je	.LBB125_529
# BB#528:                               # %if.end1068
	movb	%cl, %al
.LBB125_529:                            # %if.end1068
	xorl	%ecx, %ecx
	cmpl	$-1, -540(%ebp)         # 4-byte Folded Reload
	movl	-504(%ebp), %edx        # 4-byte Reload
	cmovel	%ecx, %edx
	movl	%edx, 12(%esp)
	movl	-524(%ebp), %edx        # 4-byte Reload
	cmovel	%ecx, %edx
	movl	%edx, 8(%esp)
	movl	-512(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	setne	%cl
	movzbl	%cl, %ecx
	leal	2(%ecx), %edx
	movl	-508(%ebp), %esi        # 4-byte Reload
	orl	%esi, -500(%ebp)        # 4-byte Folded Spill
	sete	%ah
	testb	%ah, %al
	cmovel	%ecx, %edx
	movl	%edx, 36(%esp)
	calll	fd_read_body
	addl	$48, %esp
	movl	%eax, 24(%edi)
	testl	%eax, %eax
	js	.LBB125_536
# BB#530:                               # %do.body1100
	cmpb	$0, -545(%ebp)          # 1-byte Folded Reload
	jne	.LBB125_538
	jmp	.LBB125_531
.LBB125_511:                            # %land.lhs.true1002
	calll	__errno_location
	cmpl	$17, (%eax)
	jne	.LBB125_501
# BB#512:                               # %if.then1006
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str106537, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	68(%ecx), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_517
# BB#513:                               # %if.then1006
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_517
# BB#514:                               # %if.then1015
	cmpb	$0, opt+250
	je	.LBB125_516
# BB#515:                               # %if.then.i1486
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ebx
.LBB125_516:                            # %invalidate_persistent.exit1488
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	movl	$25, %eax
	jmp	.LBB125_541
.LBB125_536:                            # %do.body1123
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_errstr
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	-584(%ebp), %ecx        # 4-byte Reload
	movl	%eax, (%ecx)
.LBB125_531:                            # %if.then1102
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_537
# BB#532:                               # %if.then1102
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_537
# BB#533:                               # %if.then1108
	cmpb	$0, opt+250
	je	.LBB125_535
# BB#534:                               # %if.then.i1494
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ebx
.LBB125_535:                            # %invalidate_persistent.exit1496
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	jmp	.LBB125_538
.LBB125_501:                            # %if.then1024
	movl	-536(%ebp), %ecx        # 4-byte Reload
	movl	68(%ecx), %esi
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str107538, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	pconn_active.b, %al
	testb	%al, %al
	je	.LBB125_518
# BB#502:                               # %if.then1024
	movl	pconn, %eax
	cmpl	%eax, %ebx
	jne	.LBB125_518
# BB#503:                               # %if.then1034
	cmpb	$0, opt+250
	je	.LBB125_505
# BB#504:                               # %if.then.i1490
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$.L.str131, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	movl	pconn, %ebx
.LBB125_505:                            # %invalidate_persistent.exit1492
	movb	$0, pconn_active.b
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	pconn+4, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	$0, pconn+4
	movl	$0, pconn
	movl	$0, pconn+12
	movl	$0, pconn+8
	movl	$24, %eax
	jmp	.LBB125_541
.LBB125_517:                            # %if.else1016
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$25, %eax
	jmp	.LBB125_541
.LBB125_537:                            # %if.else1130
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
.LBB125_538:                            # %if.end1134
	cmpl	$0, output_stream
	jne	.LBB125_540
# BB#539:                               # %if.then1136
	subl	$16, %esp
	movl	-512(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	addl	$16, %esp
.LBB125_540:                            # %if.end1138
	movl	$26, %ecx
	cmpl	$-2, 24(%edi)
	movl	$39, %eax
	cmovel	%ecx, %eax
	jmp	.LBB125_541
.LBB125_518:                            # %if.else1035
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	fd_close
	addl	$16, %esp
	movl	$24, %eax
	jmp	.LBB125_541
.Ltmp125:
	.size	gethttp, .Ltmp125-gethttp

	.globl	http_atotm
	.align	16, 0x90
	.type	http_atotm,@function
http_atotm:                             # @http_atotm
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	$0, 4(%esp)
	movl	$2, (%esp)
	calll	setlocale
	movl	%eax, 12(%esp)          # 4-byte Spill
	movl	$.L.str35466, 4(%esp)
	movl	$2, (%esp)
	calll	setlocale
	xorl	%ebx, %ebx
	movl	80(%esp), %esi
	leal	16(%esp), %ebp
	movl	$-1, %edi
	jmp	.LBB126_1
	.align	16, 0x90
.LBB126_7:                              # %for.inc
                                        #   in Loop: Header=BB126_1 Depth=1
	incl	%ebx
.LBB126_1:                              # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB126_4 Depth 2
	cmpl	$3, %ebx
	ja	.LBB126_15
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB126_1 Depth=1
	xorps	%xmm0, %xmm0
	movaps	%xmm0, 32(%esp)
	movaps	%xmm0, 16(%esp)
	movl	$0, 56(%esp)
	movl	$0, 52(%esp)
	movl	$0, 48(%esp)
	movl	%ebp, 8(%esp)
	movl	http_atotm.time_formats(,%ebx,4), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	strptime
	testl	%eax, %eax
	je	.LBB126_7
# BB#3:                                 # %while.cond.i.preheader
                                        #   in Loop: Header=BB126_1 Depth=1
	incl	%eax
	.align	16, 0x90
.LBB126_4:                              # %while.cond.i
                                        #   Parent Loop BB126_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	-1(%eax), %ecx
	incl	%eax
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB126_4
# BB#5:                                 # %while.end.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$42, %cl
	jg	.LBB126_8
# BB#6:                                 # %while.end.i
                                        #   in Loop: Header=BB126_1 Depth=1
	testb	%cl, %cl
	je	.LBB126_14
	jmp	.LBB126_7
.LBB126_8:                              # %while.end.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$43, %cl
	je	.LBB126_13
# BB#9:                                 # %while.end.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$45, %cl
	jne	.LBB126_10
.LBB126_13:                             # %land.lhs.true27.i
                                        #   in Loop: Header=BB126_1 Depth=1
	movzbl	-1(%eax), %eax
	testb	$4, _sch_istable(%eax,%eax)
	je	.LBB126_7
	jmp	.LBB126_14
.LBB126_10:                             # %while.end.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$71, %cl
	jne	.LBB126_7
# BB#11:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$77, -1(%eax)
	jne	.LBB126_7
# BB#12:                                # %land.lhs.true12.i
                                        #   in Loop: Header=BB126_1 Depth=1
	cmpb	$84, (%eax)
	jne	.LBB126_7
.LBB126_14:                             # %if.then
	movl	%ebp, (%esp)
	calll	timegm
	movl	%eax, %edi
.LBB126_15:                             # %for.end
	movl	12(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$2, (%esp)
	calll	setlocale
	movl	%edi, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp126:
	.size	http_atotm, .Ltmp126-http_atotm

	.globl	save_cookies
	.align	16, 0x90
	.type	save_cookies,@function
save_cookies:                           # @save_cookies
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	wget_cookie_jar, %eax
	testl	%eax, %eax
	je	.LBB127_2
# BB#1:                                 # %if.then
	movl	opt+304, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	cookie_jar_save
.LBB127_2:                              # %if.end
	addl	$12, %esp
	ret
.Ltmp127:
	.size	save_cookies, .Ltmp127-save_cookies

	.globl	http_cleanup
	.align	16, 0x90
	.type	http_cleanup,@function
http_cleanup:                           # @http_cleanup
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	pconn+4, %eax
	testl	%eax, %eax
	je	.LBB128_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB128_2:                              # %if.end
	movl	wget_cookie_jar, %eax
	testl	%eax, %eax
	je	.LBB128_4
# BB#3:                                 # %if.then2
	movl	%eax, (%esp)
	calll	cookie_jar_delete
.LBB128_4:                              # %if.end3
	addl	$12, %esp
	ret
.Ltmp128:
	.size	http_cleanup, .Ltmp128-http_cleanup

	.align	16, 0x90
	.type	request_set_header,@function
request_set_header:                     # @request_set_header
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, 24(%esp)          # 4-byte Spill
	movl	52(%esp), %eax
	cmpl	$0, 48(%esp)
	je	.LBB129_8
# BB#1:                                 # %for.cond.preheader
	movl	12(%ecx), %edx
	movl	%edx, 16(%esp)          # 4-byte Spill
	movl	%ecx, 20(%esp)          # 4-byte Spill
	xorl	%ebp, %ebp
	movl	$-1, %edi
	.align	16, 0x90
.LBB129_2:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	incl	%edi
	cmpl	%edx, %edi
	jge	.LBB129_14
# BB#3:                                 # %for.body
                                        #   in Loop: Header=BB129_2 Depth=1
	movl	20(%esp), %eax          # 4-byte Reload
	movl	8(%eax), %esi
	movl	(%esi,%ebp), %ebx
	addl	$12, %ebp
	movl	%ebx, 4(%esp)
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strcasecmp
	movl	16(%esp), %edx          # 4-byte Reload
	testl	%eax, %eax
	jne	.LBB129_2
# BB#4:                                 # %if.then7
	movl	-4(%esi,%ebp), %eax
	cmpl	$3, %eax
	movl	%esi, %edi
	jne	.LBB129_5
# BB#10:                                # %sw.bb2.i
	movl	%ebx, (%esp)
	calll	checking_free
	jmp	.LBB129_11
.LBB129_8:                              # %if.then
	orl	$2, %eax
	cmpl	$3, %eax
	jne	.LBB129_18
# BB#9:                                 # %if.then2
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB129_18
.LBB129_14:                             # %for.end
	movl	20(%esp), %esi          # 4-byte Reload
	movl	16(%esi), %eax
	cmpl	%eax, %edx
	jge	.LBB129_16
# BB#15:                                # %for.end.if.end20_crit_edge
	movl	8(%esi), %eax
	jmp	.LBB129_17
.LBB129_16:                             # %if.then14
	leal	(%eax,%eax), %ecx
	movl	%ecx, 16(%esi)
	movl	8(%esi), %ecx
	imull	$24, %eax, %eax
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 8(%esi)
	movl	12(%esi), %edx
.LBB129_17:                             # %if.end20
	leal	1(%edx), %ecx
	movl	%ecx, 12(%esi)
	imull	$12, %edx, %ecx
	movl	24(%esp), %edx          # 4-byte Reload
	movl	%edx, (%eax,%ecx)
	movl	48(%esp), %edx
	movl	%edx, 4(%eax,%ecx)
	movl	52(%esp), %edx
	movl	%edx, 8(%eax,%ecx)
	jmp	.LBB129_18
.LBB129_5:                              # %if.then7
	cmpl	$2, %eax
	je	.LBB129_11
# BB#6:                                 # %if.then7
	cmpl	$1, %eax
	jne	.LBB129_13
# BB#7:                                 # %sw.bb.i
	movl	%ebx, (%esp)
	jmp	.LBB129_12
.LBB129_11:                             # %sw.bb2.i
	movl	-8(%edi,%ebp), %eax
	movl	%eax, (%esp)
.LBB129_12:                             # %sw.bb2.i
	calll	checking_free
.LBB129_13:                             # %release_header.exit
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, -12(%edi,%ebp)
	movl	48(%esp), %eax
	movl	%eax, -8(%edi,%ebp)
	movl	52(%esp), %eax
	movl	%eax, -4(%edi,%ebp)
.LBB129_18:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp129:
	.size	request_set_header, .Ltmp129-request_set_header

	.align	16, 0x90
	.type	request_set_user_header,@function
request_set_user_header:                # @request_set_user_header
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, %esi
	movl	%ecx, -16(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$58, 4(%esp)
	calll	strchr
	addl	$16, %esp
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB130_4
# BB#1:                                 # %do.body
	movl	%edi, %ebx
	subl	%esi, %ebx
	leal	16(%ebx), %eax
	andl	$-16, %eax
	movl	%esi, %ecx
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%ebx,%esi)
	.align	16, 0x90
.LBB130_2:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movzbl	1(%edi), %eax
	incl	%edi
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB130_2
# BB#3:                                 # %while.end
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$1, 4(%esp)
	movl	-16(%ebp), %ecx         # 4-byte Reload
	movl	%eax, %edx
	calll	request_set_header
	addl	$16, %esp
.LBB130_4:                              # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp130:
	.size	request_set_user_header, .Ltmp130-request_set_user_header

	.align	16, 0x90
	.type	basic_authentication_encode,@function
basic_authentication_encode:            # @basic_authentication_encode
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, %edi
	movl	%ecx, %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	movl	%esi, -20(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, -16(%ebp)         # 4-byte Spill
	movl	%esi, %ecx
	leal	17(%ecx,%eax), %edx
	andl	$-16, %edx
	movl	%esp, %esi
	subl	%edx, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str140, 4(%esp)
	leal	3(%ecx,%eax), %eax
	movl	$1431655766, %ecx       # imm = 0x55555556
	imull	%ecx
	movl	%edx, %eax
	shrl	$31, %eax
	addl	%edx, %eax
	leal	16(,%eax,4), %edi
	andl	$-16, %edi
	calll	sprintf
	addl	$16, %esp
	movl	%esp, %ebx
	subl	%edi, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	-16(%ebp), %eax         # 4-byte Reload
	movl	-20(%ebp), %ecx         # 4-byte Reload
	leal	1(%ecx,%eax), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	base64_encode
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	$0, 8(%esp)
	movl	$.L.str141, (%esp)
	calll	concat_strings
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp131:
	.size	basic_authentication_encode, .Ltmp131-basic_authentication_encode

	.align	16, 0x90
	.type	request_free,@function
request_free:                           # @request_free
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%ecx, %esi
	movl	4(%esi), %eax
	testl	%eax, %eax
	je	.LBB132_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB132_2:                              # %for.cond.preheader
	movl	8(%esi), %ebp
	cmpl	$0, 12(%esi)
	jle	.LBB132_12
# BB#3:
	xorl	%edi, %edi
	movl	$8, %ebx
	.align	16, 0x90
.LBB132_4:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	(%ebp,%ebx), %eax
	cmpl	$3, %eax
	jne	.LBB132_5
# BB#8:                                 # %sw.bb2.i
                                        #   in Loop: Header=BB132_4 Depth=1
	movl	-8(%ebp,%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB132_9
.LBB132_5:                              # %for.body
                                        #   in Loop: Header=BB132_4 Depth=1
	cmpl	$2, %eax
	je	.LBB132_9
# BB#6:                                 # %for.body
                                        #   in Loop: Header=BB132_4 Depth=1
	cmpl	$1, %eax
	jne	.LBB132_11
# BB#7:                                 # %sw.bb.i
                                        #   in Loop: Header=BB132_4 Depth=1
	movl	-8(%ebp,%ebx), %eax
	jmp	.LBB132_10
.LBB132_9:                              # %sw.bb2.i
                                        #   in Loop: Header=BB132_4 Depth=1
	movl	-4(%ebp,%ebx), %eax
.LBB132_10:                             # %sw.bb2.i
                                        #   in Loop: Header=BB132_4 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB132_11:                             # %release_header.exit
                                        #   in Loop: Header=BB132_4 Depth=1
	addl	$12, %ebx
	movl	8(%esi), %ebp
	incl	%edi
	cmpl	12(%esi), %edi
	jl	.LBB132_4
.LBB132_12:                             # %for.end
	testl	%ebp, %ebp
	je	.LBB132_14
# BB#13:                                # %if.else5
	movl	%ebp, (%esp)
	calll	checking_free
.LBB132_14:                             # %if.end7
	movl	%esi, (%esp)
	calll	checking_free
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp132:
	.size	request_free, .Ltmp132-request_free

	.align	16, 0x90
	.type	request_send,@function
request_send:                           # @request_send
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %esi
	movl	%ecx, %edi
	movl	(%edi), %eax
	movl	%eax, -24(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	movl	4(%edi), %eax
	movl	%eax, -20(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	leal	12(%ebx,%eax), %ebx
	movl	12(%edi), %eax
	testl	%eax, %eax
	jle	.LBB133_1
# BB#2:                                 # %for.body.lr.ph
	movl	%esi, -32(%ebp)         # 4-byte Spill
	movl	8(%edi), %esi
	movl	%edi, -28(%ebp)         # 4-byte Spill
	addl	$4, %esi
	xorl	%edi, %edi
	movl	%eax, -16(%ebp)         # 4-byte Spill
	.align	16, 0x90
.LBB133_3:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	-4(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%ebx, %ecx
	movl	%eax, %ebx
	movl	(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	addl	%ecx, %ebx
	calll	strlen
	addl	$16, %esp
	leal	4(%eax,%ebx), %ebx
	addl	$12, %esi
	incl	%edi
	cmpl	-16(%ebp), %edi         # 4-byte Folded Reload
	jl	.LBB133_3
	jmp	.LBB133_4
.LBB133_1:
	movl	%edi, -28(%ebp)         # 4-byte Spill
	movl	%esi, -32(%ebp)         # 4-byte Spill
	movl	%eax, -16(%ebp)         # 4-byte Spill
.LBB133_4:                              # %for.end
	movl	%ebx, -40(%ebp)         # 4-byte Spill
	leal	18(%ebx), %eax
	andl	$-16, %eax
	movl	%esp, %edi
	subl	%eax, %edi
	movl	%edi, -36(%ebp)         # 4-byte Spill
	movl	%edi, %esp
	subl	$16, %esp
	movl	-24(%ebp), %esi         # 4-byte Reload
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$32, (%edi,%ebx)
	subl	$16, %esp
	movl	-20(%ebp), %esi         # 4-byte Reload
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	leal	1(%edi,%ebx), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%ebx), %esi
	calll	memcpy
	addl	$16, %esp
	movb	$32, (%edi,%esi)
	movw	$2573, 9(%edi,%esi)     # imm = 0xA0D
	movl	$808333615, 5(%edi,%esi) # imm = 0x302E312F
	movl	$1347703880, 1(%edi,%esi) # imm = 0x50545448
	leal	11(%edi,%esi), %edi
	cmpl	$0, -16(%ebp)           # 4-byte Folded Reload
	jle	.LBB133_7
# BB#5:                                 # %for.body29.lr.ph
	xorl	%eax, %eax
	movl	$4, %esi
	movl	-28(%ebp), %ecx         # 4-byte Reload
	.align	16, 0x90
.LBB133_6:                              # %for.body29
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, -16(%ebp)         # 4-byte Spill
	movl	8(%ecx), %eax
	movl	%eax, -20(%ebp)         # 4-byte Spill
	movl	-4(%eax,%esi), %eax
	movl	%eax, -24(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	-24(%ebp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$58, (%edi,%ebx)
	movb	$32, 1(%edi,%ebx)
	movl	-20(%ebp), %eax         # 4-byte Reload
	movl	(%eax,%esi), %eax
	movl	%eax, -20(%ebp)         # 4-byte Spill
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	-20(%ebp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	leal	2(%edi,%ebx), %ecx
	movl	%ecx, (%esp)
	leal	2(%eax,%ebx), %ebx
	calll	memcpy
	movl	-16(%ebp), %eax         # 4-byte Reload
	addl	$16, %esp
	movb	$13, (%edi,%ebx)
	movb	$10, 1(%edi,%ebx)
	leal	2(%edi,%ebx), %edi
	addl	$12, %esi
	incl	%eax
	movl	-28(%ebp), %ecx         # 4-byte Reload
	cmpl	12(%ecx), %eax
	jl	.LBB133_6
.LBB133_7:                              # %for.end53
	movl	-40(%ebp), %ebx         # 4-byte Reload
	leal	3(%ebx), %eax
	movb	$13, (%edi)
	movb	$10, 1(%edi)
	movb	$0, 2(%edi)
	addl	$3, %edi
	subl	-36(%ebp), %edi         # 4-byte Folded Reload
	cmpl	%eax, %edi
	movl	-32(%ebp), %esi         # 4-byte Reload
	jne	.LBB133_13
# BB#8:                                 # %do.body58
	cmpb	$0, opt+250
	movl	-36(%ebp), %edi         # 4-byte Reload
	jne	.LBB133_9
	.align	16, 0x90
.LBB133_10:                             # %do.end60
	subl	$32, %esp
	addl	$2, %ebx
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_write
	addl	$32, %esp
	movl	%eax, %edi
	testl	%edi, %edi
	jns	.LBB133_12
# BB#11:                                # %if.then64
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str139, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %ebx
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	fd_errstr
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB133_12:                             # %if.end67
	movl	%edi, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB133_9:                              # %if.then
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	$.L.str138, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB133_10
.LBB133_13:                             # %cond.false
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.request_send, 12(%esp)
	movl	$359, 8(%esp)           # imm = 0x167
	movl	$.L.str1432, 4(%esp)
	movl	$.L.str137, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.Ltmp133:
	.size	request_send, .Ltmp133-request_send

	.align	16, 0x90
	.type	skip_short_body,@function
skip_short_body:                        # @skip_short_body
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$540, %esp              # imm = 0x21C
	movl	%edx, %edi
	movl	%ecx, %esi
	movl	560(%esp), %ebx
	movl	%edi, %eax
	andl	%ebx, %eax
	movb	$0, 539(%esp)
	cmpl	$-1, %eax
	je	.LBB134_22
# BB#1:                                 # %cond.end
	cmpl	$4096, %edi             # imm = 0x1000
	seta	%al
	testl	%ebx, %ebx
	setg	%cl
	je	.LBB134_3
# BB#2:                                 # %cond.end
	movb	%cl, %al
.LBB134_3:                              # %cond.end
	xorb	%cl, %cl
	testb	%al, %al
	jne	.LBB134_21
# BB#4:                                 # %do.body
	cmpb	$0, opt+250
	jne	.LBB134_5
	.align	16, 0x90
.LBB134_6:                              # %while.cond.preheader
	leal	27(%esp), %ebp
	jmp	.LBB134_7
.LBB134_5:                              # %if.then3
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	calll	number_to_static_string
	movl	%eax, 4(%esp)
	movl	$.L.str122, (%esp)
	calll	debug_logprintf
	jmp	.LBB134_6
	.align	16, 0x90
.LBB134_18:                             # %if.then39
                                        #   in Loop: Header=BB134_7 Depth=1
	movl	%ebp, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str125, (%esp)
	calll	debug_logprintf
	.align	16, 0x90
.LBB134_7:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	testl	%edi, %edi
	sete	%al
	testl	%ebx, %ebx
	sets	%cl
	je	.LBB134_9
# BB#8:                                 # %while.cond
                                        #   in Loop: Header=BB134_7 Depth=1
	movb	%cl, %al
.LBB134_9:                              # %while.cond
                                        #   in Loop: Header=BB134_7 Depth=1
	testb	%al, %al
	jne	.LBB134_19
# BB#10:                                # %while.body
                                        #   in Loop: Header=BB134_7 Depth=1
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
	cmpl	$512, %edi              # imm = 0x200
	seta	%al
	testl	%ebx, %ebx
	setg	%cl
	je	.LBB134_12
# BB#11:                                # %while.body
                                        #   in Loop: Header=BB134_7 Depth=1
	movb	%cl, %al
.LBB134_12:                             # %while.body
                                        #   in Loop: Header=BB134_7 Depth=1
	testb	%al, %al
	movl	%edi, %eax
	movl	$512, %ecx              # imm = 0x200
	cmovnel	%ecx, %eax
	movl	%eax, 8(%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_read
	testl	%eax, %eax
	jle	.LBB134_13
# BB#17:                                # %if.end32
                                        #   in Loop: Header=BB134_7 Depth=1
	movl	%eax, %ecx
	sarl	$31, %ecx
	subl	%eax, %edi
	sbbl	%ecx, %ebx
	cmpb	$0, opt+250
	je	.LBB134_7
	jmp	.LBB134_18
.LBB134_19:                             # %do.body43
	movb	$1, %cl
	cmpb	$0, opt+250
	je	.LBB134_21
# BB#20:                                # %if.then48
	movl	$.L.str126, (%esp)
	calll	debug_logprintf
	movb	$1, %cl
	jmp	.LBB134_21
.LBB134_13:                             # %do.body17
	xorb	%cl, %cl
	cmpb	$0, opt+250
	jne	.LBB134_14
	.align	16, 0x90
.LBB134_21:                             # %return
	movzbl	%cl, %eax
	addl	$540, %esp              # imm = 0x21C
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB134_14:                             # %if.then22
	movl	$.L.str124, %ecx
	testl	%eax, %eax
	jns	.LBB134_16
# BB#15:                                # %cond.true25
	movl	%esi, (%esp)
	calll	fd_errstr
	movl	%eax, %ecx
.LBB134_16:                             # %cond.end28
	movl	%ecx, 4(%esp)
	movl	$.L.str123, (%esp)
	calll	debug_logprintf
	xorb	%cl, %cl
	jmp	.LBB134_21
.LBB134_22:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.skip_short_body, 12(%esp)
	movl	$906, 8(%esp)           # imm = 0x38A
	movl	$.L.str1432, 4(%esp)
	movl	$.L.str121, (%esp)
	calll	__assert_fail
.Ltmp134:
	.size	skip_short_body, .Ltmp134-skip_short_body

	.align	16, 0x90
	.type	resp_header_locate,@function
resp_header_locate:                     # @resp_header_locate
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, 20(%esp)          # 4-byte Spill
	movl	4(%ecx), %ecx
	movl	$-1, %eax
	testl	%ecx, %ecx
	je	.LBB135_13
# BB#1:                                 # %lor.lhs.false
	movl	$-1, %eax
	cmpl	$0, 4(%ecx)
	je	.LBB135_13
# BB#2:                                 # %if.end
	movl	%ecx, 16(%esp)          # 4-byte Spill
	movl	48(%esp), %eax
	movl	20(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	testl	%eax, %eax
	movl	$1, %ecx
	cmovgl	%eax, %ecx
	movl	%ecx, 24(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, %edi
	.align	16, 0x90
.LBB135_3:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	24(%esp), %ebx          # 4-byte Reload
	movl	16(%esp), %ecx          # 4-byte Reload
	movl	4(%ecx,%ebx,4), %esi
	movl	$-1, %eax
	testl	%esi, %esi
	je	.LBB135_13
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB135_3 Depth=1
	leal	1(%ebx), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	(%ecx,%ebx,4), %ebp
	movl	%esi, %eax
	subl	%ebp, %eax
	cmpl	%edi, %eax
	jle	.LBB135_3
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB135_3 Depth=1
	cmpb	$58, (%ebp,%edi)
	jne	.LBB135_3
# BB#6:                                 # %land.lhs.true14
                                        #   in Loop: Header=BB135_3 Depth=1
	movl	%edi, 8(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB135_3
# BB#7:                                 # %if.then18
	leal	1(%edi,%ebp), %ecx
	.align	16, 0x90
.LBB135_8:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, %eax
	cmpl	%esi, %eax
	jae	.LBB135_10
# BB#9:                                 # %land.rhs
                                        #   in Loop: Header=BB135_8 Depth=1
	leal	1(%eax), %ecx
	movzbl	(%eax), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB135_8
	.align	16, 0x90
.LBB135_10:                             # %while.cond27
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, %ecx
	cmpl	%ecx, %eax
	jae	.LBB135_12
# BB#11:                                # %land.rhs30
                                        #   in Loop: Header=BB135_10 Depth=1
	leal	-1(%ecx), %esi
	movzbl	-1(%ecx), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB135_10
.LBB135_12:                             # %while.end41
	movl	52(%esp), %edx
	movl	%eax, (%edx)
	movl	56(%esp), %eax
	movl	%ecx, (%eax)
	movl	%ebx, %eax
.LBB135_13:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp135:
	.size	resp_header_locate, .Ltmp135-resp_header_locate

	.align	16, 0x90
	.type	digest_authentication_encode,@function
digest_authentication_encode:           # @digest_authentication_encode
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$156, %esp
	movl	%edx, -156(%ebp)        # 4-byte Spill
	movl	$0, digest_authentication_encode.nonce
	movl	$0, digest_authentication_encode.opaque
	movl	$0, digest_authentication_encode.realm
	addl	$6, %ecx
	movl	%ecx, -16(%ebp)
	jmp	.LBB136_1
	.align	16, 0x90
.LBB136_6:                              # %if.then
                                        #   in Loop: Header=BB136_1 Depth=1
	movl	-32(%ebp), %eax
	movl	-28(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	digest_authentication_encode.options+4(,%esi,8), %esi
	calll	strdupdelim
	addl	$16, %esp
	movl	%eax, (%esi)
	.align	16, 0x90
.LBB136_1:                              # %entry
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB136_3 Depth 2
	subl	$16, %esp
	leal	-32(%ebp), %eax
	movl	%eax, 8(%esp)
	leal	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$44, 12(%esp)
	calll	extract_param
	addl	$16, %esp
	testb	%al, %al
	je	.LBB136_7
# BB#2:                                 # %for.cond.preheader
                                        #   in Loop: Header=BB136_1 Depth=1
	movl	-24(%ebp), %eax
	movl	%eax, -152(%ebp)        # 4-byte Spill
	movl	-20(%ebp), %ebx
	subl	%eax, %ebx
	xorl	%esi, %esi
	jmp	.LBB136_3
	.align	16, 0x90
.LBB136_30:                             # %for.inc
                                        #   in Loop: Header=BB136_3 Depth=2
	incl	%esi
.LBB136_3:                              # %for.cond
                                        #   Parent Loop BB136_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	$2, %esi
	ja	.LBB136_1
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB136_3 Depth=2
	subl	$16, %esp
	movl	digest_authentication_encode.options(,%esi,8), %edi
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	cmpl	%eax, %ebx
	jne	.LBB136_30
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB136_3 Depth=2
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	-152(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	strncmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB136_30
	jmp	.LBB136_6
.LBB136_7:                              # %while.end
	movl	digest_authentication_encode.realm, %eax
	cmpl	$0, digest_authentication_encode.nonce
	je	.LBB136_13
# BB#8:                                 # %while.end
	testl	%eax, %eax
	je	.LBB136_13
# BB#9:                                 # %while.end
	cmpl	$0, -156(%ebp)          # 4-byte Folded Reload
	je	.LBB136_13
# BB#10:                                # %while.end
	movl	8(%ebp), %edi
	testl	%edi, %edi
	je	.LBB136_13
# BB#11:                                # %while.end
	cmpl	$0, 16(%ebp)
	je	.LBB136_13
# BB#12:                                # %while.end
	cmpl	$0, 12(%ebp)
	jne	.LBB136_19
.LBB136_13:                             # %if.then27
	testl	%eax, %eax
	je	.LBB136_15
# BB#14:                                # %if.else
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB136_15:                             # %if.end30
	movl	digest_authentication_encode.opaque, %eax
	testl	%eax, %eax
	je	.LBB136_17
# BB#16:                                # %if.else33
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB136_17:                             # %if.end34
	xorl	%edi, %edi
	movl	digest_authentication_encode.nonce, %eax
	testl	%eax, %eax
	je	.LBB136_29
# BB#18:                                # %if.else37
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	xorl	%edi, %edi
	.align	16, 0x90
.LBB136_29:                             # %return
	movl	%edi, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB136_19:                             # %if.end39
	calll	gen_md5_context_size
	addl	$15, %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	gen_md5_init
	addl	$16, %esp
	subl	$16, %esp
	movl	-156(%ebp), %ebx        # 4-byte Reload
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$1, 4(%esp)
	movl	$.L.str115546, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	movl	digest_authentication_encode.realm, %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$1, 4(%esp)
	movl	$.L.str115546, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	leal	-48(%ebp), %edi
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	gen_md5_finish
	addl	$16, %esp
	xorl	%eax, %eax
	.align	16, 0x90
.LBB136_20:                             # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-48(%ebp,%eax), %ecx
	shrl	$4, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -81(%ebp,%eax,2)
	movzbl	-48(%ebp,%eax), %ecx
	andl	$15, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -80(%ebp,%eax,2)
	incl	%eax
	cmpl	$16, %eax
	jne	.LBB136_20
# BB#21:                                # %dump_hash.exit
	movb	$0, -49(%ebp)
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	gen_md5_init
	addl	$16, %esp
	subl	$16, %esp
	movl	12(%ebp), %ebx
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$1, 4(%esp)
	movl	$.L.str115546, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	16(%ebp), %ebx
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	gen_md5_finish
	addl	$16, %esp
	xorl	%eax, %eax
	.align	16, 0x90
.LBB136_22:                             # %for.body.i114
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-48(%ebp,%eax), %ecx
	shrl	$4, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -114(%ebp,%eax,2)
	movzbl	-48(%ebp,%eax), %ecx
	andl	$15, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -113(%ebp,%eax,2)
	incl	%eax
	cmpl	$16, %eax
	jne	.LBB136_22
# BB#23:                                # %dump_hash.exit116
	movb	$0, -82(%ebp)
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	gen_md5_init
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	leal	-81(%ebp), %eax
	movl	%eax, (%esp)
	movl	$32, 4(%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$1, 4(%esp)
	movl	$.L.str115546, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	movl	digest_authentication_encode.nonce, %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	$1, 4(%esp)
	movl	$.L.str115546, (%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	leal	-114(%ebp), %eax
	movl	%eax, (%esp)
	movl	$32, 4(%esp)
	calll	gen_md5_update
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	gen_md5_finish
	addl	$16, %esp
	xorl	%eax, %eax
	.align	16, 0x90
.LBB136_24:                             # %for.body.i98
                                        # =>This Inner Loop Header: Depth=1
	movzbl	-48(%ebp,%eax), %ecx
	shrl	$4, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -147(%ebp,%eax,2)
	movzbl	-48(%ebp,%eax), %ecx
	andl	$15, %ecx
	movb	.L.str119(%ecx), %cl
	movb	%cl, -146(%ebp,%eax,2)
	incl	%eax
	cmpl	$16, %eax
	jne	.LBB136_24
# BB#25:                                # %dump_hash.exit100
	movb	$0, -115(%ebp)
	subl	$16, %esp
	movl	-156(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %edi
	movl	digest_authentication_encode.realm, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, -152(%ebp)        # 4-byte Spill
	movl	digest_authentication_encode.nonce, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	addl	%edi, %edi
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ebx
	xorl	%eax, %eax
	movl	digest_authentication_encode.opaque, %ecx
	testl	%ecx, %ecx
	je	.LBB136_27
# BB#26:                                # %cond.true
	subl	$16, %esp
	movl	%ecx, (%esp)
	calll	strlen
	addl	$16, %esp
.LBB136_27:                             # %cond.end
	addl	-152(%ebp), %edi        # 4-byte Folded Reload
	addl	%esi, %edi
	addl	%ebx, %edi
	leal	160(%eax,%edi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_malloc
	addl	$16, %esp
	movl	%eax, %edi
	movl	digest_authentication_encode.realm, %eax
	movl	digest_authentication_encode.nonce, %ecx
	subl	$32, %esp
	leal	-147(%ebp), %edx
	movl	%edx, 24(%esp)
	movl	16(%ebp), %edx
	movl	%edx, 20(%esp)
	movl	%ecx, 16(%esp)
	movl	%eax, 12(%esp)
	movl	-156(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$.L.str116547, 4(%esp)
	calll	sprintf
	addl	$32, %esp
	movl	digest_authentication_encode.opaque, %eax
	movl	%eax, -152(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	je	.LBB136_29
# BB#28:                                # %if.then74
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	leal	(%edi,%esi), %ebx
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	%esi, %eax
	movb	$0, 10(%edi,%eax)
	movw	$8765, 8(%edi,%eax)     # imm = 0x223D
	movl	$1702195553, 4(%edi,%eax) # imm = 0x65757161
	movl	$1886330924, (%edi,%eax) # imm = 0x706F202C
	subl	$16, %esp
	movl	-152(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	strcat
	addl	$16, %esp
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	%esi, %eax
	movw	$34, (%edi,%eax)
	jmp	.LBB136_29
.Ltmp136:
	.size	digest_authentication_encode, .Ltmp136-digest_authentication_encode

	.align	16, 0x90
	.type	print_response_line,@function
print_response_line:                    # @print_response_line
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%edi
	pushl	%esi
	movl	%edx, %esi
	subl	%ecx, %esi
	leal	16(%esi), %eax
	andl	$-16, %eax
	movl	%esp, %edi
	subl	%eax, %edi
	movl	%edi, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%esi,%edi)
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	escnonprint
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 12(%esp)
	movl	$.L.str74505, 8(%esp)
	movl	$.L.str129, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	leal	-8(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebp
	ret
.Ltmp137:
	.size	print_response_line, .Ltmp137-print_response_line

	.align	16, 0x90
	.type	response_head_terminator,@function
response_head_terminator:               # @response_head_terminator
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	40(%esp), %ebx
	movl	36(%esp), %edi
	movl	32(%esp), %esi
	cmpl	%edi, %esi
	jne	.LBB138_2
# BB#1:                                 # %land.lhs.true
	movl	%esi, (%esp)
	cmpl	$4, %ebx
	movl	$4, %eax
	cmovlel	%ebx, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str68499, 4(%esp)
	calll	memcmp
	testl	%eax, %eax
	jne	.LBB138_11
.LBB138_2:                              # %if.end
	leal	-2(%ebx,%edi), %eax
	movl	%edi, %ecx
	subl	%esi, %ecx
	addl	$-2, %edi
	cmpl	$2, %ecx
	cmovll	%esi, %edi
	addl	$2, %edi
	jmp	.LBB138_3
	.align	16, 0x90
.LBB138_5:                              # %for.cond.backedge
                                        #   in Loop: Header=BB138_3 Depth=1
	incl	%edi
.LBB138_3:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movb	-2(%edi), %cl
	leal	-2(%edi), %edx
	cmpl	%eax, %edx
	jae	.LBB138_12
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB138_3 Depth=1
	cmpb	$10, %cl
	jne	.LBB138_5
# BB#6:                                 # %if.then13
                                        #   in Loop: Header=BB138_3 Depth=1
	movb	-1(%edi), %cl
	cmpb	$10, %cl
	je	.LBB138_10
# BB#7:                                 # %if.then13
                                        #   in Loop: Header=BB138_3 Depth=1
	cmpb	$13, %cl
	jne	.LBB138_5
# BB#8:                                 # %land.lhs.true17
                                        #   in Loop: Header=BB138_3 Depth=1
	cmpb	$10, (%edi)
	jne	.LBB138_5
# BB#9:                                 # %if.then22
	incl	%edi
.LBB138_10:                             # %if.then22
	movl	%edi, %esi
	.align	16, 0x90
.LBB138_11:                             # %return
	movl	%esi, %eax
	.align	16, 0x90
.LBB138_14:                             # %return
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB138_12:                             # %for.end
	xorl	%esi, %esi
	cmpb	$10, %cl
	jne	.LBB138_11
# BB#13:                                # %land.lhs.true37
	cmpb	$10, -1(%edi)
	movl	$0, %eax
	cmovel	%edi, %eax
	jmp	.LBB138_14
.Ltmp138:
	.size	response_head_terminator, .Ltmp138-response_head_terminator

	.globl	home_dir
	.align	16, 0x90
	.type	home_dir,@function
home_dir:                               # @home_dir
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	$.L.str554, (%esp)
	calll	getenv
	testl	%eax, %eax
	jne	.LBB139_3
# BB#1:                                 # %if.then
	calll	getuid
	movl	%eax, (%esp)
	calll	getpwuid
	testl	%eax, %eax
	je	.LBB139_4
# BB#2:                                 # %lor.lhs.false
	movl	20(%eax), %eax
	testl	%eax, %eax
	je	.LBB139_4
.LBB139_3:                              # %cond.true
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$12, %esp
	ret
.LBB139_4:                              # %return
	xorl	%eax, %eax
	addl	$12, %esp
	ret
.Ltmp139:
	.size	home_dir, .Ltmp139-home_dir

	.globl	initialize
	.align	16, 0x90
	.type	initialize,@function
initialize:                             # @initialize
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	$344, 8(%esp)           # imm = 0x158
	movl	$0, 4(%esp)
	movl	$opt, (%esp)
	calll	memset
	movb	$1, opt+296
	movl	$-1, opt
	movl	$20, opt+8
	movl	$5, opt+28
	movb	$1, opt+40
	movb	$1, opt+128
	movb	$1, opt+129
	movb	$1, opt+266
	movb	$1, opt+144
	movb	$1, opt+145
	movl	$.L.str142695, (%esp)
	calll	getenv
	testl	%eax, %eax
	je	.LBB140_2
# BB#1:                                 # %if.then.i
	movl	%eax, (%esp)
	calll	sepstring
	movl	%eax, opt+160
.LBB140_2:                              # %defaults.exit
	movb	$1, opt+146
	movl	$1082925056, opt+184    # imm = 0x408C2000
	movl	$0, opt+180
	movb	$1, opt+224
	movb	$1, opt+265
	movl	$0, opt+276
	movl	$1024, opt+272          # imm = 0x400
	movl	$10, opt+284
	movl	$50, opt+280
	movb	$1, opt+88
	movb	$1, opt+130
	movl	$0, opt+320
	movb	$1, opt+324
	movl	$0, opt+328
	movl	$20, opt+20
	movl	$.L.str1555, (%esp)
	calll	file_exists_p
	movl	$1, %ebx
	testb	%al, %al
	je	.LBB140_4
# BB#3:                                 # %if.then
	movl	$.L.str1555, %ecx
	calll	run_wgetrc
	movzbl	%al, %ebx
.LBB140_4:                              # %if.end
	movl	$.L.str134687, (%esp)
	calll	getenv
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB140_8
# BB#5:                                 # %land.lhs.true.i
	cmpb	$0, (%esi)
	je	.LBB140_8
# BB#6:                                 # %if.then.i55
	movl	%esi, (%esp)
	calll	file_exists_p
	testb	%al, %al
	je	.LBB140_7
# BB#16:                                # %wgetrc_file_name.exit
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB140_15
	jmp	.LBB140_17
.LBB140_8:                              # %if.end7.i
	movl	$.L.str554, (%esp)
	calll	getenv
	testl	%eax, %eax
	jne	.LBB140_11
# BB#9:                                 # %if.then.i.i
	calll	getuid
	movl	%eax, (%esp)
	calll	getpwuid
	testl	%eax, %eax
	je	.LBB140_15
# BB#10:                                # %lor.lhs.false.i.i
	movl	20(%eax), %eax
	testl	%eax, %eax
	je	.LBB140_15
.LBB140_11:                             # %home_dir.exit.i
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB140_15
# BB#12:                                # %if.end15.i
	movl	%edi, 4(%esp)
	movl	$.L.str136689, (%esp)
	calll	aprintf
	movl	%eax, %esi
	movl	%edi, (%esp)
	calll	checking_free
	testl	%esi, %esi
	je	.LBB140_15
# BB#13:                                # %if.end18.i
	movl	%esi, (%esp)
	calll	file_exists_p
	testb	%al, %al
	je	.LBB140_14
.LBB140_17:                             # %cond.false
	movl	%esi, (%esp)
	movl	$.L.str1555, 4(%esp)
	calll	strcmp
	testl	%eax, %eax
	je	.LBB140_18
# BB#19:                                # %if.else
	movl	%esi, %ecx
	calll	run_wgetrc
	movzbl	%al, %eax
	andl	%eax, %ebx
	jmp	.LBB140_20
.LBB140_18:                             # %if.then43
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str2556, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
.LBB140_20:                             # %if.end49
	testl	%ebx, %ebx
	je	.LBB140_21
.LBB140_14:                             # %if.then20.i
	movl	%esi, (%esp)
	calll	checking_free
.LBB140_15:                             # %return
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB140_7:                              # %if.then3.i
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str135688, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	movl	$1, (%esp)
	calll	exit
.LBB140_21:                             # %if.then51
	movl	$2, (%esp)
	calll	exit
.Ltmp140:
	.size	initialize, .Ltmp140-initialize

	.align	16, 0x90
	.type	run_wgetrc,@function
run_wgetrc:                             # @run_wgetrc
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	%ecx, %edi
	movl	%edi, (%esp)
	movl	$.L.str137690, 4(%esp)
	calll	fopen64
	movl	%eax, 32(%esp)          # 4-byte Spill
	testl	%eax, %eax
	je	.LBB141_1
# BB#2:                                 # %if.end
	movb	$1, enable_tilde_expansion.b
	xorl	%ebx, %ebx
	movl	$1, 44(%esp)            # 4-byte Folded Spill
	jmp	.LBB141_3
	.align	16, 0x90
.LBB141_22:                             # %if.end26
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	36(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	incl	44(%esp)                # 4-byte Folded Spill
.LBB141_3:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	read_whole_line
	movl	%eax, %ecx
	testl	%ecx, %ecx
	je	.LBB141_23
# BB#4:                                 # %while.body
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	$0, 56(%esp)
	movl	$0, 52(%esp)
	leal	48(%esp), %eax
	movl	%eax, 4(%esp)
	leal	52(%esp), %eax
	movl	%eax, (%esp)
	movl	%ecx, 36(%esp)          # 4-byte Spill
	leal	56(%esp), %edx
	calll	parse_line
	cmpl	$3, %eax
	ja	.LBB141_15
# BB#5:                                 # %while.body
                                        #   in Loop: Header=BB141_3 Depth=1
	jmpl	*.LJTI141_0(,%eax,4)
.LBB141_6:                              # %sw.bb
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	48(%esp), %esi
	testl	%esi, %esi
	js	.LBB141_25
# BB#7:                                 # %sw.bb
                                        #   in Loop: Header=BB141_3 Depth=1
	cmpl	$108, %esi
	jae	.LBB141_25
# BB#8:                                 # %do.body.i
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%ebx, 40(%esp)          # 4-byte Spill
	movl	%edi, %ebp
	movl	52(%esp), %ebx
	movl	56(%esp), %edi
	cmpb	$0, opt+250
	jne	.LBB141_9
	.align	16, 0x90
.LBB141_10:                             # %setval_internal.exit
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%ebx, 4(%esp)
	movl	%edi, (%esp)
	imull	$12, %esi, %eax
	movl	commands+4(%eax), %ecx
	movl	%ecx, 8(%esp)
	calll	*commands+8(%eax)
	testb	%al, %al
	jne	.LBB141_11
# BB#16:                                # %if.then8
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	stderr, %esi
	movl	$5, 8(%esp)
	movl	$.L.str139692, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	44(%esp), %edx          # 4-byte Reload
	movl	%edx, 16(%esp)
	movl	%ebp, %edi
	movl	%edi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	40(%esp), %ebx          # 4-byte Reload
	jmp	.LBB141_17
.LBB141_12:                             # %sw.bb12
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	stderr, %esi
	movl	$5, 8(%esp)
	movl	$.L.str140693, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	44(%esp), %edx          # 4-byte Reload
	movl	%edx, 16(%esp)
	movl	%edi, 12(%esp)
	jmp	.LBB141_13
.LBB141_14:                             # %sw.bb16
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	stderr, %esi
	movl	$5, 8(%esp)
	movl	$.L.str141694, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	56(%esp), %edx
	movl	44(%esp), %ebp          # 4-byte Reload
	movl	%ebp, 20(%esp)
	movl	%edi, 16(%esp)
	movl	%edx, 12(%esp)
.LBB141_13:                             # %sw.bb12
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
.LBB141_17:                             # %if.then8
                                        #   in Loop: Header=BB141_3 Depth=1
	incl	%ebx
	.align	16, 0x90
.LBB141_18:                             # %sw.epilog
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	56(%esp), %eax
	testl	%eax, %eax
	je	.LBB141_20
# BB#19:                                # %if.else
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB141_20:                             # %if.end22
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	52(%esp), %eax
	testl	%eax, %eax
	je	.LBB141_22
# BB#21:                                # %if.else25
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB141_22
.LBB141_11:                             #   in Loop: Header=BB141_3 Depth=1
	movl	%ebp, %edi
	movl	40(%esp), %ebx          # 4-byte Reload
	jmp	.LBB141_18
.LBB141_9:                              # %if.then.i
                                        #   in Loop: Header=BB141_3 Depth=1
	movl	%ebx, 12(%esp)
	movl	%edi, 4(%esp)
	imull	$12, %esi, %eax
	movl	commands(%eax), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str133686, (%esp)
	calll	debug_logprintf
	jmp	.LBB141_10
.LBB141_1:                              # %if.then
	movl	stderr, %esi
	movl	$5, 8(%esp)
	movl	$.L.str138691, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%edi, %ebp
	movl	%eax, %edi
	movl	exec_name, %ebx
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 16(%esp)
	movl	%ebp, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movb	$1, %al
	jmp	.LBB141_24
.LBB141_15:                             # %sw.default
	calll	abort
.LBB141_23:                             # %while.end
	movb	$0, enable_tilde_expansion.b
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	fclose
	testl	%ebx, %ebx
	sete	%al
.LBB141_24:                             # %return
	movzbl	%al, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB141_25:                             # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.setval_internal, 12(%esp)
	movl	$633, 8(%esp)           # imm = 0x279
	movl	$.L.str4558, 4(%esp)
	movl	$.L.str132685, (%esp)
	calll	__assert_fail
.Ltmp141:
	.size	run_wgetrc, .Ltmp141-run_wgetrc
	.section	.rodata,"a",@progbits
	.align	4
.LJTI141_0:
	.long	.LBB141_6
	.long	.LBB141_18
	.long	.LBB141_12
	.long	.LBB141_14

	.text
	.globl	setoptval
	.align	16, 0x90
	.type	setoptval,@function
setoptval:                              # @setoptval
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	subl	$16, %esp
	movl	16(%ebp), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$18, %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	movl	%ecx, %edi
	subl	%eax, %edi
	movl	%edi, %esp
	movb	$45, (%edi)
	negl	%eax
	movb	$45, 1(%ecx,%eax)
	subl	$16, %esp
	movl	%esi, 4(%esp)
	leal	2(%edi), %eax
	movl	%eax, (%esp)
	calll	strcpy
	addl	$16, %esp
	cmpl	$0, 12(%ebp)
	je	.LBB142_12
# BB#1:
	movl	%edi, -28(%ebp)         # 4-byte Spill
	movl	$107, %eax
	xorl	%edx, %edx
	.align	16, 0x90
.LBB142_2:                              # %while.cond.outer.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB142_3 Depth 2
	movl	%edx, %esi
	movl	%eax, %edi
	.align	16, 0x90
.LBB142_3:                              # %while.cond.i
                                        #   Parent Loop BB142_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%edi, %edx
	cmpl	%edx, %esi
	movl	%esi, %ecx
	jg	.LBB142_13
# BB#4:                                 # %while.body.i
                                        #   in Loop: Header=BB142_3 Depth=2
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	leal	(%edx,%ecx), %ebx
	movl	%edx, -16(%ebp)         # 4-byte Spill
	sarl	%ebx
	imull	$12, %ebx, %eax
	movl	%eax, -20(%ebp)         # 4-byte Spill
	movl	commands(%eax), %eax
	movl	%eax, -24(%ebp)         # 4-byte Spill
	movl	%eax, 4(%esp)
	leal	-1(%ebx), %edi
	movl	%ecx, %esi
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	js	.LBB142_3
# BB#5:                                 # %if.else.i
                                        #   in Loop: Header=BB142_2 Depth=1
	movl	-24(%ebp), %edi         # 4-byte Reload
	movl	-20(%ebp), %ecx         # 4-byte Reload
	leal	1(%ebx), %edx
	testl	%eax, %eax
	movl	-16(%ebp), %eax         # 4-byte Reload
	jg	.LBB142_2
# BB#6:                                 # %command_by_name.exit
	testl	%ebx, %ebx
	movl	%edi, %eax
	js	.LBB142_13
# BB#7:                                 # %command_by_name.exit
	cmpl	$108, %ebx
	jae	.LBB142_13
# BB#8:                                 # %do.body.i
	cmpb	$0, opt+250
	movl	-28(%ebp), %esi         # 4-byte Reload
	movl	12(%ebp), %edi
	movl	%ecx, %ebx
	jne	.LBB142_9
	.align	16, 0x90
.LBB142_10:                             # %setval_internal.exit
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	commands+4(%ebx), %eax
	movl	%eax, 8(%esp)
	calll	*commands+8(%ebx)
	addl	$16, %esp
	testb	%al, %al
	je	.LBB142_14
# BB#11:                                # %if.end
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB142_13:                             # %cond.false.i
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.setval_internal, 12(%esp)
	movl	$633, 8(%esp)           # imm = 0x279
	movl	$.L.str4558, 4(%esp)
	movl	$.L.str132685, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB142_9:                              # %if.then.i
	subl	$16, %esp
	movl	%edi, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str133686, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB142_10
.LBB142_12:                             # %cond.false
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.setoptval, 12(%esp)
	movl	$657, 8(%esp)           # imm = 0x291
	movl	$.L.str4558, 4(%esp)
	movl	$.L.str3557, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB142_14:                             # %if.then
	subl	$16, %esp
	movl	$2, (%esp)
	calll	exit
	addl	$16, %esp
.Ltmp142:
	.size	setoptval, .Ltmp142-setoptval

	.globl	run_command
	.align	16, 0x90
	.type	run_command,@function
run_command:                            # @run_command
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	leal	20(%esp), %eax
	movl	%eax, 4(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	movl	48(%esp), %esi
	leal	28(%esp), %edx
	movl	%esi, %ecx
	calll	parse_line
	testl	%eax, %eax
	jne	.LBB143_7
# BB#1:                                 # %sw.bb
	movl	20(%esp), %ebx
	testl	%ebx, %ebx
	js	.LBB143_8
# BB#2:                                 # %sw.bb
	cmpl	$108, %ebx
	jae	.LBB143_8
# BB#3:                                 # %do.body.i
	movl	24(%esp), %esi
	movl	28(%esp), %edi
	cmpb	$0, opt+250
	jne	.LBB143_4
	.align	16, 0x90
.LBB143_5:                              # %setval_internal.exit
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	imull	$12, %ebx, %eax
	movl	commands+4(%eax), %ecx
	movl	%ecx, 8(%esp)
	calll	*commands+8(%eax)
	testb	%al, %al
	je	.LBB143_9
# BB#6:                                 # %if.end
	movl	%edi, (%esp)
	calll	checking_free
	movl	%esi, (%esp)
	calll	checking_free
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB143_8:                              # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.setval_internal, 12(%esp)
	movl	$633, 8(%esp)           # imm = 0x279
	movl	$.L.str4558, 4(%esp)
	movl	$.L.str132685, (%esp)
	calll	__assert_fail
.LBB143_4:                              # %if.then.i
	movl	%esi, 12(%esp)
	movl	%edi, 4(%esp)
	imull	$12, %ebx, %eax
	movl	commands(%eax), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str133686, (%esp)
	calll	debug_logprintf
	jmp	.LBB143_5
.LBB143_7:                              # %sw.default
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str5559, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	movl	$2, (%esp)
	calll	exit
.LBB143_9:                              # %if.then
	movl	$2, (%esp)
	calll	exit
.Ltmp143:
	.size	run_command, .Ltmp143-run_command

	.align	16, 0x90
	.type	parse_line,@function
parse_line:                             # @parse_line
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, -20(%ebp)         # 4-byte Spill
	movl	%ecx, %edi
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %ecx
	leal	(%edi,%ecx), %esi
	.align	16, 0x90
.LBB144_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, %eax
	movl	%edi, %ebx
	movzbl	(%ebx), %edx
	testl	%edx, %edx
	je	.LBB144_3
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB144_1 Depth=1
	leal	-1(%eax), %ecx
	leal	1(%ebx), %edi
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB144_1
	.align	16, 0x90
.LBB144_3:                              # %while.cond5
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	movl	%esi, %edi
	cmpl	%ebx, %edi
	jbe	.LBB144_5
# BB#4:                                 # %land.rhs7
                                        #   in Loop: Header=BB144_3 Depth=1
	leal	-1(%ecx), %eax
	leal	-1(%edi), %esi
	movl	%esi, -16(%ebp)         # 4-byte Spill
	movl	%ebx, %esi
	movzbl	-1(%edi), %ebx
	testb	$64, _sch_istable(%ebx,%ebx)
	movl	%esi, %ebx
	movl	-16(%ebp), %esi         # 4-byte Reload
	jne	.LBB144_3
.LBB144_5:                              # %while.end18
	movl	$1, %eax
	testb	%dl, %dl
	je	.LBB144_31
# BB#6:                                 # %while.end18
	cmpb	$35, %dl
	je	.LBB144_31
# BB#7:
	xorl	%eax, %eax
	movl	%ebx, %esi
	jmp	.LBB144_8
	.align	16, 0x90
.LBB144_32:                             # %while.body41
                                        #   in Loop: Header=BB144_8 Depth=1
	incl	%eax
.LBB144_8:                              # %while.cond23
                                        # =>This Inner Loop Header: Depth=1
	leal	(%esi,%eax), %ebx
	cmpl	%edi, %ebx
	jae	.LBB144_12
# BB#9:                                 # %land.rhs26
                                        #   in Loop: Header=BB144_8 Depth=1
	movzbl	(%ebx), %edx
	testb	$-116, _sch_istable(%edx,%edx)
	jne	.LBB144_32
# BB#10:                                # %switch.early.test
                                        #   in Loop: Header=BB144_8 Depth=1
	cmpb	$45, %dl
	je	.LBB144_32
# BB#11:                                # %switch.early.test
                                        #   in Loop: Header=BB144_8 Depth=1
	cmpb	$95, %dl
	je	.LBB144_32
.LBB144_12:                             # %while.cond44.preheader
	movl	%esi, -16(%ebp)         # 4-byte Spill
	subl	%eax, %ecx
	movl	%ebx, %eax
	movl	%ebx, -24(%ebp)         # 4-byte Spill
	.align	16, 0x90
.LBB144_13:                             # %while.cond44
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, %ebx
	movl	%eax, %edx
	cmpl	%edi, %edx
	jae	.LBB144_15
# BB#14:                                # %land.rhs47
                                        #   in Loop: Header=BB144_13 Depth=1
	leal	-1(%ebx), %ecx
	leal	1(%edx), %eax
	movzbl	(%edx), %esi
	testb	$64, _sch_istable(%esi,%esi)
	jne	.LBB144_13
.LBB144_15:                             # %while.end57
	movl	$2, %eax
	testl	%ebx, %ebx
	je	.LBB144_31
# BB#16:                                # %lor.lhs.false60
	movl	$2, %eax
	cmpb	$61, (%edx)
	jne	.LBB144_31
# BB#17:
	incl	%edx
	.align	16, 0x90
.LBB144_18:                             # %while.cond67
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, %ebx
	cmpl	%edi, %ebx
	jae	.LBB144_20
# BB#19:                                # %land.rhs70
                                        #   in Loop: Header=BB144_18 Depth=1
	leal	1(%ebx), %edx
	movzbl	(%ebx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB144_18
.LBB144_20:                             # %while.end80
	subl	$16, %esp
	movl	-24(%ebp), %esi         # 4-byte Reload
	movl	%esi, 4(%esp)
	movl	-16(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	-20(%ebp), %ecx         # 4-byte Reload
	movl	%eax, (%ecx)
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strdupdelim
	addl	$16, %esp
	movl	8(%ebp), %ecx
	movl	%eax, (%ecx)
	movl	-16(%ebp), %ecx         # 4-byte Reload
	subl	%ecx, %esi
	leal	16(%esi), %eax
	andl	$-16, %eax
	movl	%esp, %edi
	subl	%eax, %edi
	movl	%edi, -20(%ebp)         # 4-byte Spill
	movl	%edi, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%esi,%edi)
	movl	%edi, %eax
	movl	%edi, %ecx
	jmp	.LBB144_21
	.align	16, 0x90
.LBB144_24:                             # %if.else.i
                                        #   in Loop: Header=BB144_21 Depth=1
	movb	%dl, (%eax)
	incl	%eax
	.align	16, 0x90
.LBB144_21:                             # %while.cond.outer.i
                                        # =>This Inner Loop Header: Depth=1
	incl	%ecx
	movb	-1(%ecx), %dl
	testb	%dl, %dl
	je	.LBB144_25
# BB#22:                                # %while.cond.i
                                        #   in Loop: Header=BB144_21 Depth=1
	cmpb	$45, %dl
	je	.LBB144_21
# BB#23:                                # %while.cond.i
                                        #   in Loop: Header=BB144_21 Depth=1
	cmpb	$95, %dl
	je	.LBB144_21
	jmp	.LBB144_24
.LBB144_25:                             # %dehyphen.exit
	movb	$0, (%eax)
	movl	$107, %ebx
	xorl	%esi, %esi
	.align	16, 0x90
.LBB144_26:                             # %while.cond.i96
                                        # =>This Inner Loop Header: Depth=1
	movl	$3, %eax
	cmpl	%ebx, %esi
	jg	.LBB144_31
# BB#27:                                # %while.body.i
                                        #   in Loop: Header=BB144_26 Depth=1
	subl	$16, %esp
	movl	-20(%ebp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	leal	(%ebx,%esi), %edi
	movl	%ebx, -16(%ebp)         # 4-byte Spill
	sarl	%edi
	imull	$12, %edi, %eax
	movl	commands(%eax), %eax
	movl	%eax, 4(%esp)
	leal	-1(%edi), %ebx
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	js	.LBB144_26
# BB#28:                                # %if.else.i97
                                        #   in Loop: Header=BB144_26 Depth=1
	leal	1(%edi), %esi
	testl	%eax, %eax
	movl	-16(%ebp), %ebx         # 4-byte Reload
	jg	.LBB144_26
# BB#29:                                # %command_by_name.exit
	movl	$3, %eax
	cmpl	$-1, %edi
	je	.LBB144_31
# BB#30:                                # %if.end88
	movl	12(%ebp), %eax
	movl	%edi, (%eax)
	xorl	%eax, %eax
.LBB144_31:                             # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp144:
	.size	parse_line, .Ltmp144-parse_line

	.globl	cleanup
	.align	16, 0x90
	.type	cleanup,@function
cleanup:                                # @cleanup
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	output_stream, %eax
	testl	%eax, %eax
	je	.LBB145_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	fclose
.LBB145_2:                              # %if.end
	addl	$12, %esp
	ret
.Ltmp145:
	.size	cleanup, .Ltmp145-cleanup

	.align	16, 0x90
	.type	cmd_vector,@function
cmd_vector:                             # @cmd_vector
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	40(%esp), %esi
	movl	(%esi), %edi
	movl	36(%esp), %eax
	cmpb	$0, (%eax)
	je	.LBB146_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	sepstring
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	merge_vecs
	jmp	.LBB146_3
.LBB146_2:                              # %if.else
	movl	%edi, (%esp)
	calll	free_vec
	xorl	%eax, %eax
.LBB146_3:                              # %if.end
	movl	%eax, (%esi)
	movl	$1, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp146:
	.size	cmd_vector, .Ltmp146-cmd_vector

	.align	16, 0x90
	.type	cmd_boolean,@function
cmd_boolean:                            # @cmd_boolean
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %esi
	movzbl	(%esi), %eax
	movb	_sch_tolower(%eax), %cl
	movl	56(%esp), %eax
	movl	48(%esp), %edi
	cmpb	$111, %cl
	jne	.LBB147_3
# BB#1:                                 # %land.lhs.true
	movzbl	1(%esi), %edx
	cmpb	$110, _sch_tolower(%edx)
	jne	.LBB147_11
# BB#2:                                 # %land.lhs.true11
	movb	$1, %dl
	cmpb	$0, 2(%esi)
	je	.LBB147_21
.LBB147_3:                              # %lor.lhs.false
	cmpb	$49, %cl
	je	.LBB147_9
# BB#4:                                 # %lor.lhs.false
	cmpb	$121, %cl
	jne	.LBB147_10
# BB#5:                                 # %land.lhs.true23
	movzbl	1(%esi), %edx
	cmpb	$101, _sch_tolower(%edx)
	jne	.LBB147_10
# BB#6:                                 # %land.lhs.true31
	movzbl	2(%esi), %edx
	cmpb	$115, _sch_tolower(%edx)
	jne	.LBB147_8
# BB#7:                                 # %land.lhs.true39
	movb	$1, %dl
	cmpb	$0, 3(%esi)
	je	.LBB147_21
.LBB147_8:                              # %lor.lhs.false44
	cmpb	$49, %cl
	jne	.LBB147_10
.LBB147_9:                              # %land.lhs.true52
	movb	$1, %dl
	cmpb	$0, 1(%esi)
	je	.LBB147_21
.LBB147_10:                             # %if.else
	cmpb	$111, %cl
	jne	.LBB147_14
.LBB147_11:                             # %land.lhs.true64
	movzbl	1(%esi), %edx
	cmpb	$102, _sch_tolower(%edx)
	jne	.LBB147_20
# BB#12:                                # %land.lhs.true72
	movzbl	2(%esi), %edx
	cmpb	$102, _sch_tolower(%edx)
	jne	.LBB147_14
# BB#13:                                # %land.lhs.true80
	xorb	%dl, %dl
	cmpb	$0, 3(%esi)
	je	.LBB147_21
.LBB147_14:                             # %lor.lhs.false85
	cmpb	$48, %cl
	je	.LBB147_19
# BB#15:                                # %lor.lhs.false85
	cmpb	$110, %cl
	jne	.LBB147_20
# BB#16:                                # %land.lhs.true93
	movzbl	1(%esi), %edx
	cmpb	$111, _sch_tolower(%edx)
	jne	.LBB147_20
# BB#17:                                # %land.lhs.true101
	xorb	%dl, %dl
	cmpb	$0, 2(%esi)
	je	.LBB147_21
# BB#18:                                # %lor.lhs.false106
	cmpb	$48, %cl
	jne	.LBB147_20
.LBB147_19:                             # %land.lhs.true114
	xorb	%dl, %dl
	cmpb	$0, 1(%esi)
	je	.LBB147_21
.LBB147_20:                             # %if.else120
	movl	stderr, %ebx
	movl	$5, 8(%esp)
	movl	$.L.str131684, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%edi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	fprintf
	xorb	%al, %al
	jmp	.LBB147_22
.LBB147_21:                             # %if.end122
	movb	%dl, (%eax)
	movb	$1, %al
.LBB147_22:                             # %return
	movzbl	%al, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp147:
	.size	cmd_boolean, .Ltmp147-cmd_boolean

	.align	16, 0x90
	.type	cmd_number,@function
cmd_number:                             # @cmd_number
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %esi
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	addl	%esi, %edi
	movl	56(%esp), %ebp
	movl	%esi, %ebx
	xorb	%al, %al
	.align	16, 0x90
.LBB148_1:                              # %while.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, %edx
	cmpl	%edi, %edx
	jae	.LBB148_6
# BB#2:                                 # %land.rhs.i
                                        #   in Loop: Header=BB148_1 Depth=1
	leal	1(%edx), %ebx
	movzbl	(%edx), %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB148_1
# BB#3:                                 # %land.lhs.true.i
	cmpb	$43, %cl
	je	.LBB148_5
# BB#4:                                 # %land.lhs.true.i
	xorb	%al, %al
	cmpb	$45, %cl
	jne	.LBB148_6
.LBB148_5:                              # %if.then.i
	cmpb	$45, %cl
	sete	%al
	movl	%ebx, %edx
.LBB148_6:                              # %if.end.i
	cmpl	%edi, %edx
	je	.LBB148_16
# BB#7:                                 # %if.end18.i
	xorl	%ebx, %ebx
	testb	%al, %al
	je	.LBB148_8
	.align	16, 0x90
.LBB148_11:                             # %for.cond37.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%edi, %edx
	jae	.LBB148_14
# BB#12:                                # %land.rhs40.i
                                        #   in Loop: Header=BB148_11 Depth=1
	movsbl	(%edx), %eax
	movzbl	%al, %ecx
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB148_14
# BB#13:                                # %for.body48.i
                                        #   in Loop: Header=BB148_11 Depth=1
	imull	$10, %ebx, %ecx
	addl	$48, %ecx
	subl	%eax, %ecx
	incl	%edx
	cmpl	%ebx, %ecx
	movl	%ecx, %ebx
	jle	.LBB148_11
	jmp	.LBB148_16
	.align	16, 0x90
.LBB148_8:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%edi, %edx
	jae	.LBB148_14
# BB#9:                                 # %land.rhs23.i
                                        #   in Loop: Header=BB148_8 Depth=1
	movsbl	(%edx), %eax
	movzbl	%al, %ecx
	testb	$4, _sch_istable(%ecx,%ecx)
	je	.LBB148_14
# BB#10:                                # %for.body.i
                                        #   in Loop: Header=BB148_8 Depth=1
	imull	$10, %ebx, %ecx
	leal	-48(%ecx,%eax), %eax
	incl	%edx
	cmpl	%ebx, %eax
	movl	%eax, %ebx
	jge	.LBB148_8
	jmp	.LBB148_16
.LBB148_14:                             # %if.end61.i
	cmpl	%edi, %edx
	jne	.LBB148_16
# BB#15:                                # %lor.lhs.false
	movl	%ebx, (%ebp)
	movb	$1, %al
	testl	%ebx, %ebx
	jns	.LBB148_17
.LBB148_16:                             # %if.then
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str130683, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	48(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB148_17:                             # %return
	movzbl	%al, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp148:
	.size	cmd_number, .Ltmp148-cmd_number

	.align	16, 0x90
	.type	cmd_string,@function
cmd_string:                             # @cmd_string
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	24(%esp), %esi
	movl	(%esi), %eax
	movl	20(%esp), %edi
	testl	%eax, %eax
	je	.LBB149_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB149_2:                              # %if.end
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, (%esi)
	movl	$1, %eax
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp149:
	.size	cmd_string, .Ltmp149-cmd_string

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI150_0:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
.LCPI150_1:
	.quad	4693442404533927936     # double 6.048000e+05
                                        #  (0x0)
.LCPI150_2:
	.quad	4680673776000565248     # double 8.640000e+04
                                        #  (0x0)
.LCPI150_3:
	.quad	4660134898793709568     # double 3.600000e+03
                                        #  (0x0)
.LCPI150_4:
	.quad	4633641066610819072     # double 6.000000e+01
                                        #  (0x0)
	.text
	.align	16, 0x90
	.type	cmd_time,@function
cmd_time:                               # @cmd_time
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	68(%esp), %ebp
	movl	%ebp, (%esp)
	calll	strlen
	movl	72(%esp), %ebx
	movl	64(%esp), %edi
	.align	16, 0x90
.LBB150_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %edx
	leal	(%ebp,%edx), %ecx
	cmpl	%ebp, %ecx
	jbe	.LBB150_3
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB150_1 Depth=1
	movzbl	-1(%ebp,%edx), %esi
	leal	-1(%edx), %eax
	testb	$64, _sch_istable(%esi,%esi)
	jne	.LBB150_1
.LBB150_3:                              # %while.end
	testl	%edx, %edx
	je	.LBB150_4
# BB#6:                                 # %if.end
	leal	-1(%ebp,%edx), %eax
	movzbl	-1(%ebp,%edx), %edx
	movzbl	_sch_tolower(%edx), %edx
	cmpl	$103, %edx
	jg	.LBB150_9
# BB#7:                                 # %if.end
	cmpl	$100, %edx
	jne	.LBB150_18
# BB#8:                                 # %sw.bb18
	movsd	.LCPI150_2, %xmm0
	movl	%eax, %ecx
	jmp	.LBB150_19
.LBB150_4:
	movl	%ebp, %esi
	jmp	.LBB150_5
.LBB150_9:                              # %if.end
	cmpl	$108, %edx
	jg	.LBB150_12
# BB#10:                                # %if.end
	cmpl	$104, %edx
	jne	.LBB150_18
# BB#11:                                # %sw.bb16
	movsd	.LCPI150_3, %xmm0
	movl	%eax, %ecx
	jmp	.LBB150_19
.LBB150_12:                             # %if.end
	cmpl	$119, %edx
	jne	.LBB150_13
# BB#17:                                # %sw.bb20
	movsd	.LCPI150_1, %xmm0
	movl	%eax, %ecx
	jmp	.LBB150_19
.LBB150_13:                             # %if.end
	cmpl	$115, %edx
	je	.LBB150_14
# BB#15:                                # %if.end
	cmpl	$109, %edx
	jne	.LBB150_18
# BB#16:                                # %sw.bb14
	movsd	.LCPI150_4, %xmm0
	movl	%eax, %ecx
	jmp	.LBB150_19
.LBB150_18:                             # %sw.default
	movsd	.LCPI150_0, %xmm0
	.align	16, 0x90
.LBB150_19:                             # %while.cond22.preheader
	movsd	%xmm0, 24(%esp)         # 8-byte Spill
	.align	16, 0x90
.LBB150_20:                             # %while.cond22
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %esi
	cmpl	%ecx, %esi
	jae	.LBB150_22
# BB#21:                                # %land.rhs25
                                        #   in Loop: Header=BB150_20 Depth=1
	leal	1(%esi), %ebp
	movzbl	(%esi), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB150_20
	.align	16, 0x90
.LBB150_22:                             # %while.cond36
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, %edx
	cmpl	%edx, %esi
	jae	.LBB150_24
# BB#23:                                # %land.rhs39
                                        #   in Loop: Header=BB150_22 Depth=1
	leal	-1(%edx), %ecx
	movzbl	-1(%edx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB150_22
.LBB150_24:                             # %while.end50
	cmpl	%edx, %esi
	je	.LBB150_5
# BB#25:                                # %if.end54
	leal	32(%esp), %eax
	movl	%eax, (%esp)
	movl	%esi, %ecx
	calll	simple_atof
	cmpb	$1, %al
	movsd	24(%esp), %xmm0         # 8-byte Reload
	jne	.LBB150_5
# BB#26:                                # %if.end57
	mulsd	32(%esp), %xmm0
	movsd	%xmm0, (%ebx)
	movb	$1, %al
	jmp	.LBB150_27
.LBB150_5:                              # %err
	movl	stderr, %ebx
	movl	$5, 8(%esp)
	movl	$.L.str129682, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%edi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB150_27:                             # %return
	movzbl	%al, %eax
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB150_14:
	movsd	.LCPI150_0, %xmm0
	movl	%eax, %ecx
	jmp	.LBB150_19
.Ltmp150:
	.size	cmd_time, .Ltmp150-cmd_time

	.align	16, 0x90
	.type	cmd_directory,@function
cmd_directory:                          # @cmd_directory
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	40(%esp), %esi
	movl	%esi, 8(%esp)
	movl	36(%esp), %eax
	movl	%eax, 4(%esp)
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	cmd_file
	movl	(%esi), %esi
	movl	%esi, (%esp)
	calll	strlen
	addl	%esi, %eax
	jmp	.LBB151_1
	.align	16, 0x90
.LBB151_3:                              # %while.body
                                        #   in Loop: Header=BB151_1 Depth=1
	movb	$0, -1(%eax)
	decl	%eax
.LBB151_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%esi, %eax
	jbe	.LBB151_4
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB151_1 Depth=1
	cmpb	$47, -1(%eax)
	je	.LBB151_3
.LBB151_4:                              # %return
	movl	$1, %eax
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp151:
	.size	cmd_directory, .Ltmp151-cmd_directory

	.align	16, 0x90
	.type	cmd_spec_dirstruct,@function
cmd_spec_dirstruct:                     # @cmd_spec_dirstruct
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	movl	$opt+32, 8(%esp)
	calll	cmd_boolean
	testb	%al, %al
	je	.LBB152_1
# BB#2:                                 # %if.end
	movb	opt+32, %al
	xorb	$1, %al
	movb	%al, opt+33
	movb	$1, %al
	jmp	.LBB152_3
.LBB152_1:
	xorb	%al, %al
.LBB152_3:                              # %return
	movzbl	%al, %eax
	addl	$12, %esp
	ret
.Ltmp152:
	.size	cmd_spec_dirstruct, .Ltmp152-cmd_spec_dirstruct

	.align	16, 0x90
	.type	cmd_bytes,@function
cmd_bytes:                              # @cmd_bytes
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$48, %esp
	movl	68(%esp), %esi
	leal	40(%esp), %edx
	movl	%esi, %ecx
	calll	parse_bytes_helper
	testb	%al, %al
	je	.LBB153_1
# BB#2:                                 # %if.end
	movl	72(%esp), %eax
	movsd	40(%esp), %xmm0
	movsd	%xmm0, 32(%esp)
	fldl	32(%esp)
	fisttpll	24(%esp)
	movl	24(%esp), %ecx
	movl	28(%esp), %edx
	movl	%edx, 4(%eax)
	movl	%ecx, (%eax)
	movb	$1, %al
	jmp	.LBB153_3
.LBB153_1:                              # %if.then
	movl	64(%esp), %ebx
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str121674, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB153_3:                              # %return
	movzbl	%al, %eax
	addl	$48, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp153:
	.size	cmd_bytes, .Ltmp153-cmd_bytes

	.align	16, 0x90
	.type	cmd_directory_vector,@function
cmd_directory_vector:                   # @cmd_directory_vector
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	40(%esp), %edi
	movl	36(%esp), %eax
	cmpb	$0, (%eax)
	je	.LBB154_9
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	sepstring
	movl	%eax, %esi
	movl	%esi, %ebx
	jmp	.LBB154_2
	.align	16, 0x90
.LBB154_7:                              # %for.inc
                                        #   in Loop: Header=BB154_2 Depth=1
	addl	$4, %ebx
.LBB154_2:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	testl	%ebx, %ebx
	je	.LBB154_8
# BB#3:                                 # %land.rhs
                                        #   in Loop: Header=BB154_2 Depth=1
	movl	(%ebx), %ebp
	testl	%ebp, %ebp
	je	.LBB154_8
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB154_2 Depth=1
	movl	%ebp, (%esp)
	calll	strlen
	cmpl	$2, %eax
	jl	.LBB154_7
# BB#5:                                 # %if.then4
                                        #   in Loop: Header=BB154_2 Depth=1
	cmpb	$47, -1(%eax,%ebp)
	jne	.LBB154_7
# BB#6:                                 # %if.then7
                                        #   in Loop: Header=BB154_2 Depth=1
	movb	$0, -1(%ebp,%eax)
	jmp	.LBB154_7
.LBB154_8:                              # %for.end
	movl	(%edi), %eax
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	merge_vecs
	jmp	.LBB154_10
.LBB154_9:                              # %if.else
	movl	(%edi), %eax
	movl	%eax, (%esp)
	calll	free_vec
	xorl	%eax, %eax
.LBB154_10:                             # %if.end12
	movl	%eax, (%edi)
	movl	$1, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp154:
	.size	cmd_directory_vector, .Ltmp154-cmd_directory_vector

	.align	16, 0x90
	.type	cmd_spec_header,@function
cmd_spec_header:                        # @cmd_spec_header
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %esi
	movb	(%esi), %cl
	testb	%cl, %cl
	je	.LBB155_13
# BB#1:
	movl	$1, %eax
	movl	48(%esp), %edi
	jmp	.LBB155_2
.LBB155_13:                             # %if.then
	movl	opt+140, %eax
	movl	%eax, (%esp)
	calll	free_vec
	movl	$0, opt+140
	.align	16, 0x90
.LBB155_11:                             # %if.end5
	movb	$1, %al
	jmp	.LBB155_12
	.align	16, 0x90
.LBB155_5:                              # %land.rhs.i.for.cond.i_crit_edge
                                        #   in Loop: Header=BB155_2 Depth=1
	movb	(%esi,%eax), %cl
	incl	%eax
.LBB155_2:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	testb	%cl, %cl
	je	.LBB155_6
# BB#3:                                 # %for.cond.i
                                        #   in Loop: Header=BB155_2 Depth=1
	cmpb	$58, %cl
	je	.LBB155_6
# BB#4:                                 # %land.rhs.i
                                        #   in Loop: Header=BB155_2 Depth=1
	movzbl	%cl, %edx
	testb	$64, _sch_istable(%edx,%edx)
	je	.LBB155_5
.LBB155_6:                              # %for.end.i
	cmpb	$58, %cl
	jne	.LBB155_9
# BB#7:                                 # %for.end.i
	cmpl	$1, %eax
	je	.LBB155_9
# BB#8:                                 # %check_user_specified_header.exit
	movl	%esi, (%esp)
	movl	$10, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	je	.LBB155_10
.LBB155_9:                              # %if.then2
	movl	stderr, %ebx
	movl	$5, 8(%esp)
	movl	$.L.str128681, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%edi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB155_12:                             # %return
	movzbl	%al, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB155_10:                             # %if.end5
	movl	opt+140, %eax
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	vec_append
	movl	%eax, opt+140
	jmp	.LBB155_11
.Ltmp155:
	.size	cmd_spec_header, .Ltmp155-cmd_spec_header

	.align	16, 0x90
	.type	cmd_spec_htmlify,@function
cmd_spec_htmlify:                       # @cmd_spec_htmlify
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	movl	$opt+266, 8(%esp)
	calll	cmd_boolean
	testb	%al, %al
	je	.LBB156_3
# BB#1:                                 # %entry
	movb	opt+266, %cl
	testb	%cl, %cl
	jne	.LBB156_3
# BB#2:                                 # %if.then
	movb	$0, opt+265
.LBB156_3:                              # %if.end
	movzbl	%al, %eax
	addl	$12, %esp
	ret
.Ltmp156:
	.size	cmd_spec_htmlify, .Ltmp156-cmd_spec_htmlify

	.align	16, 0x90
	.type	cmd_file,@function
cmd_file:                               # @cmd_file
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	40(%esp), %edi
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB157_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB157_2:                              # %if.end
	movl	36(%esp), %ebx
	movb	enable_tilde_expansion.b, %al
	cmpb	$1, %al
	jne	.LBB157_5
# BB#3:                                 # %lor.lhs.false
	cmpb	$126, (%ebx)
	jne	.LBB157_5
# BB#4:                                 # %land.lhs.true
	cmpb	$47, 1(%ebx)
	jne	.LBB157_5
# BB#6:                                 # %if.else7
	movl	$.L.str554, (%esp)
	calll	getenv
	testl	%eax, %eax
	jne	.LBB157_9
# BB#7:                                 # %if.then.i
	calll	getuid
	movl	%eax, (%esp)
	calll	getpwuid
	testl	%eax, %eax
	je	.LBB157_5
# BB#8:                                 # %lor.lhs.false.i
	movl	20(%eax), %eax
	testl	%eax, %eax
	je	.LBB157_5
.LBB157_9:                              # %home_dir.exit
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB157_5
# BB#10:                                # %if.end11
	movl	%esi, (%esp)
	calll	strlen
	jmp	.LBB157_11
.LBB157_5:                              # %noexpand
	movl	%ebx, (%esp)
	calll	checking_strdup
	.align	16, 0x90
.LBB157_16:                             # %if.end24
	movl	%eax, (%edi)
	movl	$1, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
	.align	16, 0x90
.LBB157_13:                             # %while.body
                                        #   in Loop: Header=BB157_11 Depth=1
	movb	$0, -1(%esi,%eax)
	decl	%eax
.LBB157_11:                             # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	testl	%eax, %eax
	je	.LBB157_14
# BB#12:                                # %land.rhs
                                        #   in Loop: Header=BB157_11 Depth=1
	cmpb	$47, -1(%esi,%eax)
	je	.LBB157_13
	.align	16, 0x90
.LBB157_14:                             # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpb	$47, 1(%ebx)
	leal	1(%ebx), %ebx
	je	.LBB157_14
# BB#15:                                # %for.end
	movl	%ebx, 8(%esp)
	movl	%esi, (%esp)
	movl	$0, 12(%esp)
	movl	$.L.str127680, 4(%esp)
	calll	concat_strings
	jmp	.LBB157_16
.Ltmp157:
	.size	cmd_file, .Ltmp157-cmd_file

	.align	16, 0x90
	.type	cmd_spec_mirror,@function
cmd_spec_mirror:                        # @cmd_spec_mirror
# BB#0:                                 # %entry
	subl	$28, %esp
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	36(%esp), %eax
	movl	%eax, 4(%esp)
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	cmd_boolean
	xorb	%cl, %cl
	testb	%al, %al
	je	.LBB158_5
# BB#1:                                 # %if.end
	movb	$1, %cl
	cmpl	$0, 24(%esp)
	je	.LBB158_5
# BB#2:                                 # %if.then1
	movb	$1, opt+15
	cmpb	$0, opt+33
	jne	.LBB158_4
# BB#3:                                 # %if.then3
	movb	$1, opt+32
.LBB158_4:                              # %if.end4
	movb	$1, opt+251
	movl	$-1, opt+28
	movb	$0, opt+265
	movb	$1, %cl
.LBB158_5:                              # %return
	movzbl	%cl, %eax
	addl	$28, %esp
	ret
.Ltmp158:
	.size	cmd_spec_mirror, .Ltmp158-cmd_spec_mirror

	.align	16, 0x90
	.type	cmd_number_inf,@function
cmd_number_inf:                         # @cmd_number_inf
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	36(%esp), %esi
	movl	%esi, (%esp)
	movl	$.L.str122675, 4(%esp)
	calll	strcasecmp
	movl	40(%esp), %ecx
	testl	%eax, %eax
	je	.LBB159_1
# BB#2:                                 # %if.end
	movl	32(%esp), %eax
	movl	%ecx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	cmd_number
	jmp	.LBB159_3
.LBB159_1:                              # %if.then
	movl	$0, (%ecx)
	movb	$1, %al
.LBB159_3:                              # %return
	movzbl	%al, %eax
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp159:
	.size	cmd_number_inf, .Ltmp159-cmd_number_inf

	.align	16, 0x90
	.type	cmd_spec_prefer_family,@function
cmd_spec_prefer_family:                 # @cmd_spec_prefer_family
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	xorl	%ebp, %ebp
	movl	52(%esp), %edi
	movl	48(%esp), %esi
	.align	16, 0x90
.LBB160_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %ebx
	cmpl	$2, %ebx
	jg	.LBB160_4
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB160_1 Depth=1
	movl	cmd_spec_prefer_family.choices(,%ebx,8), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	leal	1(%ebx), %ebp
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB160_1
# BB#3:                                 # %decode_string.exit.thread
	movl	cmd_spec_prefer_family.choices+4(,%ebx,8), %eax
	movb	$1, %cl
	jmp	.LBB160_5
.LBB160_4:                              # %if.then
	movl	stderr, %ebx
	movl	$5, 8(%esp)
	movl	$.L.str114668, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%edi, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	fprintf
	xorl	%eax, %eax
	xorb	%cl, %cl
.LBB160_5:                              # %if.end
	movl	%eax, opt+336
	movzbl	%cl, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp160:
	.size	cmd_spec_prefer_family, .Ltmp160-cmd_spec_prefer_family

	.align	16, 0x90
	.type	cmd_spec_progress,@function
cmd_spec_progress:                      # @cmd_spec_progress
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %esi
	movl	%esi, (%esp)
	calll	valid_progress_implementation_p
	testb	%al, %al
	je	.LBB161_1
# BB#2:                                 # %if.end
	movl	opt+168, %eax
	testl	%eax, %eax
	je	.LBB161_4
# BB#3:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB161_4:                              # %if.end4
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, opt+168
	movb	$1, %al
	jmp	.LBB161_5
.LBB161_1:                              # %if.then
	movl	48(%esp), %ebx
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str123676, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB161_5:                              # %return
	movzbl	%al, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp161:
	.size	cmd_spec_progress, .Ltmp161-cmd_spec_progress

	.align	16, 0x90
	.type	cmd_bytes_sum,@function
cmd_bytes_sum:                          # @cmd_bytes_sum
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$48, %esp
	movl	68(%esp), %esi
	leal	40(%esp), %edx
	movl	%esi, %ecx
	calll	parse_bytes_helper
	testb	%al, %al
	je	.LBB162_1
# BB#2:                                 # %if.end
	movl	72(%esp), %eax
	movsd	40(%esp), %xmm0
	movsd	%xmm0, 32(%esp)
	fldl	32(%esp)
	fisttpll	24(%esp)
	movl	24(%esp), %ecx
	movl	28(%esp), %edx
	movl	%edx, 4(%eax)
	movl	%ecx, (%eax)
	movb	$1, %al
	jmp	.LBB162_3
.LBB162_1:                              # %if.then
	movl	64(%esp), %ebx
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str121674, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB162_3:                              # %return
	movzbl	%al, %eax
	addl	$48, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp162:
	.size	cmd_bytes_sum, .Ltmp162-cmd_bytes_sum

	.align	16, 0x90
	.type	cmd_spec_recursive,@function
cmd_spec_recursive:                     # @cmd_spec_recursive
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	movl	$opt+15, 8(%esp)
	calll	cmd_boolean
	xorb	%cl, %cl
	testb	%al, %al
	je	.LBB163_4
# BB#1:                                 # %if.else
	movb	$1, %cl
	cmpb	$0, opt+15
	je	.LBB163_4
# BB#2:                                 # %if.else
	movb	opt+33, %al
	testb	%al, %al
	jne	.LBB163_4
# BB#3:                                 # %if.then2
	movb	$1, opt+32
	movb	$1, %cl
.LBB163_4:                              # %return
	movzbl	%cl, %eax
	addl	$12, %esp
	ret
.Ltmp163:
	.size	cmd_spec_recursive, .Ltmp163-cmd_spec_recursive

	.align	16, 0x90
	.type	cmd_spec_restrict_file_names,@function
cmd_spec_restrict_file_names:           # @cmd_spec_restrict_file_names
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	opt+328, %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movzbl	opt+324, %edi
	movl	opt+320, %ebp
	movl	52(%esp), %ebx
	.align	16, 0x90
.LBB164_1:                              # %do.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, (%esp)
	movl	$44, 4(%esp)
	calll	strchr
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB164_3
# BB#2:                                 # %if.then
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, %esi
	addl	%ebx, %esi
.LBB164_3:                              # %if.end
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%esi, %eax
	subl	%ebx, %eax
	cmpl	$9, %eax
	jne	.LBB164_4
# BB#11:                                # %land.lhs.true22
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%ebx, (%esp)
	movl	$9, 8(%esp)
	movl	$.L.str117671, 4(%esp)
	calll	memcmp
	testl	%eax, %eax
	je	.LBB164_12
# BB#13:                                # %land.lhs.true32
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%ebx, (%esp)
	movl	$9, 8(%esp)
	movl	$.L.str118, 4(%esp)
	calll	memcmp
	testl	%eax, %eax
	je	.LBB164_14
# BB#15:                                # %land.lhs.true42
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%ebx, (%esp)
	movl	$9, 8(%esp)
	movl	$.L.str119672, 4(%esp)
	calll	memcmp
	xorl	%edi, %edi
	jmp	.LBB164_16
.LBB164_4:                              # %if.end
                                        #   in Loop: Header=BB164_1 Depth=1
	cmpl	$7, %eax
	jne	.LBB164_5
# BB#10:                                # %land.lhs.true12
                                        #   in Loop: Header=BB164_1 Depth=1
	movl	%ebx, (%esp)
	movl	$7, 8(%esp)
	movl	$.L.str116670, 4(%esp)
	calll	memcmp
	movl	$1, %ebp
.LBB164_16:                             # %land.lhs.true42
                                        #   in Loop: Header=BB164_1 Depth=1
	testl	%eax, %eax
	je	.LBB164_7
	jmp	.LBB164_17
.LBB164_12:                             #   in Loop: Header=BB164_1 Depth=1
	movl	$1, 24(%esp)            # 4-byte Folded Spill
	jmp	.LBB164_7
.LBB164_5:                              # %if.end
                                        #   in Loop: Header=BB164_1 Depth=1
	cmpl	$4, %eax
	jne	.LBB164_17
# BB#6:                                 # %land.lhs.true
                                        #   in Loop: Header=BB164_1 Depth=1
	xorl	%ebp, %ebp
	cmpl	$2020175477, (%ebx)     # imm = 0x78696E75
	jne	.LBB164_17
	jmp	.LBB164_7
.LBB164_14:                             #   in Loop: Header=BB164_1 Depth=1
	movl	$2, 24(%esp)            # 4-byte Folded Spill
.LBB164_7:                              # %if.end53
                                        #   in Loop: Header=BB164_1 Depth=1
	movb	(%esi), %al
	incl	%esi
	testb	%al, %al
	cmovnel	%esi, %ebx
	cmpb	$0, (%ebx)
	je	.LBB164_9
# BB#8:                                 # %if.end53
                                        #   in Loop: Header=BB164_1 Depth=1
	testb	%al, %al
	jne	.LBB164_1
.LBB164_9:                              # %do.end
	movl	%ebp, opt+320
	testl	%edi, %edi
	setne	opt+324
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, opt+328
	movb	$1, %al
	jmp	.LBB164_18
.LBB164_17:                             # %if.else46
	movl	stderr, %esi
	movl	$5, 8(%esp)
	movl	$.L.str120673, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%ebx, 16(%esp)
	movl	48(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	xorb	%al, %al
.LBB164_18:                             # %return
	movzbl	%al, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp164:
	.size	cmd_spec_restrict_file_names, .Ltmp164-cmd_spec_restrict_file_names

	.align	16, 0x90
	.type	cmd_spec_timeout,@function
cmd_spec_timeout:                       # @cmd_spec_timeout
# BB#0:                                 # %entry
	subl	$28, %esp
	leal	16(%esp), %eax
	movl	%eax, 8(%esp)
	movl	36(%esp), %eax
	movl	%eax, 4(%esp)
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	cmd_time
	testb	%al, %al
	je	.LBB165_1
# BB#2:                                 # %if.end
	movsd	16(%esp), %xmm0
	movsd	%xmm0, opt+180
	movsd	%xmm0, opt+196
	movsd	%xmm0, opt+188
	movb	$1, %al
	jmp	.LBB165_3
.LBB165_1:
	xorb	%al, %al
.LBB165_3:                              # %return
	movzbl	%al, %eax
	addl	$28, %esp
	ret
.Ltmp165:
	.size	cmd_spec_timeout, .Ltmp165-cmd_spec_timeout

	.align	16, 0x90
	.type	cmd_spec_useragent,@function
cmd_spec_useragent:                     # @cmd_spec_useragent
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	52(%esp), %esi
	movl	%esi, (%esp)
	movl	$10, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	je	.LBB166_2
# BB#1:                                 # %if.then
	movl	48(%esp), %ebx
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str114668, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%esi, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	xorb	%al, %al
	jmp	.LBB166_5
.LBB166_2:                              # %if.end
	movl	opt+256, %eax
	testl	%eax, %eax
	je	.LBB166_4
# BB#3:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB166_4:                              # %if.end7
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, opt+256
	movb	$1, %al
.LBB166_5:                              # %return
	movzbl	%al, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp166:
	.size	cmd_spec_useragent, .Ltmp166-cmd_spec_useragent

	.align	16, 0x90
	.type	cmd_spec_verbose,@function
cmd_spec_verbose:                       # @cmd_spec_verbose
# BB#0:                                 # %entry
	subl	$28, %esp
	leal	27(%esp), %eax
	movl	%eax, 8(%esp)
	movl	36(%esp), %eax
	movl	%eax, 4(%esp)
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	cmd_boolean
	testb	%al, %al
	je	.LBB167_1
# BB#2:                                 # %if.then
	movzbl	27(%esp), %eax
	movl	%eax, opt
	movb	$1, %al
	jmp	.LBB167_3
.LBB167_1:
	xorb	%al, %al
.LBB167_3:                              # %return
	movzbl	%al, %eax
	addl	$28, %esp
	ret
.Ltmp167:
	.size	cmd_spec_verbose, .Ltmp167-cmd_spec_verbose

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI168_0:
	.quad	4652218415073722368     # double 1.024000e+03
                                        #  (0x0)
.LCPI168_1:
	.quad	4787326403894837248     # double 1.099512e+12
                                        #  (0x0)
.LCPI168_2:
	.quad	4742290407621132288     # double 1.073742e+09
                                        #  (0x0)
.LCPI168_3:
	.quad	4697254411347427328     # double 1.048576e+06
                                        #  (0x0)
.LCPI168_4:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
	.text
	.align	16, 0x90
	.type	parse_bytes_helper,@function
parse_bytes_helper:                     # @parse_bytes_helper
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	%edx, %esi
	movl	%ecx, %edi
	movl	%edi, (%esp)
	calll	strlen
	cmpb	$105, (%edi)
	jne	.LBB168_5
# BB#1:                                 # %if.then
	cmpb	$110, 1(%edi)
	jne	.LBB168_5
# BB#2:                                 # %if.then16
	cmpb	$102, 2(%edi)
	jne	.LBB168_5
# BB#3:                                 # %cond.end
	cmpb	$0, 3(%edi)
	je	.LBB168_4
	.align	16, 0x90
.LBB168_5:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	leal	(%edi,%ecx), %ebx
	cmpl	%edi, %ebx
	jbe	.LBB168_7
# BB#6:                                 # %land.rhs
                                        #   in Loop: Header=BB168_5 Depth=1
	movzbl	-1(%edi,%ecx), %edx
	leal	-1(%ecx), %eax
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB168_5
.LBB168_7:                              # %while.end
	xorb	%ah, %ah
	testl	%ecx, %ecx
	je	.LBB168_28
# BB#8:                                 # %if.end48
	leal	-1(%edi,%ecx), %eax
	movzbl	-1(%edi,%ecx), %ecx
	movzbl	_sch_tolower(%ecx), %ecx
	cmpl	$115, %ecx
	jg	.LBB168_15
# BB#9:                                 # %if.end48
	cmpl	$103, %ecx
	jne	.LBB168_10
# BB#14:                                # %sw.bb57
	movsd	.LCPI168_2, %xmm0
	movl	%eax, %ebx
	jmp	.LBB168_18
.LBB168_15:                             # %if.end48
	cmpl	$116, %ecx
	jne	.LBB168_17
# BB#16:                                # %sw.bb59
	movsd	.LCPI168_1, %xmm0
	movl	%eax, %ebx
	jmp	.LBB168_18
.LBB168_10:                             # %if.end48
	cmpl	$107, %ecx
	je	.LBB168_11
# BB#12:                                # %if.end48
	cmpl	$109, %ecx
	jne	.LBB168_17
# BB#13:                                # %sw.bb55
	movsd	.LCPI168_3, %xmm0
	movl	%eax, %ebx
	jmp	.LBB168_18
.LBB168_17:                             # %sw.default
	movsd	.LCPI168_4, %xmm0
	jmp	.LBB168_18
.LBB168_11:
	movsd	.LCPI168_0, %xmm0
	movl	%eax, %ebx
.LBB168_18:                             # %while.cond61.preheader
	movsd	%xmm0, 16(%esp)         # 8-byte Spill
	.align	16, 0x90
.LBB168_19:                             # %while.cond61
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ecx
	cmpl	%ebx, %ecx
	jae	.LBB168_21
# BB#20:                                # %land.rhs64
                                        #   in Loop: Header=BB168_19 Depth=1
	leal	1(%ecx), %edi
	movzbl	(%ecx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB168_19
	.align	16, 0x90
.LBB168_21:                             # %while.cond75
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, %edx
	cmpl	%edx, %ecx
	jae	.LBB168_23
# BB#22:                                # %land.rhs78
                                        #   in Loop: Header=BB168_21 Depth=1
	leal	-1(%edx), %ebx
	movzbl	-1(%edx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB168_21
.LBB168_23:                             # %while.end89
	xorb	%ah, %ah
	cmpl	%edx, %ecx
	je	.LBB168_28
# BB#24:                                # %if.end93
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	simple_atof
	xorb	%ah, %ah
	movsd	24(%esp), %xmm0
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm0, %xmm1
	ja	.LBB168_28
# BB#25:                                # %if.end93
	xorb	$1, %al
	testb	%al, %al
	jne	.LBB168_28
# BB#26:                                # %if.end98
	mulsd	16(%esp), %xmm0         # 8-byte Folded Reload
	movsd	%xmm0, (%esi)
	jmp	.LBB168_27
.LBB168_4:                              # %if.then36
	movl	$0, 4(%esi)
	movl	$0, (%esi)
.LBB168_27:                             # %if.end98
	movb	$1, %ah
.LBB168_28:                             # %return
	movzbl	%ah, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp168:
	.size	parse_bytes_helper, .Ltmp168-parse_bytes_helper

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI169_0:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
.LCPI169_2:
	.quad	4621819117588971520     # double 1.000000e+01
                                        #  (0x0)
	.section	.rodata.cst16,"aM",@progbits,16
	.align	16
.LCPI169_1:
	.quad	-9223372036854775808    # double -0.000000e+00
	.quad	-9223372036854775808    # double -0.000000e+00
	.text
	.align	16, 0x90
	.type	simple_atof,@function
simple_atof:                            # @simple_atof
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	movl	20(%esp), %edi
	xorb	%bl, %bl
	.align	16, 0x90
.LBB169_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, %esi
	cmpl	%edx, %esi
	jae	.LBB169_2
# BB#3:                                 # %land.rhs
                                        #   in Loop: Header=BB169_1 Depth=1
	leal	1(%esi), %ecx
	movzbl	(%esi), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB169_1
# BB#4:                                 # %land.lhs.true
	cmpb	$43, %al
	je	.LBB169_6
# BB#5:                                 # %land.lhs.true
	xorb	%bh, %bh
	cmpb	$45, %al
	jne	.LBB169_7
.LBB169_6:                              # %if.then
	cmpb	$45, %al
	sete	%bh
	movl	%ecx, %esi
	jmp	.LBB169_7
.LBB169_2:
	xorb	%bh, %bh
.LBB169_7:                              # %for.cond.preheader
	movsd	.LCPI169_0, %xmm1
	xorpd	%xmm0, %xmm0
	movsd	.LCPI169_2, %xmm2
	xorb	%cl, %cl
	jmp	.LBB169_8
	.align	16, 0x90
.LBB169_12:                             # %if.then25
                                        #   in Loop: Header=BB169_8 Depth=1
	addsd	%xmm3, %xmm0
	movb	$1, %cl
	incl	%esi
	.align	16, 0x90
.LBB169_8:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%edx, %esi
	jae	.LBB169_17
# BB#9:                                 # %for.body
                                        #   in Loop: Header=BB169_8 Depth=1
	movsbl	(%esi), %eax
	movzbl	%al, %ebp
	testb	$4, _sch_istable(%ebp,%ebp)
	jne	.LBB169_10
# BB#14:                                # %if.else34
                                        #   in Loop: Header=BB169_8 Depth=1
	xorb	%ch, %ch
	cmpb	$46, %al
	jne	.LBB169_21
# BB#15:                                # %if.then38
                                        #   in Loop: Header=BB169_8 Depth=1
	xorb	%ch, %ch
	testb	$1, %bl
	movb	$1, %bl
	jne	.LBB169_21
# BB#16:                                # %for.inc
                                        #   in Loop: Header=BB169_8 Depth=1
	incl	%esi
	jmp	.LBB169_8
.LBB169_10:                             # %if.then23
                                        #   in Loop: Header=BB169_8 Depth=1
	testb	$1, %bl
	jne	.LBB169_13
# BB#11:                                # %if.then25
                                        #   in Loop: Header=BB169_8 Depth=1
	mulsd	%xmm2, %xmm0
	addl	$-48, %eax
	cvtsi2sd	%eax, %xmm3
	jmp	.LBB169_12
.LBB169_13:                             # %if.else
                                        #   in Loop: Header=BB169_8 Depth=1
	mulsd	%xmm2, %xmm1
	addl	$-48, %eax
	cvtsi2sd	%eax, %xmm3
	divsd	%xmm1, %xmm3
	jmp	.LBB169_12
.LBB169_17:                             # %for.end
	xorb	%ch, %ch
	testb	$1, %cl
	je	.LBB169_21
# BB#18:                                # %if.end49
	testb	%bh, %bh
	je	.LBB169_20
# BB#19:                                # %if.then51
	xorpd	.LCPI169_1, %xmm0
.LBB169_20:                             # %if.end53
	movsd	%xmm0, (%edi)
	movb	$1, %ch
.LBB169_21:                             # %return
	movzbl	%ch, %eax
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp169:
	.size	simple_atof, .Ltmp169-simple_atof

	.globl	logputs
	.align	16, 0x90
	.type	logputs,@function
logputs:                                # @logputs
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	calll	check_redirect_output
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB170_17
# BB#1:                                 # %get_log_fp.exit
	movl	logfp, %eax
	testl	%eax, %eax
	cmovel	stderr, %eax
	testl	%eax, %eax
	je	.LBB170_17
# BB#2:                                 # %if.end
	movl	20(%esp), %esi
	movl	16(%esp), %ecx
	testl	%ecx, %ecx
	jne	.LBB170_3
# BB#8:                                 # %sw.bb8
	cmpl	$0, opt
	je	.LBB170_17
	jmp	.LBB170_9
.LBB170_3:                              # %if.end
	cmpl	$2, %ecx
	jne	.LBB170_4
# BB#6:                                 # %sw.bb3
	cmpl	$0, opt
	jne	.LBB170_17
# BB#7:                                 # %sw.bb3
	movb	opt+4, %cl
	testb	%cl, %cl
	je	.LBB170_9
	jmp	.LBB170_17
.LBB170_4:                              # %if.end
	cmpl	$1, %ecx
	jne	.LBB170_9
# BB#5:                                 # %sw.bb
	cmpb	$0, opt+4
	jne	.LBB170_17
.LBB170_9:                              # %sw.epilog
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fputs
	cmpb	$0, save_context_p
	je	.LBB170_11
# BB#10:                                # %if.then14
	movl	%esi, %ecx
	calll	saved_append
.LBB170_11:                             # %if.end15
	movb	flush_log_p.b, %al
	testb	%al, %al
	je	.LBB170_12
# BB#16:                                # %if.else
	movb	$1, needs_flushing.b
	jmp	.LBB170_17
.LBB170_12:                             # %if.then17
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB170_15
# BB#13:                                # %get_log_fp.exit.i
	movl	logfp, %eax
	testl	%eax, %eax
	cmovel	stderr, %eax
	testl	%eax, %eax
	je	.LBB170_15
# BB#14:                                # %if.then.i
	movl	%eax, (%esp)
	calll	fflush
.LBB170_15:                             # %logflush.exit
	movb	$0, needs_flushing.b
.LBB170_17:                             # %if.end18
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp170:
	.size	logputs, .Ltmp170-logputs

	.align	16, 0x90
	.type	check_redirect_output,@function
check_redirect_output:                  # @check_redirect_output
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	cmpl	$1, redirect_request
	jne	.LBB171_17
# BB#1:                                 # %if.then
	movl	$2, redirect_request
	leal	28(%esp), %eax
	movl	%eax, 8(%esp)
	movl	$0, 4(%esp)
	movl	$.L.str3699, (%esp)
	calll	unique_create
	movl	%eax, logfp
	movl	stderr, %esi
	testl	%eax, %eax
	je	.LBB171_15
# BB#2:                                 # %if.then.i
	movl	$5, 8(%esp)
	movl	$.L.str4700, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	redirect_request_signal_name, %ecx
	movl	28(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	28(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB171_16
# BB#3:                                 # %get_log_fp.exit.i.i
	movl	logfp, %esi
	testl	%esi, %esi
	cmovel	stderr, %esi
	testl	%esi, %esi
	je	.LBB171_16
# BB#4:                                 # %get_log_fp.exit.i.i
	movl	log_line_current, %eax
	cmpl	$-1, %eax
	je	.LBB171_16
# BB#5:                                 # %if.end2.i.i
	cmpb	$0, trailing_line
	je	.LBB171_6
# BB#7:                                 # %do.body.i.i
	leal	1(%eax), %ecx
	cmpl	$23, %ecx
	movl	$0, %edi
	cmovlel	%ecx, %edi
	jmp	.LBB171_8
.LBB171_15:                             # %if.else.i
	movl	$5, 8(%esp)
	movl	$.L.str5701, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	redirect_request_signal_name, %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str6702, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	28(%esp), %ebx
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	movb	$1, inhibit_logging.b
	jmp	.LBB171_16
.LBB171_6:
	movl	%eax, %edi
	.align	16, 0x90
.LBB171_8:                              # %do.body9.i.i
                                        # =>This Inner Loop Header: Depth=1
	imull	$140, %edi, %ecx
	movl	log_lines+136(%ecx), %ecx
	testl	%ecx, %ecx
	je	.LBB171_10
# BB#9:                                 # %if.then11.i.i
                                        #   in Loop: Header=BB171_8 Depth=1
	movl	%esi, 4(%esp)
	movl	%ecx, (%esp)
	calll	fputs
	movl	log_line_current, %eax
.LBB171_10:                             # %do.body15.i.i
                                        #   in Loop: Header=BB171_8 Depth=1
	incl	%edi
	cmpl	$23, %edi
	movl	$0, %ecx
	cmovgl	%ecx, %edi
	cmpl	%eax, %edi
	jne	.LBB171_8
# BB#11:                                # %do.end22.i.i
	cmpb	$0, trailing_line
	je	.LBB171_14
# BB#12:                                # %if.then24.i.i
	imull	$140, %eax, %eax
	movl	log_lines+136(%eax), %eax
	testl	%eax, %eax
	je	.LBB171_14
# BB#13:                                # %if.then27.i.i
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
.LBB171_14:                             # %if.end32.i.i
	movl	%esi, (%esp)
	calll	fflush
.LBB171_16:                             # %redirect_output.exit
	movb	$0, save_context_p
.LBB171_17:                             # %if.end
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp171:
	.size	check_redirect_output, .Ltmp171-check_redirect_output

	.align	16, 0x90
	.type	saved_append,@function
saved_append:                           # @saved_append
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	%ecx, %eax
	jmp	.LBB172_1
	.align	16, 0x90
.LBB172_23:                             # %if.then75.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	$0, log_line_current
	.align	16, 0x90
.LBB172_1:                              # %entry
                                        # =>This Inner Loop Header: Depth=1
	cmpb	$0, (%eax)
	je	.LBB172_24
# BB#2:                                 # %while.body
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%eax, %esi
	movl	%esi, (%esp)
	movl	$10, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	jne	.LBB172_4
# BB#3:                                 # %if.then
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%esi, (%esp)
	calll	strlen
	addl	%esi, %eax
	jmp	.LBB172_5
.LBB172_4:                              # %if.else
                                        #   in Loop: Header=BB172_1 Depth=1
	incl	%eax
.LBB172_5:                              # %if.end
                                        #   in Loop: Header=BB172_1 Depth=1
	cmpl	%esi, %eax
	je	.LBB172_1
# BB#6:                                 # %if.end.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%eax, %ebp
	movl	%eax, 32(%esp)          # 4-byte Spill
	subl	%esi, %ebp
	movl	log_line_current, %eax
	cmpb	$0, trailing_line
	jne	.LBB172_15
# BB#7:                                 # %if.then2.i
                                        #   in Loop: Header=BB172_1 Depth=1
	cmpl	$-1, %eax
	jne	.LBB172_9
# BB#8:                                 # %if.then3.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	$0, log_line_current
	xorl	%eax, %eax
	jmp	.LBB172_12
.LBB172_15:                             # %if.else14.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%esi, 40(%esp)          # 4-byte Spill
	imull	$140, %eax, %eax
	movl	%eax, 28(%esp)          # 4-byte Spill
	leal	log_lines+132(%eax), %ebx
	movl	log_lines+132(%eax), %esi
	testl	%esi, %esi
	jne	.LBB172_16
# BB#17:                                # %if.else33.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	28(%esp), %esi          # 4-byte Reload
	leal	log_lines(%esi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	strlen
	movl	%eax, %edi
	leal	(%edi,%ebp), %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	cmpl	$129, %eax
	jl	.LBB172_19
# BB#18:                                # %if.then40.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	36(%esp), %eax          # 4-byte Reload
	leal	1(%eax), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, (%ebx)
	movl	%edi, 8(%esp)
	movl	24(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	memcpy
	movl	(%ebx), %eax
	movl	%ebp, 8(%esp)
	movl	40(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	addl	%edi, %eax
	movl	%eax, (%esp)
	calll	memcpy
	movl	(%ebx), %eax
	movl	36(%esp), %ecx          # 4-byte Reload
	movb	$0, (%eax,%ecx)
	movl	(%ebx), %eax
	jmp	.LBB172_20
.LBB172_9:                              # %if.else.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%esi, %ebx
	imull	$140, %eax, %esi
	movl	log_lines+132(%esi), %ecx
	testl	%ecx, %ecx
	je	.LBB172_11
# BB#10:                                # %if.then.i.i
                                        #   in Loop: Header=BB172_1 Depth=1
	leal	log_lines+132(%esi), %edi
	movl	%ecx, (%esp)
	calll	checking_free
	movl	$0, (%edi)
	movl	log_line_current, %eax
.LBB172_11:                             # %free_log_line.exit.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	$0, log_lines+136(%esi)
	movl	%ebx, %esi
.LBB172_12:                             # %if.end4.i
                                        #   in Loop: Header=BB172_1 Depth=1
	cmpl	$129, %ebp
	jl	.LBB172_14
# BB#13:                                # %if.then6.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	32(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	imull	$140, %eax, %esi
	calll	strdupdelim
	movl	%eax, log_lines+132(%esi)
	jmp	.LBB172_20
.LBB172_16:                             # %if.then19.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	leal	1(%edi,%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	checking_realloc
	movl	%eax, (%ebx)
	movl	%ebp, 8(%esp)
	movl	40(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	addl	%edi, %eax
	movl	%eax, (%esp)
	addl	%ebp, %edi
	calll	memcpy
	movl	(%ebx), %eax
	movb	$0, (%eax,%edi)
	movl	(%ebx), %eax
	movl	28(%esp), %ecx          # 4-byte Reload
	movl	%eax, log_lines+136(%ecx)
	jmp	.LBB172_21
.LBB172_14:                             # %if.else8.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%ebp, 8(%esp)
	movl	%esi, 4(%esp)
	imull	$140, %eax, %esi
	leal	log_lines(%esi), %edi
	movl	%edi, (%esp)
	calll	memcpy
	movb	$0, log_lines(%esi,%ebp)
	movl	%edi, log_lines+136(%esi)
	jmp	.LBB172_21
.LBB172_19:                             # %if.else55.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%ebp, 8(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	leal	log_lines(%esi,%edi), %eax
	movl	%eax, (%esp)
	calll	memcpy
	movl	36(%esp), %eax          # 4-byte Reload
	movb	$0, log_lines(%esi,%eax)
	movl	24(%esp), %eax          # 4-byte Reload
.LBB172_20:                             # %if.else55.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%eax, log_lines+136(%esi)
.LBB172_21:                             # %if.end67.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	32(%esp), %eax          # 4-byte Reload
	cmpb	$10, -1(%eax)
	setne	trailing_line
	jne	.LBB172_1
# BB#22:                                # %do.body.i
                                        #   in Loop: Header=BB172_1 Depth=1
	movl	%eax, %ecx
	movl	log_line_current, %eax
	incl	%eax
	movl	%eax, log_line_current
	cmpl	$24, %eax
	movl	%ecx, %eax
	jl	.LBB172_1
	jmp	.LBB172_23
.LBB172_24:                             # %while.end
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp172:
	.size	saved_append, .Ltmp172-saved_append

	.globl	logflush
	.align	16, 0x90
	.type	logflush,@function
logflush:                               # @logflush
# BB#0:                                 # %entry
	subl	$12, %esp
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB173_3
# BB#1:                                 # %get_log_fp.exit
	movl	logfp, %eax
	testl	%eax, %eax
	cmovel	stderr, %eax
	testl	%eax, %eax
	je	.LBB173_3
# BB#2:                                 # %if.then
	movl	%eax, (%esp)
	calll	fflush
.LBB173_3:                              # %if.end
	movb	$0, needs_flushing.b
	addl	$12, %esp
	ret
.Ltmp173:
	.size	logflush, .Ltmp173-logflush

	.globl	log_set_flush
	.align	16, 0x90
	.type	log_set_flush,@function
log_set_flush:                          # @log_set_flush
# BB#0:                                 # %entry
	subl	$12, %esp
	movzbl	flush_log_p.b, %ecx
	xorl	$1, %ecx
	movb	16(%esp), %al
	movzbl	%al, %edx
	cmpl	%ecx, %edx
	je	.LBB174_9
# BB#1:                                 # %if.end
	testb	%al, %al
	je	.LBB174_2
# BB#3:                                 # %if.else
	movb	needs_flushing.b, %al
	cmpb	$1, %al
	jne	.LBB174_8
# BB#4:                                 # %if.then10
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB174_7
# BB#5:                                 # %get_log_fp.exit.i
	movl	logfp, %eax
	testl	%eax, %eax
	cmovel	stderr, %eax
	testl	%eax, %eax
	je	.LBB174_7
# BB#6:                                 # %if.then.i
	movl	%eax, (%esp)
	calll	fflush
.LBB174_7:                              # %logflush.exit
	movb	$0, needs_flushing.b
.LBB174_8:                              # %if.end11
	movb	$0, flush_log_p.b
.LBB174_9:                              # %if.end12
	addl	$12, %esp
	ret
.LBB174_2:                              # %if.then8
	movb	$1, flush_log_p.b
	addl	$12, %esp
	ret
.Ltmp174:
	.size	log_set_flush, .Ltmp174-log_set_flush

	.globl	log_set_save_context
	.align	16, 0x90
	.type	log_set_save_context,@function
log_set_save_context:                   # @log_set_save_context
# BB#0:                                 # %entry
	movzbl	save_context_p, %eax
	movb	4(%esp), %cl
	movb	%cl, save_context_p
	ret
.Ltmp175:
	.size	log_set_save_context, .Ltmp175-log_set_save_context

	.globl	logprintf
	.align	16, 0x90
	.type	logprintf,@function
logprintf:                              # @logprintf
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	calll	check_redirect_output
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB176_10
# BB#1:                                 # %if.end
	movl	52(%esp), %esi
	movl	48(%esp), %eax
	testl	%eax, %eax
	jne	.LBB176_2
# BB#7:                                 # %sw.bb9
	cmpl	$0, opt
	je	.LBB176_10
	jmp	.LBB176_8
.LBB176_2:                              # %if.end
	cmpl	$2, %eax
	jne	.LBB176_3
# BB#5:                                 # %sw.bb4
	cmpl	$0, opt
	jne	.LBB176_10
# BB#6:                                 # %sw.bb4
	movb	opt+4, %al
	testb	%al, %al
	je	.LBB176_8
	jmp	.LBB176_10
.LBB176_3:                              # %if.end
	cmpl	$1, %eax
	jne	.LBB176_8
# BB#4:                                 # %sw.bb
	cmpb	$0, opt+4
	jne	.LBB176_10
.LBB176_8:                              # %sw.epilog
	movl	$0, 20(%esp)
	movl	$0, 16(%esp)
	movl	$0, 24(%esp)
	leal	56(%esp), %ebx
	leal	16(%esp), %edi
	.align	16, 0x90
.LBB176_9:                              # %do.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, 28(%esp)
	movl	%ebx, (%esp)
	movl	%edi, %ecx
	movl	%esi, %edx
	calll	log_vprintf_internal
	testb	%al, %al
	je	.LBB176_9
.LBB176_10:                             # %do.end
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp176:
	.size	logprintf, .Ltmp176-logprintf

	.align	16, 0x90
	.type	log_vprintf_internal,@function
log_vprintf_internal:                   # @log_vprintf_internal
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$156, %esp
	movl	%ecx, %esi
	xorl	%ecx, %ecx
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB177_2
# BB#1:                                 # %if.end.i
	movl	logfp, %ecx
	testl	%ecx, %ecx
	cmovel	stderr, %ecx
.LBB177_2:                              # %get_log_fp.exit
	movl	176(%esp), %eax
	cmpb	$0, save_context_p
	je	.LBB177_3
# BB#4:                                 # %if.end
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	8(%esi), %ebp
	testl	%ebp, %ebp
	je	.LBB177_5
# BB#6:                                 # %if.then2
	movl	(%esi), %edi
	jmp	.LBB177_7
.LBB177_3:                              # %if.then
	movl	%eax, 8(%esp)
	movl	%edx, 4(%esp)
	movl	%ecx, (%esp)
	calll	vfprintf
	jmp	.LBB177_13
.LBB177_5:
	movl	$128, %ebp
	leal	28(%esp), %edi
.LBB177_7:                              # %if.end4
	movl	%eax, 12(%esp)
	movl	%edx, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	calll	vsnprintf
	movl	%eax, %ebx
	cmpl	$-1, %ebx
	jne	.LBB177_9
# BB#8:                                 # %if.then7
	movl	(%esi), %eax
	addl	%ebp, %ebp
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, (%esi)
	movl	%ebp, 8(%esi)
	xorb	%al, %al
	jmp	.LBB177_20
.LBB177_9:                              # %if.else
	cmpl	%ebp, %ebx
	jge	.LBB177_10
# BB#11:                                # %if.end20
	movl	%edi, %ecx
	calll	saved_append
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fputs
	movl	(%esi), %eax
	testl	%eax, %eax
	je	.LBB177_13
# BB#12:                                # %if.then24
	movl	%eax, (%esp)
	calll	checking_free
.LBB177_13:                             # %flush
	movb	flush_log_p.b, %al
	testb	%al, %al
	je	.LBB177_14
# BB#18:                                # %if.else29
	movb	$1, needs_flushing.b
	jmp	.LBB177_19
.LBB177_14:                             # %if.then28
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB177_17
# BB#15:                                # %get_log_fp.exit.i
	movl	logfp, %eax
	testl	%eax, %eax
	cmovel	stderr, %eax
	testl	%eax, %eax
	je	.LBB177_17
# BB#16:                                # %if.then.i
	movl	%eax, (%esp)
	calll	fflush
.LBB177_17:                             # %logflush.exit
	movb	$0, needs_flushing.b
.LBB177_19:                             # %if.else29
	movb	$1, %al
	jmp	.LBB177_20
.LBB177_10:                             # %if.then13
	movl	(%esi), %eax
	incl	%ebx
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, (%esi)
	movl	%ebx, 8(%esi)
	xorb	%al, %al
.LBB177_20:                             # %return
	movzbl	%al, %eax
	addl	$156, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp177:
	.size	log_vprintf_internal, .Ltmp177-log_vprintf_internal

	.globl	debug_logprintf
	.align	16, 0x90
	.type	debug_logprintf,@function
debug_logprintf:                        # @debug_logprintf
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	cmpb	$0, opt+250
	je	.LBB178_4
# BB#1:                                 # %if.then
	calll	check_redirect_output
	movb	inhibit_logging.b, %al
	testb	%al, %al
	jne	.LBB178_4
# BB#2:                                 # %if.end
	movl	48(%esp), %esi
	movl	$0, 20(%esp)
	movl	$0, 16(%esp)
	movl	$0, 24(%esp)
	leal	52(%esp), %ebx
	leal	16(%esp), %edi
	.align	16, 0x90
.LBB178_3:                              # %do.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, 28(%esp)
	movl	%ebx, (%esp)
	movl	%edi, %ecx
	movl	%esi, %edx
	calll	log_vprintf_internal
	testb	%al, %al
	je	.LBB178_3
.LBB178_4:                              # %if.end6
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp178:
	.size	debug_logprintf, .Ltmp178-debug_logprintf

	.globl	log_init
	.align	16, 0x90
	.type	log_init,@function
log_init:                               # @log_init
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	48(%esp), %esi
	testl	%esi, %esi
	je	.LBB179_3
# BB#1:                                 # %if.then
	movb	52(%esp), %al
	movl	%esi, (%esp)
	movl	$.L.str696, %ecx
	testb	%al, %al
	movl	$.L.str1697, %eax
	cmovnel	%ecx, %eax
	movl	%eax, 4(%esp)
	calll	fopen64
	movl	%eax, logfp
	testl	%eax, %eax
	jne	.LBB179_5
# BB#2:                                 # %if.then3
	movl	stderr, %edi
	movl	exec_name, %ebx
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, (%esp)
	movl	$.L.str2698, 4(%esp)
	calll	fprintf
	movl	$1, (%esp)
	calll	exit
.LBB179_3:                              # %if.else
	movl	stderr, %eax
	movl	%eax, logfp
	movl	%eax, (%esp)
	calll	fileno
	movl	%eax, (%esp)
	calll	isatty
	testl	%eax, %eax
	je	.LBB179_5
# BB#4:                                 # %if.then10
	movb	$1, save_context_p
.LBB179_5:                              # %if.end12
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp179:
	.size	log_init, .Ltmp179-log_init

	.globl	log_close
	.align	16, 0x90
	.type	log_close,@function
log_close:                              # @log_close
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	logfp, %eax
	testl	%eax, %eax
	je	.LBB180_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	fclose
.LBB180_2:                              # %if.end
	movl	$0, logfp
	movb	$1, inhibit_logging.b
	movb	$0, save_context_p
	movl	$-3360, %esi            # imm = 0xFFFFFFFFFFFFF2E0
	.align	16, 0x90
.LBB180_3:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	log_lines+3492(%esi), %eax
	testl	%eax, %eax
	je	.LBB180_5
# BB#4:                                 # %if.then.i
                                        #   in Loop: Header=BB180_3 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	movl	$0, log_lines+3492(%esi)
.LBB180_5:                              # %free_log_line.exit
                                        #   in Loop: Header=BB180_3 Depth=1
	movl	$0, log_lines+3496(%esi)
	addl	$140, %esi
	jne	.LBB180_3
# BB#6:                                 # %for.end
	movl	$-1, log_line_current
	movb	$0, trailing_line
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp180:
	.size	log_close, .Ltmp180-log_close

	.globl	escnonprint
	.align	16, 0x90
	.type	escnonprint,@function
escnonprint:                            # @escnonprint
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	$8, (%esp)
	movl	16(%esp), %ecx
	movl	$92, %edx
	calll	escnonprint_internal
	addl	$12, %esp
	ret
.Ltmp181:
	.size	escnonprint, .Ltmp181-escnonprint

	.align	16, 0x90
	.type	escnonprint_internal,@function
escnonprint_internal:                   # @escnonprint_internal
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%ecx, %esi
	movl	48(%esp), %eax
	cmpl	$8, %eax
	je	.LBB182_2
# BB#1:                                 # %entry
	cmpl	$16, %eax
	jne	.LBB182_28
.LBB182_2:                              # %cond.end
	movb	(%esi), %cl
	testb	%cl, %cl
	je	.LBB182_27
# BB#3:                                 # %for.body.i.preheader
	movb	%dl, %bl
	leal	1(%esi), %eax
	xorl	%ebp, %ebp
	.align	16, 0x90
.LBB182_4:                              # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%cl, %ecx
	movzwl	_sch_istable(%ecx,%ecx), %ecx
	shrl	$4, %ecx
	andl	$1, %ecx
	xorl	$1, %ecx
	addl	%ecx, %ebp
	movb	(%eax), %cl
	incl	%eax
	testb	%cl, %cl
	jne	.LBB182_4
# BB#5:                                 # %count_nonprint.exit
	testl	%ebp, %ebp
	je	.LBB182_27
# BB#6:                                 # %if.end
	movl	escnonprint_internal.ringpos, %edi
	movl	%esi, (%esp)
	calll	strlen
	movl	48(%esp), %ecx
	cmpl	$8, %ecx
	jne	.LBB182_8
# BB#7:                                 # %cond.true5
	leal	(%ebp,%ebp,2), %ebp
	jmp	.LBB182_9
.LBB182_28:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.escnonprint_internal, 12(%esp)
	movl	$688, 8(%esp)           # imm = 0x2B0
	movl	$.L.str8704, 4(%esp)
	movl	$.L.str7703, (%esp)
	calll	__assert_fail
.LBB182_8:                              # %cond.false6
	addl	%ebp, %ebp
.LBB182_9:                              # %cond.end8
	leal	1(%eax,%ebp), %ebp
	movl	%edi, %edx
	movl	ring(,%edx,8), %eax
	testl	%eax, %eax
	je	.LBB182_11
# BB#10:                                # %lor.lhs.false11
	cmpl	%ebp, ring+4(,%edx,8)
	jge	.LBB182_12
.LBB182_11:                             # %if.then13
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	movl	%edx, %edi
	calll	checking_realloc
	movl	%edi, %edx
	movl	48(%esp), %ecx
	movl	%eax, ring(,%edx,8)
	movl	%ebp, ring+4(,%edx,8)
.LBB182_12:                             # %if.end18
	movl	%edx, %edi
	cmpl	$16, %ecx
	jne	.LBB182_13
# BB#18:                                # %while.cond22.preheader.i
	movb	(%esi), %cl
	testb	%cl, %cl
	je	.LBB182_26
# BB#19:                                # %while.body27.i.preheader
	incl	%esi
	.align	16, 0x90
.LBB182_20:                             # %while.body27.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%cl, %edx
	testb	$16, _sch_istable(%edx,%edx)
	jne	.LBB182_21
# BB#24:                                # %if.else36.i
                                        #   in Loop: Header=BB182_20 Depth=1
	movb	%bl, (%eax)
	movl	%edx, %ecx
	shrl	$4, %ecx
	movb	.L.str9705(%ecx), %cl
	movb	%cl, 1(%eax)
	andl	$15, %edx
	movb	.L.str9705(%edx), %cl
	movb	%cl, 2(%eax)
	addl	$3, %eax
	jmp	.LBB182_25
.LBB182_21:                             # %if.then34.i
                                        #   in Loop: Header=BB182_20 Depth=1
	movb	%cl, (%eax)
	incl	%eax
.LBB182_25:                             # %while.cond22.backedge.i
                                        #   in Loop: Header=BB182_20 Depth=1
	movb	(%esi), %cl
	incl	%esi
	testb	%cl, %cl
	jne	.LBB182_20
	jmp	.LBB182_26
.LBB182_13:                             # %if.end18
	cmpl	$8, %ecx
	jne	.LBB182_29
# BB#14:                                # %while.cond.preheader.i
	movb	(%esi), %cl
	testb	%cl, %cl
	je	.LBB182_26
# BB#15:                                # %while.body.i.preheader
	incl	%esi
	.align	16, 0x90
.LBB182_16:                             # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%cl, %edx
	testb	$16, _sch_istable(%edx,%edx)
	jne	.LBB182_17
# BB#22:                                # %if.else.i
                                        #   in Loop: Header=BB182_16 Depth=1
	movb	%bl, (%eax)
	movb	%cl, %dl
	shrb	$6, %dl
	orb	$48, %dl
	movb	%dl, 1(%eax)
	movb	%cl, %dl
	shrb	$3, %dl
	andb	$7, %dl
	orb	$48, %dl
	movb	%dl, 2(%eax)
	andb	$7, %cl
	orb	$48, %cl
	movb	%cl, 3(%eax)
	addl	$4, %eax
	jmp	.LBB182_23
.LBB182_17:                             # %if.then.i
                                        #   in Loop: Header=BB182_16 Depth=1
	movb	%cl, (%eax)
	incl	%eax
.LBB182_23:                             # %while.cond.backedge.i
                                        #   in Loop: Header=BB182_16 Depth=1
	movb	(%esi), %cl
	incl	%esi
	testb	%cl, %cl
	jne	.LBB182_16
.LBB182_26:                             # %copy_and_escape.exit
	movb	$0, (%eax)
	movl	escnonprint_internal.ringpos, %ecx
	leal	1(%ecx), %eax
	movl	$1431655766, %edx       # imm = 0x55555556
	imull	%edx
	movl	%edx, %eax
	shrl	$31, %eax
	addl	%edx, %eax
	leal	(%eax,%eax,2), %eax
	negl	%eax
	leal	1(%ecx,%eax), %eax
	movl	%eax, escnonprint_internal.ringpos
	movl	ring(,%edi,8), %esi
.LBB182_27:                             # %return
	movl	%esi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB182_29:                             # %sw.default.i
	calll	abort
.Ltmp182:
	.size	escnonprint_internal, .Ltmp182-escnonprint_internal

	.globl	escnonprint_uri
	.align	16, 0x90
	.type	escnonprint_uri,@function
escnonprint_uri:                        # @escnonprint_uri
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	$16, (%esp)
	movl	16(%esp), %ecx
	movl	$37, %edx
	calll	escnonprint_internal
	addl	$12, %esp
	ret
.Ltmp183:
	.size	escnonprint_uri, .Ltmp183-escnonprint_uri

	.globl	log_cleanup
	.align	16, 0x90
	.type	log_cleanup,@function
log_cleanup:                            # @log_cleanup
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	ring, %eax
	testl	%eax, %eax
	je	.LBB184_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB184_2:                              # %for.inc
	movl	ring+8, %eax
	testl	%eax, %eax
	je	.LBB184_4
# BB#3:                                 # %if.else.1
	movl	%eax, (%esp)
	calll	checking_free
.LBB184_4:                              # %for.inc.1
	movl	ring+16, %eax
	testl	%eax, %eax
	je	.LBB184_6
# BB#5:                                 # %if.else.2
	movl	%eax, (%esp)
	calll	checking_free
.LBB184_6:                              # %for.inc.2
	addl	$12, %esp
	ret
.Ltmp184:
	.size	log_cleanup, .Ltmp184-log_cleanup

	.globl	log_request_redirect_output
	.align	16, 0x90
	.type	log_request_redirect_output,@function
log_request_redirect_output:            # @log_request_redirect_output
# BB#0:                                 # %entry
	cmpl	$0, redirect_request
	jne	.LBB185_3
# BB#1:                                 # %entry
	movb	save_context_p, %al
	testb	%al, %al
	je	.LBB185_3
# BB#2:                                 # %if.then
	movl	$1, redirect_request
.LBB185_3:                              # %if.end
	movl	4(%esp), %eax
	movl	%eax, redirect_request_signal_name
	ret
.Ltmp185:
	.size	log_request_redirect_output, .Ltmp185-log_request_redirect_output

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI186_0:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
	.text
	.globl	main
	.align	16, 0x90
	.type	main,@function
main:                                   # @main
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$156, %esp
	subl	$16, %esp
	movl	$.L.str326, 4(%esp)
	movl	$6, (%esp)
	calll	setlocale
	addl	$16, %esp
	subl	$16, %esp
	movl	$.L.str328, 4(%esp)
	movl	$.L.str327, (%esp)
	calll	bindtextdomain
	addl	$16, %esp
	subl	$16, %esp
	movl	$.L.str327, (%esp)
	calll	textdomain
	addl	$16, %esp
	movl	12(%ebp), %esi
	movl	(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$47, 4(%esp)
	calll	strrchr
	addl	$16, %esp
	movl	%eax, exec_name
	testl	%eax, %eax
	je	.LBB186_1
# BB#2:                                 # %if.else
	incl	%eax
	jmp	.LBB186_3
.LBB186_1:                              # %if.then
	movl	(%esi), %eax
.LBB186_3:                              # %if.end
	movl	%eax, exec_name
	calll	initialize
	movl	$short_options, %esi
	xorl	%ebx, %ebx
	movl	$option_data+16, %edi
	movl	%ebx, %ecx
	jmp	.LBB186_4
	.align	16, 0x90
.LBB186_20:                             # %for.inc.i
                                        #   in Loop: Header=BB186_4 Depth=1
	addl	$20, %edi
	incl	%ecx
.LBB186_4:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$114, %ecx
	ja	.LBB186_21
# BB#5:                                 # %for.body.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	-16(%edi), %edx
	testl	%edx, %edx
	je	.LBB186_20
# BB#6:                                 # %if.end.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	%ebx, %eax
	shll	$4, %eax
	movl	%edx, long_options(%eax)
	movl	%edx, -148(%ebp)        # 4-byte Spill
	movl	%ecx, long_options+12(%eax)
	movl	%ecx, -132(%ebp)        # 4-byte Spill
	movsbl	-12(%edi), %edx
	movb	%dl, %cl
	testl	%edx, %edx
	je	.LBB186_8
# BB#7:                                 # %if.then4.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movb	%cl, (%esi)
	movb	%bl, optmap-32(%edx)
	incl	%esi
.LBB186_8:                              # %if.end9.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	%ebx, -144(%ebp)        # 4-byte Spill
	leal	1(%ebx), %ebx
	movl	-8(%edi), %edx
	cmpl	$1, %edx
	jne	.LBB186_9
# BB#13:                                # %sw.bb15.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	%ebx, -152(%ebp)        # 4-byte Spill
	movl	%edi, -140(%ebp)        # 4-byte Spill
	movl	%esi, -136(%ebp)        # 4-byte Spill
	movl	$2, long_options+4(%eax)
	movl	no_prefix.p, %edi
	subl	$16, %esp
	movl	-148(%ebp), %ebx        # 4-byte Reload
	movl	%ebx, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	leal	4(%edi,%esi), %eax
	movl	$no_prefix.buffer+1024, %ecx
	cmpl	%ecx, %eax
	jae	.LBB186_177
# BB#14:                                # %no_prefix.exit.i
                                        #   in Loop: Header=BB186_4 Depth=1
	addl	$4, %esi
	movb	$110, (%edi)
	movb	$111, 1(%edi)
	movb	$45, 2(%edi)
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	leal	3(%edi), %eax
	movl	%eax, (%esp)
	calll	strcpy
	addl	$16, %esp
	addl	%esi, no_prefix.p
	movl	-152(%ebp), %edx        # 4-byte Reload
	shll	$4, %edx
	movl	%edi, long_options(%edx)
	movl	$0, long_options+4(%edx)
	movl	-132(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, %eax
	orl	$1024, %eax             # imm = 0x400
	movl	%eax, long_options+12(%edx)
	movl	-144(%ebp), %ebx        # 4-byte Reload
	addl	$2, %ebx
	movl	-136(%ebp), %esi        # 4-byte Reload
	movl	-140(%ebp), %edi        # 4-byte Reload
	jmp	.LBB186_20
.LBB186_9:                              # %if.end9.i
                                        #   in Loop: Header=BB186_4 Depth=1
	testl	%edx, %edx
	jne	.LBB186_15
# BB#10:                                # %sw.bb.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	$1, long_options+4(%eax)
	testb	%cl, %cl
	je	.LBB186_11
# BB#12:                                # %if.then12.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movb	$58, (%esi)
	incl	%esi
	movl	-132(%ebp), %ecx        # 4-byte Reload
	jmp	.LBB186_20
.LBB186_15:                             # %sw.default.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	(%edi), %edx
	cmpl	$-1, %edx
	je	.LBB186_178
# BB#16:                                # %cond.end.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movl	%edx, long_options+4(%eax)
	testb	%cl, %cl
	jne	.LBB186_18
# BB#17:                                #   in Loop: Header=BB186_4 Depth=1
	movl	-132(%ebp), %ecx        # 4-byte Reload
	jmp	.LBB186_20
.LBB186_11:                             #   in Loop: Header=BB186_4 Depth=1
	movl	-132(%ebp), %ecx        # 4-byte Reload
	jmp	.LBB186_20
.LBB186_18:                             # %cond.end.i
                                        #   in Loop: Header=BB186_4 Depth=1
	cmpl	$1, %edx
	movl	-132(%ebp), %ecx        # 4-byte Reload
	jne	.LBB186_20
# BB#19:                                # %if.then33.i
                                        #   in Loop: Header=BB186_4 Depth=1
	movb	$58, (%esi)
	incl	%esi
	jmp	.LBB186_20
.LBB186_21:                             # %for.end.i
	movb	$0, (%esi)
	cmpl	$232, %ebx
	jae	.LBB186_179
# BB#22:
	movb	$0, -132(%ebp)          # 1-byte Folded Spill
	movl	$.L.str2720, %esi
	jmp	.LBB186_23
	.align	16, 0x90
.LBB186_33:                             # %if.then18
                                        #   in Loop: Header=BB186_23 Depth=1
	calll	setoptval
	addl	$16, %esp
	.align	16, 0x90
.LBB186_23:                             # %while.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB186_39 Depth 2
	movl	$-1, -16(%ebp)
	subl	$32, %esp
	leal	-16(%ebp), %eax
	movl	%eax, 16(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$long_options, 12(%esp)
	movl	$short_options, 8(%esp)
	calll	getopt_long
	addl	$32, %esp
	cmpl	$-1, %eax
	je	.LBB186_61
# BB#24:                                # %while.body
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	-16(%ebp), %ecx
	cmpl	$-1, %ecx
	jne	.LBB186_27
# BB#25:                                # %if.then4
                                        #   in Loop: Header=BB186_23 Depth=1
	cmpl	$63, %eax
	je	.LBB186_180
# BB#26:                                # %if.end10
                                        #   in Loop: Header=BB186_23 Depth=1
	movzbl	optmap-32(%eax), %ecx
	movl	%ecx, -16(%ebp)
.LBB186_27:                             # %if.end12
                                        #   in Loop: Header=BB186_23 Depth=1
	shll	$4, %ecx
	movl	long_options+12(%ecx), %edx
	movl	%edx, %edi
	andl	$-1025, %edi            # imm = 0xFFFFFFFFFFFFFBFF
	imull	$20, %edi, %ecx
	leal	option_data(%ecx), %ebx
	movl	option_data+8(%ecx), %eax
	cmpl	$8, %eax
	ja	.LBB186_23
# BB#28:                                # %if.end12
                                        #   in Loop: Header=BB186_23 Depth=1
	jmpl	*.LJTI186_0(,%eax,4)
.LBB186_29:                             # %sw.bb
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	optarg, %eax
	jmp	.LBB186_31
.LBB186_30:                             # %sw.bb16
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	optarg, %eax
	testl	%eax, %eax
	jne	.LBB186_31
# BB#34:                                # %if.else21
                                        #   in Loop: Header=BB186_23 Depth=1
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	option_data+12(%ecx), %eax
	movl	%eax, (%esp)
	andl	$1024, %edx             # imm = 0x400
	shrl	$10, %edx
	testl	%edx, %edx
	movl	$.L.str3721, %eax
	cmovnel	%esi, %eax
	movl	%eax, 4(%esp)
	jmp	.LBB186_33
.LBB186_31:                             # %if.then18
                                        #   in Loop: Header=BB186_23 Depth=1
	subl	$16, %esp
	movl	(%ebx), %edx
	movl	%edx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	option_data+12(%ecx), %eax
	jmp	.LBB186_32
.LBB186_35:                             # %sw.bb30
                                        #   in Loop: Header=BB186_23 Depth=1
	calll	*option_data+12(%ecx)
	jmp	.LBB186_23
.LBB186_36:                             # %sw.bb32
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	optarg, %eax
	subl	$16, %esp
	movl	(%ebx), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str4722, (%esp)
	calll	setoptval
	addl	$16, %esp
	movb	$1, -132(%ebp)          # 1-byte Folded Spill
	jmp	.LBB186_23
.LBB186_54:                             # %sw.bb55
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	$.L.str2720, %ecx
	movl	optarg, %edx
	testl	%edx, %edx
	je	.LBB186_59
# BB#55:                                # %if.then57
                                        #   in Loop: Header=BB186_23 Depth=1
	movzbl	(%edx), %eax
	movl	$.L.str2720, %ecx
	cmpl	$49, %eax
	je	.LBB186_59
# BB#56:                                # %lor.lhs.false
                                        #   in Loop: Header=BB186_23 Depth=1
	movb	_sch_tolower(%eax), %al
	movl	$.L.str2720, %ecx
	cmpb	$121, %al
	je	.LBB186_59
# BB#57:                                # %lor.rhs
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	$.L.str3721, %ecx
	cmpb	$111, %al
	jne	.LBB186_59
# BB#58:                                # %land.rhs
                                        #   in Loop: Header=BB186_23 Depth=1
	movzbl	1(%edx), %eax
	cmpb	$110, _sch_tolower(%eax)
	movl	$.L.str3721, %ecx
	cmovel	%esi, %ecx
.LBB186_59:                             # %if.end82
                                        #   in Loop: Header=BB186_23 Depth=1
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	%ecx, 4(%esp)
	cmpl	$69, %edi
	movl	$.L.str8726, %eax
	movl	$.L.str9727, %ecx
	cmovel	%ecx, %eax
.LBB186_32:                             # %if.then18
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	%eax, (%esp)
	jmp	.LBB186_33
.LBB186_60:                             # %sw.bb91
                                        #   in Loop: Header=BB186_23 Depth=1
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str2720, 4(%esp)
	movl	$.L.str11729, (%esp)
	jmp	.LBB186_33
.LBB186_37:                             # %sw.bb34
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	optarg, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	run_command
	addl	$16, %esp
	jmp	.LBB186_23
.LBB186_38:                             # %sw.bb35
                                        #   in Loop: Header=BB186_23 Depth=1
	movl	optarg, %edi
	jmp	.LBB186_39
	.align	16, 0x90
.LBB186_50:                             # %sw.bb38
                                        #   in Loop: Header=BB186_39 Depth=2
	calll	setoptval
	addl	$16, %esp
	incl	%edi
.LBB186_39:                             # %for.cond
                                        #   Parent Loop BB186_23 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movsbl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB186_23
# BB#40:                                # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$98, %eax
	jg	.LBB186_43
# BB#41:                                # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$72, %eax
	jne	.LBB186_53
# BB#42:                                # %sw.bb40
                                        #   in Loop: Header=BB186_39 Depth=2
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str2720, 4(%esp)
	movl	$.L.str6724, (%esp)
	jmp	.LBB186_50
.LBB186_43:                             # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$111, %eax
	jg	.LBB186_47
# BB#44:                                # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$99, %eax
	jne	.LBB186_45
# BB#51:                                # %sw.bb44
                                        #   in Loop: Header=BB186_39 Depth=2
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str3721, 4(%esp)
	movl	$.L.str8726, (%esp)
	jmp	.LBB186_50
.LBB186_47:                             # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$112, %eax
	jne	.LBB186_48
# BB#52:                                # %sw.bb46
                                        #   in Loop: Header=BB186_39 Depth=2
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str3721, 4(%esp)
	movl	$.L.str9727, (%esp)
	jmp	.LBB186_50
.LBB186_45:                             # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$100, %eax
	jne	.LBB186_53
# BB#46:                                # %sw.bb42
                                        #   in Loop: Header=BB186_39 Depth=2
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str2720, 4(%esp)
	movl	$.L.str7725, (%esp)
	jmp	.LBB186_50
.LBB186_48:                             # %for.body
                                        #   in Loop: Header=BB186_39 Depth=2
	cmpl	$118, %eax
	jne	.LBB186_53
# BB#49:                                # %sw.bb38
                                        #   in Loop: Header=BB186_39 Depth=2
	subl	$16, %esp
	movl	(%ebx), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str2720, 4(%esp)
	movl	$.L.str5723, (%esp)
	jmp	.LBB186_50
.LBB186_61:                             # %while.end
	movl	optind, %edi
	cmpl	$0, opt+28
	jne	.LBB186_63
# BB#62:                                # %if.then97
	movl	$-1, opt+28
.LBB186_63:                             # %if.end98
	movb	opt+15, %al
	movb	opt+290, %cl
	testb	%cl, %cl
	je	.LBB186_67
# BB#64:                                # %if.end98
	testb	%al, %al
	jne	.LBB186_67
# BB#65:                                # %if.then102
	movl	$0, opt+28
	cmpb	$0, opt+33
	jne	.LBB186_67
# BB#66:                                # %if.then104
	movb	$1, opt+32
.LBB186_67:                             # %if.end106
	movb	opt+4, %dl
	movl	opt, %esi
	cmpl	$-1, %esi
	jne	.LBB186_69
# BB#68:                                # %if.then109
	movb	%dl, %ah
	xorb	$1, %ah
	movzbl	%ah, %esi
	movl	%esi, opt
.LBB186_69:                             # %if.end112
	testl	%esi, %esi
	jne	.LBB186_70
	.align	16, 0x90
.LBB186_75:                             # %if.end120
	movb	opt+251, %dl
	testb	%dl, %dl
	jne	.LBB186_76
	.align	16, 0x90
.LBB186_78:                             # %if.end129
	movw	opt+334, %bx
	testb	%bl, %bl
	jne	.LBB186_79
	.align	16, 0x90
.LBB186_81:                             # %if.end138
	movl	8(%ebp), %esi
	subl	%edi, %esi
	cmpl	$0, opt+104
	je	.LBB186_94
# BB#82:                                # %if.then140
	cmpb	$0, opt+264
	je	.LBB186_87
# BB#83:                                # %land.lhs.true143
	cmpl	$1, %esi
	jg	.LBB186_86
# BB#84:                                # %land.lhs.true143
	testb	%cl, %cl
	jne	.LBB186_86
# BB#85:                                # %land.lhs.true143
	testb	%al, %al
	jne	.LBB186_86
.LBB186_87:                             # %if.end155
	orb	%cl, %al
	je	.LBB186_89
# BB#88:                                # %if.then161
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str17737, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str16736, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	opt+251, %dl
.LBB186_89:                             # %if.end163
	testb	%dl, %dl
	je	.LBB186_91
# BB#90:                                # %if.then165
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str18738, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str16736, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
	movb	$0, opt+251
.LBB186_91:                             # %if.end167
	cmpb	$0, opt+42
	je	.LBB186_94
# BB#92:                                # %land.lhs.true170
	movl	opt+104, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	file_exists_p
	addl	$16, %esp
	cmpb	$1, %al
	je	.LBB186_93
.LBB186_94:                             # %if.end176
	cmpl	8(%ebp), %edi
	je	.LBB186_95
	.align	16, 0x90
.LBB186_98:                             # %if.end186
	cmpb	$0, opt+13
	je	.LBB186_100
# BB#99:                                # %if.then188
	calll	fork_to_background
.LBB186_100:                            # %if.end189
	movl	%edi, -144(%ebp)        # 4-byte Spill
	cmpl	$0, opt
	je	.LBB186_102
# BB#101:                               # %if.then191
	movl	opt+168, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	set_progress_implementation
	addl	$16, %esp
.LBB186_102:                            # %if.end192
	movl	%esi, -136(%ebp)        # 4-byte Spill
	leal	19(,%esi,4), %eax
	andl	$-16, %eax
	movl	%esp, %ecx
	subl	%eax, %ecx
	movl	%ecx, -140(%ebp)        # 4-byte Spill
	movl	%ecx, %esp
	xorl	%ecx, %ecx
	testl	%esi, %esi
	jle	.LBB186_107
# BB#103:                               # %for.body196.lr.ph
	movl	8(%ebp), %esi
	movl	%esi, %ebx
	subl	-144(%ebp), %ebx        # 4-byte Folded Reload
	movl	optind, %eax
	movl	-140(%ebp), %edi        # 4-byte Reload
	.align	16, 0x90
.LBB186_104:                            # %for.body196
                                        # =>This Inner Loop Header: Depth=1
	movl	12(%ebp), %esi
	movl	(%esi,%eax,4), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	rewrite_shorthand_url
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB186_106
# BB#105:                               # %if.else202
                                        #   in Loop: Header=BB186_104 Depth=1
	movl	optind, %eax
	movl	(%esi,%eax,4), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_strdup
	addl	$16, %esp
.LBB186_106:                            # %if.else202
                                        #   in Loop: Header=BB186_104 Depth=1
	movl	%eax, (%edi)
	movl	optind, %eax
	incl	%eax
	movl	%eax, optind
	addl	$4, %edi
	decl	%ebx
	movl	-136(%ebp), %ecx        # 4-byte Reload
	jne	.LBB186_104
.LBB186_107:                            # %for.end209
	movl	-140(%ebp), %esi        # 4-byte Reload
	movl	$0, (%esi,%ecx,4)
	movl	opt+48, %eax
	subl	$16, %esp
	cmpb	$0, -132(%ebp)          # 1-byte Folded Reload
	setne	%cl
	movzbl	%cl, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	log_init
	addl	$16, %esp
	cmpb	$0, opt+250
	jne	.LBB186_108
	.align	16, 0x90
.LBB186_109:                            # %do.end
	movl	opt+104, %eax
	testl	%eax, %eax
	je	.LBB186_119
# BB#110:                               # %if.then218
	cmpb	$45, (%eax)
	jne	.LBB186_113
# BB#111:                               # %land.lhs.true222
	cmpb	$0, 1(%eax)
	je	.LBB186_112
.LBB186_113:                            # %if.else225
	movl	$.L.str23743, %edx
	cmpb	$0, opt+116
	movl	$.L.str24744, %ecx
	cmovnel	%edx, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fopen64
	addl	$16, %esp
	movl	%eax, output_stream
	testl	%eax, %eax
	je	.LBB186_114
# BB#116:                               # %if.end233
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	fileno
	addl	$16, %esp
	subl	$16, %esp
	leal	-112(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__fxstat64
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB186_119
# BB#117:                               # %land.lhs.true238
	movl	$61440, %eax            # imm = 0xF000
	andl	-96(%ebp), %eax
	cmpl	$32768, %eax            # imm = 0x8000
	jne	.LBB186_119
# BB#118:                               # %if.then242
	movb	$1, output_stream_regular
	jmp	.LBB186_119
.LBB186_53:                             # %sw.default
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str10728, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movsbl	(%edi), %ecx
	movl	exec_name, %edx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%edx, 4(%esp)
	.align	16, 0x90
.LBB186_97:                             # %if.then180
	movl	%eax, (%esp)
	calll	printf
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str322, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	addl	$16, %esp
	subl	$16, %esp
	movl	$10, (%esp)
	calll	putchar
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1719, 4(%esp)
	.align	16, 0x90
.LBB186_74:                             # %if.then117
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	.align	16, 0x90
.LBB186_115:                            # %if.then232
	addl	$16, %esp
	subl	$16, %esp
	movl	$1, (%esp)
	calll	exit
	addl	$16, %esp
.LBB186_112:                            # %if.then224
	movl	stdout, %eax
	movl	%eax, output_stream
.LBB186_119:                            # %if.end245
	subl	$16, %esp
	movl	$1, 4(%esp)
	movl	$1, (%esp)
	calll	signal
	addl	$16, %esp
	cmpl	$1, %eax
	je	.LBB186_121
# BB#120:                               # %if.then249
	subl	$16, %esp
	movl	$redirect_output_signal, 4(%esp)
	movl	$1, (%esp)
	calll	signal
	addl	$16, %esp
.LBB186_121:                            # %if.end251
	subl	$16, %esp
	movl	$redirect_output_signal, 4(%esp)
	movl	$10, (%esp)
	calll	signal
	addl	$16, %esp
	subl	$16, %esp
	movl	$1, 4(%esp)
	movl	$13, (%esp)
	calll	signal
	addl	$16, %esp
	subl	$16, %esp
	movl	$progress_handle_sigwinch, 4(%esp)
	movl	$28, (%esp)
	calll	signal
	addl	$16, %esp
	movl	(%esi), %eax
	movl	%eax, -152(%ebp)        # 4-byte Spill
	movl	$31, -132(%ebp)         # 4-byte Folded Spill
	testl	%eax, %eax
	je	.LBB186_142
# BB#122:                               # %for.body257.preheader
	movl	-140(%ebp), %eax        # 4-byte Reload
	leal	4(%eax), %esi
	leal	-116(%ebp), %edi
	jmp	.LBB186_123
	.align	16, 0x90
.LBB186_134:                            # %if.then296
                                        #   in Loop: Header=BB186_123 Depth=1
	subl	$16, %esp
	movl	$.L.str25745, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB186_135
	.align	16, 0x90
.LBB186_123:                            # %for.body257
                                        # =>This Inner Loop Header: Depth=1
	movl	$0, -116(%ebp)
	movl	$0, -120(%ebp)
	movb	opt+15, %al
	movb	opt+290, %cl
	orb	%al, %cl
	je	.LBB186_127
# BB#124:                               # %land.lhs.true263
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-4(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	url_scheme
	addl	$16, %esp
	cmpl	$1, %eax
	jne	.LBB186_128
# BB#125:                               # %lor.lhs.false267
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-4(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	url_uses_proxy
	addl	$16, %esp
	testb	%al, %al
	je	.LBB186_126
.LBB186_128:                            # %if.then270
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-4(%esi), %eax
	movb	opt+100, %bl
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	url_scheme
	addl	$16, %esp
	cmpl	$1, %eax
	jne	.LBB186_130
# BB#129:                               # %if.then276
                                        #   in Loop: Header=BB186_123 Depth=1
	movb	$1, opt+100
.LBB186_130:                            # %if.end277
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-4(%esi), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	retrieve_tree
	addl	$16, %esp
	movl	%eax, -132(%ebp)        # 4-byte Spill
	movb	%bl, opt+100
	jmp	.LBB186_131
.LBB186_126:                            # %lor.lhs.false267.if.else281_crit_edge
                                        #   in Loop: Header=BB186_123 Depth=1
	movb	opt+15, %al
.LBB186_127:                            # %if.else281
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-4(%esi), %ecx
	subl	$32, %esp
	testb	%al, %al
	setne	%al
	movzbl	%al, %eax
	movl	%eax, 20(%esp)
	leal	-124(%ebp), %eax
	movl	%eax, 16(%esp)
	leal	-120(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ecx, (%esp)
	movl	$0, 12(%esp)
	calll	retrieve_url
	addl	$32, %esp
	movl	%eax, -132(%ebp)        # 4-byte Spill
.LBB186_131:                            # %if.end284
                                        #   in Loop: Header=BB186_123 Depth=1
	cmpb	$0, opt+288
	je	.LBB186_137
# BB#132:                               # %land.lhs.true287
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-116(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	file_exists_p
	addl	$16, %esp
	cmpb	$1, %al
	jne	.LBB186_137
# BB#133:                               # %do.body291
                                        #   in Loop: Header=BB186_123 Depth=1
	cmpb	$0, opt+250
	jne	.LBB186_134
.LBB186_135:                            # %do.end298
                                        #   in Loop: Header=BB186_123 Depth=1
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str26746, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	-116(%ebp), %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	addl	$16, %esp
	movl	-116(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	unlink
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB186_137
# BB#136:                               # %if.then302
                                        #   in Loop: Header=BB186_123 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str27747, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB186_137:                            # %if.end306
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-120(%ebp), %eax
	testl	%eax, %eax
	je	.LBB186_139
# BB#138:                               # %if.else309
                                        #   in Loop: Header=BB186_123 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB186_139:                            # %if.end310
                                        #   in Loop: Header=BB186_123 Depth=1
	movl	-116(%ebp), %eax
	testl	%eax, %eax
	je	.LBB186_141
# BB#140:                               # %if.else313
                                        #   in Loop: Header=BB186_123 Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB186_141:                            # %for.inc315
                                        #   in Loop: Header=BB186_123 Depth=1
	cmpl	$0, (%esi)
	leal	4(%esi), %esi
	jne	.LBB186_123
.LBB186_142:                            # %for.end317
	movl	opt+52, %eax
	testl	%eax, %eax
	je	.LBB186_145
# BB#143:                               # %if.then319
	movzbl	opt+56, %ecx
	subl	$16, %esp
	leal	-128(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	retrieve_from_file
	addl	$16, %esp
	movl	%eax, -132(%ebp)        # 4-byte Spill
	cmpl	$0, -128(%ebp)
	jne	.LBB186_145
# BB#144:                               # %if.then323
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str28748, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	opt+52, %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB186_145:                            # %if.end326
	movb	opt+15, %al
	testb	%al, %al
	je	.LBB186_148
# BB#146:                               # %if.end326
	movb	opt+57, %cl
	testb	%cl, %cl
	je	.LBB186_148
# BB#147:                               # %if.then332
	calll	print_broken_links
	movb	opt+15, %al
.LBB186_148:                            # %if.end333
	orb	opt+290, %al
	jne	.LBB186_152
# BB#149:                               # %if.end333
	cmpl	$1, -136(%ebp)          # 4-byte Folded Reload
	jle	.LBB186_150
.LBB186_152:                            # %land.lhs.true347
	movl	total_downloaded_bytes, %eax
	orl	total_downloaded_bytes+4, %eax
	je	.LBB186_167
	jmp	.LBB186_153
.LBB186_150:                            # %lor.lhs.false342
	cmpl	$0, opt+52
	je	.LBB186_167
# BB#151:                               # %lor.lhs.false342
	movl	total_downloaded_bytes+4, %eax
	movl	total_downloaded_bytes, %ecx
	orl	%eax, %ecx
	je	.LBB186_167
.LBB186_153:                            # %if.then350
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str29749, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, -156(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	$0, (%esp)
	calll	time
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	datetime_str
	addl	$16, %esp
	movl	%eax, -160(%ebp)        # 4-byte Spill
	movl	opt+244, %eax
	movl	%eax, -164(%ebp)        # 4-byte Spill
	movl	total_downloaded_bytes, %eax
	movl	total_downloaded_bytes+4, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	human_readable
	addl	$16, %esp
	movl	%eax, -168(%ebp)        # 4-byte Spill
	movsd	total_download_time, %xmm0
	movsd	.LCPI186_0, %xmm1
	addsd	%xmm0, %xmm1
	cvttsd2si	%xmm1, %esi
	movl	%esi, -148(%ebp)        # 4-byte Spill
	movl	$-1037155065, %ecx      # imm = 0xFFFFFFFFC22E4507
	movl	%esi, %eax
	imull	%ecx
	addl	%esi, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$16, %edx
	addl	%eax, %edx
	imull	$86400, %edx, %eax      # imm = 0x15180
	movl	%esi, %edi
	subl	%eax, %edi
	movl	$-1851608123, %ecx      # imm = 0xFFFFFFFF91A2B3C5
	movl	%edi, %eax
	imull	%ecx
	movl	%edx, %ebx
	addl	%edi, %ebx
	movl	%ebx, %eax
	shrl	$31, %eax
	sarl	$11, %ebx
	addl	%eax, %ebx
	imull	$3600, %ebx, %eax       # imm = 0xE10
	movl	%edi, %esi
	subl	%eax, %esi
	movl	$-2004318071, %ecx      # imm = 0xFFFFFFFF88888889
	movl	%esi, %eax
	imull	%ecx
	addl	%esi, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$5, %edx
	addl	%eax, %edx
	imull	$60, %edx, %ecx
	movl	%esi, %eax
	subl	%ecx, %eax
	movl	-148(%ebp), %ecx        # 4-byte Reload
	leal	86399(%ecx), %ecx
	cmpl	$172799, %ecx           # imm = 0x2A2FF
	jb	.LBB186_155
# BB#154:                               # %if.then.i
	subl	$32, %esp
	movl	%eax, 20(%esp)
	movl	%edx, 16(%esp)
	movl	%ebx, 12(%esp)
	movl	-148(%ebp), %ecx        # 4-byte Reload
	movl	%ecx, %eax
	movl	$-1037155065, %edx      # imm = 0xFFFFFFFFC22E4507
	imull	%edx
	addl	%ecx, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$16, %edx
	addl	%eax, %edx
	movl	%edx, 8(%esp)
	movl	$.L.str34754, 4(%esp)
	jmp	.LBB186_157
.LBB186_155:                            # %if.else.i
	addl	$3599, %edi             # imm = 0xE0F
	cmpl	$7199, %edi             # imm = 0x1C1F
	jb	.LBB186_158
# BB#156:                               # %if.then6.i
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	%edx, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	$.L.str35755, 4(%esp)
.LBB186_157:                            # %if.then6.i
	movl	$secs_to_human_time.buf, (%esp)
	calll	sprintf
	addl	$32, %esp
	jmp	.LBB186_162
.LBB186_158:                            # %if.else8.i
	addl	$59, %esi
	subl	$16, %esp
	cmpl	$119, %esi
	jb	.LBB186_160
# BB#159:                               # %if.then10.i
	movl	%eax, 12(%esp)
	movl	%edx, 8(%esp)
	movl	$.L.str36756, 4(%esp)
	jmp	.LBB186_161
.LBB186_160:                            # %if.else12.i
	movsd	%xmm0, (%esp)
	calll	print_decimal
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	$.L.str37757, 4(%esp)
.LBB186_161:                            # %if.else12.i
	movl	$secs_to_human_time.buf, (%esp)
	calll	sprintf
	addl	$16, %esp
.LBB186_162:                            # %secs_to_human_time.exit
	movl	total_downloaded_bytes, %eax
	movl	total_downloaded_bytes+4, %ecx
	movsd	total_download_time, %xmm0
	subl	$16, %esp
	movsd	%xmm0, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	retr_rate
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 24(%esp)
	movl	-168(%ebp), %eax        # 4-byte Reload
	movl	%eax, 16(%esp)
	movl	-164(%ebp), %eax        # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	-160(%ebp), %eax        # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	-156(%ebp), %eax        # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$secs_to_human_time.buf, 20(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$32, %esp
	movl	opt+240, %eax
	movl	opt+236, %ecx
	movl	%ecx, %edx
	orl	%eax, %edx
	je	.LBB186_167
# BB#163:                               # %secs_to_human_time.exit
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %esi
	cmpl	%ecx, %esi
	setbe	%cl
	cmpl	%eax, %edx
	setle	%al
	je	.LBB186_165
# BB#164:                               # %secs_to_human_time.exit
	movb	%al, %cl
.LBB186_165:                            # %secs_to_human_time.exit
	testb	%cl, %cl
	jne	.LBB186_167
# BB#166:                               # %if.then361
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str30750, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %esi
	movl	opt+236, %eax
	movl	opt+240, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	human_readable
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	addl	$16, %esp
.LBB186_167:                            # %if.end365
	cmpl	$0, opt+304
	movl	-144(%ebp), %esi        # 4-byte Reload
	movl	-140(%ebp), %edi        # 4-byte Reload
	je	.LBB186_169
# BB#168:                               # %if.then367
	calll	save_cookies
.LBB186_169:                            # %if.end368
	cmpb	$0, opt+264
	je	.LBB186_172
# BB#170:                               # %if.end368
	movb	opt+288, %al
	testb	%al, %al
	jne	.LBB186_172
# BB#171:                               # %if.then373
	calll	convert_all_links
.LBB186_172:                            # %if.end374
	calll	log_close
	cmpl	$0, -136(%ebp)          # 4-byte Folded Reload
	movl	8(%ebp), %eax
	jle	.LBB186_176
# BB#173:                               # %for.body378.preheader
	decl	%eax
	subl	%esi, %eax
	addl	$4, %edi
	movl	%eax, %esi
	movl	-152(%ebp), %eax        # 4-byte Reload
	jmp	.LBB186_174
	.align	16, 0x90
.LBB186_175:                            # %for.body378.for.body378_crit_edge
                                        #   in Loop: Header=BB186_174 Depth=1
	decl	%esi
	movl	(%edi), %eax
	addl	$4, %edi
.LBB186_174:                            # %for.body378
                                        # =>This Inner Loop Header: Depth=1
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	testl	%esi, %esi
	jne	.LBB186_175
.LBB186_176:                            # %for.end382
	calll	cleanup
	cmpl	$31, -132(%ebp)         # 4-byte Folded Reload
	setne	%al
	movzbl	%al, %eax
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB186_108:                            # %if.then215
	movl	version_string, %eax
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	$.L.str22742, 8(%esp)
	movl	$.L.str21741, (%esp)
	calll	debug_logprintf
	addl	$16, %esp
	jmp	.LBB186_109
.LBB186_86:                             # %if.then152
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str15735, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	stdout, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	.align	16, 0x90
.LBB186_73:                             # %if.then117
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str322, 4(%esp)
	jmp	.LBB186_74
.LBB186_177:                            # %if.then.i.i
	calll	abort
.LBB186_178:                            # %cond.false.i
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.init_switches, 12(%esp)
	movl	$339, 8(%esp)           # imm = 0x153
	movl	$.L.str324, 4(%esp)
	movl	$.L.str323, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB186_179:                            # %cond.false41.i
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.init_switches, 12(%esp)
	movl	$353, 8(%esp)           # imm = 0x161
	movl	$.L.str324, 4(%esp)
	movl	$.L.str325, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB186_180:                            # %if.then6
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str322, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	addl	$16, %esp
	subl	$16, %esp
	movl	$10, (%esp)
	calll	putchar
	addl	$16, %esp
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str1719, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	addl	$16, %esp
	subl	$16, %esp
	movl	$2, (%esp)
	calll	exit
	addl	$16, %esp
.LBB186_70:                             # %if.end112
	testb	%dl, %dl
	je	.LBB186_75
# BB#71:                                # %if.then117
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str12732, 4(%esp)
	jmp	.LBB186_72
.LBB186_76:                             # %if.end120
	movb	opt+42, %ah
	testb	%ah, %ah
	je	.LBB186_78
# BB#77:                                # %if.then126
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str13733, 4(%esp)
	jmp	.LBB186_72
.LBB186_79:                             # %if.end129
	cmpw	$256, %bx               # imm = 0x100
	jb	.LBB186_81
# BB#80:                                # %if.then135
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str14734, 4(%esp)
.LBB186_72:                             # %if.then117
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	printf
	jmp	.LBB186_73
.LBB186_93:                             # %if.then173
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str19739, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	opt+104, %ecx
	subl	$16, %esp
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	jmp	.LBB186_115
.LBB186_95:                             # %if.end176
	movl	opt+52, %eax
	testl	%eax, %eax
	jne	.LBB186_98
# BB#96:                                # %if.then180
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str20740, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$16, %esp
	movl	%ecx, 4(%esp)
	jmp	.LBB186_97
.LBB186_114:                            # %if.then232
	movl	opt+104, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	perror
	jmp	.LBB186_115
.Ltmp186:
	.size	main, .Ltmp186-main
	.section	.rodata,"a",@progbits
	.align	4
.LJTI186_0:
	.long	.LBB186_29
	.long	.LBB186_30
	.long	.LBB186_35
	.long	.LBB186_36
	.long	.LBB186_54
	.long	.LBB186_60
	.long	.LBB186_37
	.long	.LBB186_38
	.long	.LBB186_54

	.text
	.align	16, 0x90
	.type	redirect_output_signal,@function
redirect_output_signal:                 # @redirect_output_signal
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	$.L.str31751, %eax
	movl	16(%esp), %esi
	cmpl	$1, %esi
	je	.LBB187_2
# BB#1:                                 # %cond.false
	movl	$.L.str32752, %ecx
	cmpl	$10, %esi
	movl	$.L.str33753, %eax
	cmovel	%ecx, %eax
.LBB187_2:                              # %cond.end
	movl	%eax, (%esp)
	calll	log_request_redirect_output
	calll	progress_schedule_redirect
	movl	%esi, (%esp)
	movl	$redirect_output_signal, 4(%esp)
	calll	signal
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp187:
	.size	redirect_output_signal, .Ltmp187-redirect_output_signal

	.align	16, 0x90
	.type	print_help,@function
print_help:                             # @print_help
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	$5, 8(%esp)
	movl	$.L.str321, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	version_string, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	movl	$5, 8(%esp)
	movl	$.L.str322, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	movl	$-456, %esi             # imm = 0xFFFFFFFFFFFFFE38
	.align	16, 0x90
.LBB188_1:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	print_help.help+456(%esi), %eax
	movl	%eax, 4(%esp)
	movl	$5, 8(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	stdout, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	addl	$4, %esi
	jne	.LBB188_1
# BB#2:                                 # %for.end
	movl	$0, (%esp)
	calll	exit
.Ltmp188:
	.size	print_help, .Ltmp188-print_help

	.align	16, 0x90
	.type	print_version,@function
print_version:                          # @print_version
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	version_string, %eax
	movl	%eax, 4(%esp)
	movl	$.L.str211, (%esp)
	calll	printf
	movl	$5, 8(%esp)
	movl	$.L.str212, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	stdout, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	movl	$5, 8(%esp)
	movl	$.L.str213, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	stdout, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	movl	$5, 8(%esp)
	movl	$.L.str214, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	stdout, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	movl	$5, 8(%esp)
	movl	$.L.str215, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	stdout, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	fputs
	movl	$0, (%esp)
	calll	exit
.Ltmp189:
	.size	print_version, .Ltmp189-print_version

	.globl	gen_md5_context_size
	.align	16, 0x90
	.type	gen_md5_context_size,@function
gen_md5_context_size:                   # @gen_md5_context_size
# BB#0:                                 # %entry
	movl	$156, %eax
	ret
.Ltmp190:
	.size	gen_md5_context_size, .Ltmp190-gen_md5_context_size

	.globl	gen_md5_init
	.align	16, 0x90
	.type	gen_md5_init,@function
gen_md5_init:                           # @gen_md5_init
# BB#0:                                 # %entry
	jmp	md5_init_ctx            # TAILCALL
.Ltmp191:
	.size	gen_md5_init, .Ltmp191-gen_md5_init

	.globl	gen_md5_update
	.align	16, 0x90
	.type	gen_md5_update,@function
gen_md5_update:                         # @gen_md5_update
# BB#0:                                 # %entry
	jmp	md5_process_bytes       # TAILCALL
.Ltmp192:
	.size	gen_md5_update, .Ltmp192-gen_md5_update

	.globl	gen_md5_finish
	.align	16, 0x90
	.type	gen_md5_finish,@function
gen_md5_finish:                         # @gen_md5_finish
# BB#0:                                 # %entry
	jmp	md5_finish_ctx          # TAILCALL
.Ltmp193:
	.size	gen_md5_finish, .Ltmp193-gen_md5_finish

	.globl	md5_init_ctx
	.align	16, 0x90
	.type	md5_init_ctx,@function
md5_init_ctx:                           # @md5_init_ctx
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movl	$1732584193, (%eax)     # imm = 0x67452301
	movl	$-271733879, 4(%eax)    # imm = 0xFFFFFFFFEFCDAB89
	movl	$-1732584194, 8(%eax)   # imm = 0xFFFFFFFF98BADCFE
	movl	$271733878, 12(%eax)    # imm = 0x10325476
	movl	$0, 20(%eax)
	movl	$0, 16(%eax)
	movl	$0, 24(%eax)
	ret
.Ltmp194:
	.size	md5_init_ctx, .Ltmp194-md5_init_ctx

	.globl	md5_read_ctx
	.align	16, 0x90
	.type	md5_read_ctx,@function
md5_read_ctx:                           # @md5_read_ctx
# BB#0:                                 # %entry
	movl	4(%esp), %ecx
	movl	(%ecx), %edx
	movl	8(%esp), %eax
	movl	%edx, (%eax)
	movl	4(%ecx), %edx
	movl	%edx, 4(%eax)
	movl	8(%ecx), %edx
	movl	%edx, 8(%eax)
	movl	12(%ecx), %ecx
	movl	%ecx, 12(%eax)
	ret
.Ltmp195:
	.size	md5_read_ctx, .Ltmp195-md5_read_ctx

	.globl	md5_finish_ctx
	.align	16, 0x90
	.type	md5_finish_ctx,@function
md5_finish_ctx:                         # @md5_finish_ctx
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %edi
	movl	24(%edi), %eax
	movl	16(%edi), %ecx
	addl	%eax, %ecx
	movl	%ecx, 16(%edi)
	movl	36(%esp), %esi
	jae	.LBB196_2
# BB#1:                                 # %if.then
	incl	20(%edi)
.LBB196_2:                              # %if.end
	leal	28(%edi,%eax), %ecx
	movl	%ecx, (%esp)
	movl	$120, %ecx
	cmpl	$55, %eax
	movl	$56, %ebx
	cmoval	%ecx, %ebx
	movl	%ebx, %ecx
	subl	%eax, %ecx
	movl	%ecx, 8(%esp)
	movl	$fillbuf, 4(%esp)
	calll	memcpy
	movl	16(%edi), %eax
	shll	$3, %eax
	movl	%eax, 28(%edi,%ebx)
	movl	%ebx, %eax
	orl	$4, %eax
	movl	16(%edi), %ecx
	movl	20(%edi), %edx
	shldl	$3, %ecx, %edx
	movl	%edx, 28(%edi,%eax)
	movl	%edi, 8(%esp)
	addl	$8, %ebx
	movl	%ebx, 4(%esp)
	leal	28(%edi), %eax
	movl	%eax, (%esp)
	calll	md5_process_block
	movl	(%edi), %eax
	movl	%eax, (%esi)
	movl	4(%edi), %eax
	movl	%eax, 4(%esi)
	movl	8(%edi), %eax
	movl	%eax, 8(%esi)
	movl	12(%edi), %eax
	movl	%eax, 12(%esi)
	movl	%esi, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp196:
	.size	md5_finish_ctx, .Ltmp196-md5_finish_ctx

	.globl	md5_process_block
	.align	16, 0x90
	.type	md5_process_block,@function
md5_process_block:                      # @md5_process_block
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$88, %esp
	movl	112(%esp), %eax
	movl	%eax, %ecx
	andl	$-4, %ecx
	movl	108(%esp), %ebp
	addl	%ebp, %ecx
	movl	%ecx, (%esp)            # 4-byte Spill
	movl	116(%esp), %ecx
	movl	12(%ecx), %edx
	movl	8(%ecx), %esi
	movl	(%ecx), %ebx
	movl	4(%ecx), %edi
	addl	16(%ecx), %eax
	movl	%eax, 16(%ecx)
	jae	.LBB197_3
# BB#1:                                 # %if.then
	incl	20(%ecx)
	jmp	.LBB197_3
	.align	16, 0x90
.LBB197_2:                              # %while.body
                                        #   in Loop: Header=BB197_3 Depth=1
	movl	%ebp, 4(%esp)           # 4-byte Spill
	movl	%ebx, 8(%esp)           # 4-byte Spill
	movl	%edi, 28(%esp)          # 4-byte Spill
	movl	%esi, 32(%esp)          # 4-byte Spill
	movl	%edx, 84(%esp)          # 4-byte Spill
	movl	%esi, %eax
	xorl	%edi, %eax
	movl	%edx, %ecx
	xorl	%esi, %ecx
	andl	%edi, %ecx
	xorl	%edx, %ecx
	addl	%ebx, %ecx
	movl	(%ebp), %edx
	movl	%edx, 60(%esp)          # 4-byte Spill
	movl	4(%ebp), %ebx
	movl	%ebx, 76(%esp)          # 4-byte Spill
	leal	-680876936(%edx,%ecx), %ecx
	roll	$7, %ecx
	addl	%edi, %ecx
	andl	%ecx, %eax
	xorl	%esi, %eax
	movl	84(%esp), %edx          # 4-byte Reload
	leal	(%edx,%ebx), %edx
	leal	-389564586(%eax,%edx), %edx
	roll	$12, %edx
	addl	%ecx, %edx
	movl	%ecx, %eax
	xorl	%edi, %eax
	andl	%edx, %eax
	xorl	%edi, %eax
	movl	8(%ebp), %edi
	movl	%edi, 56(%esp)          # 4-byte Spill
	movl	32(%esp), %esi          # 4-byte Reload
	leal	(%esi,%edi), %esi
	leal	606105819(%eax,%esi), %edi
	roll	$17, %edi
	addl	%edx, %edi
	movl	%edx, %eax
	xorl	%ecx, %eax
	andl	%edi, %eax
	xorl	%ecx, %eax
	movl	12(%ebp), %ebx
	movl	%ebx, 64(%esp)          # 4-byte Spill
	movl	28(%esp), %esi          # 4-byte Reload
	leal	(%esi,%ebx), %esi
	leal	-1044525330(%eax,%esi), %eax
	roll	$22, %eax
	addl	%edi, %eax
	movl	%edi, %esi
	xorl	%edx, %esi
	andl	%eax, %esi
	xorl	%edx, %esi
	movl	16(%ebp), %ebx
	movl	%ebx, 80(%esp)          # 4-byte Spill
	addl	%ebx, %ecx
	leal	-176418897(%esi,%ecx), %ecx
	roll	$7, %ecx
	addl	%eax, %ecx
	movl	%eax, %esi
	xorl	%edi, %esi
	andl	%ecx, %esi
	xorl	%edi, %esi
	movl	20(%ebp), %ebx
	movl	%ebx, 52(%esp)          # 4-byte Spill
	addl	%ebx, %edx
	leal	1200080426(%esi,%edx), %edx
	roll	$12, %edx
	addl	%ecx, %edx
	movl	%ecx, %esi
	xorl	%eax, %esi
	andl	%edx, %esi
	xorl	%eax, %esi
	movl	24(%ebp), %ebx
	movl	%ebx, 68(%esp)          # 4-byte Spill
	addl	%ebx, %edi
	leal	-1473231341(%esi,%edi), %edi
	roll	$17, %edi
	addl	%edx, %edi
	movl	%edx, %esi
	xorl	%ecx, %esi
	andl	%edi, %esi
	xorl	%ecx, %esi
	movl	28(%ebp), %ebx
	movl	%ebx, 44(%esp)          # 4-byte Spill
	addl	%ebx, %eax
	leal	-45705983(%esi,%eax), %eax
	roll	$22, %eax
	addl	%edi, %eax
	movl	%edi, %esi
	xorl	%edx, %esi
	andl	%eax, %esi
	xorl	%edx, %esi
	movl	32(%ebp), %ebx
	movl	%ebx, 12(%esp)          # 4-byte Spill
	addl	%ebx, %ecx
	leal	1770035416(%esi,%ecx), %ebx
	roll	$7, %ebx
	addl	%eax, %ebx
	movl	%eax, %ecx
	xorl	%edi, %ecx
	andl	%ebx, %ecx
	xorl	%edi, %ecx
	movl	36(%ebp), %esi
	movl	%esi, 72(%esp)          # 4-byte Spill
	addl	%esi, %edx
	leal	-1958414417(%ecx,%edx), %edx
	roll	$12, %edx
	addl	%ebx, %edx
	movl	%ebx, %ecx
	xorl	%eax, %ecx
	andl	%edx, %ecx
	xorl	%eax, %ecx
	movl	40(%ebp), %esi
	movl	%esi, 40(%esp)          # 4-byte Spill
	addl	%esi, %edi
	leal	-42063(%ecx,%edi), %ecx
	roll	$17, %ecx
	addl	%edx, %ecx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%ecx, %esi
	xorl	%ebx, %esi
	movl	44(%ebp), %edi
	movl	%edi, 48(%esp)          # 4-byte Spill
	addl	%edi, %eax
	leal	-1990404162(%esi,%eax), %eax
	roll	$22, %eax
	addl	%ecx, %eax
	movl	%ecx, %esi
	xorl	%edx, %esi
	andl	%eax, %esi
	xorl	%edx, %esi
	movl	48(%ebp), %edi
	movl	%edi, 20(%esp)          # 4-byte Spill
	addl	%edi, %ebx
	leal	1804603682(%esi,%ebx), %ebx
	roll	$7, %ebx
	addl	%eax, %ebx
	movl	%eax, %esi
	xorl	%ecx, %esi
	andl	%ebx, %esi
	xorl	%ecx, %esi
	movl	52(%ebp), %edi
	movl	%edi, 36(%esp)          # 4-byte Spill
	addl	%edi, %edx
	leal	-40341101(%esi,%edx), %edx
	roll	$12, %edx
	addl	%ebx, %edx
	movl	%ebx, %esi
	xorl	%eax, %esi
	andl	%edx, %esi
	xorl	%eax, %esi
	movl	56(%ebp), %edi
	movl	%edi, 16(%esp)          # 4-byte Spill
	addl	%edi, %ecx
	leal	-1502002290(%esi,%ecx), %ecx
	roll	$17, %ecx
	addl	%edx, %ecx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%ecx, %esi
	xorl	%ebx, %esi
	movl	60(%ebp), %ebp
	movl	%ebp, 24(%esp)          # 4-byte Spill
	addl	%ebp, %eax
	leal	1236535329(%esi,%eax), %eax
	roll	$22, %eax
	addl	%ecx, %eax
	movl	%eax, %esi
	xorl	%ecx, %esi
	andl	%edx, %esi
	xorl	%ecx, %esi
	addl	76(%esp), %ebx          # 4-byte Folded Reload
	leal	-165796510(%esi,%ebx), %ebx
	roll	$5, %ebx
	addl	%eax, %ebx
	movl	%ebx, %esi
	xorl	%eax, %esi
	andl	%ecx, %esi
	xorl	%eax, %esi
	addl	68(%esp), %edx          # 4-byte Folded Reload
	leal	-1069501632(%esi,%edx), %edx
	roll	$9, %edx
	addl	%ebx, %edx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%eax, %esi
	xorl	%ebx, %esi
	addl	48(%esp), %ecx          # 4-byte Folded Reload
	leal	643717713(%esi,%ecx), %ecx
	roll	$14, %ecx
	addl	%edx, %ecx
	movl	%ecx, %esi
	xorl	%edx, %esi
	andl	%ebx, %esi
	xorl	%edx, %esi
	addl	60(%esp), %eax          # 4-byte Folded Reload
	leal	-373897302(%esi,%eax), %eax
	roll	$20, %eax
	addl	%ecx, %eax
	movl	%eax, %esi
	xorl	%ecx, %esi
	andl	%edx, %esi
	xorl	%ecx, %esi
	addl	52(%esp), %ebx          # 4-byte Folded Reload
	leal	-701558691(%esi,%ebx), %ebx
	roll	$5, %ebx
	addl	%eax, %ebx
	movl	%ebx, %esi
	xorl	%eax, %esi
	andl	%ecx, %esi
	xorl	%eax, %esi
	addl	40(%esp), %edx          # 4-byte Folded Reload
	leal	38016083(%esi,%edx), %edx
	roll	$9, %edx
	addl	%ebx, %edx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%eax, %esi
	xorl	%ebx, %esi
	addl	%ebp, %ecx
	leal	-660478335(%esi,%ecx), %ecx
	roll	$14, %ecx
	addl	%edx, %ecx
	movl	%ecx, %esi
	xorl	%edx, %esi
	andl	%ebx, %esi
	xorl	%edx, %esi
	addl	80(%esp), %eax          # 4-byte Folded Reload
	leal	-405537848(%esi,%eax), %eax
	roll	$20, %eax
	addl	%ecx, %eax
	movl	%eax, %esi
	xorl	%ecx, %esi
	andl	%edx, %esi
	xorl	%ecx, %esi
	addl	72(%esp), %ebx          # 4-byte Folded Reload
	leal	568446438(%esi,%ebx), %ebx
	roll	$5, %ebx
	addl	%eax, %ebx
	movl	%ebx, %esi
	xorl	%eax, %esi
	andl	%ecx, %esi
	xorl	%eax, %esi
	addl	%edi, %edx
	leal	-1019803690(%esi,%edx), %edx
	roll	$9, %edx
	addl	%ebx, %edx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%eax, %esi
	xorl	%ebx, %esi
	addl	64(%esp), %ecx          # 4-byte Folded Reload
	leal	-187363961(%esi,%ecx), %ecx
	roll	$14, %ecx
	addl	%edx, %ecx
	movl	%ecx, %esi
	xorl	%edx, %esi
	andl	%ebx, %esi
	xorl	%edx, %esi
	movl	12(%esp), %ebp          # 4-byte Reload
	addl	%ebp, %eax
	leal	1163531501(%esi,%eax), %eax
	roll	$20, %eax
	addl	%ecx, %eax
	movl	%eax, %esi
	xorl	%ecx, %esi
	andl	%edx, %esi
	xorl	%ecx, %esi
	addl	36(%esp), %ebx          # 4-byte Folded Reload
	leal	-1444681467(%esi,%ebx), %ebx
	roll	$5, %ebx
	addl	%eax, %ebx
	movl	%ebx, %esi
	xorl	%eax, %esi
	andl	%ecx, %esi
	xorl	%eax, %esi
	addl	56(%esp), %edx          # 4-byte Folded Reload
	leal	-51403784(%esi,%edx), %edx
	roll	$9, %edx
	addl	%ebx, %edx
	movl	%edx, %esi
	xorl	%ebx, %esi
	andl	%eax, %esi
	xorl	%ebx, %esi
	addl	44(%esp), %ecx          # 4-byte Folded Reload
	leal	1735328473(%esi,%ecx), %esi
	roll	$14, %esi
	addl	%edx, %esi
	movl	%esi, %ecx
	xorl	%edx, %ecx
	movl	%ecx, %edi
	andl	%ebx, %edi
	xorl	%edx, %edi
	addl	20(%esp), %eax          # 4-byte Folded Reload
	leal	-1926607734(%edi,%eax), %edi
	roll	$20, %edi
	addl	%esi, %edi
	xorl	%edi, %ecx
	addl	52(%esp), %ebx          # 4-byte Folded Reload
	leal	-378558(%ecx,%ebx), %eax
	roll	$4, %eax
	addl	%edi, %eax
	movl	%edi, %ecx
	xorl	%esi, %ecx
	xorl	%eax, %ecx
	addl	%ebp, %edx
	leal	-2022574463(%ecx,%edx), %edx
	roll	$11, %edx
	addl	%eax, %edx
	movl	%eax, %ecx
	xorl	%edi, %ecx
	xorl	%edx, %ecx
	addl	48(%esp), %esi          # 4-byte Folded Reload
	leal	1839030562(%ecx,%esi), %ecx
	roll	$16, %ecx
	addl	%edx, %ecx
	movl	%edx, %esi
	xorl	%eax, %esi
	xorl	%ecx, %esi
	addl	16(%esp), %edi          # 4-byte Folded Reload
	leal	-35309556(%esi,%edi), %ebx
	roll	$23, %ebx
	addl	%ecx, %ebx
	movl	%ecx, %esi
	xorl	%edx, %esi
	xorl	%ebx, %esi
	addl	76(%esp), %eax          # 4-byte Folded Reload
	leal	-1530992060(%esi,%eax), %eax
	roll	$4, %eax
	addl	%ebx, %eax
	movl	%ebx, %esi
	xorl	%ecx, %esi
	xorl	%eax, %esi
	addl	80(%esp), %edx          # 4-byte Folded Reload
	leal	1272893353(%esi,%edx), %edx
	roll	$11, %edx
	addl	%eax, %edx
	movl	%eax, %esi
	xorl	%ebx, %esi
	xorl	%edx, %esi
	addl	44(%esp), %ecx          # 4-byte Folded Reload
	leal	-155497632(%esi,%ecx), %ecx
	roll	$16, %ecx
	addl	%edx, %ecx
	movl	%edx, %esi
	xorl	%eax, %esi
	xorl	%ecx, %esi
	addl	40(%esp), %ebx          # 4-byte Folded Reload
	leal	-1094730640(%esi,%ebx), %ebx
	roll	$23, %ebx
	addl	%ecx, %ebx
	movl	%ecx, %esi
	xorl	%edx, %esi
	xorl	%ebx, %esi
	addl	36(%esp), %eax          # 4-byte Folded Reload
	leal	681279174(%esi,%eax), %eax
	roll	$4, %eax
	addl	%ebx, %eax
	movl	%ebx, %esi
	xorl	%ecx, %esi
	xorl	%eax, %esi
	addl	60(%esp), %edx          # 4-byte Folded Reload
	leal	-358537222(%esi,%edx), %edx
	roll	$11, %edx
	addl	%eax, %edx
	movl	%eax, %esi
	xorl	%ebx, %esi
	xorl	%edx, %esi
	addl	64(%esp), %ecx          # 4-byte Folded Reload
	leal	-722521979(%esi,%ecx), %ecx
	roll	$16, %ecx
	addl	%edx, %ecx
	movl	%edx, %esi
	xorl	%eax, %esi
	xorl	%ecx, %esi
	addl	68(%esp), %ebx          # 4-byte Folded Reload
	leal	76029189(%esi,%ebx), %ebx
	roll	$23, %ebx
	addl	%ecx, %ebx
	movl	%ecx, %esi
	xorl	%edx, %esi
	xorl	%ebx, %esi
	addl	72(%esp), %eax          # 4-byte Folded Reload
	leal	-640364487(%esi,%eax), %eax
	roll	$4, %eax
	addl	%ebx, %eax
	movl	%ebx, %esi
	xorl	%ecx, %esi
	xorl	%eax, %esi
	movl	20(%esp), %ebp          # 4-byte Reload
	addl	%ebp, %edx
	leal	-421815835(%esi,%edx), %edi
	roll	$11, %edi
	addl	%eax, %edi
	movl	%eax, %edx
	xorl	%ebx, %edx
	xorl	%edi, %edx
	addl	24(%esp), %ecx          # 4-byte Folded Reload
	leal	530742520(%edx,%ecx), %edx
	roll	$16, %edx
	addl	%edi, %edx
	movl	%edi, %ecx
	xorl	%eax, %ecx
	xorl	%edx, %ecx
	addl	56(%esp), %ebx          # 4-byte Folded Reload
	leal	-995338651(%ecx,%ebx), %ecx
	roll	$23, %ecx
	addl	%edx, %ecx
	movl	44(%esp), %esi          # 4-byte Reload
	addl	%edi, %esi
	notl	%edi
	orl	%ecx, %edi
	xorl	%edx, %edi
	addl	60(%esp), %eax          # 4-byte Folded Reload
	leal	-198630844(%edi,%eax), %eax
	movl	28(%esp), %edi          # 4-byte Reload
	roll	$6, %eax
	addl	%ecx, %eax
	movl	16(%esp), %ebx          # 4-byte Reload
	addl	%edx, %ebx
	notl	%edx
	orl	%eax, %edx
	xorl	%ecx, %edx
	leal	1126891415(%edx,%esi), %edx
	roll	$10, %edx
	addl	%eax, %edx
	movl	52(%esp), %esi          # 4-byte Reload
	addl	%ecx, %esi
	notl	%ecx
	orl	%edx, %ecx
	xorl	%eax, %ecx
	leal	-1416354905(%ecx,%ebx), %ecx
	roll	$15, %ecx
	addl	%edx, %ecx
	movl	%ebp, %ebx
	addl	%eax, %ebx
	notl	%eax
	orl	%ecx, %eax
	xorl	%edx, %eax
	leal	-57434055(%eax,%esi), %eax
	roll	$21, %eax
	addl	%ecx, %eax
	movl	64(%esp), %esi          # 4-byte Reload
	addl	%edx, %esi
	notl	%edx
	orl	%eax, %edx
	xorl	%ecx, %edx
	leal	1700485571(%edx,%ebx), %edx
	roll	$6, %edx
	addl	%eax, %edx
	movl	40(%esp), %ebx          # 4-byte Reload
	addl	%ecx, %ebx
	notl	%ecx
	orl	%edx, %ecx
	xorl	%eax, %ecx
	leal	-1894986606(%ecx,%esi), %ecx
	roll	$10, %ecx
	addl	%edx, %ecx
	movl	76(%esp), %esi          # 4-byte Reload
	addl	%eax, %esi
	notl	%eax
	orl	%ecx, %eax
	xorl	%edx, %eax
	leal	-1051523(%eax,%ebx), %eax
	roll	$15, %eax
	addl	%ecx, %eax
	movl	12(%esp), %ebx          # 4-byte Reload
	addl	%edx, %ebx
	notl	%edx
	orl	%eax, %edx
	xorl	%ecx, %edx
	leal	-2054922799(%edx,%esi), %edx
	roll	$21, %edx
	addl	%eax, %edx
	movl	24(%esp), %ebp          # 4-byte Reload
	addl	%ecx, %ebp
	notl	%ecx
	orl	%edx, %ecx
	xorl	%eax, %ecx
	leal	1873313359(%ecx,%ebx), %ecx
	roll	$6, %ecx
	addl	%edx, %ecx
	movl	68(%esp), %esi          # 4-byte Reload
	addl	%eax, %esi
	notl	%eax
	orl	%ecx, %eax
	xorl	%edx, %eax
	leal	-30611744(%eax,%ebp), %eax
	roll	$10, %eax
	addl	%ecx, %eax
	movl	36(%esp), %ebx          # 4-byte Reload
	addl	%edx, %ebx
	notl	%edx
	orl	%eax, %edx
	xorl	%ecx, %edx
	leal	-1560198380(%edx,%esi), %edx
	roll	$15, %edx
	addl	%eax, %edx
	movl	80(%esp), %esi          # 4-byte Reload
	addl	%ecx, %esi
	notl	%ecx
	orl	%edx, %ecx
	xorl	%eax, %ecx
	leal	1309151649(%ecx,%ebx), %ecx
	roll	$21, %ecx
	addl	%edx, %ecx
	movl	48(%esp), %ebx          # 4-byte Reload
	addl	%eax, %ebx
	notl	%eax
	orl	%ecx, %eax
	xorl	%edx, %eax
	leal	-145523070(%eax,%esi), %eax
	roll	$6, %eax
	addl	%ecx, %eax
	movl	56(%esp), %esi          # 4-byte Reload
	addl	%edx, %esi
	notl	%edx
	orl	%eax, %edx
	xorl	%ecx, %edx
	leal	-1120210379(%edx,%ebx), %edx
	roll	$10, %edx
	addl	%eax, %edx
	movl	72(%esp), %ebp          # 4-byte Reload
	addl	%ecx, %ebp
	notl	%ecx
	orl	%edx, %ecx
	xorl	%eax, %ecx
	leal	718787259(%ecx,%esi), %ecx
	roll	$15, %ecx
	addl	%edx, %ecx
	addl	%ecx, %edi
	movl	%eax, %esi
	notl	%esi
	orl	%ecx, %esi
	xorl	%edx, %esi
	leal	-343485551(%esi,%ebp), %esi
	movl	4(%esp), %ebp           # 4-byte Reload
	roll	$21, %esi
	addl	%esi, %edi
	movl	32(%esp), %esi          # 4-byte Reload
	addl	%ecx, %esi
	addl	%edx, 84(%esp)          # 4-byte Folded Spill
	movl	84(%esp), %edx          # 4-byte Reload
	movl	8(%esp), %ecx           # 4-byte Reload
	addl	%eax, %ecx
	movl	%ecx, %ebx
	addl	$64, %ebp
.LBB197_3:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	cmpl	(%esp), %ebp            # 4-byte Folded Reload
	jb	.LBB197_2
# BB#4:                                 # %while.end
	movl	116(%esp), %eax
	movl	%ebx, (%eax)
	movl	%edi, 4(%eax)
	movl	%esi, 8(%eax)
	movl	%edx, 12(%eax)
	addl	$88, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp197:
	.size	md5_process_block, .Ltmp197-md5_process_block

	.globl	md5_process_bytes
	.align	16, 0x90
	.type	md5_process_bytes,@function
md5_process_bytes:                      # @md5_process_bytes
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	56(%esp), %ebx
	movl	24(%ebx), %ebp
	movl	52(%esp), %edi
	movl	48(%esp), %esi
	testl	%ebp, %ebp
	je	.LBB198_4
# BB#1:                                 # %if.then
	movl	%esi, 4(%esp)
	leal	28(%ebx,%ebp), %eax
	movl	%eax, (%esp)
	movl	$128, %esi
	subl	%ebp, %esi
	cmpl	%edi, %esi
	cmoval	%edi, %esi
	movl	%esi, 8(%esp)
	calll	memcpy
	addl	%esi, 24(%ebx)
	addl	%esi, %ebp
	cmpl	$65, %ebp
	jb	.LBB198_3
# BB#2:                                 # %if.then9
	movl	%ebx, 8(%esp)
	movl	%ebx, %edi
	movl	%ebp, %ebx
	andl	$-64, %ebx
	movl	%ebx, 4(%esp)
	leal	28(%edi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	md5_process_block
	andl	$63, %ebp
	movl	%ebp, 8(%esp)
	leal	28(%edi,%ebx), %eax
	movl	%edi, %ebx
	movl	%eax, 4(%esp)
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	memcpy
	movl	%ebp, 24(%ebx)
.LBB198_3:                              # %if.end
	movl	52(%esp), %edi
	subl	%esi, %edi
	movl	48(%esp), %eax
	addl	%esi, %eax
	movl	%eax, %esi
.LBB198_4:                              # %if.end24
	cmpl	$65, %edi
	jb	.LBB198_6
# BB#5:                                 # %if.then26
	movl	%ebx, 8(%esp)
	movl	%edi, %eax
	andl	$-64, %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	addl	%eax, %esi
	calll	md5_process_block
	andl	$63, %edi
.LBB198_6:                              # %if.end31
	testl	%edi, %edi
	je	.LBB198_8
# BB#7:                                 # %if.then33
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	leal	28(%ebx), %eax
	movl	%eax, (%esp)
	calll	memcpy
	movl	%edi, 24(%ebx)
.LBB198_8:                              # %if.end37
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp198:
	.size	md5_process_bytes, .Ltmp198-md5_process_bytes

	.globl	search_netrc
	.align	16, 0x90
	.type	search_netrc,@function
search_netrc:                           # @search_netrc
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$140, %esp
	cmpb	$0, opt+128
	je	.LBB199_84
# BB#1:                                 # %if.end
	movb	search_netrc.processed_netrc.b, %al
	testb	%al, %al
	jne	.LBB199_63
# BB#2:                                 # %if.then2
	calll	home_dir
	movl	%eax, %edi
	movl	$0, netrc_list
	movb	$1, search_netrc.processed_netrc.b
	testl	%edi, %edi
	je	.LBB199_84
# BB#3:                                 # %if.then4
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$23, %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%esi, (%esp)
	movl	$.L.str1887, 12(%esp)
	movl	$.L.str886, 4(%esp)
	calll	sprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
	subl	$16, %esp
	leal	-120(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB199_4
.LBB199_63:                             # %if.end14thread-pre-split
	movl	netrc_list, %esi
	.align	16, 0x90
.LBB199_64:                             # %if.end14
	testl	%esi, %esi
	je	.LBB199_84
# BB#65:                                # %if.end17
	movl	12(%ebp), %eax
	movl	(%eax), %ebx
	testl	%ebx, %ebx
	movl	%esi, %edi
	je	.LBB199_67
# BB#66:                                # %land.lhs.true
	movl	16(%ebp), %eax
	cmpl	$0, (%eax)
	movl	%esi, %edi
	jne	.LBB199_84
	jmp	.LBB199_67
	.align	16, 0x90
.LBB199_70:                             # %for.inc
                                        #   in Loop: Header=BB199_67 Depth=1
	movl	12(%edi), %edi
.LBB199_67:                             # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	testl	%edi, %edi
	je	.LBB199_76
# BB#68:                                # %for.body
                                        #   in Loop: Header=BB199_67 Depth=1
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB199_70
# BB#69:                                # %if.else
                                        #   in Loop: Header=BB199_67 Depth=1
	subl	$16, %esp
	movl	8(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcasecmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB199_70
# BB#71:                                # %if.then33
	movl	4(%edi), %eax
	testl	%ebx, %ebx
	je	.LBB199_75
# BB#72:                                # %if.then35
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB199_73
# BB#74:                                # %if.else41
	movl	16(%ebp), %eax
	movl	$0, (%eax)
	jmp	.LBB199_84
.LBB199_76:                             # %if.else51
	testl	%ebx, %ebx
	setne	%al
	cmpl	$0, 20(%ebp)
	je	.LBB199_84
# BB#77:                                # %if.else51
	testb	%al, %al
	jne	.LBB199_84
	jmp	.LBB199_78
	.align	16, 0x90
.LBB199_80:                             # %for.body60.for.cond58_crit_edge
                                        #   in Loop: Header=BB199_78 Depth=1
	movl	12(%esi), %esi
.LBB199_78:                             # %for.cond58
                                        # =>This Inner Loop Header: Depth=1
	testl	%esi, %esi
	je	.LBB199_84
# BB#79:                                # %for.body60
                                        #   in Loop: Header=BB199_78 Depth=1
	cmpl	$0, (%esi)
	jne	.LBB199_80
# BB#81:                                # %if.end70
	movl	4(%esi), %eax
	movl	12(%ebp), %ecx
	movl	%eax, (%ecx)
	movl	16(%ebp), %eax
	cmpl	$0, (%eax)
	jne	.LBB199_84
# BB#82:                                # %if.then73
	movl	8(%esi), %eax
	jmp	.LBB199_83
.LBB199_4:                              # %if.then10
	movl	$0, -20(%ebp)
	movl	$0, -16(%ebp)
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$.L.str2888, 4(%esp)
	calll	fopen64
	addl	$16, %esp
	movl	%eax, %edi
	movl	%edi, -148(%ebp)        # 4-byte Spill
	testl	%edi, %edi
	je	.LBB199_85
# BB#5:                                 # %while.cond.preheader.i
	movl	%esi, -132(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	read_whole_line
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB199_58
# BB#6:
	xorl	%edx, %edx
	movl	$1, -128(%ebp)          # 4-byte Folded Spill
	.align	16, 0x90
.LBB199_7:                              # %while.cond7.preheader.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB199_12 Depth 2
                                        #       Child Loop BB199_14 Depth 3
                                        #       Child Loop BB199_31 Depth 3
                                        #       Child Loop BB199_21 Depth 3
                                        #         Child Loop BB199_27 Depth 4
                                        #       Child Loop BB199_19 Depth 3
                                        #     Child Loop BB199_8 Depth 2
	movl	%eax, -144(%ebp)        # 4-byte Spill
	movl	%eax, %ecx
	.align	16, 0x90
.LBB199_8:                              # %while.cond7.i
                                        #   Parent Loop BB199_7 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ecx, %ebx
	movzbl	(%ebx), %eax
	xorl	%esi, %esi
	testl	%eax, %eax
	je	.LBB199_10
# BB#9:                                 # %land.rhs.i
                                        #   in Loop: Header=BB199_8 Depth=2
	leal	1(%ebx), %ecx
	movl	$3, %esi
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB199_8
.LBB199_10:                             # %while.end.i
                                        #   in Loop: Header=BB199_7 Depth=1
                                        # kill: AL<def> AL<kill> EAX<kill>
	cmpl	$3, %edx
	je	.LBB199_12
# BB#11:                                #   in Loop: Header=BB199_7 Depth=1
	movl	%edx, %esi
	jmp	.LBB199_12
	.align	16, 0x90
.LBB199_56:                             # %while.cond19.backedge.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movb	(%ebx), %al
.LBB199_12:                             # %while.cond19.i
                                        #   Parent Loop BB199_7 Depth=1
                                        # =>  This Loop Header: Depth=2
                                        #       Child Loop BB199_14 Depth 3
                                        #       Child Loop BB199_31 Depth 3
                                        #       Child Loop BB199_21 Depth 3
                                        #         Child Loop BB199_27 Depth 4
                                        #       Child Loop BB199_19 Depth 3
	testb	%al, %al
	je	.LBB199_57
# BB#13:                                # %while.cond19.i
                                        #   in Loop: Header=BB199_12 Depth=2
	cmpl	$3, %esi
	je	.LBB199_57
	jmp	.LBB199_14
	.align	16, 0x90
.LBB199_16:                             # %land.rhs30.while.cond27_crit_edge.i
                                        #   in Loop: Header=BB199_14 Depth=3
	movb	(%ebx), %al
.LBB199_14:                             # %while.cond27.i.preheader
                                        #   Parent Loop BB199_7 Depth=1
                                        #     Parent Loop BB199_12 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	incl	%ebx
	testb	%al, %al
	je	.LBB199_57
# BB#15:                                # %land.rhs30.i
                                        #   in Loop: Header=BB199_14 Depth=3
	movzbl	%al, %ecx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB199_16
# BB#17:                                # %while.end40.i
                                        #   in Loop: Header=BB199_12 Depth=2
	cmpb	$35, %al
	je	.LBB199_57
# BB#18:                                # %while.end40.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	%esi, -124(%ebp)        # 4-byte Spill
	movb	$1, %cl
	cmpb	$34, %al
	movl	%ebx, %eax
	jne	.LBB199_20
	.align	16, 0x90
.LBB199_19:                             # %for.body.i.i
                                        #   Parent Loop BB199_7 Depth=1
                                        #     Parent Loop BB199_12 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%eax), %dl
	movb	%dl, -1(%eax)
	incl	%eax
	xorb	%cl, %cl
	testb	%dl, %dl
	jne	.LBB199_19
.LBB199_20:                             # %if.end51.i
                                        #   in Loop: Header=BB199_12 Depth=2
	leal	-1(%ebx), %edi
	movl	%edi, -136(%ebp)        # 4-byte Spill
	jmp	.LBB199_21
	.align	16, 0x90
.LBB199_28:                             # %if.end73.i
                                        #   in Loop: Header=BB199_21 Depth=3
	incl	%ebx
	incl	%edi
.LBB199_21:                             # %while.cond52.i
                                        #   Parent Loop BB199_7 Depth=1
                                        #     Parent Loop BB199_12 Depth=2
                                        # =>    This Loop Header: Depth=3
                                        #         Child Loop BB199_27 Depth 4
	movzbl	(%edi), %eax
	movb	%al, %dl
	movb	$1, %ch
	testl	%eax, %eax
	je	.LBB199_29
# BB#22:                                # %land.rhs55.i
                                        #   in Loop: Header=BB199_21 Depth=3
	testb	%cl, %cl
	je	.LBB199_23
# BB#24:                                # %cond.false.i
                                        #   in Loop: Header=BB199_21 Depth=3
	movzwl	_sch_istable(%eax,%eax), %esi
	shrl	$6, %esi
	andl	$1, %esi
	xorl	$1, %esi
	jmp	.LBB199_25
.LBB199_23:                             # %cond.true.i
                                        #   in Loop: Header=BB199_21 Depth=3
	cmpb	$34, %dl
	setne	%al
	movzbl	%al, %esi
.LBB199_25:                             # %cond.end.i
                                        #   in Loop: Header=BB199_21 Depth=3
	xorb	%ch, %ch
	testl	%esi, %esi
	je	.LBB199_29
# BB#26:                                # %while.body68.i
                                        #   in Loop: Header=BB199_21 Depth=3
	cmpb	$92, %dl
	movl	%ebx, %eax
	jne	.LBB199_28
	.align	16, 0x90
.LBB199_27:                             # %for.body.i444.i
                                        #   Parent Loop BB199_7 Depth=1
                                        #     Parent Loop BB199_12 Depth=2
                                        #       Parent Loop BB199_21 Depth=3
                                        # =>      This Inner Loop Header: Depth=4
	movb	(%eax), %dl
	movb	%dl, -1(%eax)
	incl	%eax
	testb	%dl, %dl
	jne	.LBB199_27
	jmp	.LBB199_28
.LBB199_29:                             # %while.end75.i
                                        #   in Loop: Header=BB199_12 Depth=2
	testb	%cl, %cl
	jne	.LBB199_33
# BB#30:                                # %if.then77.i
                                        #   in Loop: Header=BB199_12 Depth=2
	testb	%ch, %ch
	jne	.LBB199_35
	.align	16, 0x90
.LBB199_31:                             # %for.body.i450.i
                                        #   Parent Loop BB199_7 Depth=1
                                        #     Parent Loop BB199_12 Depth=2
                                        # =>    This Inner Loop Header: Depth=3
	movb	(%ebx), %al
	movb	%al, -1(%ebx)
	incl	%ebx
	testb	%al, %al
	jne	.LBB199_31
# BB#32:                                # %if.end78.loopexit.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movb	(%edi), %dl
.LBB199_33:                             # %if.end78.i
                                        #   in Loop: Header=BB199_12 Depth=2
	testb	%dl, %dl
	je	.LBB199_35
# BB#34:                                # %if.then80.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movb	$0, (%edi)
	incl	%edi
.LBB199_35:                             # %if.then80.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	%edi, %ebx
	movl	-124(%ebp), %ecx        # 4-byte Reload
	xorl	%esi, %esi
	cmpl	$5, %ecx
	movl	-136(%ebp), %edi        # 4-byte Reload
	ja	.LBB199_56
# BB#36:                                # %if.end82.i
                                        #   in Loop: Header=BB199_12 Depth=2
	jmpl	*.LJTI199_0(,%ecx,4)
.LBB199_43:                             # %sw.bb99.i
                                        #   in Loop: Header=BB199_12 Depth=2
	cmpl	$0, -16(%ebp)
	movl	$0, %esi
	movl	$.L.str7893, %eax
	jmp	.LBB199_44
.LBB199_37:                             # %sw.bb.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	$.L.str4890, %esi
	movl	-16(%ebp), %eax
	movl	%eax, -140(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	je	.LBB199_45
# BB#38:                                # %if.then84.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	-140(%ebp), %ecx        # 4-byte Reload
	movl	%eax, 4(%ecx)
	jmp	.LBB199_55
.LBB199_42:                             # %sw.bb95.i
                                        #   in Loop: Header=BB199_12 Depth=2
	cmpl	$0, -16(%ebp)
	movl	$0, %esi
	movl	$.L.str6892, %eax
.LBB199_44:                             # %sw.bb99.i
                                        #   in Loop: Header=BB199_12 Depth=2
	cmovel	%eax, %esi
	testl	%esi, %esi
	je	.LBB199_46
	jmp	.LBB199_45
.LBB199_39:                             # %if.end107.thread.i
                                        #   in Loop: Header=BB199_12 Depth=2
	leal	-16(%ebp), %ecx
	leal	-20(%ebp), %edx
	calll	maybe_add_to_list
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	-16(%ebp), %ecx
	movl	%eax, (%ecx)
	jmp	.LBB199_55
.LBB199_40:                             # %sw.bb89.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	$.L.str5891, %esi
	movl	-16(%ebp), %eax
	movl	%eax, -140(%ebp)        # 4-byte Spill
	testl	%eax, %eax
	jne	.LBB199_41
.LBB199_45:                             # %if.then104.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	stderr, %eax
	movl	%eax, -140(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str8894, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$32, %esp
	movl	%esi, 20(%esp)
	movl	-128(%ebp), %edx        # 4-byte Reload
	movl	%edx, 16(%esp)
	movl	-132(%ebp), %edx        # 4-byte Reload
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	-140(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fprintf
	movl	-124(%ebp), %ecx        # 4-byte Reload
	addl	$32, %esp
.LBB199_46:                             # %if.end107.i
                                        #   in Loop: Header=BB199_12 Depth=2
	xorl	%esi, %esi
	testl	%ecx, %ecx
	jne	.LBB199_56
.LBB199_47:                             # %cond.false152.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str7893, 4(%esp)
	calll	strcmp
	addl	$16, %esp
	movl	$1, %esi
	testl	%eax, %eax
	je	.LBB199_56
# BB#48:                                # %cond.false204.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str9895, 4(%esp)
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB199_50
# BB#49:                                # %if.then209.i
                                        #   in Loop: Header=BB199_12 Depth=2
	leal	-16(%ebp), %ecx
	leal	-20(%ebp), %edx
	calll	maybe_add_to_list
	jmp	.LBB199_55
.LBB199_50:                             # %cond.false256.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str4890, 4(%esp)
	calll	strcmp
	addl	$16, %esp
	movl	$2, %esi
	testl	%eax, %eax
	je	.LBB199_56
# BB#51:                                # %cond.false308.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str6892, 4(%esp)
	calll	strcmp
	addl	$16, %esp
	movl	$3, %esi
	testl	%eax, %eax
	je	.LBB199_56
# BB#52:                                # %cond.false360.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str10896, 4(%esp)
	movl	$4, %esi
	calll	strcmp
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB199_56
# BB#53:                                # %cond.false412.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	movl	$.L.str5891, 4(%esp)
	calll	strcmp
	addl	$16, %esp
	movl	$5, %esi
	testl	%eax, %eax
	je	.LBB199_56
# BB#54:                                # %if.else418.i
                                        #   in Loop: Header=BB199_12 Depth=2
	movl	stderr, %esi
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str11897, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	exec_name, %ecx
	subl	$32, %esp
	movl	%edi, 20(%esp)
	movl	-128(%ebp), %edx        # 4-byte Reload
	movl	%edx, 16(%esp)
	movl	-132(%ebp), %edx        # 4-byte Reload
	movl	%edx, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	fprintf
	addl	$32, %esp
	jmp	.LBB199_55
.LBB199_41:                             # %if.then91.i
                                        #   in Loop: Header=BB199_12 Depth=2
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	movl	-140(%ebp), %ecx        # 4-byte Reload
	movl	%eax, 8(%ecx)
.LBB199_55:                             # %if.else418.i
                                        #   in Loop: Header=BB199_12 Depth=2
	xorl	%esi, %esi
	jmp	.LBB199_56
.LBB199_57:                             # %while.end428.i
                                        #   in Loop: Header=BB199_7 Depth=1
	subl	$16, %esp
	movl	-144(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	subl	$16, %esp
	movl	-148(%ebp), %edi        # 4-byte Reload
	movl	%edi, (%esp)
	incl	-128(%ebp)              # 4-byte Folded Spill
	calll	read_whole_line
	movl	%esi, %edx
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB199_7
.LBB199_58:                             # %while.end429.i
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	fclose
	addl	$16, %esp
	leal	-16(%ebp), %ecx
	leal	-20(%ebp), %edx
	calll	maybe_add_to_list
	movl	-16(%ebp), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	-20(%ebp), %eax
	movl	%eax, -16(%ebp)
	movl	$0, -20(%ebp)
	xorl	%ecx, %ecx
	testl	%eax, %eax
	je	.LBB199_59
	.align	16, 0x90
.LBB199_60:                             # %while.body433.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %esi
	movl	12(%esi), %eax
	movl	%ecx, 12(%esi)
	testl	%eax, %eax
	movl	%esi, %ecx
	jne	.LBB199_60
# BB#61:                                # %while.cond431.return.loopexit_crit_edge.i
	movl	$0, -16(%ebp)
	movl	%esi, -20(%ebp)
	movl	%esi, netrc_list
	jmp	.LBB199_64
.LBB199_85:                             # %if.then.i
	movl	stderr, %eax
	movl	%eax, -124(%ebp)        # 4-byte Spill
	subl	$16, %esp
	movl	$5, 8(%esp)
	movl	$.L.str3889, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$16, %esp
	movl	%eax, %edi
	movl	exec_name, %ebx
	calll	__errno_location
	movl	(%eax), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	strerror
	addl	$16, %esp
	subl	$32, %esp
	movl	%eax, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	-124(%ebp), %eax        # 4-byte Reload
	movl	%eax, (%esp)
	calll	fprintf
	addl	$32, %esp
	xorl	%esi, %esi
	movl	%esi, netrc_list
	jmp	.LBB199_64
.LBB199_75:                             # %if.else43
	movl	12(%ebp), %ecx
	movl	%eax, (%ecx)
	movl	8(%edi), %eax
	testl	%eax, %eax
	jne	.LBB199_83
	jmp	.LBB199_84
.LBB199_73:                             # %if.then39
	movl	8(%edi), %eax
.LBB199_83:                             # %if.then73
	movl	16(%ebp), %ecx
	movl	%eax, (%ecx)
.LBB199_84:                             # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB199_59:
	xorl	%esi, %esi
	movl	%esi, netrc_list
	jmp	.LBB199_64
.Ltmp199:
	.size	search_netrc, .Ltmp199-search_netrc
	.section	.rodata,"a",@progbits
	.align	4
.LJTI199_0:
	.long	.LBB199_47
	.long	.LBB199_43
	.long	.LBB199_37
	.long	.LBB199_42
	.long	.LBB199_39
	.long	.LBB199_40

	.text
	.globl	free_netrc
	.align	16, 0x90
	.type	free_netrc,@function
free_netrc:                             # @free_netrc
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	16(%esp), %esi
	testl	%esi, %esi
	je	.LBB200_8
	.align	16, 0x90
.LBB200_1:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	4(%esi), %eax
	movl	12(%esi), %edi
	testl	%eax, %eax
	je	.LBB200_3
# BB#2:                                 # %if.else
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB200_3:                              # %if.end
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	8(%esi), %eax
	testl	%eax, %eax
	je	.LBB200_5
# BB#4:                                 # %if.else5
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB200_5:                              # %if.end7
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	(%esi), %eax
	testl	%eax, %eax
	je	.LBB200_7
# BB#6:                                 # %if.else10
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB200_7:                              # %if.end12
                                        #   in Loop: Header=BB200_1 Depth=1
	movl	%esi, (%esp)
	calll	checking_free
	testl	%edi, %edi
	movl	%edi, %esi
	jne	.LBB200_1
.LBB200_8:                              # %while.end
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp200:
	.size	free_netrc, .Ltmp200-free_netrc

	.align	16, 0x90
	.type	maybe_add_to_list,@function
maybe_add_to_list:                      # @maybe_add_to_list
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%edx, %esi
	movl	%ecx, %edi
	movl	(%esi), %ebp
	movl	(%edi), %ebx
	testl	%ebx, %ebx
	je	.LBB201_8
# BB#1:                                 # %land.lhs.true
	cmpl	$0, 4(%ebx)
	je	.LBB201_2
# BB#7:                                 # %if.then18
	movl	%ebp, 12(%ebx)
	movl	%ebx, %ebp
.LBB201_8:                              # %if.end19
	movl	$16, (%esp)
	calll	checking_malloc
	movl	%eax, %ebx
	.align	16, 0x90
.LBB201_9:                              # %if.end20
	movl	$0, 4(%ebx)
	movl	$0, (%ebx)
	movl	$0, 12(%ebx)
	movl	$0, 8(%ebx)
	movl	%ebx, (%edi)
	movl	%ebp, (%esi)
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB201_2:                              # %if.then
	movl	(%ebx), %eax
	testl	%eax, %eax
	je	.LBB201_5
# BB#3:                                 # %if.end
	movl	%eax, (%esp)
	calll	checking_free
	movl	4(%ebx), %eax
	testl	%eax, %eax
	je	.LBB201_5
# BB#4:                                 # %if.else8
	movl	%eax, (%esp)
	calll	checking_free
.LBB201_5:                              # %if.end10
	movl	8(%ebx), %eax
	testl	%eax, %eax
	je	.LBB201_9
# BB#6:                                 # %if.else13
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB201_9
.Ltmp201:
	.size	maybe_add_to_list, .Ltmp201-maybe_add_to_list

	.globl	valid_progress_implementation_p
	.align	16, 0x90
	.type	valid_progress_implementation_p,@function
valid_progress_implementation_p:        # @valid_progress_implementation_p
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %edi
	movl	%edi, (%esp)
	movl	$58, 4(%esp)
	calll	strchr
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB202_2
# BB#1:                                 # %cond.true
	subl	%edi, %esi
	jmp	.LBB202_3
.LBB202_2:                              # %cond.false
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %esi
.LBB202_3:                              # %cond.end
	movl	$implementations, %ebx
	movl	$-1, %ebp
	.align	16, 0x90
.LBB202_4:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	incl	%ebp
	xorb	%cl, %cl
	cmpl	$1, %ebp
	ja	.LBB202_6
# BB#5:                                 # %cond.false9
                                        #   in Loop: Header=BB202_4 Depth=1
	movl	(%ebx), %eax
	addl	$24, %ebx
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	strncmp
	movb	$1, %cl
	testl	%eax, %eax
	jne	.LBB202_4
.LBB202_6:                              # %return
	movzbl	%cl, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp202:
	.size	valid_progress_implementation_p, .Ltmp202-valid_progress_implementation_p

	.globl	set_progress_implementation
	.align	16, 0x90
	.type	set_progress_implementation,@function
set_progress_implementation:            # @set_progress_implementation
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %eax
	testl	%eax, %eax
	movl	$.L.str900, %ebx
	cmovnel	%eax, %ebx
	movl	%ebx, (%esp)
	movl	$58, 4(%esp)
	calll	strchr
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB203_2
# BB#1:                                 # %cond.true
	movl	%esi, %edi
	subl	%ebx, %edi
	movl	%ebx, 24(%esp)          # 4-byte Spill
	jmp	.LBB203_3
.LBB203_2:                              # %cond.false
	movl	%ebx, (%esp)
	movl	%ebx, 24(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, %edi
.LBB203_3:                              # %cond.end
	movl	%esi, 20(%esp)          # 4-byte Spill
	movl	$implementations, %ebx
	movl	$-1, %ebp
	.align	16, 0x90
.LBB203_4:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebx, %esi
	incl	%ebp
	cmpl	$1, %ebp
	ja	.LBB203_9
# BB#5:                                 # %cond.false10
                                        #   in Loop: Header=BB203_4 Depth=1
	leal	24(%esi), %ebx
	movl	(%esi), %eax
	movl	%edi, 8(%esp)
	movl	24(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strncmp
	testl	%eax, %eax
	jne	.LBB203_4
# BB#6:                                 # %if.then14
	movl	%esi, current_impl
	movb	$0, current_impl_locked.b
	movl	20(%esi), %eax
	testl	%eax, %eax
	je	.LBB203_8
# BB#7:                                 # %if.then19
	xorl	%edx, %edx
	movl	20(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	leal	1(%ecx), %ecx
	cmovel	%edx, %ecx
	movl	%ecx, (%esp)
	calll	*%eax
.LBB203_8:                              # %if.end21
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB203_9:                              # %for.end
	calll	abort
.Ltmp203:
	.size	set_progress_implementation, .Ltmp203-set_progress_implementation

	.globl	progress_schedule_redirect
	.align	16, 0x90
	.type	progress_schedule_redirect,@function
progress_schedule_redirect:             # @progress_schedule_redirect
# BB#0:                                 # %entry
	movb	$1, output_redirected.b
	ret
.Ltmp204:
	.size	progress_schedule_redirect, .Ltmp204-progress_schedule_redirect

	.globl	progress_create
	.align	16, 0x90
	.type	progress_create,@function
progress_create:                        # @progress_create
# BB#0:                                 # %entry
	subl	$12, %esp
	movb	output_redirected.b, %al
	cmpb	$1, %al
	jne	.LBB205_4
# BB#1:                                 # %if.then
	movb	current_impl_locked.b, %al
	testb	%al, %al
	jne	.LBB205_3
# BB#2:                                 # %if.then2
	movl	$.L.str1901, (%esp)
	calll	set_progress_implementation
.LBB205_3:                              # %if.end
	movb	$0, output_redirected.b
.LBB205_4:                              # %if.end3
	movl	current_impl, %eax
	addl	$12, %esp
	jmpl	*8(%eax)  # TAILCALL
.Ltmp205:
	.size	progress_create, .Ltmp205-progress_create

	.globl	progress_interactive_p
	.align	16, 0x90
	.type	progress_interactive_p,@function
progress_interactive_p:                 # @progress_interactive_p
# BB#0:                                 # %entry
	movl	current_impl, %eax
	movzbl	4(%eax), %eax
	ret
.Ltmp206:
	.size	progress_interactive_p, .Ltmp206-progress_interactive_p

	.globl	progress_update
	.align	16, 0x90
	.type	progress_update,@function
progress_update:                        # @progress_update
# BB#0:                                 # %entry
	movl	current_impl, %eax
	jmpl	*12(%eax)  # TAILCALL
.Ltmp207:
	.size	progress_update, .Ltmp207-progress_update

	.globl	progress_finish
	.align	16, 0x90
	.type	progress_finish,@function
progress_finish:                        # @progress_finish
# BB#0:                                 # %entry
	movl	current_impl, %eax
	jmpl	*16(%eax)  # TAILCALL
.Ltmp208:
	.size	progress_finish, .Ltmp208-progress_finish

	.globl	count_cols
	.align	16, 0x90
	.type	count_cols,@function
count_cols:                             # @count_cols
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %ebp
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, %edi
	xorl	%esi, %esi
	jmp	.LBB209_1
	.align	16, 0x90
.LBB209_4:                              # %if.end
                                        #   in Loop: Header=BB209_1 Depth=1
	movl	24(%esp), %eax
	movl	%eax, (%esp)
	calll	wcwidth
	cmpl	$-1, %eax
	movl	$1, %ecx
	cmovel	%ecx, %eax
	addl	%eax, %esi
	subl	%ebx, %edi
	addl	%ebx, %ebp
.LBB209_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpb	$0, (%ebp)
	je	.LBB209_6
# BB#2:                                 # %while.body
                                        #   in Loop: Header=BB209_1 Depth=1
	movl	%edi, 8(%esp)
	movl	%ebp, 4(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	mbtowc
	movl	%eax, %ebx
	cmpl	$-1, %ebx
	je	.LBB209_5
# BB#3:                                 # %while.body
                                        #   in Loop: Header=BB209_1 Depth=1
	testl	%ebx, %ebx
	jne	.LBB209_4
# BB#7:                                 # %cond.false
	movl	$.L__PRETTY_FUNCTION__.count_cols, 12(%esp)
	movl	$784, 8(%esp)           # imm = 0x310
	movl	$.L.str3903, 4(%esp)
	movl	$.L.str2902, (%esp)
	calll	__assert_fail
.LBB209_5:                              # %if.then
	addl	%edi, %esi
.LBB209_6:                              # %return
	movl	%esi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp209:
	.size	count_cols, .Ltmp209-count_cols

	.globl	get_eta
	.align	16, 0x90
	.type	get_eta,@function
get_eta:                                # @get_eta
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %ebx
	cmpl	$0, get_eta.eta_trans
	jne	.LBB210_2
# BB#1:                                 # %if.then
	movl	$5, 8(%esp)
	movl	$get_eta.eta_str, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	movl	%esi, get_eta.eta_trans
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	count_cols
	subl	%eax, %edi
	movl	%edi, get_eta.bytes_cols_diff
.LBB210_2:                              # %if.end
	testl	%ebx, %ebx
	je	.LBB210_4
# BB#3:                                 # %if.then4
	movl	get_eta.bytes_cols_diff, %eax
	movl	%eax, (%ebx)
.LBB210_4:                              # %if.end5
	movl	get_eta.eta_trans, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp210:
	.size	get_eta, .Ltmp210-get_eta

	.globl	progress_handle_sigwinch
	.align	16, 0x90
	.type	progress_handle_sigwinch,@function
progress_handle_sigwinch:               # @progress_handle_sigwinch
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	$1, received_sigwinch
	movl	$progress_handle_sigwinch, 4(%esp)
	movl	$28, (%esp)
	calll	signal
	addl	$12, %esp
	ret
.Ltmp211:
	.size	progress_handle_sigwinch, .Ltmp211-progress_handle_sigwinch

	.align	16, 0x90
	.type	dot_create,@function
dot_create:                             # @dot_create
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	$36, (%esp)
	calll	checking_malloc0
	movl	%eax, %esi
	movl	84(%esp), %ebp
	movl	%ebp, 4(%esi)
	movl	80(%esp), %ebx
	movl	%ebx, (%esi)
	movl	88(%esp), %eax
	movl	92(%esp), %ecx
	movl	%ecx, 12(%esi)
	movl	%eax, 8(%esi)
	movl	%ebx, %eax
	orl	%ebp, %eax
	je	.LBB212_10
# BB#1:                                 # %if.then
	movl	opt+280, %ecx
	movl	opt+272, %edi
	movl	%ecx, %eax
	mull	%edi
	movl	%eax, 44(%esp)          # 4-byte Spill
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	%ecx, %eax
	sarl	$31, %eax
	imull	%edi, %eax
	imull	opt+276, %ecx
	addl	%edx, %ecx
	addl	%eax, %ecx
	movl	%ecx, 48(%esp)          # 4-byte Spill
	movl	%ecx, 12(%esp)
	calll	__moddi3
	movl	%ebx, %edx
	movl	%ebp, %ebx
	movl	%eax, %ebp
	sarl	$31, %eax
	movl	%ebp, %ecx
	xorl	%edx, %ecx
	movl	%ecx, 36(%esp)          # 4-byte Spill
	subl	%ebp, %edx
	movl	%edx, 52(%esp)          # 4-byte Spill
	movl	%ebx, %ecx
	sbbl	%eax, %ecx
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	%ecx, %ebx
	sarl	$31, %ebx
	shrl	$22, %ebx
	addl	%edx, %ebx
	adcl	$0, %ecx
	shrdl	$10, %ecx, %ebx
	sarl	$10, %ecx
	movl	%ecx, 56(%esp)          # 4-byte Spill
	xorl	84(%esp), %eax
	orl	36(%esp), %eax          # 4-byte Folded Reload
	je	.LBB212_3
# BB#2:                                 # %if.then8
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	numdigit
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	$5, 8(%esp)
	movl	$.L.str44942, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	number_to_static_string
	movl	%eax, 16(%esp)
	movl	$8, %eax
	movl	36(%esp), %ecx          # 4-byte Reload
	cmpl	$6, %ecx
	leal	2(%ecx), %ecx
	cmovll	%eax, %ecx
	movl	%ecx, 8(%esp)
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str25923, 12(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB212_3:                              # %if.end14
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	$.L.str38936, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	24(%esi), %eax
	jmp	.LBB212_4
	.align	16, 0x90
.LBB212_7:                              # %if.end23
                                        #   in Loop: Header=BB212_4 Depth=1
	movl	$.L.str45943, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	24(%esi), %eax
	incl	%eax
	movl	%eax, 24(%esi)
	subl	%edi, %ebp
.LBB212_4:                              # %if.end14
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%edi, %ebp
	jl	.LBB212_8
# BB#5:                                 # %for.body
                                        #   in Loop: Header=BB212_4 Depth=1
	cltd
	idivl	opt+284
	testl	%edx, %edx
	jne	.LBB212_7
# BB#6:                                 # %if.then22
                                        #   in Loop: Header=BB212_4 Depth=1
	movl	$.L.str26924, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	jmp	.LBB212_7
.LBB212_8:                              # %for.end
	cmpl	opt+280, %eax
	jge	.LBB212_11
# BB#9:                                 # %cond.end
	movl	%ebp, 16(%esi)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	__divdi3
	movl	%eax, 20(%esi)
.LBB212_10:                             # %if.end31
	movl	%esi, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB212_11:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.dot_create, 12(%esp)
	movl	$257, 8(%esp)           # imm = 0x101
	movl	$.L.str3903, 4(%esp)
	movl	$.L.str46944, (%esp)
	calll	__assert_fail
.Ltmp212:
	.size	dot_create, .Ltmp212-dot_create

	.align	16, 0x90
	.type	dot_update,@function
dot_update:                             # @dot_update
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	opt+276, %ebx
	movl	opt+272, %ebp
	movl	opt+280, %edi
	movl	$0, (%esp)
	calll	log_set_flush
	movl	48(%esp), %esi
	movl	16(%esi), %eax
	addl	52(%esp), %eax
	movl	%eax, 16(%esi)
	cmpl	%ebp, %eax
	jl	.LBB213_9
# BB#1:                                 # %for.body.lr.ph
	movl	%edi, %ecx
	sarl	$31, %ecx
	movl	%edi, %eax
	mull	%ebp
	movl	%edi, 24(%esp)          # 4-byte Spill
	movl	%eax, %edi
	imull	24(%esp), %ebx          # 4-byte Folded Reload
	addl	%edx, %ebx
	imull	%ebp, %ecx
	addl	%ebx, %ecx
	movl	%ecx, 24(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB213_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	24(%esi), %eax
	testl	%eax, %eax
	jne	.LBB213_4
# BB#3:                                 # %if.then
                                        #   in Loop: Header=BB213_2 Depth=1
	movl	20(%esi), %ecx
	movl	%edi, %eax
	mull	%ecx
	movl	24(%esp), %ebx          # 4-byte Reload
	imull	%ecx, %ebx
	sarl	$31, %ecx
	imull	%edi, %ecx
	addl	%edx, %ecx
	addl	%ebx, %ecx
	movl	%ecx, %edx
	sarl	$31, %edx
	shrl	$22, %edx
	addl	%eax, %edx
	adcl	$0, %ecx
	movl	%ecx, %eax
	sarl	$10, %eax
	movl	%eax, 4(%esp)
	shldl	$22, %edx, %ecx
	movl	%ecx, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	$.L.str38936, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	24(%esi), %eax
.LBB213_4:                              # %if.end
                                        #   in Loop: Header=BB213_2 Depth=1
	cltd
	idivl	opt+284
	testl	%edx, %edx
	jne	.LBB213_6
# BB#5:                                 # %if.then13
                                        #   in Loop: Header=BB213_2 Depth=1
	movl	$.L.str26924, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
.LBB213_6:                              # %if.end14
                                        #   in Loop: Header=BB213_2 Depth=1
	movl	$.L.str43941, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	24(%esi), %eax
	incl	%eax
	movl	%eax, 24(%esi)
	cmpl	opt+280, %eax
	jl	.LBB213_8
# BB#7:                                 # %if.then19
                                        #   in Loop: Header=BB213_2 Depth=1
	incl	20(%esi)
	movl	$0, 24(%esi)
	movl	%esi, %ecx
	movsd	60(%esp), %xmm0
	xorl	%edx, %edx
	calll	print_row_stats
.LBB213_8:                              # %for.inc
                                        #   in Loop: Header=BB213_2 Depth=1
	movl	16(%esi), %eax
	subl	%ebp, %eax
	movl	%eax, 16(%esi)
	cmpl	%ebp, %eax
	jge	.LBB213_2
.LBB213_9:                              # %for.end
	movl	$1, (%esp)
	calll	log_set_flush
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp213:
	.size	dot_update, .Ltmp213-dot_update

	.align	16, 0x90
	.type	dot_finish,@function
dot_finish:                             # @dot_finish
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	opt+276, %esi
	movl	opt+272, %ebx
	movl	opt+280, %ebp
	movl	$0, (%esp)
	calll	log_set_flush
	movl	48(%esp), %ecx
	movl	24(%ecx), %edi
	testl	%edi, %edi
	jne	.LBB214_2
# BB#1:                                 # %if.then
	movl	%ebp, %eax
	movl	%eax, 16(%esp)          # 4-byte Spill
	sarl	$31, %ebp
	mull	%ebx
	movl	%eax, %edi
	movl	%edx, 20(%esp)          # 4-byte Spill
	movl	%ebx, 24(%esp)          # 4-byte Spill
	movl	20(%ecx), %ecx
	movl	%edi, %ebx
	movl	%ecx, %edi
	mull	%edi
	movl	%edi, %ecx
	sarl	$31, %ecx
	imull	%ebx, %ecx
	addl	%edx, %ecx
	imull	16(%esp), %esi          # 4-byte Folded Reload
	addl	20(%esp), %esi          # 4-byte Folded Reload
	imull	24(%esp), %ebp          # 4-byte Folded Reload
	addl	%esi, %ebp
	imull	%edi, %ebp
	addl	%ecx, %ebp
	movl	%ebp, %ecx
	sarl	$31, %ecx
	shrl	$22, %ecx
	addl	%eax, %ecx
	adcl	$0, %ebp
	movl	%ebp, %eax
	sarl	$10, %eax
	movl	%eax, 4(%esp)
	shldl	$22, %ecx, %ebp
	movl	%ebp, (%esp)
	calll	number_to_static_string
	movl	%eax, 8(%esp)
	movl	$.L.str38936, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	48(%esp), %ecx
	movl	24(%ecx), %edi
.LBB214_2:                              # %if.end
	movl	%ecx, %esi
	jmp	.LBB214_3
	.align	16, 0x90
.LBB214_6:                              # %if.end10
                                        #   in Loop: Header=BB214_3 Depth=1
	movl	$.L.str26924, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	incl	%edi
.LBB214_3:                              # %if.end
                                        # =>This Inner Loop Header: Depth=1
	cmpl	opt+280, %edi
	jge	.LBB214_7
# BB#4:                                 # %for.body
                                        #   in Loop: Header=BB214_3 Depth=1
	movl	%edi, %eax
	cltd
	idivl	opt+284
	testl	%edx, %edx
	jne	.LBB214_6
# BB#5:                                 # %if.then9
                                        #   in Loop: Header=BB214_3 Depth=1
	movl	$.L.str26924, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	jmp	.LBB214_6
.LBB214_7:                              # %for.end
	movsd	52(%esp), %xmm0
	movl	%esi, %ecx
	movl	$1, %edx
	calll	print_row_stats
	movl	$.L.str7907, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	$0, (%esp)
	calll	log_set_flush
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	jmp	checking_free           # TAILCALL
.Ltmp214:
	.size	dot_finish, .Ltmp214-dot_finish

	.align	16, 0x90
	.type	dot_set_params,@function
dot_set_params:                         # @dot_set_params
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	32(%esp), %esi
	testl	%esi, %esi
	je	.LBB215_2
# BB#1:                                 # %lor.lhs.false
	cmpb	$0, (%esi)
	jne	.LBB215_3
.LBB215_2:                              # %if.end
	movl	opt+268, %esi
	testl	%esi, %esi
	je	.LBB215_12
.LBB215_3:                              # %if.end4
	movl	%esi, (%esp)
	movl	$.L.str33931, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB215_4
# BB#5:                                 # %if.else
	movl	%esi, (%esp)
	movl	$.L.str34932, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB215_6
# BB#7:                                 # %if.else10
	movl	%esi, (%esp)
	movl	$.L.str35933, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB215_8
# BB#9:                                 # %if.else14
	movl	%esi, (%esp)
	movl	$.L.str36934, 4(%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB215_10
# BB#11:                                # %if.else18
	movl	stderr, %edi
	movl	$5, 8(%esp)
	movl	$.L.str37935, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	fprintf
	jmp	.LBB215_12
.LBB215_4:                              # %if.then6
	movl	$0, opt+276
	movl	$1024, opt+272          # imm = 0x400
	movl	$10, opt+284
	movl	$50, opt+280
	jmp	.LBB215_12
.LBB215_6:                              # %if.then9
	movl	$0, opt+276
	movl	$8192, opt+272          # imm = 0x2000
	movl	$16, opt+284
	movl	$48, opt+280
	jmp	.LBB215_12
.LBB215_8:                              # %if.then13
	movl	$0, opt+276
	movl	$65536, opt+272         # imm = 0x10000
	movl	$8, opt+284
	movl	$48, opt+280
	jmp	.LBB215_12
.LBB215_10:                             # %if.then17
	movl	$0, opt+276
	movl	$1048576, opt+272       # imm = 0x100000
	movl	$8, opt+284
	movl	$32, opt+280
.LBB215_12:                             # %if.end24
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp215:
	.size	dot_set_params, .Ltmp215-dot_set_params

	.align	16, 0x90
	.type	bar_create,@function
bar_create:                             # @bar_create
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	$416, (%esp)            # imm = 0x1A0
	calll	checking_malloc0
	movl	%eax, %esi
	movl	32(%esp), %eax
	movl	36(%esp), %edx
	movl	%edx, 4(%esi)
	movl	%eax, (%esi)
	movl	40(%esp), %ecx
	movl	44(%esp), %edi
	cmpl	%ecx, %eax
	setae	%bl
	cmpl	%edi, %edx
	setge	%bh
	je	.LBB216_2
# BB#1:                                 # %entry
	movb	%bh, %bl
.LBB216_2:                              # %entry
	testb	%bl, %bl
	cmovnel	%edx, %edi
	movl	%edi, 12(%esi)
	cmovnel	%eax, %ecx
	movl	%ecx, 8(%esi)
	cmpl	$0, screen_width
	je	.LBB216_4
# BB#3:                                 # %lor.lhs.false
	cmpl	$0, received_sigwinch
	je	.LBB216_9
.LBB216_4:                              # %if.then2
	calll	determine_screen_width
	movl	%eax, screen_width
	testl	%eax, %eax
	je	.LBB216_5
# BB#6:                                 # %if.else
	cmpl	$44, %eax
	jg	.LBB216_8
# BB#7:                                 # %if.then7
	movl	$45, screen_width
	jmp	.LBB216_8
.LBB216_5:                              # %if.then5
	movl	$80, screen_width
.LBB216_8:                              # %if.end9
	movl	$0, received_sigwinch
.LBB216_9:                              # %if.end10
	movl	screen_width, %eax
	leal	-1(%eax), %ecx
	movl	%ecx, 32(%esi)
	addl	$99, %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, 36(%esi)
	movl	$.L.str32930, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	%esi, %ecx
	xorps	%xmm0, %xmm0
	xorl	%edx, %edx
	calll	create_image
	movl	36(%esi), %edi
	movl	$0, (%esp)
	calll	log_set_save_context
	movb	%al, %bl
	movl	$.L.str8908, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movzbl	%bl, %eax
	movl	%eax, (%esp)
	calll	log_set_save_context
	movl	%esi, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp216:
	.size	bar_create, .Ltmp216-bar_create

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI217_0:
	.quad	4594572339843380019     # double 1.500000e-01
                                        #  (0x33333333)
.LCPI217_1:
	.quad	4607182418800017408     # double 1.000000e+00
                                        #  (0x0)
.LCPI217_2:
	.quad	4617315517961601024     # double 5.000000e+00
                                        #  (0x0)
.LCPI217_3:
	.quad	4596373779694328218     # double 2.000000e-01
                                        #  (0x9999999a)
	.text
	.align	16, 0x90
	.type	bar_update,@function
bar_update:                             # @bar_update
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %esi
	movl	20(%esi), %edi
	movl	16(%esi), %ecx
	addl	36(%esp), %ecx
	movl	%ecx, 16(%esi)
	adcl	40(%esp), %edi
	movl	%edi, 20(%esi)
	movl	8(%esi), %ebp
	movl	12(%esi), %ebx
	testl	%ebp, %ebp
	sete	%dl
	testl	%ebx, %ebx
	sets	%al
	je	.LBB217_2
# BB#1:                                 # %entry
	movb	%al, %dl
.LBB217_2:                              # %entry
	testb	%dl, %dl
	jne	.LBB217_7
# BB#3:                                 # %land.lhs.true
	movl	4(%esi), %edx
	addl	(%esi), %ecx
	adcl	%edi, %edx
	cmpl	%ebp, %ecx
	setbe	%al
	cmpl	%ebx, %edx
	setle	%ah
	je	.LBB217_5
# BB#4:                                 # %land.lhs.true
	movb	%ah, %al
.LBB217_5:                              # %land.lhs.true
	testb	%al, %al
	jne	.LBB217_7
# BB#6:                                 # %if.then
	movl	%ecx, 8(%esi)
	movl	%edx, 12(%esi)
.LBB217_7:                              # %if.end
	movsd	44(%esp), %xmm0
	subsd	384(%esi), %xmm0
	movl	396(%esi), %eax
	movl	392(%esi), %ecx
	movl	36(%esp), %edx
	addl	%edx, %ecx
	movl	%ecx, 392(%esi)
	movl	40(%esp), %edi
	adcl	%edi, %eax
	movl	%eax, 396(%esi)
	movsd	.LCPI217_0, %xmm1
	ucomisd	%xmm0, %xmm1
	ja	.LBB217_15
# BB#8:                                 # %if.end.i
	leal	44(%esi), %ecx
	orl	%edi, %edx
	je	.LBB217_9
# BB#11:                                # %if.end8.i
	cmpb	$0, 400(%esi)
	je	.LBB217_13
# BB#12:                                # %if.then10.i
	movb	$0, 400(%esi)
	movsd	.LCPI217_1, %xmm0
.LBB217_13:                             # %if.end12.i
	movl	44(%esi), %eax
	movsd	368(%esi), %xmm1
	subsd	48(%esi,%eax,8), %xmm1
	movsd	%xmm1, 368(%esi)
	movl	376(%esi), %edx
	movl	380(%esi), %edi
	subl	208(%esi,%eax,8), %edx
	sbbl	212(%esi,%eax,8), %edi
	movl	%edi, 380(%esi)
	movl	%edx, 376(%esi)
	movsd	%xmm0, 48(%esi,%eax,8)
	movsd	392(%esi), %xmm1
	movl	44(%esi), %eax
	movsd	%xmm1, 208(%esi,%eax,8)
	addsd	368(%esi), %xmm0
	movsd	%xmm0, 368(%esi)
	movl	376(%esi), %eax
	movl	380(%esi), %edx
	addl	392(%esi), %eax
	adcl	396(%esi), %edx
	movl	%edx, 380(%esi)
	movl	%eax, 376(%esi)
	movsd	44(%esp), %xmm0
	movsd	%xmm0, 384(%esi)
	movl	$0, 396(%esi)
	movl	$0, 392(%esi)
	movl	44(%esi), %eax
	incl	%eax
	movl	%eax, 44(%esi)
	cmpl	$20, %eax
	jne	.LBB217_15
# BB#14:                                # %if.then33.i
	movl	$0, (%ecx)
	jmp	.LBB217_15
.LBB217_9:                              # %if.then3.i
	ucomisd	.LCPI217_2, %xmm0
	jb	.LBB217_15
# BB#10:                                # %if.then5.i
	movb	$1, 400(%esi)
	movl	%ecx, (%esp)
	movl	$340, 8(%esp)           # imm = 0x154
	movl	$0, 4(%esp)
	calll	memset
	movl	$0, 396(%esi)
	movl	$0, 392(%esi)
.LBB217_15:                             # %update_speed_ring.exit
	xorb	%cl, %cl
	cmpl	$0, received_sigwinch
	je	.LBB217_23
# BB#16:                                # %if.then9
	movl	screen_width, %edi
	calll	determine_screen_width
	movl	%eax, screen_width
	testl	%eax, %eax
	je	.LBB217_17
# BB#18:                                # %if.else
	cmpl	$44, %eax
	jg	.LBB217_20
# BB#19:                                # %if.then13
	movl	$45, screen_width
	movl	$45, %eax
	jmp	.LBB217_20
.LBB217_17:                             # %if.then11
	movl	$80, screen_width
	movl	$80, %eax
.LBB217_20:                             # %if.end15
	xorb	%cl, %cl
	cmpl	%edi, %eax
	je	.LBB217_22
# BB#21:                                # %if.then17
	leal	-1(%eax), %ecx
	movl	%ecx, 32(%esi)
	movl	36(%esi), %ecx
	addl	$99, %eax
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 36(%esi)
	movb	$1, %cl
.LBB217_22:                             # %if.end22
	movl	$0, received_sigwinch
.LBB217_23:                             # %if.end23
	movsd	44(%esp), %xmm0
	subsd	24(%esi), %xmm0
	movsd	.LCPI217_3, %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB217_25
# BB#24:                                # %land.lhs.true26
	testb	%cl, %cl
	je	.LBB217_26
.LBB217_25:                             # %if.end29
	movl	%esi, %ecx
	movsd	44(%esp), %xmm0
	xorl	%edx, %edx
	calll	create_image
	movl	36(%esi), %edi
	movl	$0, (%esp)
	calll	log_set_save_context
	movb	%al, %bl
	movl	$.L.str8908, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movzbl	%bl, %eax
	movl	%eax, (%esp)
	calll	log_set_save_context
	movsd	44(%esp), %xmm0
	movsd	%xmm0, 24(%esi)
.LBB217_26:                             # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp217:
	.size	bar_update, .Ltmp217-bar_update

	.align	16, 0x90
	.type	bar_finish,@function
bar_finish:                             # @bar_finish
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %esi
	movl	8(%esi), %ecx
	movl	12(%esi), %eax
	testl	%ecx, %ecx
	sete	%dl
	testl	%eax, %eax
	sets	%dh
	je	.LBB218_2
# BB#1:                                 # %entry
	movb	%dh, %dl
.LBB218_2:                              # %entry
	testb	%dl, %dl
	jne	.LBB218_7
# BB#3:                                 # %land.lhs.true
	movl	(%esi), %edx
	movl	4(%esi), %edi
	addl	16(%esi), %edx
	adcl	20(%esi), %edi
	cmpl	%ecx, %edx
	setbe	%cl
	cmpl	%eax, %edi
	setle	%al
	je	.LBB218_5
# BB#4:                                 # %land.lhs.true
	movb	%al, %cl
.LBB218_5:                              # %land.lhs.true
	testb	%cl, %cl
	jne	.LBB218_7
# BB#6:                                 # %if.then
	movl	%edx, 8(%esi)
	movl	%edi, 12(%esi)
.LBB218_7:                              # %if.end
	movsd	36(%esp), %xmm0
	movl	%esi, %ecx
	movl	$1, %edx
	calll	create_image
	movl	36(%esi), %edi
	movl	$0, (%esp)
	calll	log_set_save_context
	movb	%al, %bl
	movl	$.L.str8908, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movzbl	%bl, %eax
	movl	%eax, (%esp)
	calll	log_set_save_context
	movl	$.L.str7907, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	36(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	jmp	checking_free           # TAILCALL
.Ltmp218:
	.size	bar_finish, .Ltmp218-bar_finish

	.align	16, 0x90
	.type	bar_set_params,@function
bar_set_params:                         # @bar_set_params
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	$.L.str4904, (%esp)
	calll	getenv
	movl	%eax, %esi
	movl	16(%esp), %eax
	testl	%eax, %eax
	je	.LBB219_3
# BB#1:                                 # %cond.false
	movl	%eax, (%esp)
	movl	$.L.str5905, 4(%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB219_3
# BB#2:                                 # %if.then37
	movb	$1, current_impl_locked.b
.LBB219_3:                              # %if.end38
	cmpl	$0, opt+48
	jne	.LBB219_8
# BB#4:                                 # %lor.lhs.false
	movl	stderr, %eax
	movl	%eax, (%esp)
	calll	fileno
	movl	%eax, (%esp)
	calll	isatty
	testl	%eax, %eax
	je	.LBB219_8
# BB#5:                                 # %lor.lhs.false43
	testl	%esi, %esi
	je	.LBB219_10
# BB#6:                                 # %cond.false91
	movl	%esi, (%esp)
	movl	$.L.str6906, 4(%esp)
	calll	strcmp
	testl	%eax, %eax
	jne	.LBB219_10
# BB#7:                                 # %cond.false91
	movb	current_impl_locked.b, %al
	testb	$1, %al
	je	.LBB219_9
	jmp	.LBB219_10
.LBB219_8:                              # %land.lhs.true97
	movb	current_impl_locked.b, %al
	testb	%al, %al
	jne	.LBB219_10
.LBB219_9:                              # %if.then99
	movl	$.L.str1901, (%esp)
	calll	set_progress_implementation
.LBB219_10:                             # %if.end100
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp219:
	.size	bar_set_params, .Ltmp219-bar_set_params

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI220_0:
	.quad	4636737291354636288     # double 1.000000e+02
                                        #  (0x0)
.LCPI220_1:
	.quad	4636733772917427405     # double 9.995000e+01
                                        #  (0xcccccccd)
.LCPI220_2:
	.quad	4621816302839204413     # double 9.995000e+00
                                        #  (0xa3d70a3d)
.LCPI220_3:
	.quad	4613937818241073152     # double 3.000000e+00
                                        #  (0x0)
.LCPI220_4:
	.quad	4607092346807469998     # double 9.900000e-01
                                        #  (0x7ae147ae)
.LCPI220_5:
	.quad	4746794007240114176     # double 2.147484e+09
                                        #  (0xff800000)
.LCPI220_6:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
.LCPI220_7:
	.quad	4621819117588971520     # double 1.000000e+01
                                        #  (0x0)
	.text
	.align	16, 0x90
	.type	create_image,@function
create_image:                           # @create_image
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$188, %esp
	movl	%edx, 48(%esp)          # 4-byte Spill
	movsd	%xmm0, 56(%esp)         # 8-byte Spill
	movl	%ecx, %edi
	movl	16(%edi), %ecx
	movl	20(%edi), %eax
	addl	(%edi), %ecx
	movl	%ecx, 64(%esp)          # 4-byte Spill
	adcl	4(%edi), %eax
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	36(%edi), %ebx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	with_thousand_seps
	movl	%eax, %esi
	movl	%esi, 32(%esp)          # 4-byte Spill
	movl	%esi, (%esp)
	calll	count_cols
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	%esi, (%esp)
	leal	29(%eax), %ecx
	cmpl	$11, %eax
	movl	$40, %esi
	cmovgel	%ecx, %esi
	calll	strlen
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	32(%edi), %eax
	subl	%esi, %eax
	cmpl	$5, %eax
	movl	$0, %ebp
	cmovgel	%eax, %ebp
	movl	8(%edi), %ecx
	movl	12(%edi), %esi
	testl	%ecx, %ecx
	sete	%dl
	testl	%esi, %esi
	sets	%dh
	je	.LBB220_2
# BB#1:                                 # %entry
	movb	%dh, %dl
.LBB220_2:                              # %entry
	movl	48(%esp), %eax          # 4-byte Reload
                                        # kill: AL<def> AL<kill> EAX<kill>
	movb	%al, 39(%esp)           # 1-byte Spill
	testb	%dl, %dl
	jne	.LBB220_7
# BB#3:                                 # %if.then11
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 176(%esp)
	movl	%ecx, 160(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 180(%esp)
	movl	%esi, 164(%esp)
	fildll	176(%esp)
	fstpl	168(%esp)
	fildll	160(%esp)
	fstpl	152(%esp)
	movsd	168(%esp), %xmm0
	mulsd	.LCPI220_0, %xmm0
	divsd	152(%esp), %xmm0
	cvttsd2si	%xmm0, %eax
	cmpl	$101, %eax
	jge	.LBB220_75
# BB#4:                                 # %cond.end19
	cmpl	$99, %eax
	jg	.LBB220_6
# BB#5:                                 # %if.then22
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str10910, 4(%esp)
	calll	sprintf
	jmp	.LBB220_8
.LBB220_7:                              # %do.body
	movl	$538976288, (%ebx)      # imm = 0x20202020
	jmp	.LBB220_8
.LBB220_6:                              # %if.else
	movb	$0, 4(%ebx)
	movl	$623915057, (%ebx)      # imm = 0x25303031
.LBB220_8:                              # %if.end28
	testl	%ebp, %ebp
	je	.LBB220_9
# BB#10:                                # %land.lhs.true
	movl	8(%edi), %ecx
	movl	12(%edi), %eax
	testl	%ecx, %ecx
	sete	%dl
	testl	%eax, %eax
	sets	%dh
	je	.LBB220_12
# BB#11:                                # %land.lhs.true
	movb	%dh, %dl
.LBB220_12:                             # %land.lhs.true
	testb	%dl, %dl
	jne	.LBB220_26
# BB#13:                                # %if.then32
	movl	%ecx, 136(%esp)
	fildll	(%edi)
	fstpl	144(%esp)
	movl	64(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 120(%esp)
	movl	%eax, 140(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 124(%esp)
	fildll	136(%esp)
	fstpl	128(%esp)
	movsd	144(%esp), %xmm0
	movsd	128(%esp), %xmm2
	cvtsi2sd	%ebp, %xmm1
	fildll	120(%esp)
	fstpl	112(%esp)
	movsd	112(%esp), %xmm3
	divsd	%xmm2, %xmm3
	mulsd	%xmm1, %xmm3
	cvttsd2si	%xmm3, %esi
	cmpl	%ebp, %esi
	jg	.LBB220_76
# BB#14:                                # %cond.end52
	divsd	%xmm2, %xmm0
	mulsd	%xmm1, %xmm0
	cvttsd2si	%xmm0, %eax
	cmpl	%esi, %eax
	jg	.LBB220_77
# BB#15:                                # %cond.end57
	movl	%edi, 44(%esp)          # 4-byte Spill
	movb	$91, 4(%ebx)
	leal	5(%ebx), %edi
	testl	%eax, %eax
	movl	%edi, %edx
	movl	%eax, 48(%esp)          # 4-byte Spill
	jle	.LBB220_17
# BB#16:                                # %for.body.lr.ph
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$43, 4(%esp)
	leal	5(%eax,%ebx), %ebx
	calll	memset
	movl	%ebx, %edx
.LBB220_17:                             # %for.end
	movl	%esi, %eax
	movl	%eax, %ecx
	movl	48(%esp), %eax          # 4-byte Reload
	subl	%eax, %esi
	testl	%esi, %esi
	jle	.LBB220_18
# BB#19:                                # %for.cond65.preheader
	movl	%eax, %ebx
	leal	-1(%esi), %eax
	testl	%eax, %eax
	jle	.LBB220_20
# BB#21:                                # %for.body69.lr.ph
	movl	%edx, (%esp)
	decl	%ecx
	subl	%ebx, %ecx
	movl	%ecx, 8(%esp)
	movl	$61, 4(%esp)
	addl	%edx, %esi
	addl	%ecx, %edx
	movl	%edx, %ebx
	calll	memset
	movl	%ebx, %edx
	movb	$62, (%edx)
	jmp	.LBB220_24
.LBB220_9:
	addl	$4, %ebx
	jmp	.LBB220_40
.LBB220_26:                             # %if.then82
	movl	40(%edi), %eax
	leal	-6(%ebp,%ebp), %ecx
	cltd
	idivl	%ecx
	leal	-2(%ebp), %eax
	cmpl	%eax, %edx
	jge	.LBB220_28
# BB#27:                                # %if.then89
	leal	1(%edx), %eax
	jmp	.LBB220_29
.LBB220_28:                             # %if.else91
	leal	-5(%ebp,%ebp), %eax
	subl	%edx, %eax
.LBB220_29:                             # %if.end95
	movb	$91, 4(%ebx)
	addl	$5, %ebx
	testl	%ebp, %ebp
	jle	.LBB220_39
	.align	16, 0x90
.LBB220_30:                             # %for.body100
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, %eax
	jne	.LBB220_32
# BB#31:                                # %if.then104
                                        #   in Loop: Header=BB220_30 Depth=1
	movb	$60, (%ebx)
	incl	%ebx
	jmp	.LBB220_38
.LBB220_32:                             # %if.else106
                                        #   in Loop: Header=BB220_30 Depth=1
	testl	%eax, %eax
	jne	.LBB220_34
# BB#33:                                # %if.then109
                                        #   in Loop: Header=BB220_30 Depth=1
	movb	$61, (%ebx)
	incl	%ebx
	jmp	.LBB220_38
.LBB220_34:                             # %if.else111
                                        #   in Loop: Header=BB220_30 Depth=1
	leal	1(%ebx), %ecx
	cmpl	$-1, %eax
	jne	.LBB220_36
# BB#35:                                # %if.then115
                                        #   in Loop: Header=BB220_30 Depth=1
	movb	$62, (%ebx)
	jmp	.LBB220_37
.LBB220_36:                             # %if.else117
                                        #   in Loop: Header=BB220_30 Depth=1
	movb	$32, (%ebx)
.LBB220_37:                             # %if.else117
                                        #   in Loop: Header=BB220_30 Depth=1
	movl	%ecx, %ebx
.LBB220_38:                             # %for.inc122
                                        #   in Loop: Header=BB220_30 Depth=1
	decl	%eax
	decl	%ebp
	jne	.LBB220_30
.LBB220_39:                             # %for.end124
	movb	$93, (%ebx)
	incl	40(%edi)
	incl	%ebx
	jmp	.LBB220_40
.LBB220_18:
	movl	%edx, %esi
	jmp	.LBB220_24
.LBB220_20:
	leal	1(%edx), %esi
	movb	$62, (%edx)
	jmp	.LBB220_24
	.align	16, 0x90
.LBB220_23:                             # %while.body
                                        #   in Loop: Header=BB220_24 Depth=1
	movb	$32, (%esi)
	incl	%esi
.LBB220_24:                             # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, %eax
	subl	%edi, %eax
	cmpl	%ebp, %eax
	jl	.LBB220_23
# BB#25:                                # %while.end.loopexit
	leal	1(%esi), %ebx
	movb	$93, (%esi)
	movl	44(%esp), %edi          # 4-byte Reload
.LBB220_40:                             # %if.end129
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$.L.str15914, 4(%esp)
	calll	sprintf
	movl	%ebx, (%esp)
	movl	$0, 4(%esp)
	movl	$11, %esi
	subl	52(%esp), %esi          # 4-byte Folded Reload
	calll	__rawmemchr
	movl	%eax, %ebp
	testl	%esi, %esi
	jle	.LBB220_42
# BB#41:                                # %for.body136.lr.ph
	movl	%esi, 8(%esp)
	movl	%ebp, (%esp)
	movl	$32, 4(%esp)
	addl	%esi, %ebp
	calll	memset
.LBB220_42:                             # %for.end139
	movsd	368(%edi), %xmm0
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	jbe	.LBB220_47
# BB#43:                                # %land.lhs.true142
	movl	376(%edi), %eax
	movl	380(%edi), %edx
	movl	%eax, %ecx
	orl	%edx, %ecx
	je	.LBB220_47
# BB#44:                                # %if.then144
	movl	$0, 184(%esp)
	movl	396(%edi), %ecx
	addl	392(%edi), %eax
	adcl	%edx, %ecx
	movsd	56(%esp), %xmm1         # 8-byte Reload
	subsd	384(%edi), %xmm1
	addsd	%xmm1, %xmm0
	movsd	%xmm0, 8(%esp)
	leal	184(%esp), %edx
	movl	%edx, 16(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	calc_rate
	fstpl	104(%esp)
	xorl	%eax, %eax
	movsd	104(%esp), %xmm0
	ucomisd	.LCPI220_1, %xmm0
	jae	.LBB220_46
# BB#45:                                # %cond.false154
	ucomisd	.LCPI220_2, %xmm0
	movl	$1, %eax
	adcl	$0, %eax
.LBB220_46:                             # %cond.end158
	movl	184(%esp), %ecx
	movl	create_image.short_units(,%ecx,4), %ecx
	movl	%ecx, 20(%esp)
	movsd	%xmm0, 12(%esp)
	movl	%eax, 8(%esp)
	movl	%ebp, (%esp)
	movl	$.L.str20919, 4(%esp)
	calll	sprintf
	movl	%ebp, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%eax, %ebp
	jmp	.LBB220_48
.LBB220_47:                             # %do.body163
	movl	$1932479277, 4(%ebp)    # imm = 0x732F4B2D
	movl	$774712608, (%ebp)      # imm = 0x2E2D2D20
	addl	$8, %ebp
.LBB220_48:                             # %if.end166
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	je	.LBB220_49
# BB#66:                                # %if.else223
	movl	$5, 8(%esp)
	movl	$.L.str23921, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	strcpy
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, %ebx
	movl	%ebp, (%esp)
	addl	%ebx, %ebp
	calll	count_cols
	subl	%eax, %ebx
	movsd	56(%esp), %xmm0         # 8-byte Reload
	ucomisd	.LCPI220_7, %xmm0
	jae	.LBB220_67
# BB#68:                                # %if.else237
	movsd	%xmm0, (%esp)
	calll	print_decimal
	movl	%eax, 8(%esp)
	movl	%ebp, (%esp)
	movl	$.L.str24922, 4(%esp)
	.align	16, 0x90
.LBB220_69:                             # %if.else237
	calll	sprintf
	jmp	.LBB220_70
.LBB220_49:                             # %if.then168
	movl	8(%edi), %esi
	movl	12(%edi), %eax
	testl	%esi, %esi
	sete	%dl
	testl	%eax, %eax
	sets	%dh
	je	.LBB220_51
# BB#50:                                # %if.then168
	movb	%dh, %dl
.LBB220_51:                             # %if.then168
	xorl	%ebx, %ebx
	testb	%dl, %dl
	jne	.LBB220_71
# BB#52:                                # %land.lhs.true172
	movl	16(%edi), %ecx
	movl	%ecx, 48(%esp)          # 4-byte Spill
	movl	20(%edi), %edx
	movl	%edx, 44(%esp)          # 4-byte Spill
	testl	%ecx, %ecx
	sete	%bl
	testl	%edx, %edx
	sets	%bh
	movsd	56(%esp), %xmm1         # 8-byte Reload
	je	.LBB220_54
# BB#53:                                # %land.lhs.true172
	movb	%bh, %bl
.LBB220_54:                             # %land.lhs.true172
	testb	%bl, %bl
	jne	.LBB220_65
# BB#55:                                # %land.lhs.true172
	ucomisd	.LCPI220_3, %xmm1
	jbe	.LBB220_65
# BB#56:                                # %if.then179
	movl	%edi, %edx
	movl	%esi, %edi
	xorl	64(%esp), %edi          # 4-byte Folded Reload
	movl	%eax, %ebx
	xorl	68(%esp), %ebx          # 4-byte Folded Reload
	orl	%edi, %ebx
	movl	%edx, %edi
	je	.LBB220_59
# BB#57:                                # %land.lhs.true183
	movl	412(%edi), %ecx
	testl	%ecx, %ecx
	je	.LBB220_59
# BB#58:                                # %land.lhs.true186
	movapd	%xmm1, %xmm0
	subsd	404(%edi), %xmm0
	movapd	%xmm1, %xmm2
	movsd	.LCPI220_4, %xmm1
	ucomisd	%xmm0, %xmm1
	movapd	%xmm2, %xmm1
	ja	.LBB220_61
.LBB220_59:                             # %if.else192
	movl	48(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 80(%esp)
	movl	44(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 84(%esp)
	subl	64(%esp), %esi          # 4-byte Folded Reload
	movl	%esi, 96(%esp)
	sbbl	68(%esp), %eax          # 4-byte Folded Reload
	movl	%eax, 100(%esp)
	fildll	80(%esp)
	fstpl	72(%esp)
	fildll	96(%esp)
	fstpl	88(%esp)
	movsd	88(%esp), %xmm0
	mulsd	%xmm1, %xmm0
	divsd	72(%esp), %xmm0
	ucomisd	.LCPI220_5, %xmm0
	jae	.LBB220_65
# BB#60:                                # %if.end203
	addsd	.LCPI220_6, %xmm0
	cvttsd2si	%xmm0, %ecx
	movl	%ecx, 412(%edi)
	movsd	%xmm1, 404(%edi)
.LBB220_61:                             # %if.end208
	movl	get_eta.eta_trans, %esi
	testl	%esi, %esi
	je	.LBB220_63
# BB#62:                                # %if.end208.get_eta.exit_crit_edge
	movl	get_eta.bytes_cols_diff, %ebx
	jmp	.LBB220_64
.LBB220_67:                             # %if.then232
	addsd	.LCPI220_6, %xmm0
	cvttsd2si	%xmm0, %ecx
	xorl	%edx, %edx
	calll	eta_to_human_short
	movl	%ebp, (%esp)
	movl	$eta_to_human_short.buf, 4(%esp)
	calll	strcpy
.LBB220_70:                             # %if.end240
	movl	%ebp, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%eax, %ebp
	jmp	.LBB220_71
.LBB220_65:                             # %do.body218
	movb	$32, 12(%ebp)
	movl	$538976288, 8(%ebp)     # imm = 0x20202020
	movl	$538976288, 4(%ebp)     # imm = 0x20202020
	movl	$538976288, (%ebp)      # imm = 0x20202020
	addl	$13, %ebp
	xorl	%ebx, %ebx
.LBB220_71:                             # %while.cond243.preheader
	movl	52(%esp), %ecx          # 4-byte Reload
	subl	40(%esp), %ecx          # 4-byte Folded Reload
	subl	%ebx, %ecx
	leal	(%ecx,%ebp), %eax
	subl	36(%edi), %eax
	jmp	.LBB220_73
	.align	16, 0x90
.LBB220_72:                             # %while.body253
                                        #   in Loop: Header=BB220_73 Depth=1
	movb	$32, (%ebp)
	leal	1(%ecx,%ebp), %eax
	subl	36(%edi), %eax
	incl	%ebp
.LBB220_73:                             # %while.body253
                                        # =>This Inner Loop Header: Depth=1
	cmpl	32(%edi), %eax
	jl	.LBB220_72
# BB#74:                                # %while.end255
	movb	$0, (%ebp)
	addl	$188, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB220_63:                             # %if.then.i
	movl	$5, 8(%esp)
	movl	$get_eta.eta_str, 4(%esp)
	movl	$0, (%esp)
	movl	%ecx, 68(%esp)          # 4-byte Spill
	calll	dcgettext
	movl	%edi, %esi
	movl	%eax, %edi
	movl	%edi, get_eta.eta_trans
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %ebx
	movl	%edi, (%esp)
	movl	%esi, %edi
	calll	count_cols
	movl	68(%esp), %ecx          # 4-byte Reload
	subl	%eax, %ebx
	movl	%ebx, get_eta.bytes_cols_diff
	movl	get_eta.eta_trans, %esi
.LBB220_64:                             # %get_eta.exit
	xorl	%edx, %edx
	calll	eta_to_human_short
	movl	%esi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$eta_to_human_short.buf, 8(%esp)
	jmp	.LBB220_69
.LBB220_75:                             # %cond.false18
	movl	$.L__PRETTY_FUNCTION__.create_image, 12(%esp)
	movl	$898, 8(%esp)           # imm = 0x382
	movl	$.L.str3903, 4(%esp)
	movl	$.L.str9909, (%esp)
	calll	__assert_fail
.LBB220_76:                             # %cond.false51
	movl	$.L__PRETTY_FUNCTION__.create_image, 12(%esp)
	movl	$921, 8(%esp)           # imm = 0x399
	movl	$.L.str3903, 4(%esp)
	movl	$.L.str13912, (%esp)
	calll	__assert_fail
.LBB220_77:                             # %cond.false56
	movl	$.L__PRETTY_FUNCTION__.create_image, 12(%esp)
	movl	$922, 8(%esp)           # imm = 0x39A
	movl	$.L.str3903, 4(%esp)
	movl	$.L.str14913, (%esp)
	calll	__assert_fail
.Ltmp220:
	.size	create_image, .Ltmp220-create_image

	.align	16, 0x90
	.type	eta_to_human_short,@function
eta_to_human_short:                     # @eta_to_human_short
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	$.L.str25923, %eax
	testb	%dl, %dl
	movl	$.L.str26924, %esi
	cmovnel	%eax, %esi
	cmpl	%ecx, eta_to_human_short.last
	je	.LBB221_4
# BB#1:                                 # %if.end
	movl	%ecx, eta_to_human_short.last
	cmpl	$99, %ecx
	jg	.LBB221_5
# BB#2:                                 # %if.then2
	movl	%ecx, 8(%esp)
	movl	$.L.str27925, 4(%esp)
	jmp	.LBB221_3
.LBB221_5:                              # %if.else
	cmpl	$5999, %ecx             # imm = 0x176F
	jg	.LBB221_7
# BB#6:                                 # %if.then4
	movl	%esi, 12(%esp)
	movl	$-2004318071, %edx      # imm = 0xFFFFFFFF88888889
	movl	%ecx, %eax
	imull	%edx
	addl	%ecx, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$5, %edx
	addl	%eax, %edx
	movl	%edx, 8(%esp)
	imull	$60, %edx, %eax
	subl	%eax, %ecx
	movl	%ecx, 16(%esp)
	movl	$.L.str28926, 4(%esp)
	jmp	.LBB221_3
.LBB221_7:                              # %if.else6
	cmpl	$172799, %ecx           # imm = 0x2A2FF
	jg	.LBB221_9
# BB#8:                                 # %if.then8
	movl	%esi, 12(%esp)
	movl	$-1851608123, %edx      # imm = 0xFFFFFFFF91A2B3C5
	movl	%ecx, %eax
	imull	%edx
	addl	%ecx, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$11, %edx
	addl	%eax, %edx
	movl	%edx, 8(%esp)
	movl	$-2004318071, %edi      # imm = 0xFFFFFFFF88888889
	movl	%ecx, %eax
	imull	%edi
	movl	%edx, %esi
	addl	%ecx, %esi
	movl	%esi, %eax
	shrl	$31, %eax
	sarl	$5, %esi
	addl	%eax, %esi
	movl	%esi, %eax
	imull	%edi
	addl	%esi, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$5, %edx
	addl	%eax, %edx
	imull	$60, %edx, %eax
	subl	%eax, %esi
	movl	%esi, 16(%esp)
	movl	$.L.str29927, 4(%esp)
	jmp	.LBB221_3
.LBB221_9:                              # %if.else13
	movl	$-1037155065, %edx      # imm = 0xFFFFFFFFC22E4507
	movl	%ecx, %eax
	imull	%edx
	addl	%ecx, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$16, %edx
	addl	%eax, %edx
	cmpl	$8639999, %ecx          # imm = 0x83D5FF
	jg	.LBB221_11
# BB#10:                                # %if.then15
	movl	%esi, 12(%esp)
	movl	%edx, 8(%esp)
	movl	$-1851608123, %edx      # imm = 0xFFFFFFFF91A2B3C5
	movl	%ecx, %eax
	imull	%edx
	movl	%edx, %esi
	addl	%ecx, %esi
	movl	%esi, %eax
	shrl	$31, %eax
	sarl	$11, %esi
	addl	%eax, %esi
	movl	$-2004318071, %ecx      # imm = 0xFFFFFFFF88888889
	movl	%esi, %eax
	imull	%ecx
	addl	%esi, %edx
	movl	%edx, %eax
	shrl	$31, %eax
	sarl	$5, %edx
	addl	%eax, %edx
	imull	$60, %edx, %eax
	subl	%eax, %esi
	movl	%esi, 16(%esp)
	movl	$.L.str30928, 4(%esp)
	jmp	.LBB221_3
.LBB221_11:                             # %if.else20
	movl	%edx, 8(%esp)
	movl	$.L.str31929, 4(%esp)
.LBB221_3:                              # %if.then2
	movl	$eta_to_human_short.buf, (%esp)
	calll	sprintf
.LBB221_4:                              # %return
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp221:
	.size	eta_to_human_short, .Ltmp221-eta_to_human_short

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI222_0:
	.quad	4636737291354636288     # double 1.000000e+02
                                        #  (0x0)
.LCPI222_1:
	.quad	4636733772917427405     # double 9.995000e+01
                                        #  (0xcccccccd)
.LCPI222_2:
	.quad	4621816302839204413     # double 9.995000e+00
                                        #  (0xa3d70a3d)
.LCPI222_3:
	.quad	4746794007240114176     # double 2.147484e+09
                                        #  (0xff800000)
.LCPI222_4:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
.LCPI222_5:
	.quad	4621819117588971520     # double 1.000000e+01
                                        #  (0x0)
	.text
	.align	16, 0x90
	.type	print_row_stats,@function
print_row_stats:                        # @print_row_stats
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$156, %esp
	movl	%edx, 52(%esp)          # 4-byte Spill
	movl	%ecx, 76(%esp)          # 4-byte Spill
	movl	20(%ecx), %eax
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	24(%ecx), %ebp
	movl	opt+276, %ebx
	movl	%ebp, %edi
	imull	%ebx, %edi
	movl	opt+272, %esi
	movl	%ebp, %eax
	mull	%esi
	movl	%eax, 44(%esp)          # 4-byte Spill
	addl	%edi, %edx
	sarl	$31, %ebp
	imull	%esi, %ebp
	addl	%edx, %ebp
	movl	opt+280, %edi
	imull	%edi, %ebx
	movl	%edi, %eax
	mull	%esi
	movl	%eax, %ecx
	movl	%ecx, 48(%esp)          # 4-byte Spill
	addl	%ebx, %edx
	sarl	$31, %edi
	imull	%esi, %edi
	addl	%edx, %edi
	movl	%edi, 56(%esp)          # 4-byte Spill
	movl	60(%esp), %edx          # 4-byte Reload
	movl	%edx, %esi
	imull	%edi, %esi
	movl	%edx, %eax
	movl	%edx, %edi
	mull	%ecx
	movl	%eax, %ebx
	addl	%esi, %edx
	movl	%edi, %esi
	sarl	$31, %esi
	imull	%ecx, %esi
	addl	%edx, %esi
	addl	44(%esp), %ebx          # 4-byte Folded Reload
	adcl	%ebp, %esi
	movl	52(%esp), %eax          # 4-byte Reload
                                        # kill: AL<def> AL<kill> EAX<kill>
	movb	%al, 52(%esp)           # 1-byte Spill
	testb	%al, %al
	je	.LBB222_1
# BB#2:                                 # %if.then
	movl	76(%esp), %edx          # 4-byte Reload
	movl	16(%edx), %ecx
	movl	%ecx, %eax
	sarl	$31, %eax
	addl	%ecx, %ebx
	adcl	%eax, %esi
	movl	%edx, %edi
	jmp	.LBB222_3
.LBB222_1:
	movl	76(%esp), %edi          # 4-byte Reload
.LBB222_3:                              # %if.end
	movsd	%xmm0, 64(%esp)         # 8-byte Spill
	movl	8(%edi), %ecx
	movl	12(%edi), %eax
	movl	%ecx, %edx
	orl	%eax, %edx
	movl	56(%esp), %ebp          # 4-byte Reload
	je	.LBB222_5
# BB#4:                                 # %if.then8
	movl	%ebx, 144(%esp)
	movl	%ecx, 128(%esp)
	movl	%esi, 148(%esp)
	movl	%eax, 132(%esp)
	fildll	144(%esp)
	fstpl	136(%esp)
	fildll	128(%esp)
	fstpl	120(%esp)
	movsd	136(%esp), %xmm0
	mulsd	.LCPI222_0, %xmm0
	divsd	120(%esp), %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str39937, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
.LBB222_5:                              # %if.end14
	movl	%ebx, 40(%esp)          # 4-byte Spill
	movl	%esi, 60(%esp)          # 4-byte Spill
	cmpb	$1, 52(%esp)            # 1-byte Folded Reload
	movl	48(%esp), %ebx          # 4-byte Reload
	movl	%ebx, %eax
	movl	%ebp, %esi
	jne	.LBB222_7
# BB#6:                                 # %if.else
	movl	16(%edi), %ebp
	movl	24(%edi), %ecx
	movl	%ecx, %esi
	sarl	$31, %esi
	movl	opt+272, %edx
	imull	%edx, %esi
	movl	%ecx, %eax
	mull	%edx
	imull	opt+276, %ecx
	addl	%edx, %ecx
	addl	%esi, %ecx
	movl	%ebp, %esi
	sarl	$31, %esi
	addl	%ebp, %eax
	adcl	%ecx, %esi
.LBB222_7:                              # %if.end23
	movl	%eax, 44(%esp)          # 4-byte Spill
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	(%edi), %ebp
	movl	4(%edi), %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	movl	20(%edi), %ebx
	movl	%edi, 76(%esp)          # 4-byte Spill
	movl	%ebx, %edi
	sarl	$31, %edi
	calll	__divdi3
	xorl	%edi, %edx
	xorl	%ebx, %eax
	orl	%edx, %eax
	jne	.LBB222_8
# BB#9:                                 # %if.then28
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	36(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	__moddi3
	movl	44(%esp), %ecx          # 4-byte Reload
	subl	%eax, %ecx
	sbbl	%edx, %esi
	movsd	64(%esp), %xmm1         # 8-byte Reload
	jmp	.LBB222_10
.LBB222_8:
	movsd	64(%esp), %xmm1         # 8-byte Reload
	movl	44(%esp), %ecx          # 4-byte Reload
.LBB222_10:                             # %if.end30
	movl	76(%esp), %edi          # 4-byte Reload
	movsd	28(%edi), %xmm0
	leal	152(%esp), %eax
	movl	%eax, 16(%esp)
	subsd	%xmm0, %xmm1
	movsd	%xmm1, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ecx, (%esp)
	calll	calc_rate
	fstpl	112(%esp)
	xorl	%eax, %eax
	movsd	112(%esp), %xmm0
	ucomisd	.LCPI222_1, %xmm0
	jae	.LBB222_12
# BB#11:                                # %cond.false
	ucomisd	.LCPI222_2, %xmm0
	movl	$1, %eax
	adcl	$0, %eax
.LBB222_12:                             # %cond.end
	movl	152(%esp), %ecx
	movsbl	print_row_stats.names(%ecx), %ecx
	movl	%ecx, 20(%esp)
	movsd	%xmm0, 12(%esp)
	movl	%eax, 8(%esp)
	movl	$.L.str40938, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movsd	64(%esp), %xmm1         # 8-byte Reload
	movsd	%xmm1, 28(%edi)
	cmpb	$0, 52(%esp)            # 1-byte Folded Reload
	movl	60(%esp), %esi          # 4-byte Reload
	movl	40(%esp), %ebx          # 4-byte Reload
	je	.LBB222_13
# BB#16:                                # %if.else60
	ucomisd	.LCPI222_5, %xmm1
	jae	.LBB222_17
# BB#18:                                # %if.else67
	movsd	%xmm1, (%esp)
	calll	print_decimal
	movl	%eax, 8(%esp)
	movl	$.L.str42940, 4(%esp)
	jmp	.LBB222_19
.LBB222_13:                             # %if.then40
	movl	8(%edi), %ecx
	movl	12(%edi), %eax
	movl	%ecx, %edx
	orl	%eax, %edx
	je	.LBB222_20
# BB#14:                                # %if.then43
	subl	%ebx, %ecx
	movl	%ecx, 104(%esp)
	sbbl	%esi, %eax
	subl	(%edi), %ebx
	movl	%ebx, 88(%esp)
	movl	%eax, 108(%esp)
	sbbl	4(%edi), %esi
	movl	%esi, 92(%esp)
	fildll	104(%esp)
	fstpl	96(%esp)
	fildll	88(%esp)
	fstpl	80(%esp)
	mulsd	96(%esp), %xmm1
	divsd	80(%esp), %xmm1
	movsd	.LCPI222_3, %xmm0
	ucomisd	%xmm1, %xmm0
	jbe	.LBB222_20
# BB#15:                                # %if.then54
	addsd	.LCPI222_4, %xmm1
	cvttsd2si	%xmm1, %ecx
	movl	$1, %edx
	calll	eta_to_human_short
	movl	$eta_to_human_short.buf, 8(%esp)
	movl	$.L.str15914, 4(%esp)
	jmp	.LBB222_19
.LBB222_17:                             # %if.then63
	addsd	.LCPI222_4, %xmm1
	cvttsd2si	%xmm1, %ecx
	movl	$1, %edx
	calll	eta_to_human_short
	movl	$eta_to_human_short.buf, 8(%esp)
	movl	$.L.str41939, 4(%esp)
.LBB222_19:                             # %if.else67
	movl	$0, (%esp)
	calll	logprintf
.LBB222_20:                             # %if.end70
	addl	$156, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp222:
	.size	print_row_stats, .Ltmp222-print_row_stats

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI223_0:
	.quad	4741671816366391296     # double 1.000000e+09
                                        #  (0x0)
	.text
	.globl	ptimer_new
	.align	16, 0x90
	.type	ptimer_new,@function
ptimer_new:                             # @ptimer_new
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	$24, (%esp)
	calll	checking_malloc0
	movl	%eax, %esi
	movb	ptimer_new.init_done.b, %al
	testb	%al, %al
	jne	.LBB223_10
# BB#1:                                 # %if.then
	movb	$1, ptimer_new.init_done.b
	xorl	%edi, %edi
	leal	16(%esp), %ebx
	jmp	.LBB223_2
	.align	16, 0x90
.LBB223_11:                             # %for.inc.i
                                        #   in Loop: Header=BB223_2 Depth=1
	incl	%edi
.LBB223_2:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, %edi
	ja	.LBB223_8
# BB#3:                                 # %for.body.i
                                        #   in Loop: Header=BB223_2 Depth=1
	testl	%edi, %edi
	jne	.LBB223_5
# BB#4:                                 # %if.then.i
                                        #   in Loop: Header=BB223_2 Depth=1
	movl	$149, (%esp)
	calll	sysconf
	testl	%eax, %eax
	js	.LBB223_11
.LBB223_5:                              # %if.end6.i
                                        #   in Loop: Header=BB223_2 Depth=1
	movl	%ebx, 4(%esp)
	movl	posix_init.clocks(,%edi,8), %ebp
	movl	%ebp, (%esp)
	calll	clock_getres
	testl	%eax, %eax
	js	.LBB223_11
# BB#6:                                 # %if.end11.i
	movl	%ebp, posix_clock_id
	cvtsi2sd	20(%esp), %xmm0
	divsd	.LCPI223_0, %xmm0
	cvtsi2sd	16(%esp), %xmm1
	addsd	%xmm0, %xmm1
	movsd	%xmm1, posix_clock_resolution
	xorpd	%xmm0, %xmm0
	ucomisd	%xmm0, %xmm1
	jne	.LBB223_8
	jp	.LBB223_8
# BB#7:                                 # %if.then17.i
	movl	$1062232653, posix_clock_resolution+4 # imm = 0x3F50624D
	movl	$-755914244, posix_clock_resolution # imm = 0xFFFFFFFFD2F1A9FC
.LBB223_8:                              # %for.end.i
	cmpl	$2, %edi
	jne	.LBB223_10
# BB#9:                                 # %if.then21.i
	movl	$5, 8(%esp)
	movl	$.L.str953, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$0, posix_clock_id
	movl	$1062232653, posix_clock_resolution+4 # imm = 0x3F50624D
	movl	$-755914244, posix_clock_resolution # imm = 0xFFFFFFFFD2F1A9FC
.LBB223_10:                             # %if.end
	movl	posix_clock_id, %eax
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	clock_gettime
	movl	$0, 12(%esi)
	movl	$0, 8(%esi)
	movl	$0, 20(%esi)
	movl	$0, 16(%esi)
	movl	%esi, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp223:
	.size	ptimer_new, .Ltmp223-ptimer_new

	.globl	ptimer_reset
	.align	16, 0x90
	.type	ptimer_reset,@function
ptimer_reset:                           # @ptimer_reset
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	posix_clock_id, %eax
	movl	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	clock_gettime
	movl	$0, 12(%esi)
	movl	$0, 8(%esi)
	movl	$0, 20(%esi)
	movl	$0, 16(%esi)
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp224:
	.size	ptimer_reset, .Ltmp224-ptimer_reset

	.globl	ptimer_destroy
	.align	16, 0x90
	.type	ptimer_destroy,@function
ptimer_destroy:                         # @ptimer_destroy
# BB#0:                                 # %entry
	jmp	checking_free           # TAILCALL
.Ltmp225:
	.size	ptimer_destroy, .Ltmp225-ptimer_destroy

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI226_0:
	.quad	4741671816366391296     # double 1.000000e+09
                                        #  (0x0)
	.text
	.globl	ptimer_measure
	.align	16, 0x90
	.type	ptimer_measure,@function
ptimer_measure:                         # @ptimer_measure
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	posix_clock_id, %eax
	leal	16(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	clock_gettime
	movl	32(%esp), %eax
	movl	16(%esp), %edx
	movl	20(%esp), %ecx
	subl	(%eax), %edx
	cvtsi2sd	%edx, %xmm1
	subl	4(%eax), %ecx
	cvtsi2sd	%ecx, %xmm0
	divsd	.LCPI226_0, %xmm0
	addsd	%xmm1, %xmm0
	addsd	16(%eax), %xmm0
	movsd	8(%eax), %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB226_2
# BB#1:                                 # %if.then
	movsd	16(%esp), %xmm0
	movsd	%xmm0, (%eax)
	movsd	%xmm1, 16(%eax)
	movapd	%xmm1, %xmm0
.LBB226_2:                              # %if.end
	movsd	%xmm0, 8(%eax)
	movsd	%xmm0, 8(%esp)
	fldl	8(%esp)
	addl	$28, %esp
	ret
.Ltmp226:
	.size	ptimer_measure, .Ltmp226-ptimer_measure

	.globl	ptimer_read
	.align	16, 0x90
	.type	ptimer_read,@function
ptimer_read:                            # @ptimer_read
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	fldl	8(%eax)
	ret
.Ltmp227:
	.size	ptimer_read, .Ltmp227-ptimer_read

	.globl	ptimer_resolution
	.align	16, 0x90
	.type	ptimer_resolution,@function
ptimer_resolution:                      # @ptimer_resolution
# BB#0:                                 # %entry
	fldl	posix_clock_resolution
	ret
.Ltmp228:
	.size	ptimer_resolution, .Ltmp228-ptimer_resolution

	.globl	retrieve_tree
	.align	16, 0x90
	.type	retrieve_tree,@function
retrieve_tree:                          # @retrieve_tree
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$124, %esp
	leal	120(%esp), %eax
	movl	%eax, 4(%esp)
	movl	144(%esp), %esi
	movl	%esi, (%esp)
	calll	url_parse
	testl	%eax, %eax
	je	.LBB229_1
# BB#2:                                 # %if.end
	movl	$16, (%esp)
	movl	%eax, %esi
	movl	%esi, 52(%esp)          # 4-byte Spill
	calll	checking_malloc0
	movl	%eax, %ebx
	movl	%ebx, 60(%esp)          # 4-byte Spill
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, %edi
	movl	%edi, 68(%esp)          # 4-byte Spill
	movl	(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	$1, 8(%esp)
	movl	$0, 4(%esp)
	movl	$0, (%esp)
	movl	%ebx, %ecx
	movl	%eax, %edx
	calll	url_enqueue
	movl	(%esi), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	string_set_add
	movl	$31, 36(%esp)           # 4-byte Folded Spill
	jmp	.LBB229_3
.LBB229_1:                              # %if.then
	movl	120(%esp), %eax
	movl	%eax, (%esp)
	calll	url_error
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str960, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	$23, %eax
	jmp	.LBB229_17
	.align	16, 0x90
.LBB229_83:                             # %if.else196
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	.align	16, 0x90
.LBB229_3:                              # %while.body
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB229_57 Depth 2
	movl	$0, 108(%esp)
	movl	opt+236, %ecx
	cmpl	%ecx, total_downloaded_bytes
	seta	%al
	movl	opt+240, %edx
	cmpl	%edx, total_downloaded_bytes+4
	setg	%ah
	je	.LBB229_5
# BB#4:                                 # %while.body
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	%ah, %al
.LBB229_5:                              # %while.body
                                        #   in Loop: Header=BB229_3 Depth=1
	orl	%edx, %ecx
	setne	%cl
	movl	36(%esp), %edx          # 4-byte Reload
	cmpl	$26, %edx
	sete	%bl
	testb	%al, %cl
	jne	.LBB229_7
# BB#6:                                 # %while.body
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpl	$26, %edx
	je	.LBB229_7
# BB#18:                                # %if.end12
                                        #   in Loop: Header=BB229_3 Depth=1
	leal	103(%esp), %eax
	movl	%eax, 8(%esp)
	leal	104(%esp), %eax
	movl	%eax, 4(%esp)
	leal	112(%esp), %eax
	movl	%eax, (%esp)
	movl	60(%esp), %ecx          # 4-byte Reload
	leal	116(%esp), %edx
	calll	url_dequeue
	xorb	%bl, %bl
	testb	%al, %al
	je	.LBB229_7
# BB#19:                                # %if.end15
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	116(%esp), %edi
	movl	dl_url_file_map, %eax
	testl	%eax, %eax
	je	.LBB229_26
# BB#20:                                # %land.lhs.true17
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_contains
	testl	%eax, %eax
	jne	.LBB229_21
.LBB229_26:                             # %if.else
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$0, 96(%esp)
	movl	$0, 92(%esp)
	movl	112(%esp), %eax
	leal	96(%esp), %ecx
	movl	%ecx, 16(%esp)
	movl	%eax, 12(%esp)
	leal	92(%esp), %eax
	movl	%eax, 8(%esp)
	leal	108(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 20(%esp)
	calll	retrieve_url
	xorb	%cl, %cl
	cmpb	$0, 103(%esp)
	je	.LBB229_30
# BB#27:                                # %land.lhs.true39
                                        #   in Loop: Header=BB229_3 Depth=1
	xorb	%cl, %cl
	cmpl	$0, 108(%esp)
	je	.LBB229_30
# BB#28:                                # %land.lhs.true39
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpl	$31, %eax
	jne	.LBB229_30
# BB#29:                                # %land.lhs.true44
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	96(%esp), %ecx
	andl	$3, %ecx
	cmpl	$3, %ecx
	sete	%cl
.LBB229_30:                             # %if.end50
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	92(%esp), %ebp
	testl	%ebp, %ebp
	je	.LBB229_31
# BB#32:                                # %if.then52
                                        #   in Loop: Header=BB229_3 Depth=1
	xorb	%bh, %bh
	testb	%cl, %cl
	movb	%cl, 64(%esp)           # 1-byte Spill
	je	.LBB229_40
# BB#33:                                # %if.then54
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	104(%esp), %ebx
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB229_84
# BB#34:                                # %cond.end.i
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%edi, 44(%esp)          # 4-byte Spill
	movl	%ebp, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB229_85
# BB#35:                                # %cond.end5.i
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%ebp, 56(%esp)          # 4-byte Spill
	movl	$32, (%esp)
	calll	checking_malloc0
	movl	%eax, %ebp
	movl	%edi, (%ebp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	%ebp, %ecx
	movl	%esi, %edx
	calll	download_child_p
	movb	%al, %bl
	movl	%esi, (%esp)
	calll	url_free
	movl	%edi, (%esp)
	calll	url_free
	movl	%ebp, (%esp)
	calll	checking_free
	testb	%bl, %bl
	jne	.LBB229_38
# BB#36:                                # %cond.end5.i
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	opt+250, %al
	testb	%al, %al
	je	.LBB229_38
# BB#37:                                # %if.then10.i
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str15975, (%esp)
	calll	debug_logprintf
.LBB229_38:                             # %descend_redirect_p.exit
                                        #   in Loop: Header=BB229_3 Depth=1
	xorb	%bh, %bh
	cmpb	$1, %bl
	movl	44(%esp), %edi          # 4-byte Reload
	jne	.LBB229_40
# BB#39:                                # %if.else57
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%edi, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	string_set_add
	movb	64(%esp), %bh           # 1-byte Reload
.LBB229_40:                             # %if.end59
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	movl	92(%esp), %edi
	movl	%edi, 116(%esp)
	jmp	.LBB229_41
.LBB229_31:                             #   in Loop: Header=BB229_3 Depth=1
	movb	%cl, %bh
	.align	16, 0x90
.LBB229_41:                             # %if.end61
                                        #   in Loop: Header=BB229_3 Depth=1
	testb	%bh, %bh
	je	.LBB229_67
# BB#42:                                # %land.lhs.true67
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	$0, 56(%esp)            # 1-byte Folded Spill
	movl	opt+28, %ecx
	movl	104(%esp), %eax
	cmpl	%ecx, %eax
	jl	.LBB229_50
# BB#43:                                # %land.lhs.true67
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpl	$-1, %ecx
	je	.LBB229_50
# BB#44:                                # %if.then73
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, opt+290
	je	.LBB229_47
# BB#45:                                # %land.lhs.true76
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpl	%ecx, %eax
	je	.LBB229_49
# BB#46:                                # %land.lhs.true76
                                        #   in Loop: Header=BB229_3 Depth=1
	leal	1(%ecx), %edx
	cmpl	%edx, %eax
	jne	.LBB229_47
.LBB229_49:                             # %if.end92
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	$1, 56(%esp)            # 1-byte Folded Spill
	testb	%bh, %bh
	je	.LBB229_67
.LBB229_50:                             # %if.then94
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	$0, 91(%esp)
	movl	108(%esp), %eax
	leal	91(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	get_urls_html
	cmpb	$0, opt+224
	je	.LBB229_52
# BB#51:                                # %land.lhs.true98
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, 91(%esp)
	jne	.LBB229_66
.LBB229_52:                             # %if.end102
                                        #   in Loop: Header=BB229_3 Depth=1
	testl	%eax, %eax
	je	.LBB229_67
# BB#53:                                # %if.then104
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB229_86
# BB#54:                                # %cond.end
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	40(%esi), %eax
	movl	%eax, 32(%esp)          # 4-byte Spill
	testl	%eax, %eax
	movl	%edi, 64(%esp)          # 4-byte Spill
	movl	%edi, 44(%esp)          # 4-byte Spill
	je	.LBB229_56
# BB#55:                                # %if.then113
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%esi, (%esp)
	movl	$2, 4(%esp)
	calll	url_string
	movl	%eax, 64(%esp)          # 4-byte Spill
.LBB229_56:                             # %for.body.lr.ph
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	104(%esp), %ebx
	leal	1(%ebx), %eax
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	40(%esp), %edi          # 4-byte Reload
	.align	16, 0x90
.LBB229_57:                             # %for.body
                                        #   Parent Loop BB229_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	8(%edi), %eax
	testb	$1, %al
	jne	.LBB229_62
# BB#58:                                # %if.end119
                                        #   in Loop: Header=BB229_57 Depth=2
	cmpb	$1, 56(%esp)            # 1-byte Folded Reload
	jne	.LBB229_60
# BB#59:                                # %land.lhs.true122
                                        #   in Loop: Header=BB229_57 Depth=2
	testb	$16, %al
	je	.LBB229_62
.LBB229_60:                             # %if.end127
                                        #   in Loop: Header=BB229_57 Depth=2
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 8(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	%edi, %ecx
	movl	%esi, %edx
	calll	download_child_p
	cmpb	$1, %al
	jne	.LBB229_62
# BB#61:                                # %if.then129
                                        #   in Loop: Header=BB229_57 Depth=2
	movl	(%edi), %eax
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, %ebp
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	8(%edi), %ecx
	andl	$32, %ecx
	shrl	$5, %ecx
	movl	%ecx, 8(%esp)
	movl	48(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	movl	60(%esp), %ecx          # 4-byte Reload
	movl	%ebp, %edx
	calll	url_enqueue
	movl	(%edi), %eax
	movl	(%eax), %eax
	movl	%eax, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	string_set_add
.LBB229_62:                             # %for.inc
                                        #   in Loop: Header=BB229_57 Depth=2
	movl	28(%edi), %edi
	testl	%edi, %edi
	jne	.LBB229_57
# BB#63:                                # %for.end
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpl	$0, 32(%esp)            # 4-byte Folded Reload
	movl	44(%esp), %edi          # 4-byte Reload
	je	.LBB229_65
# BB#64:                                # %if.then142
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
.LBB229_65:                             # %if.end143
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%esi, (%esp)
	calll	url_free
	movl	40(%esp), %eax          # 4-byte Reload
.LBB229_66:                             # %if.end143
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, (%esp)
	calll	free_urlpos
	jmp	.LBB229_67
.LBB229_21:                             # %if.then20
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	dl_url_file_map, %eax
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, 108(%esp)
	cmpb	$0, opt+250
	jne	.LBB229_22
	.align	16, 0x90
.LBB229_23:                             # %do.end
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, 103(%esp)
	je	.LBB229_67
# BB#24:                                # %do.end
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	downloaded_html_set, %eax
	testl	%eax, %eax
	je	.LBB229_67
# BB#25:                                # %land.lhs.true31
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	108(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_contains
	testl	%eax, %eax
	setne	%bh
	jmp	.LBB229_41
.LBB229_47:                             # %do.body83
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, opt+250
	jne	.LBB229_48
	.align	16, 0x90
.LBB229_67:                             # %if.end145
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	108(%esp), %eax
	testl	%eax, %eax
	je	.LBB229_80
# BB#68:                                # %land.lhs.true147
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	opt+57, %cl
	orb	opt+288, %cl
	jne	.LBB229_70
# BB#69:                                # %lor.lhs.false153
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, (%esp)
	calll	acceptable
	testb	%al, %al
	jne	.LBB229_80
.LBB229_70:                             # %do.body156
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, opt+250
	jne	.LBB229_71
	.align	16, 0x90
.LBB229_74:                             # %do.end171
                                        #   in Loop: Header=BB229_3 Depth=1
	movb	opt+57, %al
	orb	opt+288, %al
	jne	.LBB229_75
# BB#76:                                # %cond.false179
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str10970, 4(%esp)
	jmp	.LBB229_77
.LBB229_75:                             # %cond.true177
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str9969, 4(%esp)
.LBB229_77:                             # %cond.false179
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$0, (%esp)
	calll	dcgettext
	movl	108(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	108(%esp), %eax
	movl	%eax, (%esp)
	calll	unlink
	testl	%eax, %eax
	je	.LBB229_79
# BB#78:                                # %if.then185
                                        #   in Loop: Header=BB229_3 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	$.L.str11971, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB229_79:                             # %if.end188
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$.L.str12972, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	108(%esp), %eax
	movl	%eax, (%esp)
	calll	register_delete_file
.LBB229_80:                             # %if.end189
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	movl	112(%esp), %eax
	testl	%eax, %eax
	je	.LBB229_82
# BB#81:                                # %if.else192
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB229_82:                             # %if.end193
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	108(%esp), %eax
	testl	%eax, %eax
	je	.LBB229_3
	jmp	.LBB229_83
.LBB229_71:                             # %if.then161
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	$.L.str6966, %eax
	cmpb	$0, opt+288
	jne	.LBB229_73
# BB#72:                                # %cond.false165
                                        #   in Loop: Header=BB229_3 Depth=1
	cmpb	$0, opt+57
	movl	$.L.str8968, %eax
	movl	$.L.str7967, %ecx
	cmovnel	%ecx, %eax
.LBB229_73:                             # %cond.end168
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, 4(%esp)
	movl	$.L.str5965, (%esp)
	calll	debug_logprintf
	jmp	.LBB229_74
.LBB229_22:                             # %if.then25
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$.L.str1961, (%esp)
	calll	debug_logprintf
	jmp	.LBB229_23
.LBB229_48:                             # %if.then88
                                        #   in Loop: Header=BB229_3 Depth=1
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str2962, (%esp)
	calll	debug_logprintf
	jmp	.LBB229_67
.LBB229_7:                              # %while.cond.preheader
	leal	75(%esp), %ebp
	movl	%ebp, 8(%esp)
	leal	76(%esp), %edi
	movl	%edi, 4(%esp)
	leal	80(%esp), %esi
	movl	%esi, (%esp)
	leal	84(%esp), %edx
	movl	60(%esp), %ecx          # 4-byte Reload
	jmp	.LBB229_8
	.align	16, 0x90
.LBB229_11:                             # %while.cond.backedge
                                        #   in Loop: Header=BB229_8 Depth=1
	movl	%ebp, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	60(%esp), %ecx          # 4-byte Reload
	leal	84(%esp), %edx
.LBB229_8:                              # %while.cond.preheader
                                        # =>This Inner Loop Header: Depth=1
	calll	url_dequeue
	testb	%al, %al
	je	.LBB229_12
# BB#9:                                 # %while.body199
                                        #   in Loop: Header=BB229_8 Depth=1
	movl	84(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	80(%esp), %eax
	testl	%eax, %eax
	je	.LBB229_11
# BB#10:                                # %if.else202
                                        #   in Loop: Header=BB229_8 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB229_11
.LBB229_12:                             # %if.end207
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_free
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	string_set_free
	movl	opt+240, %eax
	movl	opt+236, %ecx
	movl	%ecx, %edx
	orl	%eax, %edx
	je	.LBB229_16
# BB#13:                                # %if.end207
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %esi
	cmpl	%ecx, %esi
	seta	%cl
	cmpl	%eax, %edx
	setg	%al
	je	.LBB229_15
# BB#14:                                # %if.end207
	movb	%al, %cl
.LBB229_15:                             # %if.end207
	movl	$51, %eax
	testb	%cl, %cl
	jne	.LBB229_17
.LBB229_16:                             # %if.else213
	testb	%bl, %bl
	sete	%al
	movzbl	%al, %eax
	leal	26(%eax,%eax,4), %eax
.LBB229_17:                             # %return
	addl	$124, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB229_84:                             # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.descend_redirect_p, 12(%esp)
	movl	$622, 8(%esp)           # imm = 0x26E
	movl	$.L.str4964, 4(%esp)
	movl	$.L.str13973, (%esp)
	calll	__assert_fail
.LBB229_85:                             # %cond.false4.i
	movl	$.L__PRETTY_FUNCTION__.descend_redirect_p, 12(%esp)
	movl	$625, 8(%esp)           # imm = 0x271
	movl	$.L.str4964, 4(%esp)
	movl	$.L.str14974, (%esp)
	calll	__assert_fail
.LBB229_86:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.retrieve_tree, 12(%esp)
	movl	$332, 8(%esp)           # imm = 0x14C
	movl	$.L.str4964, 4(%esp)
	movl	$.L.str3963, (%esp)
	calll	__assert_fail
.Ltmp229:
	.size	retrieve_tree, .Ltmp229-retrieve_tree

	.align	16, 0x90
	.type	url_enqueue,@function
url_enqueue:                            # @url_enqueue
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	%edx, %ebx
	movl	%ecx, %esi
	movl	$20, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	%ebx, (%edi)
	movl	32(%esp), %eax
	movl	%eax, 4(%edi)
	movl	36(%esp), %eax
	movl	%eax, 8(%edi)
	movb	40(%esp), %cl
	movb	%cl, 12(%edi)
	movl	$0, 16(%edi)
	movl	8(%esi), %ecx
	incl	%ecx
	movl	%ecx, 8(%esi)
	cmpl	12(%esi), %ecx
	jle	.LBB230_2
# BB#1:                                 # %if.then
	movl	%ecx, 12(%esi)
.LBB230_2:                              # %do.body
	cmpb	$0, opt+250
	jne	.LBB230_3
	.align	16, 0x90
.LBB230_5:                              # %do.end22
	movl	4(%esi), %eax
	testl	%eax, %eax
	je	.LBB230_7
# BB#6:                                 # %if.then24
	movl	%edi, 16(%eax)
.LBB230_7:                              # %if.end27
	movl	%edi, 4(%esi)
	cmpl	$0, (%esi)
	jne	.LBB230_9
# BB#8:                                 # %if.then30
	movl	%edi, (%esi)
.LBB230_9:                              # %if.end33
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB230_3:                              # %do.body13
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$.L.str32992, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	je	.LBB230_5
# BB#4:                                 # %if.then18
	movl	8(%esi), %eax
	movl	12(%esi), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str31991, (%esp)
	calll	debug_logprintf
	jmp	.LBB230_5
.Ltmp230:
	.size	url_enqueue, .Ltmp230-url_enqueue

	.align	16, 0x90
	.type	url_dequeue,@function
url_dequeue:                            # @url_dequeue
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	%ecx, %esi
	movl	(%esi), %edi
	xorb	%al, %al
	testl	%edi, %edi
	je	.LBB231_7
# BB#1:                                 # %if.end
	movl	40(%esp), %eax
	movl	36(%esp), %ecx
	movl	32(%esp), %ebx
	movl	16(%edi), %ebp
	movl	%ebp, (%esi)
	testl	%ebp, %ebp
	jne	.LBB231_3
# BB#2:                                 # %if.then5
	movl	$0, 4(%esi)
.LBB231_3:                              # %if.end6
	movl	(%edi), %ebp
	movl	%ebp, (%edx)
	movl	4(%edi), %edx
	movl	%edx, (%ebx)
	movl	8(%edi), %edx
	movl	%edx, (%ecx)
	movb	12(%edi), %cl
	movb	%cl, (%eax)
	decl	8(%esi)
	cmpb	$0, opt+250
	jne	.LBB231_4
	.align	16, 0x90
.LBB231_6:                              # %do.end26
	movl	%edi, (%esp)
	calll	checking_free
	movb	$1, %al
.LBB231_7:                              # %return
	movzbl	%al, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB231_4:                              # %do.body18
	movl	(%edi), %eax
	movl	8(%edi), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str30990, (%esp)
	calll	debug_logprintf
	cmpb	$0, opt+250
	je	.LBB231_6
# BB#5:                                 # %if.then23
	movl	8(%esi), %eax
	movl	12(%esi), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str31991, (%esp)
	calll	debug_logprintf
	jmp	.LBB231_6
.Ltmp231:
	.size	url_dequeue, .Ltmp231-url_dequeue

	.align	16, 0x90
	.type	download_child_p,@function
download_child_p:                       # @download_child_p
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, 16(%esp)          # 4-byte Spill
	movl	%ecx, %edi
	movl	(%edi), %ebp
	movl	(%ebp), %esi
	movl	56(%esp), %ebx
	cmpb	$0, opt+250
	jne	.LBB232_1
	.align	16, 0x90
.LBB232_2:                              # %do.end
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	string_set_contains
	testl	%eax, %eax
	je	.LBB232_12
# BB#3:                                 # %if.then5
	cmpb	$0, opt+57
	movl	16(%esp), %esi          # 4-byte Reload
	je	.LBB232_7
# BB#4:                                 # %if.then7
	movl	%esi, (%esp)
	movl	$1, 4(%esp)
	calll	url_string
	movl	%eax, %edi
	cmpb	$0, opt+250
	jne	.LBB232_5
	.align	16, 0x90
.LBB232_6:                              # %do.end17
	movl	%edi, (%esp)
	calll	checking_free
.LBB232_7:                              # %do.body19
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#8:                                 # %if.then24
	movl	$.L.str18978, (%esp)
	jmp	.LBB232_9
.LBB232_12:                             # %if.end27
	movl	%esi, 20(%esp)          # 4-byte Spill
	movl	52(%esp), %esi
	movl	4(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	calll	schemes_are_similar_p
	movb	%al, %bl
	testb	%bl, %bl
	je	.LBB232_13
# BB#17:                                # %if.then46.critedge
	cmpb	$0, opt+24
	je	.LBB232_21
# BB#18:                                # %land.lhs.true49
	testb	$2, 8(%edi)
	jne	.LBB232_21
# BB#19:                                # %do.body52
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#20:                                # %if.then57
	movl	$.L.str20980, (%esp)
	jmp	.LBB232_9
.LBB232_13:                             # %land.lhs.true
	cmpl	$1, 4(%ebp)
	jne	.LBB232_15
# BB#14:                                # %land.lhs.true
	movb	opt+100, %al
	testb	%al, %al
	jne	.LBB232_21
.LBB232_15:                             # %do.body36
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#16:                                # %if.then41
	movl	$.L.str19979, (%esp)
	jmp	.LBB232_9
.LBB232_21:                             # %if.end61
	movl	%ebp, (%esp)
	calll	accept_domain
	testb	%al, %al
	je	.LBB232_22
# BB#24:                                # %if.end72
	cmpb	$0, opt+25
	je	.LBB232_33
# BB#25:                                # %land.lhs.true75
	movl	4(%ebp), %eax
	movl	4(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	schemes_are_similar_p
	cmpb	$1, %al
	jne	.LBB232_33
# BB#26:                                # %land.lhs.true80
	movl	8(%ebp), %eax
	movl	8(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strcasecmp
	testl	%eax, %eax
	jne	.LBB232_33
# BB#27:                                # %land.lhs.true85
	movl	12(%ebp), %eax
	cmpl	12(%esi), %eax
	jne	.LBB232_33
# BB#28:                                # %land.lhs.true89
	cmpb	$0, opt+290
	je	.LBB232_30
# BB#29:                                # %land.lhs.true92
	testb	$16, 8(%edi)
	jne	.LBB232_33
.LBB232_30:                             # %if.then96
	movl	32(%esi), %eax
	movl	32(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	subdir_p
	testb	%al, %al
	je	.LBB232_31
.LBB232_33:                             # %if.end111
	movl	opt+72, %eax
	orl	opt+68, %eax
	movl	20(%esp), %esi          # 4-byte Reload
	je	.LBB232_37
# BB#34:                                # %if.then114
	movl	32(%ebp), %eax
	movl	%eax, (%esp)
	calll	accdir
	testb	%al, %al
	je	.LBB232_35
.LBB232_37:                             # %if.end128
	movl	36(%ebp), %eax
	cmpb	$0, (%eax)
	je	.LBB232_45
# BB#38:                                # %land.lhs.true132
	movl	%eax, (%esp)
	calll	has_html_suffix_p
	cmpb	$1, %al
	jne	.LBB232_42
# BB#39:                                # %land.lhs.true136
	movl	opt+28, %eax
	leal	-1(%eax), %ecx
	cmpl	48(%esp), %ecx
	jg	.LBB232_45
# BB#40:                                # %land.lhs.true136
	cmpl	$-1, %eax
	je	.LBB232_45
# BB#41:                                # %land.lhs.true136
	movb	opt+290, %al
	testb	%al, %al
	jne	.LBB232_45
.LBB232_42:                             # %if.then145
	movl	36(%ebp), %eax
	movl	%eax, (%esp)
	calll	acceptable
	testb	%al, %al
	je	.LBB232_43
.LBB232_45:                             # %if.end159
	movl	4(%ebp), %eax
	movl	16(%esp), %esi          # 4-byte Reload
	movl	4(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	schemes_are_similar_p
	testb	%al, %al
	je	.LBB232_50
# BB#46:                                # %if.end159
	movb	opt+16, %al
	testb	%al, %al
	jne	.LBB232_50
# BB#47:                                # %land.lhs.true165
	movl	8(%esi), %esi
	movl	8(%ebp), %edi
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	strcasecmp
	testl	%eax, %eax
	je	.LBB232_50
# BB#48:                                # %do.body172
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#49:                                # %if.then177
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$.L.str25985, (%esp)
	jmp	.LBB232_9
.LBB232_22:                             # %do.body64
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#23:                                # %if.then69
	movl	$.L.str21981, (%esp)
	jmp	.LBB232_9
.LBB232_1:                              # %if.then
	movl	%esi, 4(%esp)
	movl	$.L.str16976, (%esp)
	calll	debug_logprintf
	jmp	.LBB232_2
.LBB232_50:                             # %if.end183
	cmpb	$0, opt+224
	je	.LBB232_61
# BB#51:                                # %if.end183
	xorb	$1, %bl
	testb	%bl, %bl
	jne	.LBB232_61
# BB#52:                                # %if.then189
	movl	8(%ebp), %eax
	movl	12(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	res_get_specs
	movl	%eax, %esi
	testl	%esi, %esi
	jne	.LBB232_57
# BB#53:                                # %if.then194
	leal	24(%esp), %eax
	movl	%eax, 4(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	res_retrieve_file
	cmpb	$1, %al
	jne	.LBB232_55
# BB#54:                                # %if.then196
	movl	24(%esp), %eax
	movl	%eax, (%esp)
	calll	res_parse_from_file
	movl	%eax, %esi
	movl	24(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB232_56
.LBB232_5:                              # %if.then14
	movl	(%esi), %eax
	movl	%eax, 4(%esp)
	movl	$.L.str17977, (%esp)
	calll	debug_logprintf
	jmp	.LBB232_6
.LBB232_35:                             # %do.body118
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#36:                                # %if.then123
	movl	32(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str23983, (%esp)
	jmp	.LBB232_9
.LBB232_43:                             # %do.body149
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#44:                                # %if.then154
	movl	36(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$.L.str24984, (%esp)
	jmp	.LBB232_9
.LBB232_31:                             # %do.body100
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#32:                                # %if.then105
	movl	32(%ebp), %eax
	movl	32(%esi), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$.L.str22982, (%esp)
.LBB232_9:                              # %if.then24
	calll	debug_logprintf
	.align	16, 0x90
.LBB232_10:                             # %do.body223
	xorb	%al, %al
	cmpb	$0, opt+250
	je	.LBB232_63
# BB#11:                                # %if.then228
	movl	$.L.str29989, (%esp)
	calll	debug_logprintf
	xorb	%al, %al
	jmp	.LBB232_63
.LBB232_55:                             # %if.else
	movl	$0, 4(%esp)
	movl	$.L.str26986, (%esp)
	calll	res_parse
	movl	%eax, %esi
.LBB232_56:                             # %if.end199
	movl	8(%ebp), %eax
	movl	12(%ebp), %ecx
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	res_register_specs
.LBB232_57:                             # %if.end202
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	res_match_path
	testb	%al, %al
	je	.LBB232_58
.LBB232_61:                             # %do.body215
	movb	$1, %al
	cmpb	$0, opt+250
	jne	.LBB232_62
	.align	16, 0x90
.LBB232_63:                             # %return
	movzbl	%al, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB232_58:                             # %do.body205
	cmpb	$0, opt+250
	movl	20(%esp), %esi          # 4-byte Reload
	je	.LBB232_60
# BB#59:                                # %if.then210
	movl	%esi, 4(%esp)
	movl	$.L.str27987, (%esp)
	calll	debug_logprintf
.LBB232_60:                             # %do.end212
	movl	%esi, 4(%esp)
	movl	56(%esp), %eax
	movl	%eax, (%esp)
	calll	string_set_add
	jmp	.LBB232_10
.LBB232_62:                             # %if.then220
	movl	$.L.str28988, (%esp)
	calll	debug_logprintf
	movb	$1, %al
	jmp	.LBB232_63
.Ltmp232:
	.size	download_child_p, .Ltmp232-download_child_p

	.globl	res_parse
	.align	16, 0x90
	.type	res_parse,@function
res_parse:                              # @res_parse
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	$12, (%esp)
	movl	80(%esp), %eax
	movl	%eax, 56(%esp)          # 4-byte Spill
	movl	84(%esp), %esi
	addl	%eax, %esi
	movl	%esi, 48(%esp)          # 4-byte Spill
	calll	checking_malloc0
	movl	%eax, %ebx
	movl	%ebx, 40(%esp)          # 4-byte Spill
	movl	$0, 32(%esp)            # 4-byte Folded Spill
	xorb	%al, %al
	movb	$0, 39(%esp)            # 1-byte Folded Spill
	movb	%al, 26(%esp)           # 1-byte Spill
	movb	$0, 47(%esp)            # 1-byte Folded Spill
	movl	$1, 28(%esp)            # 4-byte Folded Spill
	jmp	.LBB233_1
	.align	16, 0x90
.LBB233_63:                             # %next
                                        #   in Loop: Header=BB233_1 Depth=1
	incl	28(%esp)                # 4-byte Folded Spill
	.align	16, 0x90
.LBB233_1:                              # %while.body
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB233_18 Depth 2
                                        #     Child Loop BB233_14 Depth 2
                                        #     Child Loop BB233_11 Depth 2
                                        #     Child Loop BB233_6 Depth 2
                                        #     Child Loop BB233_3 Depth 2
                                        #     Child Loop BB233_25 Depth 2
	movl	56(%esp), %edi          # 4-byte Reload
	cmpl	%esi, %edi
	je	.LBB233_64
# BB#2:                                 # %if.end
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%esi, %eax
	subl	%edi, %eax
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$10, 4(%esp)
	calll	memchr
	testl	%eax, %eax
	leal	1(%eax), %eax
	cmovel	%esi, %eax
	movl	%eax, 56(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB233_3:                              # %while.cond4
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%edi, %eax
	cmpl	56(%esp), %eax          # 4-byte Folded Reload
	jae	.LBB233_63
# BB#4:                                 # %land.rhs
                                        #   in Loop: Header=BB233_3 Depth=2
	leal	1(%eax), %edi
	movzbl	(%eax), %edx
	testb	$64, _sch_istable(%edx,%edx)
	jne	.LBB233_3
# BB#5:                                 # %lor.lhs.false
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	$-1, %ecx
	cmpb	$35, %dl
	je	.LBB233_63
	jmp	.LBB233_6
	.align	16, 0x90
.LBB233_10:                             # %for.inc
                                        #   in Loop: Header=BB233_6 Depth=2
	incl	%ecx
.LBB233_6:                              # %for.cond
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	(%edi,%ecx), %ebp
	cmpl	56(%esp), %ebp          # 4-byte Folded Reload
	jae	.LBB233_11
# BB#7:                                 # %for.body
                                        #   in Loop: Header=BB233_6 Depth=2
	cmpl	$-1, %ecx
	je	.LBB233_9
# BB#8:                                 # %lor.lhs.false22
                                        #   in Loop: Header=BB233_6 Depth=2
	movzbl	-1(%edi,%ecx), %eax
	testb	$64, _sch_istable(%eax,%eax)
	je	.LBB233_10
.LBB233_9:                              # %land.lhs.true
                                        #   in Loop: Header=BB233_6 Depth=2
	cmpb	$35, (%ebp)
	jne	.LBB233_10
	.align	16, 0x90
.LBB233_11:                             # %while.cond36
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	52(%esp), %ebp          # 4-byte Folded Reload
	jbe	.LBB233_78
# BB#12:                                # %land.rhs39
                                        #   in Loop: Header=BB233_11 Depth=2
	movzbl	-1(%ebp), %eax
	decl	%ebp
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB233_11
# BB#13:                                # %while.cond53.loopexit
                                        #   in Loop: Header=BB233_1 Depth=1
	incl	%ebp
	xorl	%esi, %esi
	.align	16, 0x90
.LBB233_14:                             # %while.cond53
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%esi, %edx
	leal	-1(%edi,%edx), %ecx
	cmpl	%ebp, %ecx
	jae	.LBB233_17
# BB#15:                                # %land.rhs56
                                        #   in Loop: Header=BB233_14 Depth=2
	movzbl	-1(%edi,%edx), %eax
	movzwl	_sch_istable(%eax,%eax), %ebx
	andl	$140, %ebx
	leal	1(%edx), %esi
	cmpl	$45, %eax
	je	.LBB233_14
# BB#16:                                # %land.rhs56
                                        #   in Loop: Header=BB233_14 Depth=2
	testw	%bx, %bx
	jne	.LBB233_14
.LBB233_17:                             # %while.cond71.loopexit
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%ecx, %edi
	.align	16, 0x90
.LBB233_18:                             # %while.cond71
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	%ebp, %edi
	jae	.LBB233_22
# BB#19:                                # %land.rhs74
                                        #   in Loop: Header=BB233_18 Depth=2
	movzbl	(%edi), %ebx
	incl	%edi
	testb	$64, _sch_istable(%ebx,%ebx)
	jne	.LBB233_18
# BB#20:                                # %do.end85
                                        #   in Loop: Header=BB233_1 Depth=1
	testl	%edx, %edx
	je	.LBB233_22
# BB#21:                                # %do.end85
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$58, %bl
	jne	.LBB233_22
	.align	16, 0x90
.LBB233_25:                             # %while.cond106
                                        #   Parent Loop BB233_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%edi, %esi
	cmpl	%ebp, %esi
	jae	.LBB233_27
# BB#26:                                # %land.rhs109
                                        #   in Loop: Header=BB233_25 Depth=2
	leal	1(%esi), %edi
	movzbl	(%esi), %eax
	testb	$64, _sch_istable(%eax,%eax)
	jne	.LBB233_25
.LBB233_27:                             # %while.cond121.loopexit
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	%ebp, %esi
	cmoval	%esi, %ebp
	movl	52(%esp), %eax          # 4-byte Reload
	subl	%eax, %ecx
	cmpl	$5, %ecx
	jne	.LBB233_28
# BB#42:                                # %land.lhs.true157
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%eax, (%esp)
	movl	$5, 8(%esp)
	movl	$.L.str4999, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	movl	40(%esp), %ebx          # 4-byte Reload
	jne	.LBB233_61
# BB#43:                                # %if.then160
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	je	.LBB233_52
# BB#44:                                # %if.then162
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	%ebp, %esi
	jae	.LBB233_45
# BB#46:                                # %land.lhs.true.i218
                                        #   in Loop: Header=BB233_1 Depth=1
	leal	1(%esi), %eax
	cmpb	$47, (%esi)
	cmovnel	%esi, %eax
	jmp	.LBB233_47
.LBB233_22:                             # %do.body96
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$0, opt+250
	jne	.LBB233_24
	.align	16, 0x90
.LBB233_23:                             #   in Loop: Header=BB233_1 Depth=1
	movl	40(%esp), %ebx          # 4-byte Reload
	movl	48(%esp), %esi          # 4-byte Reload
	incl	28(%esp)                # 4-byte Folded Spill
	jmp	.LBB233_1
.LBB233_24:                             # %if.then100
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str2997, (%esp)
	calll	debug_logprintf
	jmp	.LBB233_23
.LBB233_28:                             # %while.cond121.loopexit
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	$8, %ecx
	movl	40(%esp), %ebx          # 4-byte Reload
	jne	.LBB233_29
# BB#53:                                # %land.lhs.true171
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%eax, (%esp)
	movl	$8, 8(%esp)
	movl	$.L.str51000, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB233_61
# BB#54:                                # %if.then174
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	je	.LBB233_52
# BB#55:                                # %if.then176
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	%ebp, %esi
	movl	%esi, %eax
	jae	.LBB233_57
# BB#56:                                # %land.lhs.true.i224
                                        #   in Loop: Header=BB233_1 Depth=1
	leal	1(%esi), %eax
	cmpb	$47, (%esi)
	cmovnel	%esi, %eax
.LBB233_57:                             # %if.end.i232
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, %edi
	movl	(%ebx), %ecx
	incl	%ecx
	movl	%ecx, (%ebx)
	cmpl	%ebp, %esi
	sete	52(%esp)                # 1-byte Folded Spill
	cmpb	$0, 47(%esp)            # 1-byte Folded Reload
	setne	27(%esp)                # 1-byte Folded Spill
	movl	4(%ebx), %eax
	cmpl	%eax, %ecx
	jle	.LBB233_58
# BB#59:                                # %if.then11.i243
                                        #   in Loop: Header=BB233_1 Depth=1
	testl	%eax, %eax
	leal	(%eax,%eax), %eax
	movl	$1, %ecx
	cmovel	%ecx, %eax
	movl	%eax, 4(%ebx)
	shll	$3, %eax
	movl	8(%ebx), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 8(%ebx)
	movl	(%ebx), %ecx
	jmp	.LBB233_60
.LBB233_29:                             # %while.cond121.loopexit
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	$10, %ecx
	jne	.LBB233_61
# BB#30:                                # %land.lhs.true132
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%eax, (%esp)
	movl	$10, 8(%esp)
	movl	$.L.str3998, 4(%esp)
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB233_61
# BB#31:                                # %if.then135
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	$0, 32(%esp)            # 4-byte Folded Reload
	movb	39(%esp), %al           # 1-byte Reload
	jne	.LBB233_33
# BB#32:                                # %if.then135
                                        #   in Loop: Header=BB233_1 Depth=1
	testb	%al, %al
	jne	.LBB233_39
.LBB233_33:                             # %if.then143
                                        #   in Loop: Header=BB233_1 Depth=1
	subl	%esi, %ebp
	cmpl	$4, %ebp
	jne	.LBB233_34
# BB#37:                                # %land.lhs.true5.i
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%esi, (%esp)
	movl	$4, 8(%esp)
	movl	$.L.str141009, 4(%esp)
	calll	strncasecmp
	movb	$1, 47(%esp)            # 1-byte Folded Spill
	testl	%eax, %eax
	movb	$1, %al
	je	.LBB233_39
	jmp	.LBB233_38
.LBB233_61:                             # %do.body186
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$0, opt+250
	movl	48(%esp), %esi          # 4-byte Reload
	je	.LBB233_63
# BB#62:                                # %if.then191
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	$.L.str61001, (%esp)
	calll	debug_logprintf
	jmp	.LBB233_63
.LBB233_45:                             #   in Loop: Header=BB233_1 Depth=1
	movl	%esi, %eax
.LBB233_47:                             # %if.end.i
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, %edi
	movl	(%ebx), %ecx
	incl	%ecx
	movl	%ecx, (%ebx)
	cmpb	$0, 47(%esp)            # 1-byte Folded Reload
	setne	52(%esp)                # 1-byte Folded Spill
	movl	4(%ebx), %eax
	cmpl	%eax, %ecx
	jle	.LBB233_48
# BB#49:                                # %if.then11.i
                                        #   in Loop: Header=BB233_1 Depth=1
	testl	%eax, %eax
	leal	(%eax,%eax), %eax
	movl	$1, %ecx
	cmovel	%ecx, %eax
	movl	%eax, 4(%ebx)
	shll	$3, %eax
	movl	8(%ebx), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 8(%ebx)
	movl	(%ebx), %ecx
	jmp	.LBB233_50
.LBB233_48:                             # %if.end.if.end22_crit_edge.i
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	8(%ebx), %eax
.LBB233_50:                             # %add_path.exit
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%edi, -8(%eax,%ecx,8)
	movb	$1, -4(%eax,%ecx,8)
	movb	52(%esp), %dl           # 1-byte Reload
	jmp	.LBB233_51
.LBB233_58:                             # %if.end.if.end22_crit_edge.i235
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	8(%ebx), %eax
.LBB233_60:                             # %add_path.exit248
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	%edi, -8(%eax,%ecx,8)
	movb	52(%esp), %dl           # 1-byte Reload
	movb	%dl, -4(%eax,%ecx,8)
	movb	27(%esp), %dl           # 1-byte Reload
.LBB233_51:                             # %add_path.exit
                                        #   in Loop: Header=BB233_1 Depth=1
	movb	%dl, -3(%eax,%ecx,8)
.LBB233_52:                             # %if.end164
                                        #   in Loop: Header=BB233_1 Depth=1
	incl	32(%esp)                # 4-byte Folded Spill
	movl	48(%esp), %esi          # 4-byte Reload
	incl	28(%esp)                # 4-byte Folded Spill
	jmp	.LBB233_1
.LBB233_34:                             # %if.then143
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpl	$1, %ebp
	jne	.LBB233_38
# BB#35:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB233_1 Depth=1
	cmpb	$42, (%esi)
	je	.LBB233_36
.LBB233_38:                             # %if.else7.i
                                        #   in Loop: Header=BB233_1 Depth=1
	movb	$0, 47(%esp)            # 1-byte Folded Spill
	xorb	%al, %al
	jmp	.LBB233_39
.LBB233_36:                             #   in Loop: Header=BB233_1 Depth=1
	movb	$0, 47(%esp)            # 1-byte Folded Spill
	movb	$1, %al
.LBB233_39:                             # %if.end147
                                        #   in Loop: Header=BB233_1 Depth=1
	movb	%al, 39(%esp)           # 1-byte Spill
	cmpb	$0, 47(%esp)            # 1-byte Folded Reload
	je	.LBB233_41
# BB#40:                                # %if.end147
                                        #   in Loop: Header=BB233_1 Depth=1
	movb	$1, 26(%esp)            # 1-byte Folded Spill
.LBB233_41:                             # %if.end147
                                        #   in Loop: Header=BB233_1 Depth=1
	movl	$0, 32(%esp)            # 4-byte Folded Spill
	movl	48(%esp), %esi          # 4-byte Reload
	incl	28(%esp)                # 4-byte Folded Spill
	jmp	.LBB233_1
.LBB233_64:                             # %while.end198
	testb	$1, 26(%esp)            # 1-byte Folded Reload
	je	.LBB233_75
# BB#65:                                # %if.then200
	movl	(%ebx), %eax
	movl	%ebx, %esi
	xorl	%ebp, %ebp
	testl	%eax, %eax
	movl	%ebp, %ebx
	jle	.LBB233_68
# BB#66:                                # %for.body.lr.ph.i
	movl	8(%esi), %ecx
	addl	$5, %ecx
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB233_67:                             # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%ecx), %edx
	addl	%edx, %ebx
	addl	$8, %ecx
	decl	%eax
	jne	.LBB233_67
.LBB233_68:                             # %for.end.i
	leal	(,%ebx,8), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	(%esi), %eax
	testl	%eax, %eax
	jle	.LBB233_73
# BB#69:
	movl	%ebp, %ecx
	.align	16, 0x90
.LBB233_70:                             # %for.body5.i
                                        # =>This Inner Loop Header: Depth=1
	movl	8(%esi), %edx
	cmpb	$0, 5(%edx,%ecx,8)
	je	.LBB233_72
# BB#71:                                # %if.then10.i
                                        #   in Loop: Header=BB233_70 Depth=1
	movsd	(%edx,%ecx,8), %xmm0
	movsd	%xmm0, (%edi,%ebp,8)
	incl	%ebp
	movl	(%esi), %eax
.LBB233_72:                             # %for.inc16.i
                                        #   in Loop: Header=BB233_70 Depth=1
	incl	%ecx
	cmpl	%eax, %ecx
	jl	.LBB233_70
.LBB233_73:                             # %for.end18.i
	cmpl	%ebx, %ebp
	jne	.LBB233_79
# BB#74:                                # %prune_non_exact.exit
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	%edi, 8(%esi)
	movl	%ebx, (%esi)
	movl	%ebx, 4(%esi)
	movl	%esi, %ebx
	jmp	.LBB233_77
.LBB233_75:                             # %if.else201
	movl	(%ebx), %eax
	cmpl	%eax, 4(%ebx)
	jle	.LBB233_77
# BB#76:                                # %if.then204
	movl	8(%ebx), %ecx
	shll	$3, %eax
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 8(%ebx)
	movl	(%ebx), %eax
	movl	%eax, 4(%ebx)
.LBB233_77:                             # %if.end211
	movl	%ebx, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB233_78:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.res_parse, 12(%esp)
	movl	$278, 8(%esp)           # imm = 0x116
	movl	$.L.str1996, 4(%esp)
	movl	$.L.str995, (%esp)
	calll	__assert_fail
.LBB233_79:                             # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.prune_non_exact, 12(%esp)
	movl	$174, 8(%esp)
	movl	$.L.str1996, 4(%esp)
	movl	$.L.str131008, (%esp)
	calll	__assert_fail
.Ltmp233:
	.size	res_parse, .Ltmp233-res_parse

	.globl	res_parse_from_file
	.align	16, 0x90
	.type	res_parse_from_file,@function
res_parse_from_file:                    # @res_parse_from_file
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	32(%esp), %edi
	movl	%edi, (%esp)
	calll	read_file
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB234_1
# BB#3:                                 # %if.end
	movl	(%esi), %eax
	movl	4(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	res_parse
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	read_file_free
	movl	%edi, %eax
	jmp	.LBB234_2
.LBB234_1:                              # %if.then
	movl	$5, 8(%esp)
	movl	$.L.str71002, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %esi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	xorl	%eax, %eax
.LBB234_2:                              # %return
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp234:
	.size	res_parse_from_file, .Ltmp234-res_parse_from_file

	.globl	res_match_path
	.align	16, 0x90
	.type	res_match_path,@function
res_match_path:                         # @res_match_path
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movb	$1, %al
	cmpl	$0, 48(%esp)
	je	.LBB235_41
# BB#1:                                 # %for.cond.preheader
	movl	48(%esp), %eax
	movl	(%eax), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	xorl	%edx, %edx
	jmp	.LBB235_2
	.align	16, 0x90
.LBB235_42:                             # %for.inc
                                        #   in Loop: Header=BB235_2 Depth=1
	incl	%edx
.LBB235_2:                              # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB235_4 Depth 2
	movb	$1, %al
	cmpl	24(%esp), %edx          # 4-byte Folded Reload
	jge	.LBB235_41
# BB#3:                                 # %for.body
                                        #   in Loop: Header=BB235_2 Depth=1
	movl	48(%esp), %eax
	movl	8(%eax), %eax
	movl	%eax, 16(%esp)          # 4-byte Spill
	movl	(%eax,%edx,8), %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	52(%esp), %ebp
	jmp	.LBB235_4
	.align	16, 0x90
.LBB235_37:                             # %for.inc.i
                                        #   in Loop: Header=BB235_4 Depth=2
	incl	%eax
	incl	%esi
	movl	%eax, %ebp
	movl	%esi, %eax
.LBB235_4:                              # %for.cond.i
                                        #   Parent Loop BB235_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB235_38
# BB#5:                                 # %if.end.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	(%ebp), %ch
	testb	%ch, %ch
	je	.LBB235_42
# BB#6:                                 # %do.body.i
                                        #   in Loop: Header=BB235_4 Depth=2
	cmpb	$37, %cl
	jne	.LBB235_7
# BB#8:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movzbl	1(%eax), %ebx
	movb	$37, %cl
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB235_9
# BB#10:                                # %land.lhs.true10.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movzbl	2(%eax), %edi
	movb	$37, %cl
	testb	$1, _sch_istable+1(%edi,%edi)
	je	.LBB235_11
# BB#12:                                # %if.then18.i
                                        #   in Loop: Header=BB235_4 Depth=2
	leal	2(%eax), %esi
	cmpb	$64, %bl
	jg	.LBB235_14
# BB#13:                                # %cond.true.i
                                        #   in Loop: Header=BB235_4 Depth=2
	addb	$-48, %bl
	movb	%bl, %cl
	jmp	.LBB235_15
.LBB235_7:                              #   in Loop: Header=BB235_4 Depth=2
	movl	%eax, %esi
	jmp	.LBB235_21
.LBB235_9:                              #   in Loop: Header=BB235_4 Depth=2
	movl	%eax, %esi
	jmp	.LBB235_21
.LBB235_11:                             #   in Loop: Header=BB235_4 Depth=2
	movl	%eax, %esi
	jmp	.LBB235_21
.LBB235_14:                             # %cond.false.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	_sch_toupper(%ebx), %cl
	addb	$-55, %cl
.LBB235_15:                             # %cond.end.i
                                        #   in Loop: Header=BB235_4 Depth=2
	shlb	$4, %cl
	movl	%edi, %ebx
	cmpb	$64, %bl
	jg	.LBB235_17
# BB#16:                                # %cond.true35.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movl	%edi, %ebx
	addb	$-48, %bl
	jmp	.LBB235_18
.LBB235_17:                             # %cond.false39.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	_sch_toupper(%edi), %bl
	addb	$-55, %bl
.LBB235_18:                             # %cond.end47.i
                                        #   in Loop: Header=BB235_4 Depth=2
	addb	%cl, %bl
	movb	$37, %cl
	cmpb	$47, %bl
	je	.LBB235_20
# BB#19:                                # %cond.end47.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	%bl, %cl
.LBB235_20:                             # %cond.end47.i
                                        #   in Loop: Header=BB235_4 Depth=2
	cmovel	%eax, %esi
.LBB235_21:                             # %do.body57.i
                                        #   in Loop: Header=BB235_4 Depth=2
	cmpb	$37, %ch
	jne	.LBB235_22
# BB#23:                                # %land.lhs.true61.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movzbl	1(%ebp), %ebx
	movb	$37, %ch
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB235_24
# BB#25:                                # %land.lhs.true69.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movzbl	2(%ebp), %edi
	movb	$37, %ch
	testb	$1, _sch_istable+1(%edi,%edi)
	je	.LBB235_26
# BB#27:                                # %if.then77.i
                                        #   in Loop: Header=BB235_4 Depth=2
	leal	2(%ebp), %eax
	cmpb	$64, %bl
	jg	.LBB235_29
# BB#28:                                # %cond.true83.i
                                        #   in Loop: Header=BB235_4 Depth=2
	addb	$-48, %bl
	movb	%bl, %ch
	jmp	.LBB235_30
.LBB235_22:                             #   in Loop: Header=BB235_4 Depth=2
	movl	%ebp, %eax
	jmp	.LBB235_36
.LBB235_24:                             #   in Loop: Header=BB235_4 Depth=2
	movl	%ebp, %eax
	jmp	.LBB235_36
.LBB235_26:                             #   in Loop: Header=BB235_4 Depth=2
	movl	%ebp, %eax
	jmp	.LBB235_36
.LBB235_29:                             # %cond.false87.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	_sch_toupper(%ebx), %ch
	addb	$-55, %ch
.LBB235_30:                             # %cond.end95.i
                                        #   in Loop: Header=BB235_4 Depth=2
	shlb	$4, %ch
	movl	%edi, %ebx
	cmpb	$64, %bl
	jg	.LBB235_32
# BB#31:                                # %cond.true102.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movl	%edi, %ebx
	addb	$-48, %bl
	jmp	.LBB235_33
.LBB235_32:                             # %cond.false106.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	_sch_toupper(%edi), %bl
	addb	$-55, %bl
.LBB235_33:                             # %cond.end114.i
                                        #   in Loop: Header=BB235_4 Depth=2
	addb	%ch, %bl
	movb	$37, %ch
	cmpb	$47, %bl
	je	.LBB235_35
# BB#34:                                # %cond.end114.i
                                        #   in Loop: Header=BB235_4 Depth=2
	movb	%bl, %ch
.LBB235_35:                             # %cond.end114.i
                                        #   in Loop: Header=BB235_4 Depth=2
	cmovel	%ebp, %eax
.LBB235_36:                             # %do.end125.i
                                        #   in Loop: Header=BB235_4 Depth=2
	cmpb	%ch, %cl
	jne	.LBB235_42
	jmp	.LBB235_37
.LBB235_38:                             # %if.then2
	movl	16(%esp), %eax          # 4-byte Reload
	movb	4(%eax,%edx,8), %bl
	cmpb	$0, opt+250
	jne	.LBB235_39
	.align	16, 0x90
.LBB235_40:                             # %do.end
	testb	%bl, %bl
	setne	%al
.LBB235_41:                             # %return
	movzbl	%al, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB235_39:                             # %if.then9
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	movl	52(%esp), %eax
	movl	%eax, 8(%esp)
	movl	$.L.str91004, %eax
	testb	%bl, %bl
	movl	$.L.str101005, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 4(%esp)
	movl	$.L.str81003, (%esp)
	calll	debug_logprintf
	jmp	.LBB235_40
.Ltmp235:
	.size	res_match_path, .Ltmp235-res_match_path

	.globl	res_register_specs
	.align	16, 0x90
	.type	res_register_specs,@function
res_register_specs:                     # @res_register_specs
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	12(%ebp), %eax
	movl	%eax, %ebx
	sarl	$31, %ebx
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	numdigit
	addl	$16, %esp
	leal	17(%esi,%eax), %eax
	andl	$-16, %eax
	movl	%esp, %edi
	subl	%eax, %edi
	movl	%edi, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$58, (%esi,%edi)
	subl	$16, %esp
	movl	%ebx, 8(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	calll	number_to_string
	addl	$16, %esp
	movl	registered_specs, %eax
	testl	%eax, %eax
	jne	.LBB236_2
# BB#1:                                 # %if.then
	subl	$16, %esp
	movl	$0, (%esp)
	calll	make_nocase_string_hash_table
	addl	$16, %esp
	movl	%eax, registered_specs
.LBB236_2:                              # %if.end
	movl	16(%ebp), %esi
	subl	$16, %esp
	leal	-16(%ebp), %ecx
	movl	%ecx, 12(%esp)
	leal	-20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get_pair
	addl	$16, %esp
	testl	%eax, %eax
	je	.LBB236_11
# BB#3:                                 # %if.then10
	movl	-16(%ebp), %edi
	testl	%edi, %edi
	je	.LBB236_10
# BB#4:                                 # %if.then12
	movl	8(%edi), %eax
	cmpl	$0, (%edi)
	jle	.LBB236_7
# BB#5:
	xorl	%ebx, %ebx
	.align	16, 0x90
.LBB236_6:                              # %for.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%eax,%ebx,8), %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
	movl	8(%edi), %eax
	incl	%ebx
	cmpl	(%edi), %ebx
	jl	.LBB236_6
.LBB236_7:                              # %for.end.i
	testl	%eax, %eax
	je	.LBB236_9
# BB#8:                                 # %if.else.i
	subl	$16, %esp
	movl	%eax, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB236_9:                              # %free_specs.exit
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_free
	addl	$16, %esp
.LBB236_10:                             # %if.end13
	movl	registered_specs, %eax
	movl	-20(%ebp), %ecx
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	jmp	.LBB236_12
.LBB236_11:                             # %if.else
	movl	registered_specs, %ebx
	subl	$16, %esp
	movl	%edi, (%esp)
	calll	checking_strdup
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
.LBB236_12:                             # %if.else
	calll	hash_table_put
	addl	$16, %esp
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp236:
	.size	res_register_specs, .Ltmp236-res_register_specs

	.globl	res_get_specs
	.align	16, 0x90
	.type	res_get_specs,@function
res_get_specs:                          # @res_get_specs
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	subl	$16, %esp
	movl	12(%ebp), %eax
	movl	%eax, %edi
	sarl	$31, %edi
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	numdigit
	addl	$16, %esp
	leal	17(%esi,%eax), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$58, (%esi,%ebx)
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	1(%ebx,%esi), %eax
	movl	%eax, (%esp)
	calll	number_to_string
	addl	$16, %esp
	movl	registered_specs, %eax
	testl	%eax, %eax
	je	.LBB237_1
# BB#2:                                 # %if.end
	subl	$16, %esp
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_get
	addl	$16, %esp
	jmp	.LBB237_3
.LBB237_1:
	xorl	%eax, %eax
.LBB237_3:                              # %return
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp237:
	.size	res_get_specs, .Ltmp237-res_get_specs

	.globl	res_retrieve_file
	.align	16, 0x90
	.type	res_retrieve_file,@function
res_retrieve_file:                      # @res_retrieve_file
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	48(%esp), %eax
	movl	%eax, (%esp)
	movl	$.L.str111006, 4(%esp)
	calll	uri_merge
	movl	%eax, %esi
	movb	opt+57, %al
	movb	%al, 31(%esp)           # 1-byte Spill
	movb	opt+251, %al
	movb	%al, 30(%esp)           # 1-byte Spill
	movl	$5, 8(%esp)
	movl	$.L.str121007, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	movl	52(%esp), %ebx
	movl	$0, (%ebx)
	movb	$0, opt+251
	movb	$0, opt+57
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 20(%esp)
	movl	$0, 16(%esp)
	movl	$0, 12(%esp)
	movl	$0, 8(%esp)
	calll	retrieve_url
	movl	%eax, %edi
	movb	30(%esp), %al           # 1-byte Reload
	movb	%al, opt+251
	movb	31(%esp), %al           # 1-byte Reload
	movb	%al, opt+57
	movl	%esi, (%esp)
	calll	checking_free
	cmpl	$31, %edi
	je	.LBB238_3
# BB#1:                                 # %land.lhs.true
	movl	(%ebx), %eax
	testl	%eax, %eax
	je	.LBB238_3
# BB#2:                                 # %if.then
	movl	%eax, (%esp)
	calll	checking_free
	movl	$0, (%ebx)
.LBB238_3:                              # %if.end
	cmpl	$31, %edi
	sete	%al
	movzbl	%al, %eax
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp238:
	.size	res_retrieve_file, .Ltmp238-res_retrieve_file

	.globl	is_robots_txt_url
	.align	16, 0x90
	.type	is_robots_txt_url,@function
is_robots_txt_url:                      # @is_robots_txt_url
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %edi
	movl	%edi, (%esp)
	movl	$.L.str111006, 4(%esp)
	calll	uri_merge
	movl	%eax, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	are_urls_equal
	movb	%al, %bl
	movl	%esi, (%esp)
	calll	checking_free
	movzbl	%bl, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp239:
	.size	is_robots_txt_url, .Ltmp239-is_robots_txt_url

	.globl	res_cleanup
	.align	16, 0x90
	.type	res_cleanup,@function
res_cleanup:                            # @res_cleanup
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$32, %esp
	movl	registered_specs, %eax
	testl	%eax, %eax
	je	.LBB240_9
# BB#1:                                 # %if.then
	leal	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB240_2
	.align	16, 0x90
.LBB240_7:                              # %free_specs.exit
                                        #   in Loop: Header=BB240_2 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
.LBB240_2:                              # %if.then
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB240_4 Depth 2
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	je	.LBB240_8
# BB#3:                                 # %for.body
                                        #   in Loop: Header=BB240_2 Depth=1
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %edi
	movl	8(%edi), %eax
	xorl	%ebx, %ebx
	cmpl	$0, (%edi)
	jle	.LBB240_5
	.align	16, 0x90
.LBB240_4:                              # %for.body.i
                                        #   Parent Loop BB240_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	(%eax,%ebx,8), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	8(%edi), %eax
	incl	%ebx
	cmpl	(%edi), %ebx
	jl	.LBB240_4
.LBB240_5:                              # %for.end.i
                                        #   in Loop: Header=BB240_2 Depth=1
	testl	%eax, %eax
	je	.LBB240_7
# BB#6:                                 # %if.else.i
                                        #   in Loop: Header=BB240_2 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB240_7
.LBB240_8:                              # %for.end
	movl	registered_specs, %eax
	movl	%eax, (%esp)
	calll	hash_table_destroy
	movl	$0, registered_specs
.LBB240_9:                              # %if.end
	addl	$32, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp240:
	.size	res_cleanup, .Ltmp240-res_cleanup

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI241_0:
	.quad	4606732058837280358     # double 9.500000e-01
                                        #  (0x66666666)
.LCPI241_1:
	.quad	4596373779694328218     # double 2.000000e-01
                                        #  (0x9999999a)
.LCPI241_2:
	.quad	4652007308841189376     # double 1.000000e+03
                                        #  (0x0)
.LCPI241_3:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
.LCPI241_4:
	.quad	-4620693217682128896    # double -5.000000e-01
                                        #  (0x0)
.LCPI241_5:
	.quad	0                       # double 0.000000e+00
                                        #  (0x0)
	.text
	.globl	fd_read_body
	.align	16, 0x90
	.type	fd_read_body,@function
fd_read_body:                           # @fd_read_body
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$204, %esp
	movl	260(%esp), %edx
	movl	%edx, %edi
	shll	$30, %edi
	sarl	$31, %edi
	movl	244(%esp), %eax
	movl	%edi, %ebp
	andl	%eax, %ebp
	movl	240(%esp), %ecx
	andl	%ecx, %edi
	andl	$1, %edx
	movl	%edx, 72(%esp)          # 4-byte Spill
	cmpl	$0, opt
	je	.LBB241_1
# BB#2:                                 # %if.then5
	movl	%ecx, %edx
	addl	232(%esp), %edx
	movl	%edx, 8(%esp)
	movl	%eax, %edx
	adcl	236(%esp), %edx
	movl	%edx, 12(%esp)
	xorl	%edx, %edx
	movl	%edi, %esi
	movl	%edi, 132(%esp)         # 4-byte Spill
	orl	%ebp, %esi
	cmovnel	%edx, %eax
	movl	%eax, 4(%esp)
	cmovnel	%edx, %ecx
	movl	%ecx, (%esp)
	calll	progress_create
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	progress_interactive_p
	movb	%al, 63(%esp)           # 1-byte Spill
	jmp	.LBB241_3
.LBB241_1:
	movl	%edi, 132(%esp)         # 4-byte Spill
	movl	$0, 76(%esp)            # 4-byte Folded Spill
	movb	$0, 63(%esp)            # 1-byte Folded Spill
.LBB241_3:                              # %if.end9
	movl	256(%esp), %ecx
	movl	opt+228, %eax
	orl	opt+232, %eax
	je	.LBB241_6
# BB#4:                                 # %if.end12.thread
	movl	$0, limit_data+4
	movl	$0, limit_data
	movl	$0, limit_data+12
	movl	$0, limit_data+8
	movl	$0, limit_data+20
	movl	$0, limit_data+16
	testl	%ecx, %ecx
	sete	50(%esp)                # 1-byte Folded Spill
	cmpl	$0, 76(%esp)            # 4-byte Folded Reload
	setne	111(%esp)               # 1-byte Folded Spill
	jmp	.LBB241_5
.LBB241_6:                              # %if.end12
	cmpl	$0, 76(%esp)            # 4-byte Folded Reload
	setne	111(%esp)               # 1-byte Folded Spill
	sete	%al
	testl	%ecx, %ecx
	sete	50(%esp)                # 1-byte Folded Spill
	jne	.LBB241_5
# BB#7:                                 # %if.end12
	testb	%al, %al
	je	.LBB241_5
# BB#8:
	xorl	%eax, %eax
	xorl	%ecx, %ecx
	xorl	%edi, %edi
	jmp	.LBB241_9
.LBB241_5:                              # %if.then17
	calll	ptimer_new
	movl	%eax, %edi
	movl	opt+232, %ecx
	movl	opt+228, %eax
.LBB241_9:                              # %if.end19
	cmpl	$16384, %eax            # imm = 0x4000
	setb	%dl
	testl	%ecx, %ecx
	sets	%dh
	je	.LBB241_11
# BB#10:                                # %if.end19
	movb	%dh, %dl
.LBB241_11:                             # %if.end19
	orl	%eax, %ecx
	setne	%cl
	testb	%dl, %cl
	movl	$16384, %ecx            # imm = 0x4000
	cmovnel	%eax, %ecx
	movl	%ecx, 56(%esp)          # 4-byte Spill
	sarl	$31, %ecx
	movl	%ecx, 52(%esp)          # 4-byte Spill
	cmpl	$0, 72(%esp)            # 4-byte Folded Reload
	sete	51(%esp)                # 1-byte Folded Spill
	xorl	%esi, %esi
	movl	$0, 64(%esp)            # 4-byte Folded Spill
	movl	$0, 68(%esp)            # 4-byte Folded Spill
	xorpd	%xmm0, %xmm0
	movsd	%xmm0, 96(%esp)         # 8-byte Spill
	movl	$0, 112(%esp)           # 4-byte Folded Spill
	movl	$0, 116(%esp)           # 4-byte Folded Spill
	jmp	.LBB241_12
	.align	16, 0x90
.LBB241_56:                             # %if.then106
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpl	12(%esp)
	movl	%esi, %eax
	sarl	$31, %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	progress_update
	.align	16, 0x90
.LBB241_12:                             # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ebx
	movl	112(%esp), %eax         # 4-byte Reload
	cmpl	232(%esp), %eax
	setb	%al
	movl	116(%esp), %ecx         # 4-byte Reload
	cmpl	236(%esp), %ecx
	setl	%cl
	je	.LBB241_14
# BB#13:                                # %while.cond
                                        #   in Loop: Header=BB241_12 Depth=1
	movb	%cl, %al
.LBB241_14:                             # %while.cond
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%ebp, %edi
	orb	51(%esp), %al           # 1-byte Folded Reload
	cmpb	$1, %al
	jne	.LBB241_58
# BB#15:                                # %while.body
                                        #   in Loop: Header=BB241_12 Depth=1
	cmpl	$0, 72(%esp)            # 4-byte Folded Reload
	movl	56(%esp), %edx          # 4-byte Reload
	movl	%edx, %ebp
	je	.LBB241_19
# BB#16:                                # %cond.true30
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	232(%esp), %ebp
	subl	112(%esp), %ebp         # 4-byte Folded Reload
	movl	236(%esp), %ecx
	sbbl	116(%esp), %ecx         # 4-byte Folded Reload
	cmpl	%edx, %ebp
	seta	%al
	cmpl	52(%esp), %ecx          # 4-byte Folded Reload
	setg	%cl
	je	.LBB241_18
# BB#17:                                # %cond.true30
                                        #   in Loop: Header=BB241_12 Depth=1
	movb	%cl, %al
.LBB241_18:                             # %cond.true30
                                        #   in Loop: Header=BB241_12 Depth=1
	testb	%al, %al
	cmovnel	%edx, %ebp
.LBB241_19:                             # %cond.end42
                                        #   in Loop: Header=BB241_12 Depth=1
	movsd	opt+180, %xmm0
	cmpb	$0, 63(%esp)            # 1-byte Folded Reload
	je	.LBB241_20
# BB#21:                                # %if.then46
                                        #   in Loop: Header=BB241_12 Depth=1
	ucomisd	.LCPI241_5, %xmm0
	movsd	.LCPI241_0, %xmm0
	jne	.LBB241_22
	jnp	.LBB241_25
.LBB241_22:                             # %if.then48
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%ebx, (%esp)
	calll	ptimer_read
	fstpl	192(%esp)
	movsd	192(%esp), %xmm1
	subsd	96(%esp), %xmm1         # 8-byte Folded Reload
	movapd	%xmm1, %xmm0
	movsd	.LCPI241_0, %xmm3
	addsd	%xmm3, %xmm0
	movsd	opt+180, %xmm2
	ucomisd	%xmm2, %xmm0
	movapd	%xmm3, %xmm0
	jbe	.LBB241_25
# BB#23:                                # %if.then54
                                        #   in Loop: Header=BB241_12 Depth=1
	subsd	%xmm1, %xmm2
	xorpd	%xmm0, %xmm0
	ucomisd	%xmm2, %xmm0
	movapd	%xmm2, %xmm0
	ja	.LBB241_24
.LBB241_25:                             # %if.end63
                                        #   in Loop: Header=BB241_12 Depth=1
	movsd	%xmm0, 12(%esp)
	movl	%ebp, 8(%esp)
	movl	224(%esp), %eax
	movl	%eax, (%esp)
	movl	$fd_read_body.dlbuf, 4(%esp)
	calll	fd_read
	movl	%eax, %esi
	testl	%esi, %esi
	jns	.LBB241_26
# BB#57:                                # %land.lhs.true70
                                        #   in Loop: Header=BB241_12 Depth=1
	calll	__errno_location
	movl	%eax, %ecx
	xorl	%eax, %eax
	cmpl	$110, (%ecx)
	je	.LBB241_28
	jmp	.LBB241_58
.LBB241_20:                             # %if.end63.thread
                                        #   in Loop: Header=BB241_12 Depth=1
	movsd	%xmm0, 12(%esp)
	movl	%ebp, 8(%esp)
	movl	224(%esp), %eax
	movl	%eax, (%esp)
	movl	$fd_read_body.dlbuf, 4(%esp)
	calll	fd_read
	jmp	.LBB241_27
.LBB241_26:                             #   in Loop: Header=BB241_12 Depth=1
	movl	%esi, %eax
.LBB241_27:                             # %if.else
                                        #   in Loop: Header=BB241_12 Depth=1
	testl	%eax, %eax
	movl	%eax, %esi
	jle	.LBB241_58
.LBB241_28:                             # %if.end79
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%eax, %esi
	movl	opt+228, %eax
	orl	opt+232, %eax
	setne	%al
	orb	111(%esp), %al          # 1-byte Folded Reload
	cmpb	$1, %al
	movl	%edi, %ebp
	jne	.LBB241_31
# BB#29:                                # %if.then83
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%ebx, %edi
	movl	%edi, (%esp)
	calll	ptimer_measure
	fstp	%st(0)
	testl	%esi, %esi
	jle	.LBB241_42
# BB#30:                                # %if.end90.thread
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpl	184(%esp)
	movsd	184(%esp), %xmm0
	movsd	%xmm0, 96(%esp)         # 8-byte Spill
	jmp	.LBB241_32
.LBB241_31:                             # %if.end90
                                        #   in Loop: Header=BB241_12 Depth=1
	testl	%esi, %esi
	movl	%ebx, %edi
	jle	.LBB241_42
.LBB241_32:                             # %if.then93
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%esi, %eax
	sarl	$31, %eax
	addl	%esi, 112(%esp)         # 4-byte Folded Spill
	adcl	%eax, 116(%esp)         # 4-byte Folded Spill
	cmpl	$0, 228(%esp)
	je	.LBB241_42
# BB#33:                                # %if.end.i
                                        #   in Loop: Header=BB241_12 Depth=1
	cmpl	%esi, 132(%esp)         # 4-byte Folded Reload
	setbe	%cl
	cmpl	%eax, %ebp
	setle	%dl
	je	.LBB241_35
# BB#34:                                # %if.end.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movb	%dl, %cl
.LBB241_35:                             # %if.end.i
                                        #   in Loop: Header=BB241_12 Depth=1
	testb	%cl, %cl
	jne	.LBB241_37
# BB#36:                                # %if.then2.i
                                        #   in Loop: Header=BB241_12 Depth=1
	subl	%esi, 132(%esp)         # 4-byte Folded Spill
	sbbl	%eax, %ebp
	jmp	.LBB241_42
.LBB241_37:                             # %if.end4.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	$fd_read_body.dlbuf, %eax
	movl	132(%esp), %ecx         # 4-byte Reload
	orl	%ecx, %ebp
	movl	%esi, %ebp
	je	.LBB241_40
# BB#38:                                # %if.then6.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%esi, %ebp
	subl	%ecx, %ebp
	je	.LBB241_41
# BB#39:                                #   in Loop: Header=BB241_12 Depth=1
	leal	fd_read_body.dlbuf(%ecx), %eax
.LBB241_40:                             # %write_data.exit
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	228(%esp), %ebx
	movl	%ebx, 12(%esp)
	movl	%ebp, 8(%esp)
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	calll	fwrite
	movl	%ebx, (%esp)
	calll	fflush
	movl	%ebx, (%esp)
	movl	%ebp, %eax
	sarl	$31, %eax
	addl	%ebp, 68(%esp)          # 4-byte Folded Spill
	adcl	%eax, 64(%esp)          # 4-byte Folded Spill
	calll	ferror
	testl	%eax, %eax
	jne	.LBB241_60
.LBB241_41:                             #   in Loop: Header=BB241_12 Depth=1
	movl	$0, 132(%esp)           # 4-byte Folded Spill
	xorl	%ebp, %ebp
.LBB241_42:                             # %if.end100
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	opt+228, %eax
	orl	opt+232, %eax
	je	.LBB241_55
# BB#43:                                # %if.then102
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpl	152(%esp)
	movl	%esi, %edx
	sarl	$31, %edx
	movl	limit_data, %eax
	addl	%esi, %eax
	movl	%eax, 168(%esp)
	movl	limit_data+4, %ecx
	adcl	%edx, %ecx
	movl	%ecx, 172(%esp)
	movsd	152(%esp), %xmm0
	subsd	limit_data+8, %xmm0
	movl	%ecx, limit_data+4
	movl	%eax, limit_data
	fildll	168(%esp)
	fstpl	160(%esp)
	fildll	opt+228
	fstpl	176(%esp)
	movsd	160(%esp), %xmm1
	divsd	176(%esp), %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB241_54
# BB#44:                                # %if.then.i
                                        #   in Loop: Header=BB241_12 Depth=1
	subsd	%xmm0, %xmm1
	movsd	%xmm0, 80(%esp)         # 8-byte Spill
	addsd	limit_data+16, %xmm1
	movsd	%xmm1, 120(%esp)        # 8-byte Spill
	movb	opt+250, %dl
	movsd	.LCPI241_1, %xmm0
	ucomisd	%xmm1, %xmm0
	jbe	.LBB241_47
# BB#45:                                # %do.body.i
                                        #   in Loop: Header=BB241_12 Depth=1
	testb	%dl, %dl
	je	.LBB241_55
# BB#46:                                # %if.then10.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movsd	80(%esp), %xmm0         # 8-byte Reload
	movsd	%xmm0, 16(%esp)
	movl	%eax, 12(%esp)
	movsd	120(%esp), %xmm0        # 8-byte Reload
	mulsd	.LCPI241_2, %xmm0
	movsd	%xmm0, 4(%esp)
	movl	$.L.str241054, (%esp)
	calll	debug_logprintf
	jmp	.LBB241_55
.LBB241_47:                             # %do.body13.i
                                        #   in Loop: Header=BB241_12 Depth=1
	testb	%dl, %dl
	je	.LBB241_49
# BB#48:                                # %if.then18.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	number_to_static_string
	movsd	limit_data+16, %xmm0
	movsd	%xmm0, 16(%esp)
	movl	%eax, 12(%esp)
	movsd	120(%esp), %xmm0        # 8-byte Reload
	mulsd	.LCPI241_2, %xmm0
	movsd	%xmm0, 4(%esp)
	movl	$.L.str251055, (%esp)
	calll	debug_logprintf
.LBB241_49:                             # %do.end22.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpt	80(%esp)                # 10-byte Folded Spill
	movsd	120(%esp), %xmm0        # 8-byte Reload
	movsd	%xmm0, (%esp)
	calll	xsleep
	movl	%edi, (%esp)
	fldt	80(%esp)                # 10-byte Folded Reload
	fstpl	144(%esp)
	calll	ptimer_measure
	fstpl	136(%esp)
	movsd	136(%esp), %xmm0
	subsd	144(%esp), %xmm0
	movsd	120(%esp), %xmm1        # 8-byte Reload
	subsd	%xmm0, %xmm1
	movsd	%xmm1, limit_data+16
	ucomisd	.LCPI241_3, %xmm1
	jbe	.LBB241_51
# BB#50:                                # %if.then29.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	$1071644672, limit_data+20 # imm = 0x3FE00000
	jmp	.LBB241_53
.LBB241_51:                             # %if.else.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movsd	.LCPI241_4, %xmm0
	ucomisd	%xmm1, %xmm0
	jbe	.LBB241_54
# BB#52:                                # %if.then32.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	$-1075838976, limit_data+20 # imm = 0xFFFFFFFFBFE00000
.LBB241_53:                             # %if.then32.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	$0, limit_data+16
.LBB241_54:                             # %if.end35.i
                                        #   in Loop: Header=BB241_12 Depth=1
	movl	$0, limit_data+4
	movl	$0, limit_data
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpl	limit_data+8
.LBB241_55:                             # %if.end104
                                        #   in Loop: Header=BB241_12 Depth=1
	cmpb	$1, 111(%esp)           # 1-byte Folded Reload
	jne	.LBB241_12
	jmp	.LBB241_56
.LBB241_58:                             # %while.end
	cmpl	$-1, %esi
	movl	$-1, %ebp
	cmovgel	%esi, %ebp
	.align	16, 0x90
.LBB241_59:                             # %while.end
	cmpb	$0, 111(%esp)           # 1-byte Folded Reload
	movl	%ebx, %edi
	jne	.LBB241_61
	jmp	.LBB241_62
.LBB241_24:                             # %if.then58
	calll	__errno_location
	movl	$110, (%eax)
	movl	$-1, %ebp
	jmp	.LBB241_59
.LBB241_60:                             # %out114
	movl	$-2, %ebp
	cmpb	$1, 111(%esp)           # 1-byte Folded Reload
	jne	.LBB241_62
.LBB241_61:                             # %if.then116
	movl	%edi, (%esp)
	calll	ptimer_read
	fstpl	4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	progress_finish
.LBB241_62:                             # %if.end118
	cmpb	$0, 50(%esp)            # 1-byte Folded Reload
	movl	248(%esp), %ebx
	jne	.LBB241_64
# BB#63:                                # %if.then120
	movl	%edi, (%esp)
	calll	ptimer_read
	movl	256(%esp), %eax
	fstpl	(%eax)
.LBB241_64:                             # %if.end122
	testl	%edi, %edi
	movl	252(%esp), %esi
	je	.LBB241_66
# BB#65:                                # %if.then124
	movl	%edi, (%esp)
	calll	ptimer_destroy
.LBB241_66:                             # %if.end125
	testl	%ebx, %ebx
	je	.LBB241_68
# BB#67:                                # %if.then127
	movl	4(%ebx), %eax
	movl	112(%esp), %ecx         # 4-byte Reload
	addl	(%ebx), %ecx
	movl	%ecx, (%ebx)
	adcl	116(%esp), %eax         # 4-byte Folded Reload
	movl	%eax, 4(%ebx)
.LBB241_68:                             # %if.end129
	testl	%esi, %esi
	je	.LBB241_70
# BB#69:                                # %if.then131
	movl	4(%esi), %eax
	movl	68(%esp), %ecx          # 4-byte Reload
	addl	(%esi), %ecx
	movl	%ecx, (%esi)
	adcl	64(%esp), %eax          # 4-byte Folded Reload
	movl	%eax, 4(%esi)
.LBB241_70:                             # %if.end133
	movl	%ebp, %eax
	addl	$204, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp241:
	.size	fd_read_body, .Ltmp241-fd_read_body

	.globl	fd_read_hunk
	.align	16, 0x90
	.type	fd_read_hunk,@function
fd_read_hunk:                           # @fd_read_hunk
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	72(%esp), %edi
	movl	%edi, (%esp)
	calll	checking_malloc
	movl	%eax, %ebx
	movl	76(%esp), %eax
	cmpl	%edi, %eax
	jl	.LBB242_26
# BB#1:                                 # %while.body.preheader
	testl	%eax, %eax
	sete	27(%esp)                # 1-byte Folded Spill
	xorl	%esi, %esi
	jmp	.LBB242_2
	.align	16, 0x90
.LBB242_22:                             # %if.end53
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	%ebx, (%esp)
	addl	%edi, %edi
	cmpl	%edx, %edi
	setg	%al
	testl	%edx, %edx
	setne	%cl
	testb	%al, %cl
	cmovnel	%edx, %edi
	movl	%edi, 4(%esp)
	calll	checking_realloc
	movl	%eax, %ebx
	.align	16, 0x90
.LBB242_2:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, 36(%esp)          # 4-byte Spill
	movl	%esi, %ecx
	leal	(%ebx,%ecx), %esi
	movl	%esi, 4(%esp)
	movl	64(%esp), %eax
	movl	%eax, (%esp)
	leal	-1(%edi), %eax
	movl	%eax, 28(%esp)          # 4-byte Spill
	subl	%ecx, %eax
	movl	%ecx, %ebp
	movl	%eax, 8(%esp)
	movl	$-1074790400, 16(%esp)  # imm = 0xFFFFFFFFBFF00000
	movl	$0, 12(%esp)
	calll	fd_peek
	movl	%eax, %edi
	testl	%edi, %edi
	js	.LBB242_3
# BB#4:                                 # %if.end
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	%ebx, 40(%esp)          # 4-byte Spill
	calll	*68(%esp)
	testl	%eax, %eax
	je	.LBB242_5
# BB#6:                                 # %if.then6
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	%eax, %edi
	subl	%esi, %edi
	js	.LBB242_27
# BB#7:                                 # %cond.end11
                                        #   in Loop: Header=BB242_2 Depth=1
	cmpl	%esi, %eax
	je	.LBB242_8
# BB#9:                                 # %if.end14
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	%ebp, %esi
	leal	(%edi,%esi), %ebx
	cmpl	%ebx, 28(%esp)          # 4-byte Folded Reload
	jge	.LBB242_11
# BB#10:                                # %if.then17
                                        #   in Loop: Header=BB242_2 Depth=1
	incl	%ebx
	movl	%ebx, 4(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	%ebx, 36(%esp)          # 4-byte Spill
	jmp	.LBB242_11
.LBB242_5:                              #   in Loop: Header=BB242_2 Depth=1
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	%ebp, %esi
.LBB242_11:                             # %if.end22
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	%edi, 8(%esp)
	movl	40(%esp), %ebx          # 4-byte Reload
	leal	(%ebx,%esi), %eax
	movl	%eax, 4(%esp)
	movl	64(%esp), %eax
	movl	%eax, (%esp)
	movl	$0, 16(%esp)
	movl	$0, 12(%esp)
	calll	fd_read
	testl	%eax, %eax
	js	.LBB242_12
# BB#13:                                # %if.end31
                                        #   in Loop: Header=BB242_2 Depth=1
	addl	%eax, %esi
	movb	$0, (%ebx,%esi)
	testl	%eax, %eax
	je	.LBB242_14
# BB#16:                                # %if.end40
                                        #   in Loop: Header=BB242_2 Depth=1
	cmpl	$0, 32(%esp)            # 4-byte Folded Reload
	movl	76(%esp), %edx
	jne	.LBB242_17
	.align	16, 0x90
.LBB242_19:                             # %if.end44
                                        #   in Loop: Header=BB242_2 Depth=1
	movl	36(%esp), %edi          # 4-byte Reload
	leal	-1(%edi), %eax
	cmpl	%eax, %esi
	jne	.LBB242_2
# BB#20:                                # %if.then47
                                        #   in Loop: Header=BB242_2 Depth=1
	cmpl	%edx, %edi
	setl	%al
	orb	27(%esp), %al           # 1-byte Folded Reload
	jne	.LBB242_22
	jmp	.LBB242_21
.LBB242_17:                             # %if.end40
                                        #   in Loop: Header=BB242_2 Depth=1
	cmpl	%edi, %eax
	jne	.LBB242_19
# BB#18:
	movl	%ebx, %eax
	jmp	.LBB242_25
.LBB242_12:                             # %if.then26
	xorl	%eax, %eax
	testl	%ebx, %ebx
	je	.LBB242_25
.LBB242_3:                              # %if.then
	movl	%ebx, (%esp)
	calll	checking_free
	jmp	.LBB242_24
.LBB242_14:                             # %if.then35
	testl	%esi, %esi
	je	.LBB242_23
# BB#15:
	movl	%ebx, %eax
	jmp	.LBB242_25
.LBB242_8:                              # %if.then13
	movb	$0, (%esi)
	movl	40(%esp), %eax          # 4-byte Reload
	jmp	.LBB242_25
.LBB242_21:                             # %if.then51
	movl	%ebx, (%esp)
	calll	checking_free
	calll	__errno_location
	movl	$12, (%eax)
	jmp	.LBB242_24
.LBB242_23:                             # %if.then37
	movl	%ebx, (%esp)
	calll	checking_free
	calll	__errno_location
	movl	$0, (%eax)
.LBB242_24:                             # %if.then37
	xorl	%eax, %eax
.LBB242_25:                             # %return
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB242_26:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.fd_read_hunk, 12(%esp)
	movl	$396, 8(%esp)           # imm = 0x18C
	movl	$.L.str11023, 4(%esp)
	movl	$.L.str1022, (%esp)
	calll	__assert_fail
.LBB242_27:                             # %cond.false10
	movl	$.L__PRETTY_FUNCTION__.fd_read_hunk, 12(%esp)
	movl	$417, 8(%esp)           # imm = 0x1A1
	movl	$.L.str11023, 4(%esp)
	movl	$.L.str21024, (%esp)
	calll	__assert_fail
.Ltmp242:
	.size	fd_read_hunk, .Ltmp242-fd_read_hunk

	.globl	fd_read_line
	.align	16, 0x90
	.type	fd_read_line,@function
fd_read_line:                           # @fd_read_line
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	movl	$4096, 12(%esp)         # imm = 0x1000
	movl	$128, 8(%esp)
	movl	$line_terminator, 4(%esp)
	calll	fd_read_hunk
	addl	$28, %esp
	ret
.Ltmp243:
	.size	fd_read_line, .Ltmp243-fd_read_line

	.align	16, 0x90
	.type	line_terminator,@function
line_terminator:                        # @line_terminator
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	movl	$10, 4(%esp)
	calll	memchr
	xorl	%ecx, %ecx
	testl	%eax, %eax
	leal	1(%eax), %eax
	cmovel	%ecx, %eax
	addl	$12, %esp
	ret
.Ltmp244:
	.size	line_terminator, .Ltmp244-line_terminator

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI245_0:
	.quad	4636733772917427405     # double 9.995000e+01
                                        #  (0xcccccccd)
.LCPI245_1:
	.quad	4621816302839204413     # double 9.995000e+00
                                        #  (0xa3d70a3d)
	.text
	.globl	retr_rate
	.align	16, 0x90
	.type	retr_rate,@function
retr_rate:                              # @retr_rate
# BB#0:                                 # %entry
	subl	$44, %esp
	leal	40(%esp), %eax
	movl	%eax, 16(%esp)
	movsd	56(%esp), %xmm0
	movsd	%xmm0, 8(%esp)
	movl	52(%esp), %eax
	movl	%eax, 4(%esp)
	movl	48(%esp), %eax
	movl	%eax, (%esp)
	calll	calc_rate
	fstpl	32(%esp)
	xorl	%eax, %eax
	movsd	32(%esp), %xmm0
	ucomisd	.LCPI245_0, %xmm0
	jae	.LBB245_2
# BB#1:                                 # %cond.false
	ucomisd	.LCPI245_1, %xmm0
	movl	$1, %eax
	adcl	$0, %eax
.LBB245_2:                              # %cond.end
	movl	40(%esp), %ecx
	movl	retr_rate.rate_names(,%ecx,4), %ecx
	movl	%ecx, 20(%esp)
	movsd	%xmm0, 12(%esp)
	movl	%eax, 8(%esp)
	movl	$.L.str71029, 4(%esp)
	movl	$retr_rate.res, (%esp)
	calll	sprintf
	movl	$retr_rate.res, %eax
	addl	$44, %esp
	ret
.Ltmp245:
	.size	retr_rate, .Ltmp245-retr_rate

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI246_0:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
.LCPI246_1:
	.quad	4652218415073722368     # double 1.024000e+03
                                        #  (0x0)
.LCPI246_2:
	.quad	4697254411347427328     # double 1.048576e+06
                                        #  (0x0)
.LCPI246_3:
	.quad	4742290407621132288     # double 1.073742e+09
                                        #  (0x0)
.LCPI246_4:
	.quad	4472074429978902528     # double 9.313226e-10
                                        #  (0x0)
.LCPI246_5:
	.quad	4517110426252607488     # double 9.536743e-07
                                        #  (0x0)
.LCPI246_6:
	.quad	4562146422526312448     # double 9.765625e-04
                                        #  (0x0)
	.text
	.globl	calc_rate
	.align	16, 0x90
	.type	calc_rate,@function
calc_rate:                              # @calc_rate
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$52, %esp
	movsd	72(%esp), %xmm1
	xorpd	%xmm0, %xmm0
	ucomisd	%xmm0, %xmm1
	jb	.LBB246_12
# BB#1:                                 # %cond.end
	movl	68(%esp), %esi
	testl	%esi, %esi
	js	.LBB246_13
# BB#2:                                 # %cond.end4
	movl	64(%esp), %edi
	xorpd	%xmm0, %xmm0
	ucomisd	%xmm0, %xmm1
	jne	.LBB246_4
	jp	.LBB246_4
# BB#3:                                 # %if.then
	calll	ptimer_resolution
	fstpl	40(%esp)
	movsd	40(%esp), %xmm1
	mulsd	.LCPI246_0, %xmm1
.LBB246_4:                              # %if.end
	movl	80(%esp), %eax
	movl	%edi, 32(%esp)
	movl	%esi, 36(%esp)
	fildll	32(%esp)
	fstpl	24(%esp)
	movsd	24(%esp), %xmm0
	divsd	%xmm1, %xmm0
	movsd	.LCPI246_1, %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB246_6
# BB#5:                                 # %if.then9
	movl	$0, (%eax)
	jmp	.LBB246_11
.LBB246_6:                              # %if.else
	movsd	.LCPI246_2, %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB246_8
# BB#7:                                 # %if.then12
	movl	$1, (%eax)
	mulsd	.LCPI246_6, %xmm0
	jmp	.LBB246_11
.LBB246_8:                              # %if.else14
	movsd	.LCPI246_3, %xmm1
	ucomisd	%xmm0, %xmm1
	jbe	.LBB246_10
# BB#9:                                 # %if.then17
	movl	$2, (%eax)
	mulsd	.LCPI246_5, %xmm0
	jmp	.LBB246_11
.LBB246_10:                             # %if.else19
	movl	$3, (%eax)
	mulsd	.LCPI246_4, %xmm0
.LBB246_11:                             # %if.end23
	movsd	%xmm0, 16(%esp)
	fldl	16(%esp)
	addl	$52, %esp
	popl	%esi
	popl	%edi
	ret
.LBB246_12:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.calc_rate, 12(%esp)
	movl	$548, 8(%esp)           # imm = 0x224
	movl	$.L.str11023, 4(%esp)
	movl	$.L.str81030, (%esp)
	calll	__assert_fail
.LBB246_13:                             # %cond.false3
	movl	$.L__PRETTY_FUNCTION__.calc_rate, 12(%esp)
	movl	$549, 8(%esp)           # imm = 0x225
	movl	$.L.str11023, 4(%esp)
	movl	$.L.str91031, (%esp)
	calll	__assert_fail
.Ltmp246:
	.size	calc_rate, .Ltmp246-calc_rate

	.globl	retrieve_url
	.align	16, 0x90
	.type	retrieve_url,@function
retrieve_url:                           # @retrieve_url
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$76, %esp
	movl	112(%esp), %eax
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	104(%esp), %esi
	movl	96(%esp), %ecx
	testl	%eax, %eax
	jne	.LBB247_2
# BB#1:                                 # %if.then
	movl	$0, 72(%esp)
	leal	72(%esp), %eax
	movl	%eax, 48(%esp)          # 4-byte Spill
.LBB247_2:                              # %if.end
	movl	100(%esp), %edi
	movl	%ecx, (%esp)
	calll	checking_strdup
	movl	%eax, %ebp
	testl	%esi, %esi
	je	.LBB247_4
# BB#3:                                 # %if.then2
	movl	$0, (%esi)
.LBB247_4:                              # %if.end3
	testl	%edi, %edi
	je	.LBB247_6
# BB#5:                                 # %if.then5
	movl	$0, (%edi)
.LBB247_6:                              # %if.end6
	leal	64(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebp, (%esp)
	calll	url_parse
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB247_7
# BB#8:                                 # %if.end11
	movb	116(%esp), %al
	movb	%al, 43(%esp)           # 1-byte Spill
	movl	108(%esp), %eax
	testl	%eax, %eax
	cmovel	opt+260, %eax
	movl	%eax, 36(%esp)          # 4-byte Spill
	xorl	%eax, %eax
	movb	$1, 42(%esp)            # 1-byte Folded Spill
	movl	%eax, 28(%esp)          # 4-byte Spill
	movl	%eax, 32(%esp)          # 4-byte Spill
	jmp	.LBB247_9
.LBB247_7:                              # %if.then9
	movl	64(%esp), %eax
	movl	%eax, (%esp)
	calll	url_error
	movl	%eax, 12(%esp)
	movl	%ebp, 8(%esp)
	movl	$.L.str101032, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	%ebp, (%esp)
	calll	checking_free
	movl	$23, %edi
	jmp	.LBB247_65
	.align	16, 0x90
.LBB247_44:                             # %do.body111
                                        #   in Loop: Header=BB247_9 Depth=1
	movl	opt+316, %eax
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	opt+312, %eax
	movl	%eax, 28(%esp)          # 4-byte Spill
	movl	$0, opt+312
	movl	$0, opt+316
	movl	52(%esp), %eax          # 4-byte Reload
	decl	%eax
	movb	$0, 42(%esp)            # 1-byte Folded Spill
	movl	%ebx, %edi
.LBB247_9:                              # %redirected.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB247_10 Depth 2
	incl	%eax
	movl	%eax, 52(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB247_10:                             # %redirected
                                        #   Parent Loop BB247_9 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%ebp, 44(%esp)          # 4-byte Spill
	movl	$0, 68(%esp)
	movl	$0, 60(%esp)
	movl	%edi, %ecx
	calll	getproxy
	movl	%eax, %ebx
	xorl	%ebp, %ebp
	testl	%ebx, %ebx
	je	.LBB247_18
# BB#11:                                # %if.then17
                                        #   in Loop: Header=BB247_10 Depth=2
	leal	64(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	url_parse
	movl	%eax, %ebp
	testl	%ebp, %ebp
	je	.LBB247_12
# BB#15:                                # %if.end26
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	4(%ebp), %eax
	testl	%eax, %eax
	je	.LBB247_18
# BB#16:                                # %land.lhs.true
                                        #   in Loop: Header=BB247_10 Depth=2
	cmpl	4(%edi), %eax
	jne	.LBB247_17
.LBB247_18:                             # %if.end38
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	4(%edi), %eax
	testl	%eax, %eax
	movb	43(%esp), %bh           # 1-byte Reload
	je	.LBB247_21
# BB#19:                                # %lor.lhs.false
                                        #   in Loop: Header=BB247_10 Depth=2
	testl	%ebp, %ebp
	je	.LBB247_22
# BB#20:                                # %land.lhs.true42
                                        #   in Loop: Header=BB247_10 Depth=2
	cmpl	$0, 4(%ebp)
	jne	.LBB247_22
.LBB247_21:                             # %if.then45
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%ebp, 20(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 16(%esp)
	movl	36(%esp), %eax          # 4-byte Reload
	movl	%eax, 12(%esp)
	leal	60(%esp), %eax
	movl	%eax, 8(%esp)
	leal	68(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	movl	%edi, 56(%esp)          # 4-byte Spill
	calll	http_loop
	movl	%eax, %edi
	jmp	.LBB247_31
.LBB247_22:                             # %if.else
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%edi, 56(%esp)          # 4-byte Spill
	xorl	%edi, %edi
	cmpl	$1, %eax
	jne	.LBB247_31
# BB#23:                                # %if.then49
                                        #   in Loop: Header=BB247_10 Depth=2
	cmpb	$0, opt+129
	setne	%al
	movl	%ebp, 8(%esp)
	movl	48(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	56(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	andb	$1, %bh
	movzbl	%bh, %ecx
	movl	%ecx, 12(%esp)
	movl	52(%esp), %esi          # 4-byte Reload
	cmpl	$1, %esi
	sete	%cl
	andb	%al, %cl
	movzbl	%cl, %eax
	movl	%eax, 16(%esp)
	xorb	%bl, %bl
	calll	ftp_loop
	movl	%eax, %edi
	cmpl	$1, %esi
	jne	.LBB247_25
# BB#24:                                # %if.then49
                                        #   in Loop: Header=BB247_10 Depth=2
	movb	%bh, %bl
.LBB247_25:                             # %if.then49
                                        #   in Loop: Header=BB247_10 Depth=2
	je	.LBB247_30
# BB#26:                                # %land.lhs.true63
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	60(%esp), %eax
	testl	%eax, %eax
	je	.LBB247_30
# BB#27:                                # %land.lhs.true65
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	56(%esp), %ecx          # 4-byte Reload
	cmpl	$1, 4(%ecx)
	jne	.LBB247_30
# BB#28:                                # %if.then68
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%eax, (%esp)
	calll	has_html_suffix_p
	cmpb	$1, %al
	jne	.LBB247_30
# BB#29:                                # %if.then70
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	48(%esp), %eax          # 4-byte Reload
	orb	$1, (%eax)
.LBB247_30:                             # %if.then70
                                        #   in Loop: Header=BB247_10 Depth=2
	movb	%bl, %bh
.LBB247_31:                             # %if.end74
                                        #   in Loop: Header=BB247_10 Depth=2
	testl	%ebp, %ebp
	je	.LBB247_33
# BB#32:                                # %if.then76
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%ebp, (%esp)
	calll	url_free
.LBB247_33:                             # %if.end77
                                        #   in Loop: Header=BB247_10 Depth=2
	cmpl	$6, %edi
	jne	.LBB247_45
# BB#34:                                # %if.then81
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	68(%esp), %eax
	testl	%eax, %eax
	je	.LBB247_66
# BB#35:                                # %cond.end
                                        #   in Loop: Header=BB247_10 Depth=2
	movb	%bh, 43(%esp)           # 1-byte Spill
	movl	60(%esp), %ecx
	testl	%ecx, %ecx
	movl	56(%esp), %esi          # 4-byte Reload
	movl	52(%esp), %edi          # 4-byte Reload
	je	.LBB247_37
# BB#36:                                # %if.then84
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%ecx, (%esp)
	calll	checking_free
	movl	68(%esp), %eax
.LBB247_37:                             # %if.end85
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%eax, 4(%esp)
	movl	44(%esp), %ebp          # 4-byte Reload
	movl	%ebp, (%esp)
	calll	uri_merge
	movl	%eax, %ebx
	movl	68(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	%ebx, 68(%esp)
	leal	64(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	url_parse
	movl	%eax, %ebx
	movl	68(%esp), %eax
	testl	%ebx, %ebx
	je	.LBB247_38
# BB#40:                                # %if.end97
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%eax, (%esp)
	calll	checking_free
	movl	(%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, 68(%esp)
	cmpl	opt+20, %edi
	jg	.LBB247_41
# BB#43:                                # %if.end108
                                        #   in Loop: Header=BB247_10 Depth=2
	movl	%ebp, (%esp)
	calll	checking_free
	movl	68(%esp), %ebp
	movl	%esi, (%esp)
	calll	url_free
	incl	%edi
	movl	%edi, 52(%esp)          # 4-byte Spill
	testb	$1, 42(%esp)            # 1-byte Folded Reload
	movl	%ebx, %edi
	je	.LBB247_10
	jmp	.LBB247_44
.LBB247_45:                             # %if.end114
	xorl	%eax, %eax
	movl	60(%esp), %ecx
	testl	%ecx, %ecx
	je	.LBB247_53
# BB#46:                                # %if.then116
	movl	48(%esp), %eax          # 4-byte Reload
	testb	$2, (%eax)
	movl	96(%esp), %ebp
	je	.LBB247_52
# BB#47:                                # %if.then118
	movl	56(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	register_download
	cmpl	$1, 52(%esp)            # 4-byte Folded Reload
	je	.LBB247_50
# BB#48:                                # %land.lhs.true121
	movl	56(%esp), %eax          # 4-byte Reload
	movl	(%eax), %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	calll	strcmp
	testl	%eax, %eax
	je	.LBB247_50
# BB#49:                                # %if.then125
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	calll	register_redirection
.LBB247_50:                             # %if.end127
	movl	48(%esp), %eax          # 4-byte Reload
	testb	$1, (%eax)
	je	.LBB247_52
# BB#51:                                # %if.then130
	movl	56(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	60(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	register_html
.LBB247_52:                             # %if.end134thread-pre-split
	movl	60(%esp), %eax
.LBB247_53:                             # %if.end134
	movl	100(%esp), %ecx
	testl	%ecx, %ecx
	movl	44(%esp), %ebx          # 4-byte Reload
	je	.LBB247_55
# BB#54:                                # %if.then136
	movl	%eax, (%ecx)
	jmp	.LBB247_57
.LBB247_38:                             # %if.then89
	movl	%eax, (%esp)
	calll	escnonprint_uri
	movl	%eax, %ebx
	movl	64(%esp), %eax
	movl	%eax, (%esp)
	calll	url_error
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	$.L.str101032, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	%esi, (%esp)
	calll	url_free
	movl	%ebp, (%esp)
	calll	checking_free
	movl	68(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	$6, %edi
	testb	$1, 42(%esp)            # 1-byte Folded Reload
	movl	32(%esp), %eax          # 4-byte Reload
	movl	28(%esp), %ecx          # 4-byte Reload
	jne	.LBB247_65
# BB#39:                                # %if.then94
	movl	%ecx, opt+312
	movl	%eax, opt+316
	movl	$6, %edi
	jmp	.LBB247_65
.LBB247_41:                             # %if.then101
	movl	$5, 8(%esp)
	movl	$.L.str141036, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	opt+20, %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	%ebx, (%esp)
	calll	url_free
	movl	%esi, (%esp)
	calll	url_free
	movl	%ebp, (%esp)
	calll	checking_free
	movl	68(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	$34, %edi
	testb	$1, 42(%esp)            # 1-byte Folded Reload
	movl	32(%esp), %eax          # 4-byte Reload
	movl	28(%esp), %ecx          # 4-byte Reload
	jne	.LBB247_65
# BB#42:                                # %if.then105
	movl	%ecx, opt+312
	movl	%eax, opt+316
	movl	$34, %edi
	jmp	.LBB247_65
.LBB247_12:                             # %if.then20
	movl	$5, 8(%esp)
	movl	$.L.str111033, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	movl	64(%esp), %eax
	movl	%eax, (%esp)
	calll	url_error
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	jmp	.LBB247_13
.LBB247_55:                             # %if.else141
	testl	%eax, %eax
	je	.LBB247_57
# BB#56:                                # %if.else144
	movl	%eax, (%esp)
	calll	checking_free
.LBB247_57:                             # %if.end146
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	url_free
	cmpl	$1, 52(%esp)            # 4-byte Folded Reload
	jne	.LBB247_58
# BB#60:                                # %if.else153
	movl	104(%esp), %eax
	testl	%eax, %eax
	movl	32(%esp), %esi          # 4-byte Reload
	je	.LBB247_62
# BB#61:                                # %if.then155
	movl	$0, (%eax)
	jmp	.LBB247_62
.LBB247_58:                             # %if.then148
	movl	104(%esp), %eax
	testl	%eax, %eax
	movl	32(%esp), %esi          # 4-byte Reload
	je	.LBB247_62
# BB#59:                                # %if.then150
	movl	%ebx, (%eax)
	jmp	.LBB247_63
.LBB247_62:                             # %if.end156
	movl	%ebx, (%esp)
	calll	checking_free
.LBB247_63:                             # %do.body158
	testb	$1, 42(%esp)            # 1-byte Folded Reload
	jne	.LBB247_65
# BB#64:                                # %if.then160
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, opt+312
	movl	%esi, opt+316
	jmp	.LBB247_65
.LBB247_17:                             # %if.then30
	movl	$5, 8(%esp)
	movl	$.L.str121034, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%ebx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	%ebp, (%esp)
	calll	url_free
.LBB247_13:                             # %if.then20
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	checking_free
	movl	$49, %edi
	testb	$1, 42(%esp)            # 1-byte Folded Reload
	movl	32(%esp), %eax          # 4-byte Reload
	movl	28(%esp), %ecx          # 4-byte Reload
	jne	.LBB247_65
# BB#14:                                # %if.then24
	movl	%ecx, opt+312
	movl	%eax, opt+316
	movl	$49, %edi
.LBB247_65:                             # %return
	movl	%edi, %eax
	addl	$76, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB247_66:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.retrieve_url, 12(%esp)
	movl	$712, 8(%esp)           # imm = 0x2C8
	movl	$.L.str11023, 4(%esp)
	movl	$.L.str131035, (%esp)
	calll	__assert_fail
.Ltmp247:
	.size	retrieve_url, .Ltmp247-retrieve_url

	.align	16, 0x90
	.type	getproxy,@function
getproxy:                               # @getproxy
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	%ecx, %esi
	xorl	%eax, %eax
	cmpb	$0, opt+145
	je	.LBB248_13
# BB#1:                                 # %if.end
	movl	opt+160, %eax
	testl	%eax, %eax
	je	.LBB248_3
# BB#2:                                 # %no_proxy_match.exit
	movl	8(%esi), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	sufmatch
	movb	%al, %cl
	xorl	%eax, %eax
	testb	%cl, %cl
	jne	.LBB248_13
.LBB248_3:                              # %if.end2
	movl	4(%esi), %ecx
	cmpl	$1, %ecx
	jne	.LBB248_4
# BB#7:                                 # %sw.bb5
	movl	opt+152, %esi
	testl	%esi, %esi
	jne	.LBB248_10
# BB#8:                                 # %cond.false8
	movl	$.L.str231053, (%esp)
	jmp	.LBB248_9
.LBB248_4:                              # %if.end2
	xorl	%eax, %eax
	testl	%ecx, %ecx
	jne	.LBB248_13
# BB#5:                                 # %sw.bb
	movl	opt+148, %esi
	testl	%esi, %esi
	jne	.LBB248_10
# BB#6:                                 # %cond.false
	movl	$.L.str221052, (%esp)
.LBB248_9:                              # %cond.false8
	calll	getenv
	movl	%eax, %esi
	xorl	%eax, %eax
	testl	%esi, %esi
	je	.LBB248_13
.LBB248_10:                             # %lor.lhs.false
	xorl	%eax, %eax
	cmpb	$0, (%esi)
	je	.LBB248_13
# BB#11:                                # %if.end15
	movl	%esi, (%esp)
	calll	rewrite_shorthand_url
	movl	%eax, %ecx
	testl	%ecx, %ecx
	movl	%esi, %eax
	je	.LBB248_13
# BB#12:                                # %if.then18
	movl	%ecx, 4(%esp)
	movl	$1024, 8(%esp)          # imm = 0x400
	movl	$getproxy.rewritten_storage, (%esp)
	calll	strncpy
	movb	$0, getproxy.rewritten_storage+1023
	movl	$getproxy.rewritten_storage, %eax
.LBB248_13:                             # %return
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp248:
	.size	getproxy, .Ltmp248-getproxy

	.globl	retrieve_from_file
	.align	16, 0x90
	.type	retrieve_from_file,@function
retrieve_from_file:                     # @retrieve_from_file
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	movl	72(%esp), %ebx
	movl	64(%esp), %eax
	movb	68(%esp), %cl
	testb	%cl, %cl
	je	.LBB249_2
# BB#1:                                 # %cond.true
	movl	%eax, (%esp)
	movl	$0, 8(%esp)
	movl	$0, 4(%esp)
	calll	get_urls_html
	jmp	.LBB249_3
.LBB249_2:                              # %cond.false
	movl	%eax, (%esp)
	calll	get_urls_file
.LBB249_3:                              # %cond.false
	movl	%eax, %ebp
	movl	$31, %edi
	xorl	%eax, %eax
	movl	%ebp, %esi
	movl	%ebx, %ecx
	jmp	.LBB249_4
	.align	16, 0x90
.LBB249_31:                             # %for.inc
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	28(%esi), %esi
	movl	72(%esp), %ecx
	movl	(%ecx), %eax
	incl	%eax
.LBB249_4:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, (%ecx)
	testl	%esi, %esi
	je	.LBB249_32
# BB#5:                                 # %for.body
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	$0, 40(%esp)
	movl	$0, 36(%esp)
	testb	$1, 8(%esi)
	jne	.LBB249_31
# BB#6:                                 # %if.end
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	opt+240, %eax
	movl	opt+236, %ecx
	movl	%ecx, %edx
	orl	%eax, %edx
	jne	.LBB249_7
	.align	16, 0x90
.LBB249_10:                             # %if.end6
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	opt+15, %al
	movb	opt+290, %cl
	orb	%al, %cl
	je	.LBB249_15
# BB#11:                                # %land.lhs.true9
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	(%esi), %ecx
	cmpl	$1, 4(%ecx)
	jne	.LBB249_12
# BB#13:                                # %lor.lhs.false11
                                        #   in Loop: Header=BB249_4 Depth=1
	calll	getproxy
	testl	%eax, %eax
	jne	.LBB249_16
# BB#14:                                # %lor.lhs.false11.if.else_crit_edge
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	opt+15, %al
.LBB249_15:                             # %if.else
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	(%esi), %ecx
	movl	(%ecx), %ecx
	testb	%al, %al
	setne	%al
	movzbl	%al, %eax
	movl	%eax, 20(%esp)
	leal	32(%esp), %eax
	movl	%eax, 16(%esp)
	leal	36(%esp), %eax
	movl	%eax, 8(%esp)
	leal	40(%esp), %eax
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	movl	$0, 12(%esp)
	calll	retrieve_url
	movl	%eax, %edi
	jmp	.LBB249_19
.LBB249_12:                             # %if.then15.thread
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	opt+100, %bl
	jmp	.LBB249_18
.LBB249_16:                             # %if.then15
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	(%esi), %ecx
	movb	opt+100, %bl
	cmpl	$1, 4(%ecx)
	jne	.LBB249_18
# BB#17:                                # %if.then21
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	$1, opt+100
.LBB249_18:                             # %if.end22
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	calll	retrieve_tree
	movl	%eax, %edi
	movb	%bl, opt+100
.LBB249_19:                             # %if.end32
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	40(%esp), %eax
	testl	%eax, %eax
	je	.LBB249_27
# BB#20:                                # %if.end32
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	opt+288, %cl
	testb	%cl, %cl
	je	.LBB249_27
# BB#21:                                # %land.lhs.true37
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	%eax, (%esp)
	calll	file_exists_p
	cmpb	$1, %al
	jne	.LBB249_27
# BB#22:                                # %do.body
                                        #   in Loop: Header=BB249_4 Depth=1
	cmpb	$0, opt+250
	jne	.LBB249_23
	.align	16, 0x90
.LBB249_24:                             # %do.end
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	$5, 8(%esp)
	movl	$.L.str161040, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	40(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	40(%esp), %eax
	movl	%eax, (%esp)
	calll	unlink
	testl	%eax, %eax
	je	.LBB249_26
# BB#25:                                # %if.then49
                                        #   in Loop: Header=BB249_4 Depth=1
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 8(%esp)
	movl	$.L.str171041, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB249_26:                             # %if.end52
                                        #   in Loop: Header=BB249_4 Depth=1
	andb	$-3, 32(%esp)
.LBB249_27:                             # %if.end53
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	36(%esp), %eax
	testl	%eax, %eax
	je	.LBB249_29
# BB#28:                                # %if.else56
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB249_29:                             # %if.end57
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	40(%esp), %eax
	testl	%eax, %eax
	je	.LBB249_31
# BB#30:                                # %if.else60
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	jmp	.LBB249_31
.LBB249_7:                              # %if.end
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	total_downloaded_bytes+4, %edx
	movl	total_downloaded_bytes, %edi
	cmpl	%ecx, %edi
	seta	%cl
	cmpl	%eax, %edx
	setg	%al
	je	.LBB249_9
# BB#8:                                 # %if.end
                                        #   in Loop: Header=BB249_4 Depth=1
	movb	%al, %cl
.LBB249_9:                              # %if.end
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	$51, %edi
	testb	%cl, %cl
	jne	.LBB249_32
	jmp	.LBB249_10
.LBB249_23:                             # %if.then44
                                        #   in Loop: Header=BB249_4 Depth=1
	movl	$.L.str151039, (%esp)
	calll	debug_logprintf
	jmp	.LBB249_24
.LBB249_32:                             # %for.end
	testl	%ebp, %ebp
	je	.LBB249_38
	.align	16, 0x90
.LBB249_33:                             # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%ebp), %eax
	movl	28(%ebp), %esi
	testl	%eax, %eax
	je	.LBB249_35
# BB#34:                                # %if.then.i
                                        #   in Loop: Header=BB249_33 Depth=1
	movl	%eax, (%esp)
	calll	url_free
.LBB249_35:                             # %if.end.i
                                        #   in Loop: Header=BB249_33 Depth=1
	movl	4(%ebp), %eax
	testl	%eax, %eax
	je	.LBB249_37
# BB#36:                                # %if.else.i
                                        #   in Loop: Header=BB249_33 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB249_37:                             # %if.end7.i
                                        #   in Loop: Header=BB249_33 Depth=1
	movl	%ebp, (%esp)
	calll	checking_free
	testl	%esi, %esi
	movl	%esi, %ebp
	jne	.LBB249_33
.LBB249_38:                             # %free_urlpos.exit
	movl	%edi, %eax
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp249:
	.size	retrieve_from_file, .Ltmp249-retrieve_from_file

	.globl	free_urlpos
	.align	16, 0x90
	.type	free_urlpos,@function
free_urlpos:                            # @free_urlpos
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	16(%esp), %esi
	testl	%esi, %esi
	je	.LBB250_6
	.align	16, 0x90
.LBB250_1:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	(%esi), %eax
	movl	28(%esi), %edi
	testl	%eax, %eax
	je	.LBB250_3
# BB#2:                                 # %if.then
                                        #   in Loop: Header=BB250_1 Depth=1
	movl	%eax, (%esp)
	calll	url_free
.LBB250_3:                              # %if.end
                                        #   in Loop: Header=BB250_1 Depth=1
	movl	4(%esi), %eax
	testl	%eax, %eax
	je	.LBB250_5
# BB#4:                                 # %if.else
                                        #   in Loop: Header=BB250_1 Depth=1
	movl	%eax, (%esp)
	calll	checking_free
.LBB250_5:                              # %if.end7
                                        #   in Loop: Header=BB250_1 Depth=1
	movl	%esi, (%esp)
	calll	checking_free
	testl	%edi, %edi
	movl	%edi, %esi
	jne	.LBB250_1
.LBB250_6:                              # %while.end
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp250:
	.size	free_urlpos, .Ltmp250-free_urlpos

	.globl	printwhat
	.align	16, 0x90
	.type	printwhat,@function
printwhat:                              # @printwhat
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	16(%esp), %eax
	cmpl	20(%esp), %eax
	jne	.LBB251_2
# BB#1:                                 # %cond.true
	movl	$5, 8(%esp)
	movl	$.L.str181042, 4(%esp)
	jmp	.LBB251_3
.LBB251_2:                              # %cond.false
	movl	$5, 8(%esp)
	movl	$.L.str191043, 4(%esp)
.LBB251_3:                              # %cond.false
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$0, (%esp)
	calll	logputs
	addl	$12, %esp
	ret
.Ltmp251:
	.size	printwhat, .Ltmp251-printwhat

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI252_0:
	.quad	4602678819172646912     # double 5.000000e-01
                                        #  (0x0)
	.text
	.globl	sleep_between_retrievals
	.align	16, 0x90
	.type	sleep_between_retrievals,@function
sleep_between_retrievals:               # @sleep_between_retrievals
# BB#0:                                 # %entry
	subl	$44, %esp
	movb	sleep_between_retrievals.first_retrieval.b, %al
	testb	%al, %al
	je	.LBB252_1
# BB#3:                                 # %if.end
	movl	48(%esp), %eax
	movsd	opt+216, %xmm0
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	jne	.LBB252_4
	jnp	.LBB252_9
.LBB252_4:                              # %if.end
	cmpl	$2, %eax
	jl	.LBB252_9
# BB#5:                                 # %if.then2
	xorps	%xmm1, %xmm1
	cvtsi2sd	%eax, %xmm1
	ucomisd	%xmm1, %xmm0
	jb	.LBB252_7
# BB#6:                                 # %if.then5
	decl	%eax
	xorps	%xmm0, %xmm0
	cvtsi2sd	%eax, %xmm0
	jmp	.LBB252_7
.LBB252_1:                              # %if.then
	movb	$1, sleep_between_retrievals.first_retrieval.b
	jmp	.LBB252_2
.LBB252_9:                              # %if.else8
	movsd	opt+208, %xmm0
	ucomisd	%xmm1, %xmm0
	jne	.LBB252_10
	jnp	.LBB252_2
.LBB252_10:                             # %if.then10
	cmpb	$0, opt+204
	je	.LBB252_7
# BB#11:                                # %if.then10
	cmpl	$2, %eax
	jge	.LBB252_7
# BB#12:                                # %if.else15
	calll	random_float
	fstpl	32(%esp)
	movsd	32(%esp), %xmm1
	addsd	.LCPI252_0, %xmm1
	movsd	opt+208, %xmm0
	mulsd	%xmm0, %xmm1
	cmpb	$0, opt+250
	jne	.LBB252_13
	.align	16, 0x90
.LBB252_14:                             # %do.end
	movsd	%xmm1, (%esp)
	jmp	.LBB252_8
.LBB252_2:                              # %if.end23
	addl	$44, %esp
	ret
.LBB252_7:                              # %if.else
	movsd	%xmm0, (%esp)
.LBB252_8:                              # %if.else
	calll	xsleep
	addl	$44, %esp
	ret
.LBB252_13:                             # %if.then19
	movsd	%xmm1, 12(%esp)
	movsd	%xmm0, 4(%esp)
	movl	$.L.str201044, (%esp)
	movsd	%xmm1, 24(%esp)         # 8-byte Spill
	calll	debug_logprintf
	movsd	24(%esp), %xmm1         # 8-byte Reload
	jmp	.LBB252_14
.Ltmp252:
	.size	sleep_between_retrievals, .Ltmp252-sleep_between_retrievals

	.globl	rotate_backups
	.align	16, 0x90
	.type	rotate_backups,@function
rotate_backups:                         # @rotate_backups
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%edi
	pushl	%esi
	subl	$96, %esp
	subl	$16, %esp
	movl	8(%ebp), %edi
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	movzbl	opt+253, %eax
	subl	$16, %esp
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	calll	numdigit
	addl	$16, %esp
	leal	17(%esi,%eax), %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	leal	-104(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	testl	%eax, %eax
	jne	.LBB253_2
# BB#1:                                 # %if.then
	movl	$61440, %eax            # imm = 0xF000
	andl	-88(%ebp), %eax
	cmpl	$32768, %eax            # imm = 0x8000
	jne	.LBB253_3
.LBB253_2:                              # %for.end
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%esi, (%esp)
	movl	$1, 12(%esp)
	movl	$.L.str211045, 4(%esp)
	calll	sprintf
	addl	$16, %esp
	subl	$16, %esp
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	rename
	addl	$16, %esp
.LBB253_3:                              # %return
	leal	-8(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebp
	ret
.Ltmp253:
	.size	rotate_backups, .Ltmp253-rotate_backups

	.globl	url_uses_proxy
	.align	16, 0x90
	.type	url_uses_proxy,@function
url_uses_proxy:                         # @url_uses_proxy
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	calll	url_parse
	movl	%eax, %esi
	xorb	%al, %al
	testl	%esi, %esi
	je	.LBB254_2
# BB#1:                                 # %if.end
	movl	%esi, %ecx
	calll	getproxy
	movl	%eax, %edi
	movl	%esi, (%esp)
	calll	url_free
	testl	%edi, %edi
	setne	%al
.LBB254_2:                              # %return
	movzbl	%al, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp254:
	.size	url_uses_proxy, .Ltmp254-url_uses_proxy

	.globl	spider_cleanup
	.align	16, 0x90
	.type	spider_cleanup,@function
spider_cleanup:                         # @spider_cleanup
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	nonexisting_urls_set, %eax
	testl	%eax, %eax
	je	.LBB255_2
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	calll	string_set_free
.LBB255_2:                              # %if.end
	addl	$12, %esp
	ret
.Ltmp255:
	.size	spider_cleanup, .Ltmp255-spider_cleanup

	.globl	nonexisting_url
	.align	16, 0x90
	.type	nonexisting_url,@function
nonexisting_url:                        # @nonexisting_url
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	%esi, (%esp)
	calll	is_robots_txt_url
	testb	%al, %al
	jne	.LBB256_4
# BB#1:                                 # %if.end
	movl	nonexisting_urls_set, %eax
	testl	%eax, %eax
	jne	.LBB256_3
# BB#2:                                 # %if.then1
	movl	$0, (%esp)
	calll	make_string_hash_table
	movl	%eax, nonexisting_urls_set
.LBB256_3:                              # %if.end3
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	string_set_add
.LBB256_4:                              # %return
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp256:
	.size	nonexisting_url, .Ltmp256-nonexisting_url

	.globl	print_broken_links
	.align	16, 0x90
	.type	print_broken_links,@function
print_broken_links:                     # @print_broken_links
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$52, %esp
	movl	nonexisting_urls_set, %eax
	testl	%eax, %eax
	je	.LBB257_1
# BB#2:                                 # %if.end
	movl	%eax, (%esp)
	calll	hash_table_count
	movl	%eax, %esi
	testl	%esi, %esi
	jle	.LBB257_8
# BB#3:                                 # %cond.end
	movl	%esi, 12(%esp)
	movl	$5, 16(%esp)
	movl	$.L.str41090, 8(%esp)
	movl	$.L.str31089, 4(%esp)
	movl	$0, (%esp)
	calll	dcngettext
	movl	%esi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
	movl	nonexisting_urls_set, %eax
	leal	32(%esp), %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB257_5
	.align	16, 0x90
.LBB257_4:                              # %for.body
                                        #   in Loop: Header=BB257_5 Depth=1
	movl	32(%esp), %edi
	movl	$5, 8(%esp)
	movl	$.L.str51091, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%edi, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB257_5:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB257_4
# BB#6:                                 # %for.end
	movl	$.L.str61092, 4(%esp)
	movl	$1, (%esp)
	calll	logputs
	jmp	.LBB257_7
.LBB257_1:                              # %if.then
	movl	$5, 8(%esp)
	movl	$.L.str1086, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB257_7:                              # %return
	addl	$52, %esp
	popl	%esi
	popl	%edi
	ret
.LBB257_8:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.print_broken_links, 12(%esp)
	movl	$80, 8(%esp)
	movl	$.L.str21088, 4(%esp)
	movl	$.L.str11087, (%esp)
	calll	__assert_fail
.Ltmp257:
	.size	print_broken_links, .Ltmp257-print_broken_links

	.globl	url_escape
	.align	16, 0x90
	.type	url_escape,@function
url_escape:                             # @url_escape
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	$0, (%esp)
	movl	16(%esp), %ecx
	movl	$2, %edx
	calll	url_escape_1
	addl	$12, %esp
	ret
.Ltmp258:
	.size	url_escape, .Ltmp258-url_escape

	.align	16, 0x90
	.type	url_escape_1,@function
url_escape_1:                           # @url_escape_1
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%ecx, %esi
	movb	(%esi), %al
	testb	%al, %al
	je	.LBB259_4
# BB#1:
                                        # kill: DL<def> DL<kill> EDX<kill>
	xorl	%ebx, %ebx
	movl	%esi, %edi
	.align	16, 0x90
.LBB259_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	leal	2(%ebx), %ecx
	movzbl	%al, %eax
	testb	urlchr_table(%eax), %dl
	cmovnel	%ecx, %ebx
	movb	1(%edi), %al
	incl	%edi
	testb	%al, %al
	jne	.LBB259_2
# BB#3:                                 # %for.end
	movb	%dl, 27(%esp)           # 1-byte Spill
	testl	%ebx, %ebx
	je	.LBB259_4
# BB#7:                                 # %if.end7
	subl	%esi, %edi
	leal	1(%edi,%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movb	(%esi), %dl
	testb	%dl, %dl
	movl	%eax, %ecx
	je	.LBB259_13
# BB#8:                                 # %while.body.preheader
	incl	%esi
	movl	%eax, %ecx
	.align	16, 0x90
.LBB259_9:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%dl, %ebp
	movb	27(%esp), %dh           # 1-byte Reload
	testb	urlchr_table(%ebp), %dh
	jne	.LBB259_10
# BB#11:                                # %if.else
                                        #   in Loop: Header=BB259_9 Depth=1
	movb	%dl, (%ecx)
	incl	%ecx
	jmp	.LBB259_12
.LBB259_10:                             # %if.then18
                                        #   in Loop: Header=BB259_9 Depth=1
	movb	$37, (%ecx)
	movl	%ebp, %edx
	shrl	$4, %edx
	movb	.L.str181113(%edx), %dl
	movb	%dl, 1(%ecx)
	andl	$15, %ebp
	movb	.L.str181113(%ebp), %dl
	movb	%dl, 2(%ecx)
	addl	$3, %ecx
.LBB259_12:                             # %while.cond.backedge
                                        #   in Loop: Header=BB259_9 Depth=1
	movb	(%esi), %dl
	incl	%esi
	testb	%dl, %dl
	jne	.LBB259_9
.LBB259_13:                             # %while.end
	addl	%ebx, %edi
	movl	%ecx, %edx
	subl	%eax, %edx
	cmpl	%edi, %edx
	jne	.LBB259_16
# BB#14:                                # %cond.end43
	movb	$0, (%ecx)
	jmp	.LBB259_15
.LBB259_4:                              # %if.then4
	movb	48(%esp), %al
	testb	%al, %al
	jne	.LBB259_5
# BB#6:                                 # %cond.false
	movl	%esi, (%esp)
	calll	checking_strdup
	jmp	.LBB259_15
.LBB259_5:
	movl	%esi, %eax
.LBB259_15:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB259_16:                             # %cond.false42
	movl	$.L__PRETTY_FUNCTION__.url_escape_1, 12(%esp)
	movl	$241, 8(%esp)
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str301125, (%esp)
	calll	__assert_fail
.Ltmp259:
	.size	url_escape_1, .Ltmp259-url_escape_1

	.globl	url_scheme
	.align	16, 0x90
	.type	url_scheme,@function
url_scheme:                             # @url_scheme
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	$-1, %esi
	movl	$supported_schemes+4, %edi
	movl	32(%esp), %ebx
	.align	16, 0x90
.LBB260_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	(%edi), %ebp
	movl	$2, %eax
	testl	%ebp, %ebp
	je	.LBB260_4
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB260_1 Depth=1
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	addl	$16, %edi
	incl	%esi
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB260_1
# BB#3:                                 # %if.then
	testb	$1, -8(%edi)
	movl	$2, %eax
	cmovel	%esi, %eax
.LBB260_4:                              # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp260:
	.size	url_scheme, .Ltmp260-url_scheme

	.globl	url_has_scheme
	.align	16, 0x90
	.type	url_has_scheme,@function
url_has_scheme:                         # @url_has_scheme
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	movzbl	(%eax), %ecx
	xorb	%dl, %dl
	testl	%ecx, %ecx
	je	.LBB261_9
# BB#1:                                 # %lor.lhs.false
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB261_4
# BB#2:                                 # %switch.early.test
	cmpb	$43, %cl
	je	.LBB261_4
# BB#3:                                 # %switch.early.test
	xorb	%dl, %dl
	cmpb	$45, %cl
	jne	.LBB261_9
	.align	16, 0x90
.LBB261_4:                              # %while.cond.preheader
                                        # =>This Inner Loop Header: Depth=1
	incl	%eax
	movzbl	(%eax), %ecx
	testl	%ecx, %ecx
	je	.LBB261_8
# BB#5:                                 # %land.rhs
                                        #   in Loop: Header=BB261_4 Depth=1
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB261_4
# BB#6:                                 # %switch.early.test34
                                        #   in Loop: Header=BB261_4 Depth=1
	cmpb	$43, %cl
	je	.LBB261_4
# BB#7:                                 # %switch.early.test34
                                        #   in Loop: Header=BB261_4 Depth=1
	cmpb	$45, %cl
	je	.LBB261_4
.LBB261_8:                              # %while.end
	cmpb	$58, %cl
	sete	%dl
.LBB261_9:                              # %return
	movzbl	%dl, %eax
	ret
.Ltmp261:
	.size	url_has_scheme, .Ltmp261-url_has_scheme

	.globl	scheme_default_port
	.align	16, 0x90
	.type	scheme_default_port,@function
scheme_default_port:                    # @scheme_default_port
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	shll	$4, %eax
	movl	supported_schemes+8(%eax), %eax
	ret
.Ltmp262:
	.size	scheme_default_port, .Ltmp262-scheme_default_port

	.globl	scheme_disable
	.align	16, 0x90
	.type	scheme_disable,@function
scheme_disable:                         # @scheme_disable
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	shll	$4, %eax
	orb	$1, supported_schemes+12(%eax)
	ret
.Ltmp263:
	.size	scheme_disable, .Ltmp263-scheme_disable

	.globl	rewrite_shorthand_url
	.align	16, 0x90
	.type	rewrite_shorthand_url,@function
rewrite_shorthand_url:                  # @rewrite_shorthand_url
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	$4, %edi
	movl	32(%esp), %esi
	.align	16, 0x90
.LBB264_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	supported_schemes(%edi), %ebx
	testl	%ebx, %ebx
	je	.LBB264_5
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB264_1 Depth=1
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	addl	$16, %edi
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB264_1
# BB#3:                                 # %url_scheme.exit
	cmpl	$52, %edi
	je	.LBB264_5
# BB#4:                                 # %url_scheme.exit
	movl	supported_schemes-8(%edi), %ecx
	andl	$1, %ecx
	xorl	%eax, %eax
	testl	%ecx, %ecx
	je	.LBB264_18
.LBB264_5:                              # %while.cond.i.preheader
	leal	-1(%esi), %edi
	.align	16, 0x90
.LBB264_6:                              # %while.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	1(%edi), %cl
	cmpb	$58, %cl
	setne	%al
	testb	%cl, %cl
	setne	%dl
	incl	%edi
	cmpb	$47, %cl
	je	.LBB264_8
# BB#7:                                 # %while.cond.i
                                        #   in Loop: Header=BB264_6 Depth=1
	andb	%al, %dl
	testb	%dl, %dl
	jne	.LBB264_6
.LBB264_8:                              # %__strpbrk_c2.exit
	xorl	%eax, %eax
	testb	%cl, %cl
	cmovel	%eax, %edi
	cmpl	%esi, %edi
	je	.LBB264_18
# BB#9:                                 # %if.end42
	testl	%edi, %edi
	je	.LBB264_17
# BB#10:                                # %land.lhs.true
	cmpb	$58, (%edi)
	jne	.LBB264_17
# BB#11:                                # %land.lhs.true46
	cmpb	$47, 1(%edi)
	jne	.LBB264_13
# BB#12:                                # %land.lhs.true51
	xorl	%eax, %eax
	cmpb	$47, 2(%edi)
	je	.LBB264_18
.LBB264_13:                             # %cond.false99
	leal	1(%edi), %eax
	movl	%eax, (%esp)
	movl	$.L.str11097, 4(%esp)
	calll	strspn
	testl	%eax, %eax
	je	.LBB264_16
# BB#14:                                # %land.lhs.true116
	movb	1(%eax,%edi), %al
	testb	%al, %al
	je	.LBB264_17
# BB#15:                                # %land.lhs.true116
	cmpb	$47, %al
	jne	.LBB264_16
.LBB264_17:                             # %http
	movl	%esi, 4(%esp)
	movl	$.L.str31099, (%esp)
	calll	aprintf
	.align	16, 0x90
.LBB264_18:                             # %return
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB264_16:                             # %if.end127
	movl	%esi, 4(%esp)
	movl	$.L.str21098, (%esp)
	movl	$6, %ebx
	subl	%esi, %ebx
	addl	%edi, %ebx
	calll	aprintf
	movb	$47, (%eax,%ebx)
	jmp	.LBB264_18
.Ltmp264:
	.size	rewrite_shorthand_url, .Ltmp264-rewrite_shorthand_url

	.globl	url_parse
	.align	16, 0x90
	.type	url_parse,@function
url_parse:                              # @url_parse
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$92, %esp
	movl	$-1, %esi
	movl	$supported_schemes+4, %edi
	movl	$1, %ebx
	.align	16, 0x90
.LBB265_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%edi), %ebp
	testl	%ebp, %ebp
	je	.LBB265_59
# BB#2:                                 # %for.body.i
                                        #   in Loop: Header=BB265_1 Depth=1
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	112(%esp), %eax
	movl	%eax, (%esp)
	addl	$16, %edi
	incl	%esi
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB265_1
# BB#3:                                 # %url_scheme.exit
	testb	$1, -8(%edi)
	movl	$2, %eax
	cmovel	%esi, %eax
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	$1, %ebx
	cmpl	$2, %eax
	je	.LBB265_59
# BB#4:
	xorl	%eax, %eax
	movl	112(%esp), %edi
	movl	%edi, %ecx
	jmp	.LBB265_5
	.align	16, 0x90
.LBB265_12:                             # %char_needs_escaping.exit.i
                                        #   in Loop: Header=BB265_5 Depth=1
	movzbl	%dl, %edx
	addl	%edx, %eax
.LBB265_5:                              # %for.cond.i204
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%ecx), %edx
	testl	%edx, %edx
	je	.LBB265_13
# BB#6:                                 # %for.cond.i204
                                        #   in Loop: Header=BB265_5 Depth=1
	cmpb	$37, %dl
	jne	.LBB265_11
# BB#7:                                 # %if.then.i.i
                                        #   in Loop: Header=BB265_5 Depth=1
	leal	1(%ecx), %esi
	movzbl	1(%ecx), %edx
	testb	$1, _sch_istable+1(%edx,%edx)
	je	.LBB265_10
# BB#8:                                 # %land.lhs.true.i.i
                                        #   in Loop: Header=BB265_5 Depth=1
	movzbl	2(%ecx), %ecx
	xorb	%dl, %dl
	testb	$1, _sch_istable+1(%ecx,%ecx)
	jne	.LBB265_9
.LBB265_10:                             # %if.else.i.i
                                        #   in Loop: Header=BB265_5 Depth=1
	movb	$1, %dl
	movl	%esi, %ecx
	jmp	.LBB265_12
.LBB265_11:                             # %if.else13.i.i
                                        #   in Loop: Header=BB265_5 Depth=1
	incl	%ecx
	movb	urlchr_table(%edx), %dl
	andb	$3, %dl
	cmpb	$2, %dl
	sete	%dl
	jmp	.LBB265_12
.LBB265_9:                              #   in Loop: Header=BB265_5 Depth=1
	movl	%esi, %ecx
	jmp	.LBB265_12
.LBB265_13:                             # %for.end.i
	testl	%eax, %eax
	movl	%edi, %edx
	je	.LBB265_28
# BB#14:                                # %if.end3.i
	subl	%edi, %ecx
	leal	1(%ecx,%eax,2), %edx
	movl	%edx, (%esp)
	leal	(%ecx,%eax,2), %esi
	calll	checking_malloc
	movl	%eax, %ebp
	jmp	.LBB265_15
	.align	16, 0x90
.LBB265_24:                             # %if.then8.i
                                        #   in Loop: Header=BB265_15 Depth=1
	movb	$37, (%ebp)
	movzbl	%dl, %ecx
	movl	%ecx, %edx
	shrl	$4, %edx
	movb	.L.str181113(%edx), %dl
	movb	%dl, 1(%ebp)
	andl	$15, %ecx
	movb	.L.str181113(%ecx), %cl
	movb	%cl, 2(%ebp)
	addl	$3, %ebp
.LBB265_15:                             # %if.end3.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB265_16 Depth 2
	movl	%edi, %ecx
	jmp	.LBB265_16
	.align	16, 0x90
.LBB265_26:                             # %if.else.i
                                        #   in Loop: Header=BB265_16 Depth=2
	movb	%dl, (%ebp)
	movl	%ebx, %ebp
.LBB265_16:                             # %while.cond.i
                                        #   Parent Loop BB265_15 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%ecx), %edx
	testl	%edx, %edx
	je	.LBB265_27
# BB#17:                                # %while.cond.i
                                        #   in Loop: Header=BB265_16 Depth=2
	cmpb	$37, %dl
	jne	.LBB265_21
# BB#18:                                # %if.then.i36.i
                                        #   in Loop: Header=BB265_16 Depth=2
	leal	1(%ecx), %edi
	movzbl	1(%ecx), %edx
	testb	$1, _sch_istable+1(%edx,%edx)
	je	.LBB265_23
# BB#19:                                # %land.lhs.true.i42.i
                                        #   in Loop: Header=BB265_16 Depth=2
	movzbl	2(%ecx), %ecx
	testb	$1, _sch_istable+1(%ecx,%ecx)
	je	.LBB265_23
# BB#20:                                # %char_needs_escaping.exit49.thread55.i
                                        #   in Loop: Header=BB265_16 Depth=2
	leal	1(%ebp), %ebx
	movb	$37, %dl
	movl	%edi, %ecx
	jmp	.LBB265_26
.LBB265_21:                             # %char_needs_escaping.exit49.i
                                        #   in Loop: Header=BB265_16 Depth=2
	incl	%ecx
	movb	urlchr_table(%edx), %bl
	andb	$3, %bl
	cmpb	$2, %bl
	je	.LBB265_22
# BB#25:                                #   in Loop: Header=BB265_16 Depth=2
	leal	1(%ebp), %ebx
	jmp	.LBB265_26
.LBB265_23:                             # %char_needs_escaping.exit49.thread.i
                                        #   in Loop: Header=BB265_15 Depth=1
	movb	$37, %dl
	jmp	.LBB265_24
.LBB265_22:                             #   in Loop: Header=BB265_15 Depth=1
	movl	%ecx, %edi
	jmp	.LBB265_24
.LBB265_27:                             # %while.end.i
	movb	$0, (%ebp)
	movl	%eax, %edx
	subl	%edx, %ebp
	cmpl	%esi, %ebp
	jne	.LBB265_231
.LBB265_28:                             # %reencode_escapes.exit
	movl	%edx, 60(%esp)          # 4-byte Spill
	movl	84(%esp), %esi          # 4-byte Reload
	shll	$4, %esi
	movl	supported_schemes+4(%esi), %eax
	movl	%eax, (%esp)
	movl	%edx, %edi
	calll	strlen
	addl	%edi, %eax
	movl	%eax, %edi
	movl	%edi, (%esp)
	movl	$.L.str291124, 4(%esp)
	calll	strpbrk
	testl	%eax, %eax
	movl	%edi, %ebx
	je	.LBB265_30
# BB#29:                                # %lor.lhs.false.i
	cmpb	$64, (%eax)
	leal	1(%eax), %ebx
	cmovnel	%edi, %ebx
.LBB265_30:                             # %url_skip_credentials.exit
	movl	supported_schemes+12(%esi), %ecx
	movl	%ecx, %edx
	movl	$init_seps.seps+2, %eax
	testb	$2, %dl
	je	.LBB265_32
# BB#31:                                # %if.then.i214
	movb	$59, init_seps.seps+2
	movl	$init_seps.seps+3, %eax
.LBB265_32:                             # %if.end.i
	movl	%ecx, %edx
	testb	$4, %dl
	je	.LBB265_33
# BB#34:                                # %if.then4.i
	movl	%edi, 56(%esp)          # 4-byte Spill
	movb	$63, (%eax)
	incl	%eax
	jmp	.LBB265_35
.LBB265_33:
	movl	%edi, 56(%esp)          # 4-byte Spill
.LBB265_35:                             # %if.end6.i
	testb	$8, %cl
	movl	%ebx, %edi
	je	.LBB265_37
# BB#36:                                # %if.then9.i
	movb	$35, (%eax)
	incl	%eax
.LBB265_37:                             # %init_seps.exit
	leal	supported_schemes+12(%esi), %ecx
	movl	%ecx, 52(%esp)          # 4-byte Spill
	movb	$0, (%eax)
	cmpb	$91, (%edi)
	jne	.LBB265_42
# BB#38:                                # %if.then7
	leal	1(%edi), %ebp
	movl	%edi, 88(%esp)          # 4-byte Spill
	movl	%ebp, (%esp)
	movl	$93, 4(%esp)
	calll	strchr
	movl	$5, %ebx
	testl	%eax, %eax
	movl	%eax, %edi
	je	.LBB265_56
# BB#39:                                # %if.end11
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	is_valid_ipv6_address
	movl	$7, %ebx
	testb	%al, %al
	je	.LBB265_56
# BB#40:                                # %if.end14
	movsbl	1(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$init_seps.seps, (%esp)
	calll	strchr
	movl	$2, %ebx
	testl	%eax, %eax
	je	.LBB265_56
# BB#41:
	movl	%edi, %eax
	leal	1(%eax), %edi
	movl	%ebp, %ecx
	jmp	.LBB265_44
.LBB265_42:                             # %if.else
	movl	%edi, (%esp)
	movl	$init_seps.seps, 4(%esp)
	calll	strpbrk
	testl	%eax, %eax
	movl	%edi, %ecx
	movl	%edi, 88(%esp)          # 4-byte Spill
	movl	%eax, %edi
	jne	.LBB265_44
# BB#43:                                # %if.then.i218
	movl	88(%esp), %edi          # 4-byte Reload
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%edi, %ecx
	movl	%eax, %edi
.LBB265_44:                             # %if.end28
	movl	%ecx, 28(%esp)          # 4-byte Spill
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	$2, %ebx
	cmpl	%eax, %ecx
	je	.LBB265_56
# BB#45:                                # %if.end32
	movl	supported_schemes+8(%esi), %esi
	cmpb	$58, (%edi)
	jne	.LBB265_52
# BB#46:                                # %if.then37
	incl	%edi
	movl	%edi, (%esp)
	movl	$init_seps.seps+1, 4(%esp)
	calll	strpbrk
	testl	%eax, %eax
	jne	.LBB265_48
# BB#47:                                # %if.then.i224
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
.LBB265_48:                             # %strpbrk_or_eos.exit227
	cmpl	%eax, %edi
	je	.LBB265_52
# BB#49:
	xorl	%esi, %esi
	.align	16, 0x90
.LBB265_50:                             # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	%eax, %edi
	jae	.LBB265_51
# BB#54:                                # %for.body
                                        #   in Loop: Header=BB265_50 Depth=1
	movsbl	(%edi), %ecx
	movzbl	%cl, %edx
	movl	$3, %ebx
	testb	$4, _sch_istable(%edx,%edx)
	je	.LBB265_56
# BB#55:                                # %if.end51
                                        #   in Loop: Header=BB265_50 Depth=1
	imull	$10, %esi, %edx
	leal	-48(%edx,%ecx), %esi
	incl	%edi
	movl	$3, %ebx
	cmpl	$65535, %esi            # imm = 0xFFFF
	jle	.LBB265_50
	jmp	.LBB265_56
.LBB265_51:
	movl	%eax, %edi
.LBB265_52:                             # %if.end59
	cmpb	$47, (%edi)
	jne	.LBB265_53
# BB#61:                                # %if.then64
	incl	%edi
	movl	%edi, (%esp)
	movl	$init_seps.seps+2, 4(%esp)
	calll	strpbrk
	testl	%eax, %eax
	jne	.LBB265_63
# BB#62:                                # %if.then.i231
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
.LBB265_63:                             # %if.then.i231
	movl	%edi, 76(%esp)          # 4-byte Spill
	movl	%eax, %edi
	jmp	.LBB265_64
.LBB265_53:
	xorl	%eax, %eax
	movl	$0, 76(%esp)            # 4-byte Folded Spill
.LBB265_64:                             # %if.end67
	movl	84(%esp), %ebp          # 4-byte Reload
	movl	52(%esp), %ecx          # 4-byte Reload
	movl	(%ecx), %ecx
	movl	%ecx, 64(%esp)          # 4-byte Spill
	movl	$init_seps.seps+3, %ebx
	testb	$2, %cl
	je	.LBB265_65
# BB#66:                                # %do.body73
	cmpb	$59, (%edi)
	jne	.LBB265_67
# BB#68:                                # %if.then77
	movl	%eax, 80(%esp)          # 4-byte Spill
	incl	%edi
	movl	%edi, (%esp)
	movl	$init_seps.seps+3, 4(%esp)
	calll	strpbrk
	testl	%eax, %eax
	jne	.LBB265_70
# BB#69:                                # %if.then.i238
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	52(%esp), %ecx          # 4-byte Reload
	movl	(%ecx), %ecx
	movl	%ecx, 64(%esp)          # 4-byte Spill
.LBB265_70:                             # %if.then.i238
	movl	$init_seps.seps+4, %ebx
	movl	%edi, %ecx
	movl	%eax, %edi
	jmp	.LBB265_71
.LBB265_65:
	movl	%eax, 80(%esp)          # 4-byte Spill
	xorl	%ecx, %ecx
	xorl	%eax, %eax
	jmp	.LBB265_71
.LBB265_67:
	movl	%eax, 80(%esp)          # 4-byte Spill
	xorl	%eax, %eax
	movl	$init_seps.seps+4, %ebx
	xorl	%ecx, %ecx
.LBB265_71:                             # %if.end83
	movl	64(%esp), %edx          # 4-byte Reload
	testb	$4, %dl
	je	.LBB265_72
# BB#73:                                # %do.body89
	movl	$0, 68(%esp)            # 4-byte Folded Spill
	cmpb	$63, (%edi)
	jne	.LBB265_74
# BB#75:                                # %if.then93
	movl	%ecx, 72(%esp)          # 4-byte Spill
	movl	%ebp, 84(%esp)          # 4-byte Spill
	movl	%eax, %ebp
	movl	%ebx, 4(%esp)
	incl	%edi
	movl	%edi, (%esp)
	calll	strpbrk
	movl	%eax, %edx
	testl	%edx, %edx
	jne	.LBB265_77
# BB#76:                                # %if.then.i245
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%eax, %edx
	movl	52(%esp), %eax          # 4-byte Reload
	movl	(%eax), %eax
	movl	%eax, 64(%esp)          # 4-byte Spill
.LBB265_77:                             # %if.then.i245
	movl	%edi, 68(%esp)          # 4-byte Spill
	movl	%edx, %edi
	movl	%ebp, %eax
	movl	84(%esp), %ebp          # 4-byte Reload
	movl	72(%esp), %ecx          # 4-byte Reload
	jmp	.LBB265_78
.LBB265_72:
	movl	$0, 68(%esp)            # 4-byte Folded Spill
	xorl	%edx, %edx
	jmp	.LBB265_79
.LBB265_74:
	xorl	%edx, %edx
.LBB265_78:                             # %if.end96
	incl	%ebx
.LBB265_79:                             # %if.end99
	movl	%ecx, 72(%esp)          # 4-byte Spill
	movl	%eax, 44(%esp)          # 4-byte Spill
	movl	64(%esp), %eax          # 4-byte Reload
	testb	$8, %al
	je	.LBB265_80
# BB#81:                                # %do.body105
	xorl	%ecx, %ecx
	cmpb	$35, (%edi)
	jne	.LBB265_82
# BB#83:                                # %if.then109
	movl	%edx, 64(%esp)          # 4-byte Spill
	movl	%ebx, 4(%esp)
	incl	%edi
	movl	%edi, (%esp)
	calll	strpbrk
	testl	%eax, %eax
	jne	.LBB265_85
# BB#84:                                # %if.then.i252
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
.LBB265_85:                             # %if.then.i252
	movl	%edi, %ecx
	movl	%eax, %edi
	jmp	.LBB265_86
.LBB265_80:
	movl	%edx, 64(%esp)          # 4-byte Spill
	xorl	%eax, %eax
	xorl	%ecx, %ecx
	jmp	.LBB265_86
.LBB265_82:
	movl	%edx, 64(%esp)          # 4-byte Spill
	xorl	%eax, %eax
.LBB265_86:                             # %if.end115
	cmpb	$0, (%edi)
	jne	.LBB265_232
# BB#87:                                # %cond.end
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	$0, 52(%esp)            # 4-byte Folded Spill
	movl	56(%esp), %eax          # 4-byte Reload
	movl	88(%esp), %ecx          # 4-byte Reload
	cmpl	%ecx, %eax
	movl	$0, 48(%esp)            # 4-byte Folded Spill
	je	.LBB265_125
# BB#88:                                # %if.then123
	decl	%ecx
	movl	%ecx, 88(%esp)          # 4-byte Spill
	movl	$4, %ebx
	cmpl	%ecx, %eax
	movl	%eax, %ecx
	je	.LBB265_56
# BB#89:                                # %if.end.i261
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%ecx, %edi
	subl	%edi, %eax
	movl	%eax, 8(%esp)
	movl	%edi, (%esp)
	movl	$58, 4(%esp)
	movl	$4, %ebx
	calll	memchr
	movl	%eax, %ecx
	cmpl	%edi, %ecx
	je	.LBB265_56
# BB#90:                                # %if.end3.i263
	movl	%ebp, 84(%esp)          # 4-byte Spill
	movl	$0, 52(%esp)            # 4-byte Folded Spill
	testl	%ecx, %ecx
	je	.LBB265_108
# BB#91:                                # %if.then4.i266
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	leal	1(%ecx), %eax
	movl	%ecx, 88(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	%eax, %edi
	movl	%eax, %ebp
	jmp	.LBB265_92
.LBB265_56:                             # %error192
	movl	60(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	je	.LBB265_59
# BB#57:                                # %error192
	cmpl	112(%esp), %eax
	je	.LBB265_59
# BB#58:                                # %if.then197
	movl	%eax, (%esp)
	calll	checking_free
.LBB265_59:                             # %if.end198
	xorl	%esi, %esi
	movl	116(%esp), %eax
	testl	%eax, %eax
	je	.LBB265_230
# BB#60:                                # %if.then200
	movl	%ebx, (%eax)
	xorl	%esi, %esi
	.align	16, 0x90
.LBB265_230:                            # %return
	movl	%esi, %eax
	addl	$92, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
	.align	16, 0x90
.LBB265_106:                            # %for.inc.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	movb	%al, (%edi)
	incl	%edi
	incl	%ebp
.LBB265_92:                             # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %ecx
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB265_107
# BB#93:                                # %for.cond.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	cmpb	$37, %dl
	jne	.LBB265_94
# BB#95:                                # %if.else.i.i268
                                        #   in Loop: Header=BB265_92 Depth=1
	movzbl	1(%ecx), %ebx
	testl	%ebx, %ebx
	je	.LBB265_94
# BB#96:                                # %lor.lhs.false.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	movzbl	2(%ecx), %eax
	testl	%eax, %eax
	je	.LBB265_94
# BB#97:                                # %lor.lhs.false5.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB265_94
# BB#98:                                # %land.lhs.true.i.i272
                                        #   in Loop: Header=BB265_92 Depth=1
	testb	$1, _sch_istable+1(%eax,%eax)
	je	.LBB265_94
# BB#99:                                # %if.end.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	leal	2(%ecx), %ebp
	cmpb	$64, %bl
	jg	.LBB265_101
# BB#100:                               # %cond.true.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	addb	$-48, %bl
	movb	%bl, %dh
	jmp	.LBB265_102
.LBB265_101:                            # %cond.false.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	movb	_sch_toupper(%ebx), %dh
	addb	$-55, %dh
.LBB265_102:                            # %cond.end.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	shlb	$4, %dh
	cmpb	$64, %al
	jg	.LBB265_104
# BB#103:                               # %cond.true36.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	addb	$-48, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	jmp	.LBB265_105
.LBB265_104:                            # %cond.false40.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	movb	_sch_toupper(%eax), %al
	addb	$-55, %al
.LBB265_105:                            # %cond.end48.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	addb	%dh, %al
	jne	.LBB265_106
.LBB265_94:                             # %copychar.i.i
                                        #   in Loop: Header=BB265_92 Depth=1
	movb	%dl, %al
	movl	%ecx, %ebp
	jmp	.LBB265_106
.LBB265_107:                            # %url_unescape.exit.i
	movb	$0, (%edi)
.LBB265_108:                            # %url_unescape.exit.i
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	%eax, %edi
	movl	%eax, %ebp
	jmp	.LBB265_109
	.align	16, 0x90
.LBB265_123:                            # %for.inc.i52.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movb	%al, (%edi)
	incl	%edi
	incl	%ebp
.LBB265_109:                            # %for.cond.i10.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %ecx
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB265_124
# BB#110:                               # %for.cond.i10.i
                                        #   in Loop: Header=BB265_109 Depth=1
	cmpb	$37, %dl
	jne	.LBB265_111
# BB#112:                               # %if.else.i14.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movzbl	1(%ecx), %ebx
	testl	%ebx, %ebx
	je	.LBB265_111
# BB#113:                               # %lor.lhs.false.i17.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movzbl	2(%ecx), %eax
	testl	%eax, %eax
	je	.LBB265_111
# BB#114:                               # %lor.lhs.false5.i22.i
                                        #   in Loop: Header=BB265_109 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB265_111
# BB#115:                               # %land.lhs.true.i27.i
                                        #   in Loop: Header=BB265_109 Depth=1
	testb	$1, _sch_istable+1(%eax,%eax)
	je	.LBB265_111
# BB#116:                               # %if.end.i29.i
                                        #   in Loop: Header=BB265_109 Depth=1
	leal	2(%ecx), %ebp
	cmpb	$64, %bl
	jg	.LBB265_118
# BB#117:                               # %cond.true.i31.i
                                        #   in Loop: Header=BB265_109 Depth=1
	addb	$-48, %bl
	movb	%bl, %dh
	jmp	.LBB265_119
.LBB265_118:                            # %cond.false.i34.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movb	_sch_toupper(%ebx), %dh
	addb	$-55, %dh
.LBB265_119:                            # %cond.end.i38.i
                                        #   in Loop: Header=BB265_109 Depth=1
	shlb	$4, %dh
	cmpb	$64, %al
	jg	.LBB265_121
# BB#120:                               # %cond.true36.i40.i
                                        #   in Loop: Header=BB265_109 Depth=1
	addb	$-48, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	jmp	.LBB265_122
.LBB265_121:                            # %cond.false40.i43.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movb	_sch_toupper(%eax), %al
	addb	$-55, %al
.LBB265_122:                            # %cond.end48.i47.i
                                        #   in Loop: Header=BB265_109 Depth=1
	addb	%dh, %al
	jne	.LBB265_123
.LBB265_111:                            # %copychar.i11.i
                                        #   in Loop: Header=BB265_109 Depth=1
	movb	%dl, %al
	movl	%ecx, %ebp
	jmp	.LBB265_123
.LBB265_124:                            # %parse_credentials.exit
	movb	$0, (%edi)
	movl	84(%esp), %ebp          # 4-byte Reload
.LBB265_125:                            # %if.end128
	movl	$48, (%esp)
	calll	checking_malloc0
	movl	%eax, %edi
	movl	%edi, 88(%esp)          # 4-byte Spill
	movl	%ebp, 4(%edi)
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, 8(%edi)
	movl	%esi, 12(%edi)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 40(%edi)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 44(%edi)
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	%eax, %esi
	movl	%esi, 16(%edi)
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%esi, %edx
	movl	%esi, %ecx
	jmp	.LBB265_127
	.align	16, 0x90
.LBB265_126:                            # %while.cond70.i.while.cond.outer.outer.i.loopexit_crit_edge
                                        #   in Loop: Header=BB265_127 Depth=1
	addl	%edi, %edx
	movl	%ebx, %esi
	.align	16, 0x90
.LBB265_127:                            # %while.cond.outer.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB265_150 Depth 2
                                        #     Child Loop BB265_128 Depth 2
                                        #     Child Loop BB265_146 Depth 2
                                        #     Child Loop BB265_138 Depth 2
	addl	$3, %esi
	jmp	.LBB265_128
	.align	16, 0x90
.LBB265_133:                            # %if.then.i282
                                        #   in Loop: Header=BB265_128 Depth=2
	addl	$2, %esi
.LBB265_128:                            # %while.cond.i279
                                        #   Parent Loop BB265_127 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	-3(%esi), %edi
	cmpl	%eax, %edi
	jae	.LBB265_153
# BB#129:                               # %while.body.i
                                        #   in Loop: Header=BB265_128 Depth=2
	cmpb	$46, (%edi)
	jne	.LBB265_144
# BB#130:                               # %land.lhs.true.i
                                        #   in Loop: Header=BB265_128 Depth=2
	movb	-2(%esi), %bl
	testb	%bl, %bl
	je	.LBB265_133
# BB#131:                               # %land.lhs.true.i
                                        #   in Loop: Header=BB265_128 Depth=2
	cmpb	$46, %bl
	je	.LBB265_134
# BB#132:                               # %land.lhs.true.i
                                        #   in Loop: Header=BB265_128 Depth=2
	cmpb	$47, %bl
	jne	.LBB265_144
	jmp	.LBB265_133
.LBB265_134:                            # %land.lhs.true20.i
                                        #   in Loop: Header=BB265_127 Depth=1
	movb	-1(%esi), %bl
	testb	%bl, %bl
	je	.LBB265_136
# BB#135:                               # %land.lhs.true20.i
                                        #   in Loop: Header=BB265_127 Depth=1
	cmpb	$47, %bl
	jne	.LBB265_144
.LBB265_136:                            # %if.then30.i
                                        #   in Loop: Header=BB265_127 Depth=1
	cmpl	%ecx, %edx
	jbe	.LBB265_142
# BB#137:                               # %if.then33.i
                                        #   in Loop: Header=BB265_127 Depth=1
	decl	%edx
	.align	16, 0x90
.LBB265_138:                            # %for.cond.i283
                                        #   Parent Loop BB265_127 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%edx, %edi
	cmpl	%ecx, %edi
	jbe	.LBB265_139
# BB#140:                               # %land.rhs.i
                                        #   in Loop: Header=BB265_138 Depth=2
	leal	-1(%edi), %edx
	cmpb	$47, -1(%edi)
	jne	.LBB265_138
# BB#141:                               #   in Loop: Header=BB265_127 Depth=1
	movl	%edi, %edx
	jmp	.LBB265_127
.LBB265_142:                            # %if.else41.i
                                        #   in Loop: Header=BB265_127 Depth=1
	cmpl	$1, %ebp
	jne	.LBB265_127
# BB#143:                               # %if.then44.i
                                        #   in Loop: Header=BB265_127 Depth=1
	leal	3(%edx), %ecx
.LBB265_144:                            # %regular.i
                                        #   in Loop: Header=BB265_127 Depth=1
	movl	%esi, %ebx
	subl	%edx, %ebx
	xorl	%edi, %edi
	cmpl	$3, %ebx
	je	.LBB265_145
	.align	16, 0x90
.LBB265_150:                            # %while.cond70.i
                                        #   Parent Loop BB265_127 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	leal	-3(%esi,%edi), %ebx
	cmpl	%eax, %ebx
	jae	.LBB265_126
# BB#151:                               # %land.rhs73.i
                                        #   in Loop: Header=BB265_150 Depth=2
	movb	-3(%esi,%edi), %bl
	movb	%bl, (%edx,%edi)
	incl	%edi
	cmpb	$47, %bl
	jne	.LBB265_150
# BB#152:                               # %while.cond.outer.outer.i.loopexitsplit
                                        #   in Loop: Header=BB265_127 Depth=1
	leal	-3(%esi,%edi), %esi
	addl	%edi, %edx
	jmp	.LBB265_127
.LBB265_145:                            #   in Loop: Header=BB265_127 Depth=1
	movl	%edx, %esi
	.align	16, 0x90
.LBB265_146:                            # %while.cond52.i
                                        #   Parent Loop BB265_127 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	cmpl	%eax, %esi
	jae	.LBB265_147
# BB#148:                               # %land.rhs55.i
                                        #   in Loop: Header=BB265_146 Depth=2
	leal	1(%esi), %edx
	cmpb	$47, (%esi)
	movl	%edx, %esi
	jne	.LBB265_146
# BB#149:                               #   in Loop: Header=BB265_127 Depth=1
	movl	%edx, %esi
	jmp	.LBB265_127
.LBB265_147:                            #   in Loop: Header=BB265_127 Depth=1
	movl	%esi, %edx
	jmp	.LBB265_127
.LBB265_139:                            #   in Loop: Header=BB265_127 Depth=1
	movl	%edi, %edx
	jmp	.LBB265_127
.LBB265_153:                            # %while.end91.i
	subl	%edx, %esi
	cmpl	$3, %esi
	je	.LBB265_155
# BB#154:                               # %if.then94.i
	movb	$0, (%edx)
.LBB265_155:                            # %path_simplify.exit
	movl	88(%esp), %ebp          # 4-byte Reload
	movl	16(%ebp), %ebx
	movl	%ebx, (%esp)
	movl	$47, 4(%esp)
	calll	strrchr
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB265_156
# BB#157:                               # %if.else.i290
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	strdupdelim
	movl	%eax, 32(%ebp)
	incl	%edi
	movl	%edi, (%esp)
	jmp	.LBB265_158
.LBB265_156:                            # %if.then.i288
	movl	$.L.str201115, (%esp)
	calll	checking_strdup
	movl	%eax, 32(%ebp)
	movl	%ebx, (%esp)
.LBB265_158:                            # %if.else.i290
	calll	checking_strdup
	movl	%eax, 36(%ebp)
	movl	32(%ebp), %ebp
	movl	%ebp, %edi
	jmp	.LBB265_159
	.align	16, 0x90
.LBB265_173:                            # %for.inc.i.i336
                                        #   in Loop: Header=BB265_159 Depth=1
	movb	%dh, (%ebp)
	incl	%ebp
	incl	%edi
.LBB265_159:                            # %for.cond.i.i294
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ecx
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB265_174
# BB#160:                               # %for.cond.i.i294
                                        #   in Loop: Header=BB265_159 Depth=1
	cmpb	$37, %dl
	jne	.LBB265_161
# BB#162:                               # %if.else.i.i298
                                        #   in Loop: Header=BB265_159 Depth=1
	movzbl	1(%ecx), %eax
	testl	%eax, %eax
	je	.LBB265_161
# BB#163:                               # %lor.lhs.false.i.i301
                                        #   in Loop: Header=BB265_159 Depth=1
	movzbl	2(%ecx), %ebx
	testl	%ebx, %ebx
	je	.LBB265_161
# BB#164:                               # %lor.lhs.false5.i.i306
                                        #   in Loop: Header=BB265_159 Depth=1
	testb	$1, _sch_istable+1(%eax,%eax)
	je	.LBB265_161
# BB#165:                               # %land.lhs.true.i.i311
                                        #   in Loop: Header=BB265_159 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB265_161
# BB#166:                               # %if.end.i.i313
                                        #   in Loop: Header=BB265_159 Depth=1
	leal	2(%ecx), %edi
	cmpb	$64, %al
	jg	.LBB265_168
# BB#167:                               # %cond.true.i.i315
                                        #   in Loop: Header=BB265_159 Depth=1
	addb	$-48, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	jmp	.LBB265_169
.LBB265_168:                            # %cond.false.i.i318
                                        #   in Loop: Header=BB265_159 Depth=1
	movb	_sch_toupper(%eax), %al
	addb	$-55, %al
.LBB265_169:                            # %cond.end.i.i322
                                        #   in Loop: Header=BB265_159 Depth=1
	shlb	$4, %al
	cmpb	$64, %bl
	jg	.LBB265_171
# BB#170:                               # %cond.true36.i.i324
                                        #   in Loop: Header=BB265_159 Depth=1
	addb	$-48, %bl
	movb	%bl, %dh
	jmp	.LBB265_172
.LBB265_171:                            # %cond.false40.i.i327
                                        #   in Loop: Header=BB265_159 Depth=1
	movb	_sch_toupper(%ebx), %dh
	addb	$-55, %dh
.LBB265_172:                            # %cond.end48.i.i331
                                        #   in Loop: Header=BB265_159 Depth=1
	addb	%al, %dh
	jne	.LBB265_173
.LBB265_161:                            # %copychar.i.i295
                                        #   in Loop: Header=BB265_159 Depth=1
	movb	%dl, %dh
	movl	%ecx, %edi
	jmp	.LBB265_173
.LBB265_174:                            # %url_unescape.exit.i337
	movb	$0, (%ebp)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	36(%eax), %ebp
	movl	%ebp, %edi
	jmp	.LBB265_175
	.align	16, 0x90
.LBB265_189:                            # %for.inc.i49.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movb	%dh, (%ebp)
	incl	%ebp
	incl	%edi
.LBB265_175:                            # %for.cond.i7.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %ecx
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB265_190
# BB#176:                               # %for.cond.i7.i
                                        #   in Loop: Header=BB265_175 Depth=1
	cmpb	$37, %dl
	jne	.LBB265_177
# BB#178:                               # %if.else.i11.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movzbl	1(%ecx), %eax
	testl	%eax, %eax
	je	.LBB265_177
# BB#179:                               # %lor.lhs.false.i14.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movzbl	2(%ecx), %ebx
	testl	%ebx, %ebx
	je	.LBB265_177
# BB#180:                               # %lor.lhs.false5.i19.i
                                        #   in Loop: Header=BB265_175 Depth=1
	testb	$1, _sch_istable+1(%eax,%eax)
	je	.LBB265_177
# BB#181:                               # %land.lhs.true.i24.i
                                        #   in Loop: Header=BB265_175 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB265_177
# BB#182:                               # %if.end.i26.i
                                        #   in Loop: Header=BB265_175 Depth=1
	leal	2(%ecx), %edi
	cmpb	$64, %al
	jg	.LBB265_184
# BB#183:                               # %cond.true.i28.i
                                        #   in Loop: Header=BB265_175 Depth=1
	addb	$-48, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	jmp	.LBB265_185
.LBB265_184:                            # %cond.false.i31.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movb	_sch_toupper(%eax), %al
	addb	$-55, %al
.LBB265_185:                            # %cond.end.i35.i
                                        #   in Loop: Header=BB265_175 Depth=1
	shlb	$4, %al
	cmpb	$64, %bl
	jg	.LBB265_187
# BB#186:                               # %cond.true36.i37.i
                                        #   in Loop: Header=BB265_175 Depth=1
	addb	$-48, %bl
	movb	%bl, %dh
	jmp	.LBB265_188
.LBB265_187:                            # %cond.false40.i40.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movb	_sch_toupper(%ebx), %dh
	addb	$-55, %dh
.LBB265_188:                            # %cond.end48.i44.i
                                        #   in Loop: Header=BB265_175 Depth=1
	addb	%al, %dh
	jne	.LBB265_189
.LBB265_177:                            # %copychar.i8.i
                                        #   in Loop: Header=BB265_175 Depth=1
	movb	%dl, %dh
	movl	%ecx, %edi
	jmp	.LBB265_189
.LBB265_190:                            # %split_path.exit
	movb	$0, (%ebp)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	8(%eax), %edi
	movb	(%edi), %al
	xorb	%bl, %bl
	testb	%al, %al
	je	.LBB265_196
# BB#191:                               # %for.body.i341.preheader
	incl	%edi
	xorb	%bl, %bl
	.align	16, 0x90
.LBB265_192:                            # %for.body.i341
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%al, %eax
	testb	$-128, _sch_istable(%eax,%eax)
	je	.LBB265_194
# BB#193:                               # %if.then.i342
                                        #   in Loop: Header=BB265_192 Depth=1
	movb	_sch_tolower(%eax), %al
	movb	%al, -1(%edi)
	movb	$1, %bl
.LBB265_194:                            # %for.inc.i
                                        #   in Loop: Header=BB265_192 Depth=1
	movb	(%edi), %al
	incl	%edi
	testb	%al, %al
	jne	.LBB265_192
# BB#195:                               # %lowercase_str.exit.loopexit
	movl	88(%esp), %eax          # 4-byte Reload
	movl	8(%eax), %edi
.LBB265_196:                            # %lowercase_str.exit
	movl	%edi, (%esp)
	movl	$37, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	je	.LBB265_197
# BB#198:
	movl	%edi, %ebp
	jmp	.LBB265_199
.LBB265_197:
	andb	$1, %bl
	jmp	.LBB265_215
	.align	16, 0x90
.LBB265_213:                            # %for.inc.i362
                                        #   in Loop: Header=BB265_199 Depth=1
	movb	%ch, (%edi)
	incl	%edi
	incl	%ebp
.LBB265_199:                            # %for.cond.i348
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, %eax
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB265_214
# BB#200:                               # %for.cond.i348
                                        #   in Loop: Header=BB265_199 Depth=1
	cmpb	$37, %cl
	jne	.LBB265_201
# BB#202:                               # %if.else.i350
                                        #   in Loop: Header=BB265_199 Depth=1
	movzbl	1(%eax), %edx
	testl	%edx, %edx
	je	.LBB265_201
# BB#203:                               # %lor.lhs.false.i352
                                        #   in Loop: Header=BB265_199 Depth=1
	movzbl	2(%eax), %ebx
	testl	%ebx, %ebx
	je	.LBB265_201
# BB#204:                               # %lor.lhs.false5.i
                                        #   in Loop: Header=BB265_199 Depth=1
	testb	$1, _sch_istable+1(%edx,%edx)
	je	.LBB265_201
# BB#205:                               # %land.lhs.true.i353
                                        #   in Loop: Header=BB265_199 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB265_201
# BB#206:                               # %if.end.i354
                                        #   in Loop: Header=BB265_199 Depth=1
	leal	2(%eax), %ebp
	cmpb	$64, %dl
	jg	.LBB265_208
# BB#207:                               # %cond.true.i
                                        #   in Loop: Header=BB265_199 Depth=1
	addb	$-48, %dl
                                        # kill: DL<def> DL<kill> EDX<kill>
	jmp	.LBB265_209
.LBB265_208:                            # %cond.false.i356
                                        #   in Loop: Header=BB265_199 Depth=1
	movb	_sch_toupper(%edx), %dl
	addb	$-55, %dl
.LBB265_209:                            # %cond.end.i
                                        #   in Loop: Header=BB265_199 Depth=1
	shlb	$4, %dl
	cmpb	$64, %bl
	jg	.LBB265_211
# BB#210:                               # %cond.true36.i
                                        #   in Loop: Header=BB265_199 Depth=1
	addb	$-48, %bl
	movb	%bl, %ch
	jmp	.LBB265_212
.LBB265_211:                            # %cond.false40.i
                                        #   in Loop: Header=BB265_199 Depth=1
	movb	_sch_toupper(%ebx), %ch
	addb	$-55, %ch
.LBB265_212:                            # %cond.end48.i
                                        #   in Loop: Header=BB265_199 Depth=1
	addb	%dl, %ch
	jne	.LBB265_213
.LBB265_201:                            # %copychar.i
                                        #   in Loop: Header=BB265_199 Depth=1
	movb	%cl, %ch
	movl	%eax, %ebp
	jmp	.LBB265_213
.LBB265_214:                            # %url_unescape.exit
	movb	$0, (%edi)
	movb	$1, %bl
.LBB265_215:                            # %url_unescape.exit
	movl	60(%esp), %ebp          # 4-byte Reload
	movl	72(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	movl	112(%esp), %edi
	movl	44(%esp), %eax          # 4-byte Reload
	je	.LBB265_217
# BB#216:                               # %if.then154
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	strdupdelim
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%eax, 20(%ecx)
.LBB265_217:                            # %if.end156
	movl	68(%esp), %ecx          # 4-byte Reload
	testl	%ecx, %ecx
	je	.LBB265_219
# BB#218:                               # %if.then158
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	strdupdelim
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%eax, 24(%ecx)
.LBB265_219:                            # %if.end160
	movl	40(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	je	.LBB265_221
# BB#220:                               # %if.then162
	movl	36(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	strdupdelim
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%eax, 28(%ecx)
.LBB265_221:                            # %if.end164
	cmpl	$3, %esi
	movl	88(%esp), %esi          # 4-byte Reload
	jne	.LBB265_225
# BB#222:                               # %lor.lhs.false
	testb	%bl, %bl
	jne	.LBB265_225
# BB#223:                               # %lor.lhs.false
	movl	28(%esi), %eax
	testl	%eax, %eax
	jne	.LBB265_225
# BB#224:                               # %lor.lhs.false
	movl	76(%esp), %eax          # 4-byte Reload
	cmpl	80(%esp), %eax          # 4-byte Folded Reload
	jne	.LBB265_227
.LBB265_225:                            # %if.then175
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	calll	url_string
	movl	%eax, (%esi)
	cmpl	%edi, %ebp
	je	.LBB265_230
# BB#226:                               # %if.then180
	movl	%ebp, (%esp)
	calll	checking_free
	jmp	.LBB265_230
.LBB265_231:                            # %cond.false.i
	movl	$.L__PRETTY_FUNCTION__.reencode_escapes, 12(%esp)
	movl	$407, 8(%esp)           # imm = 0x197
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str301125, (%esp)
	calll	__assert_fail
.LBB265_232:                            # %cond.false120
	movl	$.L__PRETTY_FUNCTION__.url_parse, 12(%esp)
	movl	$811, 8(%esp)           # imm = 0x32B
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str41100, (%esp)
	calll	__assert_fail
.LBB265_227:                            # %if.else182
	cmpl	%edi, %ebp
	je	.LBB265_228
# BB#229:                               # %if.else188
	movl	%ebp, (%esi)
	jmp	.LBB265_230
.LBB265_228:                            # %if.then185
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, (%esi)
	jmp	.LBB265_230
.Ltmp265:
	.size	url_parse, .Ltmp265-url_parse

	.globl	url_string
	.align	16, 0x90
	.type	url_string,@function
url_string:                             # @url_string
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	80(%esp), %edi
	movl	4(%edi), %ecx
	movl	16(%edi), %eax
	shll	$4, %ecx
	movl	supported_schemes+4(%ecx), %edx
	movl	%edx, 40(%esp)          # 4-byte Spill
	movl	supported_schemes+8(%ecx), %ecx
	movl	%ecx, 32(%esp)          # 4-byte Spill
	xorl	%ebx, %ebx
	testl	%eax, %eax
	je	.LBB266_2
# BB#1:                                 # %if.then.i
	movl	%eax, (%esp)
	calll	strlen
	movl	%eax, %ebx
	incl	%ebx
.LBB266_2:                              # %if.end.i
	movl	20(%edi), %eax
	testl	%eax, %eax
	je	.LBB266_4
# BB#3:                                 # %if.then4.i
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%ebx,%eax), %ebx
.LBB266_4:                              # %if.end9.i
	movl	24(%edi), %eax
	testl	%eax, %eax
	je	.LBB266_6
# BB#5:                                 # %if.then11.i
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%ebx,%eax), %ebx
.LBB266_6:                              # %full_path_length.exit
	cmpl	$0, 40(%esp)            # 4-byte Folded Reload
	je	.LBB266_59
# BB#7:                                 # %cond.end
	movl	84(%esp), %esi
	movl	40(%edi), %ecx
	movl	$0, 48(%esp)            # 4-byte Folded Spill
	testl	%ecx, %ecx
	je	.LBB266_8
# BB#9:                                 # %cond.end
	cmpl	$2, %esi
	movl	$0, %eax
	je	.LBB266_13
# BB#10:                                # %if.then4
	movl	$1, (%esp)
	movl	$2, %edx
	calll	url_escape_1
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	44(%edi), %ecx
	xorl	%eax, %eax
	testl	%ecx, %ecx
	je	.LBB266_13
# BB#11:                                # %if.then8
	movl	$.L.str131108, %eax
	cmpl	$1, %esi
	je	.LBB266_13
# BB#12:                                # %if.else
	movl	$1, (%esp)
	movl	$2, %edx
	calll	url_escape_1
	jmp	.LBB266_13
.LBB266_8:
	xorl	%eax, %eax
.LBB266_13:                             # %if.end15
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	8(%edi), %ecx
	movl	$1, (%esp)
	movl	$2, %edx
	calll	url_escape_1
	cmpl	8(%edi), %eax
	je	.LBB266_22
# BB#14:
	movl	%eax, %ecx
	movl	%eax, %edx
	movl	%edx, %esi
	jmp	.LBB266_15
	.align	16, 0x90
.LBB266_20:                             # %for.inc.i
                                        #   in Loop: Header=BB266_15 Depth=1
	movb	%dl, (%eax)
	incl	%eax
	incl	%ecx
.LBB266_15:                             # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB266_21
# BB#16:                                # %for.cond.i
                                        #   in Loop: Header=BB266_15 Depth=1
	cmpb	$37, %dl
	jne	.LBB266_20
# BB#17:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB266_15 Depth=1
	cmpb	$51, 1(%ecx)
	jne	.LBB266_20
# BB#18:                                # %land.lhs.true16.i
                                        #   in Loop: Header=BB266_15 Depth=1
	cmpb	$65, 2(%ecx)
	jne	.LBB266_20
# BB#19:                                #   in Loop: Header=BB266_15 Depth=1
	movb	$58, %dl
	addl	$2, %ecx
	jmp	.LBB266_20
.LBB266_21:                             # %unescape_single_char.exit
	movb	$0, (%eax)
	movl	%esi, %eax
.LBB266_22:                             # %if.end20
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	$58, 4(%esp)
	movl	%eax, %esi
	calll	strchr
	movl	%eax, %ebp
	movl	%ebp, 28(%esp)          # 4-byte Spill
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	calll	strlen
	movl	%esi, (%esp)
	leal	1(%ebx,%eax), %esi
	calll	strlen
	addl	%esi, %eax
	testl	%ebp, %ebp
	setne	%cl
	movzbl	%cl, %ecx
	leal	(%eax,%ecx,2), %esi
	movl	12(%edi), %eax
	cmpl	32(%esp), %eax          # 4-byte Folded Reload
	je	.LBB266_24
# BB#23:                                # %if.then30
	movl	%eax, %ecx
	sarl	$31, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	numdigit
	leal	1(%esi,%eax), %esi
.LBB266_24:                             # %if.end35
	movl	48(%esp), %ebp          # 4-byte Reload
	testl	%ebp, %ebp
	je	.LBB266_25
# BB#26:                                # %if.then37
	movl	%ebp, (%esp)
	calll	strlen
	leal	1(%esi,%eax), %esi
	movl	52(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	je	.LBB266_27
# BB#28:                                # %if.then42
	movl	%ebx, 56(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%esi,%eax), %esi
	jmp	.LBB266_29
.LBB266_25:
	movl	%ebx, 56(%esp)          # 4-byte Spill
	jmp	.LBB266_29
.LBB266_27:
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	%ebx, 56(%esp)          # 4-byte Spill
.LBB266_29:                             # %if.end47
	movl	%esi, 24(%esp)          # 4-byte Spill
	movl	%esi, (%esp)
	calll	checking_malloc
	movl	%eax, %ebx
	movl	%ebx, 44(%esp)          # 4-byte Spill
	movl	40(%esp), %edi          # 4-byte Reload
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %esi
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	leal	(%ebx,%esi), %ebx
	testl	%ebp, %ebp
	je	.LBB266_30
# BB#31:                                # %do.body52
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%ebp, 48(%esp)          # 4-byte Spill
	movl	%ebx, (%esp)
	addl	%eax, %esi
	calll	memcpy
	movl	52(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	movl	80(%esp), %edi
	je	.LBB266_32
# BB#33:                                # %if.then58
	movl	44(%esp), %ebp          # 4-byte Reload
	movb	$58, (%ebp,%esi)
	movl	%eax, (%esp)
	movl	%eax, %ebx
	movl	%ebx, 52(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	leal	1(%ebp,%esi), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%esi), %esi
	addl	%ebp, %esi
	calll	memcpy
	jmp	.LBB266_34
.LBB266_30:
	movl	%ebp, 48(%esp)          # 4-byte Spill
	movl	%ebx, %esi
	movl	56(%esp), %ebp          # 4-byte Reload
	movl	80(%esp), %edi
	jmp	.LBB266_35
.LBB266_32:
	movl	%eax, 52(%esp)          # 4-byte Spill
	addl	44(%esp), %esi          # 4-byte Folded Reload
.LBB266_34:                             # %if.end64
	movb	$64, (%esi)
	incl	%esi
	movl	56(%esp), %ebp          # 4-byte Reload
.LBB266_35:                             # %if.end66
	cmpl	$0, 28(%esp)            # 4-byte Folded Reload
	movl	36(%esp), %eax          # 4-byte Reload
	je	.LBB266_37
# BB#36:                                # %if.then68
	movb	$91, (%esi)
	incl	%esi
.LBB266_37:                             # %do.body71
	movl	%ebp, 56(%esp)          # 4-byte Spill
	leal	1(%ebp), %ecx
	movl	%ecx, 40(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	movl	%eax, %ebx
	calll	strlen
	movl	%eax, %ebp
	movl	%ebp, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	cmpl	$0, 28(%esp)            # 4-byte Folded Reload
	je	.LBB266_38
# BB#39:                                # %if.then77
	movb	$93, (%esi,%ebp)
	leal	1(%esi,%ebp), %esi
	jmp	.LBB266_40
.LBB266_38:
	addl	%ebp, %esi
.LBB266_40:                             # %if.end79
	movl	32(%esp), %eax          # 4-byte Reload
	cmpl	%eax, 12(%edi)
	je	.LBB266_42
# BB#41:                                # %if.then83
	movb	$58, (%esi)
	movl	12(%edi), %eax
	movl	%eax, %ecx
	sarl	$31, %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	incl	%esi
	movl	%esi, (%esp)
	calll	number_to_string
	movl	%eax, %esi
.LBB266_42:                             # %if.end88
	movl	16(%edi), %edi
	testl	%edi, %edi
	movl	%esi, %ebp
	je	.LBB266_44
# BB#43:                                # %if.then.i125
	movl	%edi, (%esp)
	calll	strlen
	movb	$47, (%esi)
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	leal	1(%esi), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%esi), %ebp
	calll	memcpy
.LBB266_44:                             # %do.body1.i
	movl	80(%esp), %eax
	movl	20(%eax), %edi
	testl	%edi, %edi
	je	.LBB266_46
# BB#45:                                # %if.then4.i129
	movl	%edi, (%esp)
	calll	strlen
	movb	$59, (%ebp)
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	leal	1(%ebp), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%ebp), %ebp
	calll	memcpy
.LBB266_46:                             # %do.body11.i
	movl	80(%esp), %eax
	movl	24(%eax), %edi
	testl	%edi, %edi
	je	.LBB266_48
# BB#47:                                # %if.then14.i
	movl	%edi, (%esp)
	calll	strlen
	movb	$63, (%ebp)
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	incl	%ebp
	movl	%ebp, (%esp)
	calll	memcpy
.LBB266_48:                             # %full_path_write.exit
	movl	56(%esp), %eax          # 4-byte Reload
	movb	$0, (%esi,%eax)
	movl	40(%esp), %eax          # 4-byte Reload
	addl	%esi, %eax
	subl	44(%esp), %eax          # 4-byte Folded Reload
	cmpl	24(%esp), %eax          # 4-byte Folded Reload
	movl	48(%esp), %eax          # 4-byte Reload
	jne	.LBB266_60
# BB#49:                                # %cond.end95
	testl	%eax, %eax
	movl	80(%esp), %esi
	je	.LBB266_52
# BB#50:                                # %land.lhs.true
	cmpl	40(%esi), %eax
	je	.LBB266_52
# BB#51:                                # %if.then100
	movl	%eax, (%esp)
	calll	checking_free
.LBB266_52:                             # %if.end101
	movl	52(%esp), %eax          # 4-byte Reload
	testl	%eax, %eax
	je	.LBB266_56
# BB#53:                                # %if.end101
	cmpl	$0, 84(%esp)
	jne	.LBB266_56
# BB#54:                                # %land.lhs.true106
	cmpl	44(%esi), %eax
	je	.LBB266_56
# BB#55:                                # %if.then110
	movl	%eax, (%esp)
	calll	checking_free
.LBB266_56:                             # %if.end111
	movl	36(%esp), %eax          # 4-byte Reload
	cmpl	8(%esi), %eax
	je	.LBB266_58
# BB#57:                                # %if.then115
	movl	%eax, (%esp)
	calll	checking_free
.LBB266_58:                             # %if.end116
	movl	44(%esp), %eax          # 4-byte Reload
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB266_59:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.url_string, 12(%esp)
	movl	$1844, 8(%esp)          # imm = 0x734
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str121107, (%esp)
	calll	__assert_fail
.LBB266_60:                             # %cond.false94
	movl	$.L__PRETTY_FUNCTION__.url_string, 12(%esp)
	movl	$1916, 8(%esp)          # imm = 0x77C
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str141109, (%esp)
	calll	__assert_fail
.Ltmp266:
	.size	url_string, .Ltmp266-url_string

	.globl	url_error
	.align	16, 0x90
	.type	url_error,@function
url_error:                              # @url_error
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %eax
	testl	%eax, %eax
	js	.LBB267_3
# BB#1:                                 # %entry
	cmpl	$8, %eax
	jae	.LBB267_3
# BB#2:                                 # %cond.end
	movl	parse_errors(,%eax,4), %eax
	movl	%eax, 4(%esp)
	movl	$5, 8(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	addl	$28, %esp
	ret
.LBB267_3:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.url_error, 12(%esp)
	movl	$893, 8(%esp)           # imm = 0x37D
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str61102, (%esp)
	calll	__assert_fail
.Ltmp267:
	.size	url_error, .Ltmp267-url_error

	.globl	url_full_path
	.align	16, 0x90
	.type	url_full_path,@function
url_full_path:                          # @url_full_path
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %ebx
	movl	16(%ebx), %eax
	xorl	%esi, %esi
	testl	%eax, %eax
	je	.LBB268_2
# BB#1:                                 # %if.then.i
	movl	%eax, (%esp)
	calll	strlen
	movl	%eax, %esi
	incl	%esi
.LBB268_2:                              # %if.end.i
	movl	20(%ebx), %eax
	testl	%eax, %eax
	je	.LBB268_4
# BB#3:                                 # %if.then4.i
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%esi,%eax), %esi
.LBB268_4:                              # %if.end9.i
	movl	24(%ebx), %eax
	testl	%eax, %eax
	je	.LBB268_6
# BB#5:                                 # %if.then11.i
	movl	%eax, (%esp)
	calll	strlen
	leal	1(%esi,%eax), %esi
.LBB268_6:                              # %full_path_length.exit
	leal	1(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	16(%ebx), %ebx
	testl	%ebx, %ebx
	movl	%edi, %ebp
	je	.LBB268_8
# BB#7:                                 # %if.then.i5
	movl	%ebx, (%esp)
	calll	strlen
	movb	$47, (%edi)
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	leal	1(%edi), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%edi), %ebp
	calll	memcpy
.LBB268_8:                              # %do.body1.i
	movl	32(%esp), %eax
	movl	20(%eax), %ebx
	testl	%ebx, %ebx
	je	.LBB268_10
# BB#9:                                 # %if.then4.i9
	movl	%ebx, (%esp)
	calll	strlen
	movb	$59, (%ebp)
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	leal	1(%ebp), %ecx
	movl	%ecx, (%esp)
	leal	1(%eax,%ebp), %ebp
	calll	memcpy
.LBB268_10:                             # %do.body11.i
	movl	32(%esp), %eax
	movl	24(%eax), %ebx
	testl	%ebx, %ebx
	je	.LBB268_12
# BB#11:                                # %if.then14.i
	movl	%ebx, (%esp)
	calll	strlen
	movb	$63, (%ebp)
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	incl	%ebp
	movl	%ebp, (%esp)
	calll	memcpy
.LBB268_12:                             # %full_path_write.exit
	movb	$0, (%edi,%esi)
	movl	%edi, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp268:
	.size	url_full_path, .Ltmp268-url_full_path

	.globl	url_set_dir
	.align	16, 0x90
	.type	url_set_dir,@function
url_set_dir:                            # @url_set_dir
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	32(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, 32(%esi)
	movl	%esi, %ecx
	addl	$8, %esp
	popl	%esi
	jmp	sync_path               # TAILCALL
.Ltmp269:
	.size	url_set_dir, .Ltmp269-url_set_dir

	.align	16, 0x90
	.type	sync_path,@function
sync_path:                              # @sync_path
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%ecx, %esi
	movl	16(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	32(%esi), %edi
	movl	$1, (%esp)
	movl	%edi, %ecx
	movl	$3, %edx
	calll	url_escape_1
	cmpl	%edi, %eax
	je	.LBB270_9
# BB#1:
	movl	%eax, %edx
	movl	%eax, %ecx
	jmp	.LBB270_2
	.align	16, 0x90
.LBB270_7:                              # %for.inc.i.i
                                        #   in Loop: Header=BB270_2 Depth=1
	movb	%bl, (%ecx)
	incl	%ecx
	incl	%edx
.LBB270_2:                              # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	movb	(%edx), %bl
	testb	%bl, %bl
	je	.LBB270_8
# BB#3:                                 # %for.cond.i.i
                                        #   in Loop: Header=BB270_2 Depth=1
	cmpb	$37, %bl
	jne	.LBB270_7
# BB#4:                                 # %land.lhs.true.i.i
                                        #   in Loop: Header=BB270_2 Depth=1
	cmpb	$50, 1(%edx)
	jne	.LBB270_7
# BB#5:                                 # %land.lhs.true16.i.i
                                        #   in Loop: Header=BB270_2 Depth=1
	cmpb	$70, 2(%edx)
	jne	.LBB270_7
# BB#6:                                 #   in Loop: Header=BB270_2 Depth=1
	movb	$47, %bl
	addl	$2, %edx
	jmp	.LBB270_7
.LBB270_8:                              # %unescape_single_char.exit.i
	movb	$0, (%ecx)
	movl	%eax, %edi
.LBB270_9:                              # %url_escape_dir.exit
	movl	%esi, %ebx
	movl	36(%ebx), %ecx
	movl	$1, (%esp)
	movl	$3, %edx
	calll	url_escape_1
	movl	%eax, %esi
	cmpb	$0, (%edi)
	je	.LBB270_10
# BB#11:                                # %if.else
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %ebp
	movl	%esi, (%esp)
	calll	strlen
	movl	%ebx, 20(%esp)          # 4-byte Spill
	movl	%eax, %ebx
	leal	2(%ebp,%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%esi, 24(%esp)          # 4-byte Spill
	movl	%eax, %esi
	movl	%ebp, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	movb	$47, (%esi,%ebp)
	movl	%ebx, 8(%esp)
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	leal	1(%esi,%ebp), %eax
	movl	%eax, (%esp)
	leal	1(%ebp,%ebx), %ebx
	calll	memcpy
	movb	$0, (%esi,%ebx)
	movl	20(%esp), %ebx          # 4-byte Reload
	jmp	.LBB270_12
.LBB270_10:                             # %if.then
	movl	%esi, (%esp)
	movl	%esi, 24(%esp)          # 4-byte Spill
	calll	checking_strdup
	movl	%eax, %esi
.LBB270_12:                             # %if.end
	movl	%esi, 16(%ebx)
	cmpl	32(%ebx), %edi
	je	.LBB270_14
# BB#13:                                # %if.then11
	movl	%edi, (%esp)
	calll	checking_free
.LBB270_14:                             # %if.end12
	movl	24(%esp), %eax          # 4-byte Reload
	cmpl	36(%ebx), %eax
	je	.LBB270_16
# BB#15:                                # %if.then15
	movl	%eax, (%esp)
	calll	checking_free
.LBB270_16:                             # %if.end16
	movl	(%ebx), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	%ebx, (%esp)
	movl	$0, 4(%esp)
	calll	url_string
	movl	%eax, (%ebx)
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp270:
	.size	sync_path, .Ltmp270-sync_path

	.globl	url_set_file
	.align	16, 0x90
	.type	url_set_file,@function
url_set_file:                           # @url_set_file
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	36(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movl	%eax, 36(%esi)
	movl	%esi, %ecx
	addl	$8, %esp
	popl	%esi
	jmp	sync_path               # TAILCALL
.Ltmp271:
	.size	url_set_file, .Ltmp271-url_set_file

	.globl	url_free
	.align	16, 0x90
	.type	url_free,@function
url_free:                               # @url_free
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	16(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	20(%esi), %eax
	testl	%eax, %eax
	je	.LBB272_2
# BB#1:                                 # %if.else
	movl	%eax, (%esp)
	calll	checking_free
.LBB272_2:                              # %if.end
	movl	24(%esi), %eax
	testl	%eax, %eax
	je	.LBB272_4
# BB#3:                                 # %if.else5
	movl	%eax, (%esp)
	calll	checking_free
.LBB272_4:                              # %if.end7
	movl	28(%esi), %eax
	testl	%eax, %eax
	je	.LBB272_6
# BB#5:                                 # %if.else10
	movl	%eax, (%esp)
	calll	checking_free
.LBB272_6:                              # %if.end12
	movl	40(%esi), %eax
	testl	%eax, %eax
	je	.LBB272_8
# BB#7:                                 # %if.else15
	movl	%eax, (%esp)
	calll	checking_free
.LBB272_8:                              # %if.end17
	movl	44(%esi), %eax
	testl	%eax, %eax
	je	.LBB272_10
# BB#9:                                 # %if.else20
	movl	%eax, (%esp)
	calll	checking_free
.LBB272_10:                             # %if.end22
	movl	32(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	36(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	addl	$8, %esp
	popl	%esi
	jmp	checking_free           # TAILCALL
.Ltmp272:
	.size	url_free, .Ltmp272-url_free

	.globl	mkalldirs
	.align	16, 0x90
	.type	mkalldirs,@function
mkalldirs:                              # @mkalldirs
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$116, %esp
	movl	128(%esp), %esi
	movl	%esi, (%esp)
	calll	strlen
	.align	16, 0x90
.LBB273_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %edx
	movb	(%esi,%edx), %cl
	leal	-1(%edx), %eax
	cmpb	$47, %cl
	je	.LBB273_3
# BB#2:                                 # %for.cond
                                        #   in Loop: Header=BB273_1 Depth=1
	testl	%edx, %edx
	jne	.LBB273_1
.LBB273_3:                              # %for.end
	testl	%edx, %edx
	setne	%dl
	cmpb	$47, %cl
	je	.LBB273_5
# BB#4:                                 # %for.end
	xorl	%edi, %edi
	cmpb	$1, %dl
	jne	.LBB273_14
.LBB273_5:                              # %if.end
	leal	1(%esi,%eax), %eax
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	calll	strdupdelim
	movl	%eax, %esi
	leal	16(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	jne	.LBB273_11
# BB#6:                                 # %if.then13
	movl	$61440, %eax            # imm = 0xF000
	andl	32(%esp), %eax
	cmpl	$16384, %eax            # imm = 0x4000
	jne	.LBB273_8
# BB#7:                                 # %if.then16
	movl	%esi, (%esp)
	calll	checking_free
	xorl	%edi, %edi
	jmp	.LBB273_14
.LBB273_8:                              # %do.body
	cmpb	$0, opt+250
	jne	.LBB273_9
	.align	16, 0x90
.LBB273_10:                             # %do.end
	movl	%esi, (%esp)
	calll	unlink
.LBB273_11:                             # %if.end23
	movl	%esi, (%esp)
	calll	make_directory
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB273_13
# BB#12:                                # %if.then27
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str81104, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB273_13:                             # %if.end30
	movl	%esi, (%esp)
	calll	checking_free
.LBB273_14:                             # %return
	movl	%edi, %eax
	addl	$116, %esp
	popl	%esi
	popl	%edi
	ret
.LBB273_9:                              # %if.then19
	movl	%esi, 4(%esp)
	movl	$.L.str71103, (%esp)
	calll	debug_logprintf
	jmp	.LBB273_10
.Ltmp273:
	.size	mkalldirs, .Ltmp273-mkalldirs

	.globl	url_file_name
	.align	16, 0x90
	.type	url_file_name,@function
url_file_name:                          # @url_file_name
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	$0, 48(%esp)
	movl	$0, 52(%esp)
	movl	$0, 56(%esp)
	xorl	%ebp, %ebp
	movl	opt+44, %eax
	testl	%eax, %eax
	movl	$0, %edi
	movl	%ebp, %esi
	je	.LBB274_8
# BB#1:                                 # %if.then
	movl	%eax, (%esp)
	movl	%eax, 20(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, %esi
	xorl	%ebp, %ebp
	testl	%esi, %esi
	jle	.LBB274_2
# BB#3:
	movl	$16, %eax
	.align	16, 0x90
.LBB274_4:                              # %while.body.i
                                        # =>This Inner Loop Header: Depth=1
	addl	%ebp, %ebp
	cmpl	$16, %ebp
	cmovll	%eax, %ebp
	cmpl	%esi, %ebp
	jl	.LBB274_4
# BB#5:                                 # %while.end.i
	movl	%ebp, 52(%esp)
	xorl	%edi, %edi
	testl	%ebp, %ebp
	movl	$0, %ebx
	je	.LBB274_7
# BB#6:                                 # %if.then5.i
	movl	%ebp, 4(%esp)
	movl	$0, (%esp)
	calll	checking_realloc
	movl	%eax, %ebx
	movl	%ebx, 48(%esp)
	movl	%ebp, %edi
	jmp	.LBB274_7
.LBB274_2:
	xorl	%edi, %edi
	xorl	%ebx, %ebx
.LBB274_7:                              # %append_string.exit
	movl	%esi, 8(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	movl	%esi, 56(%esp)
	movl	%ebx, %ebp
.LBB274_8:                              # %if.end
	cmpb	$0, opt+32
	je	.LBB274_80
# BB#9:                                 # %if.then2
	cmpb	$0, opt+41
	je	.LBB274_25
# BB#10:                                # %if.then4
	xorl	%ebx, %ebx
	testl	%esi, %esi
	je	.LBB274_18
# BB#11:                                # %if.then7
	leal	1(%esi), %eax
	cmpl	%eax, %edi
	jge	.LBB274_17
# BB#12:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_13:                             # %while.body.i137
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%eax, %edi
	jl	.LBB274_13
# BB#14:                                # %while.end.i139
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_15
# BB#16:                                # %if.then5.i143
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)
	jmp	.LBB274_17
.LBB274_15:
	xorl	%edi, %edi
.LBB274_17:                             # %append_char.exit
	movb	$47, (%ebp,%esi)
	movl	56(%esp), %ebx
	incl	%ebx
	movl	%ebx, 56(%esp)
.LBB274_18:                             # %if.end8
	movl	80(%esp), %eax
	movl	4(%eax), %eax
	shll	$4, %eax
	movl	supported_schemes(%eax), %eax
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	%eax, (%esp)
	calll	strlen
	movl	%eax, %esi
	leal	(%ebx,%esi), %eax
	cmpl	%eax, %edi
	jge	.LBB274_24
# BB#19:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_20:                             # %while.body.i154
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%eax, %edi
	jl	.LBB274_20
# BB#21:                                # %while.end.i156
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_22
# BB#23:                                # %if.then5.i163
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)
	jmp	.LBB274_24
.LBB274_22:
	xorl	%edi, %edi
.LBB274_24:                             # %append_string.exit166
	movl	%esi, 8(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	addl	%ebp, %ebx
	movl	%ebx, (%esp)
	calll	memcpy
	addl	56(%esp), %esi
	movl	%esi, 56(%esp)
.LBB274_25:                             # %if.end9
	cmpb	$0, opt+40
	je	.LBB274_66
# BB#26:                                # %if.then11
	xorl	%ebx, %ebx
	testl	%esi, %esi
	je	.LBB274_34
# BB#27:                                # %if.then14
	leal	1(%esi), %eax
	cmpl	%eax, %edi
	jge	.LBB274_33
# BB#28:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_29:                             # %while.body.i175
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%eax, %edi
	jl	.LBB274_29
# BB#30:                                # %while.end.i177
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_31
# BB#32:                                # %if.then5.i184
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)
	jmp	.LBB274_33
.LBB274_31:
	xorl	%edi, %edi
.LBB274_33:                             # %append_char.exit187
	movb	$47, (%ebp,%esi)
	movl	56(%esp), %ebx
	incl	%ebx
	movl	%ebx, 56(%esp)
.LBB274_34:                             # %cond.true
	movl	80(%esp), %eax
	movl	8(%eax), %eax
	cmpb	$46, (%eax)
	jne	.LBB274_37
# BB#35:                                # %if.then23
	cmpb	$46, 1(%eax)
	jne	.LBB274_37
# BB#36:                                # %cond.end
	cmpb	$0, 2(%eax)
	je	.LBB274_44
.LBB274_37:                             # %if.then54
	movl	%eax, (%esp)
	movl	%eax, 20(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, %esi
	leal	(%ebx,%esi), %eax
	cmpl	%eax, %edi
	jge	.LBB274_43
# BB#38:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_39:                             # %while.body.i197
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%eax, %edi
	jl	.LBB274_39
# BB#40:                                # %while.end.i199
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_41
# BB#42:                                # %if.then5.i206
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)
	jmp	.LBB274_43
.LBB274_41:
	xorl	%edi, %edi
.LBB274_43:                             # %append_string.exit209
	movl	%esi, 8(%esp)
	movl	20(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	addl	%ebp, %ebx
	movl	%ebx, (%esp)
	calll	memcpy
	addl	56(%esp), %esi
	.align	16, 0x90
.LBB274_51:                             # %if.end56
	movl	%esi, 56(%esp)
	movl	80(%esp), %eax
	movl	4(%eax), %ecx
	movl	12(%eax), %eax
	shll	$4, %ecx
	cmpl	supported_schemes+8(%ecx), %eax
	je	.LBB274_66
# BB#52:                                # %if.then61
	movl	%eax, %ecx
	sarl	$31, %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	number_to_string
	movb	$58, %bl
	cmpl	$1, opt+320
	jne	.LBB274_54
# BB#53:                                # %if.then61
	movb	$43, %bl
.LBB274_54:                             # %if.then61
	leal	1(%esi), %edx
	cmpl	%edx, %edi
	movl	%ebp, %eax
	jge	.LBB274_59
# BB#55:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_56:                             # %while.body.i240
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%edx, %edi
	jl	.LBB274_56
# BB#57:                                # %while.end.i242
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_59
# BB#58:                                # %if.then5.i249
	movl	%edi, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, 48(%esp)
.LBB274_59:                             # %append_char.exit252
	movb	%bl, (%eax,%esi)
	movl	56(%esp), %esi
	leal	1(%esi), %ebp
	movl	%ebp, 56(%esp)
	leal	24(%esp), %ebx
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, %edi
	leal	1(%esi,%edi), %esi
	movl	52(%esp), %eax
	cmpl	%esi, %eax
	jge	.LBB274_63
# BB#60:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_61:                             # %while.body.i262
                                        # =>This Inner Loop Header: Depth=1
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%esi, %eax
	jl	.LBB274_61
# BB#62:                                # %while.end.i264
	movl	%eax, 52(%esp)
	testl	%eax, %eax
	je	.LBB274_63
# BB#64:                                # %if.then5.i271
	movl	48(%esp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 48(%esp)
	jmp	.LBB274_65
.LBB274_63:                             # %while.end.do.end9_crit_edge.i267
	movl	48(%esp), %eax
.LBB274_65:                             # %append_string.exit274
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	addl	%ebp, %eax
	movl	%eax, (%esp)
	calll	memcpy
	movl	%esi, 56(%esp)
.LBB274_66:                             # %if.end71
	movl	80(%esp), %eax
	movl	16(%eax), %edi
	movl	%edi, (%esp)
	movl	$47, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	je	.LBB274_80
# BB#67:                                # %for.body.lr.ph.i
	movl	opt+36, %ebx
	.align	16, 0x90
.LBB274_68:                             # %for.body.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB274_72 Depth 2
	movl	%eax, %esi
	testl	%ebx, %ebx
	jg	.LBB274_78
# BB#69:                                # %for.body.i
                                        #   in Loop: Header=BB274_68 Depth=1
	cmpl	%esi, %edi
	je	.LBB274_78
# BB#70:                                # %if.end4.i
                                        #   in Loop: Header=BB274_68 Depth=1
	movl	%edi, 20(%esp)          # 4-byte Spill
	movl	56(%esp), %ebp
	testl	%ebp, %ebp
	je	.LBB274_77
# BB#71:                                # %if.then5.i277
                                        #   in Loop: Header=BB274_68 Depth=1
	leal	1(%ebp), %edi
	movl	52(%esp), %eax
	cmpl	%edi, %eax
	movl	$16, %ecx
	jge	.LBB274_74
	.align	16, 0x90
.LBB274_72:                             # %while.body.i.i
                                        #   Parent Loop BB274_68 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%edi, %eax
	jl	.LBB274_72
# BB#73:                                # %while.end.i.i
                                        #   in Loop: Header=BB274_68 Depth=1
	movl	%eax, 52(%esp)
	testl	%eax, %eax
	jne	.LBB274_75
.LBB274_74:                             # %while.end.do.end8_crit_edge.i.i
                                        #   in Loop: Header=BB274_68 Depth=1
	movl	48(%esp), %eax
	jmp	.LBB274_76
.LBB274_75:                             # %if.then5.i.i
                                        #   in Loop: Header=BB274_68 Depth=1
	movl	48(%esp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 48(%esp)
.LBB274_76:                             # %append_char.exit.i
                                        #   in Loop: Header=BB274_68 Depth=1
	movb	$47, (%eax,%ebp)
	movl	%edi, 56(%esp)
.LBB274_77:                             # %if.end6.i
                                        #   in Loop: Header=BB274_68 Depth=1
	leal	48(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$1, (%esp)
	movl	20(%esp), %ecx          # 4-byte Reload
	movl	%esi, %edx
	calll	append_uri_pathel
.LBB274_78:                             # %for.inc.i
                                        #   in Loop: Header=BB274_68 Depth=1
	decl	%ebx
	incl	%esi
	movl	%esi, (%esp)
	movl	$47, 4(%esp)
	calll	strchr
	testl	%eax, %eax
	movl	%esi, %edi
	jne	.LBB274_68
# BB#79:                                # %if.end72.loopexit
	movl	56(%esp), %esi
.LBB274_80:                             # %if.end72
	testl	%esi, %esi
	je	.LBB274_88
# BB#81:                                # %if.then75
	leal	1(%esi), %edi
	movl	52(%esp), %eax
	cmpl	%edi, %eax
	jge	.LBB274_85
# BB#82:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_83:                             # %while.body.i289
                                        # =>This Inner Loop Header: Depth=1
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%edi, %eax
	jl	.LBB274_83
# BB#84:                                # %while.end.i291
	movl	%eax, 52(%esp)
	testl	%eax, %eax
	je	.LBB274_85
# BB#86:                                # %if.then5.i298
	movl	48(%esp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 48(%esp)
	jmp	.LBB274_87
.LBB274_85:                             # %while.end.do.end8_crit_edge.i294
	movl	48(%esp), %eax
.LBB274_87:                             # %append_char.exit301
	movb	$47, (%eax,%esi)
	movl	%edi, 56(%esp)
.LBB274_88:                             # %if.end76
	movl	80(%esp), %edi
	movl	36(%edi), %eax
	cmpb	$0, (%eax)
	movl	$.L.str111106, %esi
	cmovnel	%eax, %esi
	movl	%esi, (%esp)
	calll	strlen
	leal	48(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	$0, (%esp)
	addl	%esi, %eax
	movl	%esi, %ecx
	movl	%eax, %edx
	calll	append_uri_pathel
	movl	24(%edi), %eax
	testl	%eax, %eax
	je	.LBB274_97
# BB#89:                                # %cond.end93
	cmpb	$0, (%eax)
	movl	$0, %esi
	cmovnel	%eax, %esi
	testl	%esi, %esi
	je	.LBB274_97
# BB#90:                                # %if.then96
	cmpl	$1, opt+320
	sete	%bl
	addb	$63, %bl
	movl	52(%esp), %eax
	movl	56(%esp), %ebp
	leal	1(%ebp), %edi
	cmpl	%edi, %eax
	jge	.LBB274_94
# BB#91:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_92:                             # %while.body.i310
                                        # =>This Inner Loop Header: Depth=1
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%edi, %eax
	jl	.LBB274_92
# BB#93:                                # %while.end.i312
	movl	%eax, 52(%esp)
	testl	%eax, %eax
	je	.LBB274_94
# BB#95:                                # %if.then5.i319
	movl	48(%esp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, 48(%esp)
	jmp	.LBB274_96
.LBB274_94:                             # %while.end.do.end8_crit_edge.i315
	movl	48(%esp), %eax
.LBB274_96:                             # %append_char.exit322
	movb	%bl, (%eax,%ebp)
	movl	%edi, 56(%esp)
	movl	%esi, (%esp)
	calll	strlen
	leal	48(%esp), %ecx
	movl	%ecx, 4(%esp)
	movl	$1, (%esp)
	addl	%esi, %eax
	movl	%esi, %ecx
	movl	%eax, %edx
	calll	append_uri_pathel
.LBB274_97:                             # %if.end103
	movl	52(%esp), %eax
	movl	56(%esp), %edi
	leal	1(%edi), %ebx
	cmpl	%ebx, %eax
	jge	.LBB274_101
# BB#98:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_99:                             # %while.body.i331
                                        # =>This Inner Loop Header: Depth=1
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%ebx, %eax
	jl	.LBB274_99
# BB#100:                               # %while.end.i333
	movl	%eax, 52(%esp)
	testl	%eax, %eax
	je	.LBB274_101
# BB#102:                               # %if.then5.i340
	movl	48(%esp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, %esi
	movl	%esi, 48(%esp)
	jmp	.LBB274_103
.LBB274_101:                            # %while.end.do.end8_crit_edge.i336
	movl	48(%esp), %esi
.LBB274_103:                            # %append_char.exit343
	movb	$0, (%esi,%edi)
	movl	%ebx, 56(%esp)
	movb	opt+116, %al
	orb	opt+42, %al
	orb	opt+251, %al
	orb	opt+32, %al
	je	.LBB274_108
# BB#104:                               # %land.lhs.true115
	movl	%esi, (%esp)
	calll	file_exists_p
	cmpb	$1, %al
	jne	.LBB274_105
# BB#106:                               # %land.lhs.true118
	movl	%esi, (%esp)
	calll	file_non_directory_p
	testb	%al, %al
	jne	.LBB274_107
.LBB274_108:                            # %if.end121
	movl	%esi, (%esp)
	movl	$1, 4(%esp)
	calll	unique_name
	movl	%eax, %edi
	cmpl	%esi, %edi
	je	.LBB274_110
# BB#109:                               # %if.then125
	movl	%esi, (%esp)
	calll	checking_free
	jmp	.LBB274_110
.LBB274_105:
	movl	%esi, %edi
	jmp	.LBB274_110
.LBB274_107:
	movl	%esi, %edi
.LBB274_110:                            # %return
	movl	%edi, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB274_44:                             # %if.else
	leal	6(%ebx), %eax
	cmpl	%eax, %edi
	jge	.LBB274_50
# BB#45:
	movl	$16, %ecx
	.align	16, 0x90
.LBB274_46:                             # %while.body.i219
                                        # =>This Inner Loop Header: Depth=1
	addl	%edi, %edi
	cmpl	$16, %edi
	cmovll	%ecx, %edi
	cmpl	%eax, %edi
	jl	.LBB274_46
# BB#47:                                # %while.end.i221
	movl	%edi, 52(%esp)
	testl	%edi, %edi
	je	.LBB274_48
# BB#49:                                # %if.then5.i228
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	calll	checking_realloc
	movl	%eax, %ebp
	movl	%ebp, 48(%esp)
	jmp	.LBB274_50
.LBB274_48:
	xorl	%edi, %edi
.LBB274_50:                             # %append_string.exit231
	movw	$17714, 4(%ebp,%ebx)    # imm = 0x4532
	movl	$625291813, (%ebp,%ebx) # imm = 0x25453225
	movl	56(%esp), %esi
	addl	$6, %esi
	jmp	.LBB274_51
.Ltmp274:
	.size	url_file_name, .Ltmp274-url_file_name

	.align	16, 0x90
	.type	append_uri_pathel,@function
append_uri_pathel:                      # @append_uri_pathel
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %esi
	cmpl	$1, opt+320
	movl	$1, %eax
	sbbl	$-1, %eax
	movl	%eax, %edx
	orl	$4, %edx
	cmpb	$0, opt+324
	cmovel	%eax, %edx
	movb	8(%ebp), %al
	testb	%al, %al
	je	.LBB275_1
# BB#2:                                 # %do.body
	movl	%edx, -16(%ebp)         # 4-byte Spill
	subl	%ecx, %esi
	leal	16(%esi), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, -20(%ebp)         # 4-byte Spill
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%esi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$0, (%esi,%ebx)
	movl	%ebx, %edi
	movl	%ebx, %esi
	jmp	.LBB275_3
.LBB275_1:
	movl	%ecx, %edi
	jmp	.LBB275_19
	.align	16, 0x90
.LBB275_17:                             # %for.inc.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movb	%dh, (%edi)
	incl	%edi
	incl	%esi
.LBB275_3:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, %ecx
	movb	(%ecx), %dl
	testb	%dl, %dl
	je	.LBB275_18
# BB#4:                                 # %for.cond.i
                                        #   in Loop: Header=BB275_3 Depth=1
	cmpb	$37, %dl
	jne	.LBB275_5
# BB#6:                                 # %if.else.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movzbl	1(%ecx), %eax
	testl	%eax, %eax
	je	.LBB275_5
# BB#7:                                 # %lor.lhs.false.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movzbl	2(%ecx), %ebx
	testl	%ebx, %ebx
	je	.LBB275_5
# BB#8:                                 # %lor.lhs.false5.i
                                        #   in Loop: Header=BB275_3 Depth=1
	testb	$1, _sch_istable+1(%eax,%eax)
	je	.LBB275_5
# BB#9:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB275_3 Depth=1
	testb	$1, _sch_istable+1(%ebx,%ebx)
	je	.LBB275_5
# BB#10:                                # %if.end.i
                                        #   in Loop: Header=BB275_3 Depth=1
	leal	2(%ecx), %esi
	cmpb	$64, %al
	jg	.LBB275_12
# BB#11:                                # %cond.true.i
                                        #   in Loop: Header=BB275_3 Depth=1
	addb	$-48, %al
                                        # kill: AL<def> AL<kill> EAX<kill>
	jmp	.LBB275_13
.LBB275_12:                             # %cond.false.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movb	_sch_toupper(%eax), %al
	addb	$-55, %al
.LBB275_13:                             # %cond.end.i
                                        #   in Loop: Header=BB275_3 Depth=1
	shlb	$4, %al
	cmpb	$64, %bl
	jg	.LBB275_15
# BB#14:                                # %cond.true36.i
                                        #   in Loop: Header=BB275_3 Depth=1
	addb	$-48, %bl
	movb	%bl, %dh
	jmp	.LBB275_16
.LBB275_15:                             # %cond.false40.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movb	_sch_toupper(%ebx), %dh
	addb	$-55, %dh
.LBB275_16:                             # %cond.end48.i
                                        #   in Loop: Header=BB275_3 Depth=1
	addb	%al, %dh
	jne	.LBB275_17
.LBB275_5:                              # %copychar.i
                                        #   in Loop: Header=BB275_3 Depth=1
	movb	%dl, %dh
	movl	%ecx, %esi
	jmp	.LBB275_17
.LBB275_18:                             # %url_unescape.exit
	movb	$0, (%edi)
	subl	$16, %esp
	movl	-20(%ebp), %edi         # 4-byte Reload
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %esi
	addl	%edi, %esi
	movl	-16(%ebp), %edx         # 4-byte Reload
.LBB275_19:                             # %if.end5
	movl	%esi, %eax
	subl	%edi, %eax
	cmpl	$2, %eax
	jne	.LBB275_20
# BB#21:                                # %land.lhs.true
	cmpb	$46, (%edi)
	jne	.LBB275_22
# BB#23:                                # %land.lhs.true13
	cmpb	$46, 1(%edi)
	movl	$.L.str101105, %ebx
	cmovnel	%edi, %ebx
	movl	$.L.str101105+6, %eax
	cmovel	%eax, %esi
	jmp	.LBB275_24
.LBB275_20:
	movl	%edi, %ebx
	jmp	.LBB275_24
.LBB275_22:
	movl	%edi, %ebx
.LBB275_24:                             # %if.end20
	xorl	%edi, %edi
	cmpl	%esi, %ebx
	jae	.LBB275_27
# BB#25:
	movl	%ebx, %eax
	.align	16, 0x90
.LBB275_26:                             # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%eax), %ecx
	movzbl	filechr_table(%ecx), %ecx
	andl	%edx, %ecx
	cmpl	$1, %ecx
	sbbl	$-1, %edi
	incl	%eax
	cmpl	%eax, %esi
	jne	.LBB275_26
.LBB275_27:                             # %for.end
	movl	%edx, -16(%ebp)         # 4-byte Spill
	movl	%esi, %eax
	movl	%eax, -28(%ebp)         # 4-byte Spill
	movl	12(%ebp), %esi
	subl	%ebx, %eax
	leal	(%eax,%edi,2), %edx
	movl	%edx, -24(%ebp)         # 4-byte Spill
	movl	4(%esi), %eax
	movl	8(%esi), %ecx
	leal	(%ecx,%edx), %edx
	cmpl	%edx, %eax
	jge	.LBB275_32
# BB#28:
	movl	%ecx, -20(%ebp)         # 4-byte Spill
	movl	$16, %ecx
	.align	16, 0x90
.LBB275_29:                             # %while.body
                                        # =>This Inner Loop Header: Depth=1
	addl	%eax, %eax
	cmpl	$16, %eax
	cmovll	%ecx, %eax
	cmpl	%edx, %eax
	jl	.LBB275_29
# BB#30:                                # %while.end
	movl	%eax, 4(%esi)
	testl	%eax, %eax
	movl	-20(%ebp), %ecx         # 4-byte Reload
	je	.LBB275_32
# BB#31:                                # %if.then44
	movl	(%esi), %ecx
	subl	$16, %esp
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	addl	$16, %esp
	movl	%eax, (%esi)
	movl	8(%esi), %ecx
.LBB275_32:                             # %do.end50
	movl	%esi, -20(%ebp)         # 4-byte Spill
	movl	(%esi), %edx
	leal	(%edx,%ecx), %eax
	testl	%edi, %edi
	movl	-28(%ebp), %esi         # 4-byte Reload
	je	.LBB275_42
# BB#33:                                # %for.cond60.preheader
	cmpl	%esi, %ebx
	jb	.LBB275_35
# BB#34:
	movl	12(%ebp), %edi
	jmp	.LBB275_40
	.align	16, 0x90
.LBB275_35:                             # %for.body63
                                        # =>This Inner Loop Header: Depth=1
	movb	(%ebx), %dl
	movzbl	%dl, %ecx
	movzbl	filechr_table(%ecx), %edi
	testl	-16(%ebp), %edi         # 4-byte Folded Reload
	jne	.LBB275_37
# BB#36:                                # %if.then69
                                        #   in Loop: Header=BB275_35 Depth=1
	movb	%dl, (%eax)
	jmp	.LBB275_38
.LBB275_37:                             # %if.else71
                                        #   in Loop: Header=BB275_35 Depth=1
	movb	$37, (%eax)
	movl	%ecx, %edx
	shrl	$4, %edx
	movb	.L.str181113(%edx), %dl
	movb	%dl, 1(%eax)
	andl	$15, %ecx
	movb	.L.str181113(%ecx), %cl
	movb	%cl, 2(%eax)
	addl	$2, %eax
.LBB275_38:                             # %for.inc87
                                        #   in Loop: Header=BB275_35 Depth=1
	incl	%eax
	incl	%ebx
	cmpl	%ebx, %esi
	jne	.LBB275_35
# BB#39:                                # %for.cond60.for.end89_crit_edge
	movl	12(%ebp), %edi
	movl	(%edi), %edx
	movl	8(%edi), %ecx
.LBB275_40:                             # %for.end89
	addl	%ecx, %edx
	subl	%edx, %eax
	movl	-24(%ebp), %ebx         # 4-byte Reload
	cmpl	%ebx, %eax
	je	.LBB275_43
# BB#41:                                # %cond.false
	subl	$16, %esp
	movl	$.L__PRETTY_FUNCTION__.append_uri_pathel, 12(%esp)
	movl	$1366, 8(%esp)          # imm = 0x556
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str191114, (%esp)
	calll	__assert_fail
	addl	$16, %esp
.LBB275_42:                             # %if.then52
	subl	$16, %esp
	movl	-24(%ebp), %ecx         # 4-byte Reload
	movl	%ecx, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%ecx, %ebx
	movl	%eax, (%esp)
	calll	memcpy
	addl	$16, %esp
	movl	12(%ebp), %edi
.LBB275_43:                             # %if.end98
	movl	8(%edi), %eax
	movl	opt+328, %esi
	leal	-1(%esi), %ecx
	cmpl	$1, %ecx
	ja	.LBB275_48
# BB#44:                                # %if.then103
	leal	(%eax,%ebx), %ecx
	cmpl	%ecx, %eax
	jge	.LBB275_48
# BB#45:                                # %for.body115.lr.ph
	movl	-20(%ebp), %ecx         # 4-byte Reload
	movl	(%ecx), %ecx
	leal	1(%eax,%ecx), %ecx
	jmp	.LBB275_46
	.align	16, 0x90
.LBB275_47:                             # %for.body115.for.body115_crit_edge
                                        #   in Loop: Header=BB275_46 Depth=1
	incl	%ecx
	movl	opt+328, %esi
.LBB275_46:                             # %for.body115
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, %esi
	movl	$_sch_toupper, %eax
	movl	$_sch_tolower, %edx
	cmovel	%edx, %eax
	movzbl	-1(%ecx), %esi
	movb	(%eax,%esi), %al
	movb	%al, -1(%ecx)
	movl	8(%edi), %eax
	leal	(%eax,%ebx), %esi
	movl	-20(%ebp), %edx         # 4-byte Reload
	addl	(%edx), %esi
	cmpl	%esi, %ecx
	jb	.LBB275_47
.LBB275_48:                             # %if.end130
	addl	%ebx, %eax
	movl	%eax, 8(%edi)
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp275:
	.size	append_uri_pathel, .Ltmp275-append_uri_pathel

	.globl	uri_merge
	.align	16, 0x90
	.type	uri_merge,@function
uri_merge:                              # @uri_merge
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	52(%esp), %ebp
	movzbl	(%ebp), %eax
	testl	%eax, %eax
	je	.LBB276_1
# BB#16:                                # %lor.lhs.false.i
	testb	$-116, _sch_istable(%eax,%eax)
	jne	.LBB276_20
# BB#17:                                # %switch.early.test.i
	cmpb	$43, %al
	je	.LBB276_20
# BB#18:                                # %switch.early.test.i
	cmpb	$45, %al
	jne	.LBB276_19
.LBB276_20:                             # %while.cond.i.preheader
	leal	1(%ebp), %eax
	jmp	.LBB276_21
	.align	16, 0x90
.LBB276_23:                             # %while.cond.i.backedge
                                        #   in Loop: Header=BB276_21 Depth=1
	incl	%eax
.LBB276_21:                             # %while.cond.i
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%eax), %ecx
	testl	%ecx, %ecx
	je	.LBB276_19
# BB#22:                                # %land.rhs.i
                                        #   in Loop: Header=BB276_21 Depth=1
	testb	$-116, _sch_istable(%ecx,%ecx)
	jne	.LBB276_23
# BB#24:                                # %switch.early.test34.i
                                        #   in Loop: Header=BB276_21 Depth=1
	cmpb	$43, %cl
	je	.LBB276_23
# BB#25:                                # %switch.early.test34.i
                                        #   in Loop: Header=BB276_21 Depth=1
	cmpb	$45, %cl
	je	.LBB276_23
# BB#26:                                # %switch.early.test34.i
	cmpb	$58, %cl
	jne	.LBB276_19
# BB#27:                                # %if.then
	movl	%ebp, (%esp)
	calll	checking_strdup
	jmp	.LBB276_68
.LBB276_19:
	movl	$supported_schemes+4, %esi
	movl	$-1, %edi
	jmp	.LBB276_2
.LBB276_1:
	movl	$-1, %edi
	movl	$supported_schemes+4, %esi
	.align	16, 0x90
.LBB276_2:                              # %for.cond.i.i
                                        # =>This Inner Loop Header: Depth=1
	movl	(%esi), %ebx
	movl	$2, %eax
	testl	%ebx, %ebx
	je	.LBB276_5
# BB#3:                                 # %for.body.i.i
                                        #   in Loop: Header=BB276_2 Depth=1
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	48(%esp), %eax
	movl	%eax, (%esp)
	addl	$16, %esi
	incl	%edi
	calll	strncasecmp
	testl	%eax, %eax
	jne	.LBB276_2
# BB#4:                                 # %if.then.i.i
	testb	$1, -8(%esi)
	movl	$2, %eax
	cmovel	%edi, %eax
.LBB276_5:                              # %url_scheme.exit.i
	cmpl	$2, %eax
	movl	$0, %ecx
	cmovnel	%eax, %ecx
	shll	$4, %ecx
	movl	supported_schemes+12(%ecx), %ecx
	movl	%ecx, %edx
	movl	$init_seps.seps+2, %eax
	testb	$2, %dl
	je	.LBB276_7
# BB#6:                                 # %if.then.i5.i
	movb	$59, init_seps.seps+2
	movl	$init_seps.seps+3, %eax
.LBB276_7:                              # %if.end.i.i
	movl	%ecx, %edx
	testb	$4, %dl
	movl	48(%esp), %ebx
	je	.LBB276_9
# BB#8:                                 # %if.then4.i.i
	movb	$63, (%eax)
	incl	%eax
.LBB276_9:                              # %if.end6.i.i
	testb	$8, %cl
	je	.LBB276_11
# BB#10:                                # %if.then9.i.i
	movb	$35, (%eax)
	incl	%eax
.LBB276_11:                             # %init_seps.exit.i
	movb	$0, (%eax)
	movl	%ebx, (%esp)
	movl	$init_seps.seps+2, 4(%esp)
	calll	strpbrk
	movl	%eax, %edi
	testl	%edi, %edi
	jne	.LBB276_13
# BB#12:                                # %if.then.i8.i
	movl	%ebx, (%esp)
	movl	$0, 4(%esp)
	calll	__rawmemchr
	movl	%eax, %edi
.LBB276_13:                             # %path_end.exit
	movl	%ebp, (%esp)
	calll	strlen
	movl	%eax, %esi
	movb	(%ebp), %al
	cmpb	$34, %al
	jg	.LBB276_28
# BB#14:                                # %path_end.exit
	testb	%al, %al
	jne	.LBB276_56
# BB#15:                                # %if.then4
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	jmp	checking_strdup         # TAILCALL
.LBB276_28:                             # %path_end.exit
	cmpb	$35, %al
	jne	.LBB276_29
# BB#32:                                # %if.then15
	movl	%ebx, (%esp)
	movl	$35, 4(%esp)
	calll	strchr
	movl	%eax, %edi
	testl	%edi, %edi
	jne	.LBB276_31
# BB#33:                                # %if.then19
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, %edi
	addl	%ebx, %edi
	jmp	.LBB276_31
.LBB276_29:                             # %path_end.exit
	cmpb	$47, %al
	jne	.LBB276_30
# BB#34:                                # %land.lhs.true
	cmpb	$47, 1(%ebp)
	jne	.LBB276_35
# BB#38:                                # %if.then40
	subl	%ebx, %edi
	movl	%edi, 8(%esp)
	movl	%ebx, (%esp)
	movl	$47, 4(%esp)
	calll	memchr
	movl	%eax, %edi
	testl	%edi, %edi
	je	.LBB276_40
# BB#39:                                # %land.lhs.true46
	cmpb	$47, 1(%edi)
	je	.LBB276_41
.LBB276_40:                             # %if.else52
	movl	%ebx, %edi
.LBB276_41:                             # %if.end53
	movl	%edi, %ebp
	subl	%ebx, %ebp
	leal	1(%ebp,%esi), %eax
	movl	%eax, (%esp)
	leal	(%ebp,%esi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	calll	checking_malloc
	movl	%ebx, %ecx
	movl	%eax, %ebx
	cmpl	%ecx, %edi
	je	.LBB276_43
# BB#42:                                # %if.then61
	movl	%ebp, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
.LBB276_43:                             # %if.end62
	movl	%esi, 8(%esp)
	movl	52(%esp), %eax
	movl	%eax, 4(%esp)
	addl	%ebx, %ebp
	movl	%ebp, (%esp)
	jmp	.LBB276_44
.LBB276_30:                             # %path_end.exit
	cmpb	$63, %al
	jne	.LBB276_56
.LBB276_31:                             # %if.then7
	subl	%ebx, %edi
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%ebx, %ecx
	movl	%eax, %ebx
	movl	%edi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	movl	%esi, 8(%esp)
	movl	%ebp, 4(%esp)
	leal	(%ebx,%edi), %eax
	movl	%eax, (%esp)
	addl	%esi, %edi
	calll	memcpy
	movb	$0, (%ebx,%edi)
	jmp	.LBB276_67
.LBB276_56:                             # %if.else127
	movl	%edi, %eax
	subl	%ebx, %eax
	movl	%eax, 8(%esp)
	movl	%ebx, (%esp)
	movl	$47, 4(%esp)
	calll	memrchr
	xorb	%cl, %cl
	testl	%eax, %eax
	movl	%ebx, %ebp
	je	.LBB276_62
# BB#57:                                # %land.lhs.true138
	movl	%eax, %ebp
	leal	2(%ebx), %eax
	cmpl	%eax, %ebp
	jb	.LBB276_61
# BB#58:                                # %land.lhs.true142
	cmpb	$58, -2(%ebp)
	jne	.LBB276_61
# BB#59:                                # %land.lhs.true147
	cmpb	$47, -1(%ebp)
	jne	.LBB276_61
# BB#60:                                # %if.then152
	incl	%edi
	movb	$1, %cl
	movl	%edi, %ebp
	jmp	.LBB276_62
.LBB276_61:                             # %if.else154
	incl	%ebp
	xorb	%cl, %cl
.LBB276_62:                             # %if.end157
	movb	%cl, 24(%esp)           # 1-byte Spill
	movl	%ebp, %edi
	subl	%ebx, %edi
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%ebx, %ecx
	movl	%eax, %ebx
	cmpl	%ecx, %ebp
	je	.LBB276_64
# BB#63:                                # %if.then165
	movl	%edi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
.LBB276_64:                             # %if.end166
	leal	(%edi,%esi), %ebp
	cmpb	$1, 24(%esp)            # 1-byte Folded Reload
	jne	.LBB276_66
# BB#65:                                # %if.then168
	movb	$47, -1(%edi,%ebx)
.LBB276_66:                             # %if.end170
	movl	%esi, 8(%esp)
	movl	52(%esp), %eax
	movl	%eax, 4(%esp)
	addl	%ebx, %edi
	movl	%edi, (%esp)
	calll	memcpy
	movb	$0, (%ebx,%ebp)
	jmp	.LBB276_67
.LBB276_35:
	movl	%ebx, %eax
	xorb	%bl, %bl
	movl	%eax, %ebp
	.align	16, 0x90
.LBB276_36:                             # %again
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, %eax
	subl	%ebp, %eax
	movl	%eax, 8(%esp)
	movl	%ebp, (%esp)
	movl	$47, 4(%esp)
	calll	memchr
	testl	%eax, %eax
	sete	%cl
	testb	$1, %bl
	jne	.LBB276_37
# BB#45:                                # %again
                                        #   in Loop: Header=BB276_36 Depth=1
	testb	%cl, %cl
	movb	%bl, %dl
	jne	.LBB276_47
# BB#46:                                # %if.then81
                                        #   in Loop: Header=BB276_36 Depth=1
	leal	2(%eax), %ebp
	xorb	%cl, %cl
	movb	$1, %bl
	cmpb	$47, 1(%eax)
	movb	$0, %dl
	je	.LBB276_36
	jmp	.LBB276_47
.LBB276_37:
	movb	%bl, %dl
.LBB276_47:                             # %if.end89
	testl	%eax, %eax
	movl	48(%esp), %ebx
	jne	.LBB276_49
# BB#48:                                # %if.end89
	testb	$1, %dl
	movl	%ebx, %ebp
	je	.LBB276_53
.LBB276_49:                             # %if.else94
	movb	%dl, %ch
	xorb	$1, %ch
	testl	%eax, %eax
	jne	.LBB276_51
# BB#50:                                # %if.else94
	testb	$1, %ch
	movl	%edi, %ebp
	je	.LBB276_53
.LBB276_51:                             # %if.else100
	testl	%eax, %eax
	setne	%dh
	xorl	%edi, %edi
	andb	%ch, %dh
	movl	$0, %ebp
	cmovnel	%ebx, %ebp
	orb	%cl, %dh
	jne	.LBB276_53
# BB#52:                                # %land.lhs.true107
	testb	$1, %dl
	cmovnel	%eax, %edi
	movl	%edi, %ebp
.LBB276_53:                             # %if.end114
	movl	%ebp, %edi
	subl	%ebx, %edi
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	leal	(%edi,%esi), %eax
	movl	%eax, 24(%esp)          # 4-byte Spill
	calll	checking_malloc
	movl	%ebx, %ecx
	movl	%eax, %ebx
	cmpl	%ecx, %ebp
	je	.LBB276_55
# BB#54:                                # %if.then122
	movl	%edi, 8(%esp)
	movl	%ecx, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
.LBB276_55:                             # %if.end123
	movl	%esi, 8(%esp)
	movl	52(%esp), %eax
	movl	%eax, 4(%esp)
	addl	%ebx, %edi
	movl	%edi, (%esp)
.LBB276_44:                             # %if.end62
	calll	memcpy
	movl	24(%esp), %eax          # 4-byte Reload
	movb	$0, (%ebx,%eax)
.LBB276_67:                             # %return
	movl	%ebx, %eax
.LBB276_68:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp276:
	.size	uri_merge, .Ltmp276-uri_merge

	.globl	schemes_are_similar_p
	.align	16, 0x90
	.type	schemes_are_similar_p,@function
schemes_are_similar_p:                  # @schemes_are_similar_p
# BB#0:                                 # %entry
	movl	4(%esp), %eax
	cmpl	8(%esp), %eax
	sete	%al
	movzbl	%al, %eax
	ret
.Ltmp277:
	.size	schemes_are_similar_p, .Ltmp277-schemes_are_similar_p

	.globl	are_urls_equal
	.align	16, 0x90
	.type	are_urls_equal,@function
are_urls_equal:                         # @are_urls_equal
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %esi
	testl	%esi, %esi
	je	.LBB278_12
# BB#1:                                 # %entry
	movl	52(%esp), %edi
	testl	%edi, %edi
	je	.LBB278_12
# BB#2:
	leal	26(%esp), %ebp
	jmp	.LBB278_3
	.align	16, 0x90
.LBB278_8:                              # %while.body
                                        #   in Loop: Header=BB278_3 Depth=1
	addl	%eax, %edi
	addl	%ebx, %esi
.LBB278_3:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpb	$0, (%esi)
	je	.LBB278_10
# BB#4:                                 # %land.lhs.true3
                                        #   in Loop: Header=BB278_3 Depth=1
	cmpb	$0, (%edi)
	je	.LBB278_9
# BB#5:                                 # %land.lhs.true6
                                        #   in Loop: Header=BB278_3 Depth=1
	movl	%esi, %ecx
	leal	27(%esp), %edx
	calll	getchar_from_escaped_string
	movl	%eax, %ebx
	testl	%ebx, %ebx
	je	.LBB278_9
# BB#6:                                 # %land.lhs.true8
                                        #   in Loop: Header=BB278_3 Depth=1
	movl	%edi, %ecx
	movl	%ebp, %edx
	calll	getchar_from_escaped_string
	testl	%eax, %eax
	je	.LBB278_9
# BB#7:                                 # %land.rhs
                                        #   in Loop: Header=BB278_3 Depth=1
	movzbl	27(%esp), %ecx
	movb	_sch_tolower(%ecx), %cl
	movzbl	26(%esp), %edx
	cmpb	_sch_tolower(%edx), %cl
	je	.LBB278_8
.LBB278_9:                              # %while.end
	xorb	%al, %al
	cmpb	$0, (%esi)
	jne	.LBB278_11
.LBB278_10:                             # %land.rhs22
	cmpb	$0, (%edi)
	sete	%al
.LBB278_11:                             # %land.end26
	movzbl	%al, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB278_12:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.are_urls_equal, 12(%esp)
	movl	$1991, 8(%esp)          # imm = 0x7C7
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str151110, (%esp)
	calll	__assert_fail
.Ltmp278:
	.size	are_urls_equal, .Ltmp278-are_urls_equal

	.align	16, 0x90
	.type	getchar_from_escaped_string,@function
getchar_from_escaped_string:            # @getchar_from_escaped_string
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%esi
	subl	$20, %esp
	testl	%ecx, %ecx
	je	.LBB279_18
# BB#1:                                 # %land.lhs.true
	movb	(%ecx), %al
	testb	%al, %al
	je	.LBB279_18
# BB#2:                                 # %cond.end
	testl	%edx, %edx
	je	.LBB279_19
# BB#3:                                 # %cond.end5
	cmpb	$37, %al
	jne	.LBB279_15
# BB#4:                                 # %if.then
	movzbl	1(%ecx), %esi
	testb	$1, _sch_istable+1(%esi,%esi)
	je	.LBB279_6
# BB#5:                                 # %lor.lhs.false
	movzbl	2(%ecx), %ecx
	testb	$1, _sch_istable+1(%ecx,%ecx)
	je	.LBB279_6
# BB#7:                                 # %if.else
	movl	%ecx, %ebx
	xorl	%eax, %eax
	testb	%bl, %bl
	je	.LBB279_17
# BB#8:                                 # %if.end
	movl	%esi, %eax
	cmpb	$64, %al
	jg	.LBB279_10
# BB#9:                                 # %cond.true31
	movl	%esi, %eax
	addb	$-48, %al
	jmp	.LBB279_11
.LBB279_15:                             # %if.else68
	movb	%al, (%edx)
	jmp	.LBB279_16
.LBB279_10:                             # %cond.false34
	movb	_sch_toupper(%esi), %al
	addb	$-55, %al
.LBB279_11:                             # %cond.end41
                                        # kill: AL<def> AL<kill> EAX<kill>
	shlb	$4, %al
	movl	%ecx, %ebx
	cmpb	$64, %bl
	jg	.LBB279_13
# BB#12:                                # %cond.true46
	addb	$-48, %cl
	jmp	.LBB279_14
.LBB279_13:                             # %cond.false50
	movb	_sch_toupper(%ecx), %cl
	addb	$-55, %cl
.LBB279_14:                             # %cond.end58
	addb	%al, %cl
	movb	%cl, (%edx)
	movzbl	%cl, %ecx
	movl	$3, %eax
	testb	$1, urlchr_table(%ecx)
	je	.LBB279_17
.LBB279_6:                              # %if.then21
	movb	$37, (%edx)
.LBB279_16:                             # %if.else68
	movl	$1, %eax
.LBB279_17:                             # %return
	addl	$20, %esp
	popl	%esi
	popl	%ebx
	ret
.LBB279_18:                             # %cond.false
	movl	$.L__PRETTY_FUNCTION__.getchar_from_escaped_string, 12(%esp)
	movl	$1952, 8(%esp)          # imm = 0x7A0
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str161111, (%esp)
	calll	__assert_fail
.LBB279_19:                             # %cond.false4
	movl	$.L__PRETTY_FUNCTION__.getchar_from_escaped_string, 12(%esp)
	movl	$1953, 8(%esp)          # imm = 0x7A1
	movl	$.L.str51101, 4(%esp)
	movl	$.L.str171112, (%esp)
	calll	__assert_fail
.Ltmp279:
	.size	getchar_from_escaped_string, .Ltmp279-getchar_from_escaped_string

	.globl	xstrdup_lower
	.align	16, 0x90
	.type	xstrdup_lower,@function
xstrdup_lower:                          # @xstrdup_lower
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_strdup
	movb	(%eax), %cl
	testb	%cl, %cl
	je	.LBB280_3
# BB#1:                                 # %for.body.preheader
	leal	1(%eax), %edx
	.align	16, 0x90
.LBB280_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movzbl	%cl, %ecx
	movb	_sch_tolower(%ecx), %cl
	movb	%cl, -1(%edx)
	movb	(%edx), %cl
	incl	%edx
	testb	%cl, %cl
	jne	.LBB280_2
.LBB280_3:                              # %for.end
	addl	$12, %esp
	ret
.Ltmp280:
	.size	xstrdup_lower, .Ltmp280-xstrdup_lower

	.globl	strdupdelim
	.align	16, 0x90
	.type	strdupdelim,@function
strdupdelim:                            # @strdupdelim
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %ebx
	movl	36(%esp), %edi
	subl	%ebx, %edi
	leal	1(%edi), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	memcpy
	movb	$0, (%esi,%edi)
	movl	%esi, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp281:
	.size	strdupdelim, .Ltmp281-strdupdelim

	.globl	sepstring
	.align	16, 0x90
	.type	sepstring,@function
sepstring:                              # @sepstring
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	xorl	%eax, %eax
	movl	48(%esp), %edx
	testl	%edx, %edx
	je	.LBB282_11
# BB#1:                                 # %lor.lhs.false
	movb	(%edx), %cl
	xorl	%eax, %eax
	testb	%cl, %cl
	je	.LBB282_11
# BB#2:
	movl	%eax, %esi
	jmp	.LBB282_3
	.align	16, 0x90
.LBB282_8:                              #   in Loop: Header=BB282_3 Depth=1
                                        # kill: CL<def> CL<kill> ECX<kill>
	movl	%ebp, %edx
.LBB282_3:                              # %while.cond.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB282_7 Depth 2
                                        #     Child Loop BB282_4 Depth 2
	movl	%edx, %ebp
	jmp	.LBB282_4
	.align	16, 0x90
.LBB282_9:                              # %if.else
                                        #   in Loop: Header=BB282_4 Depth=2
	movb	1(%ebp), %cl
	incl	%ebp
.LBB282_4:                              # %while.cond
                                        #   Parent Loop BB282_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	je	.LBB282_10
# BB#5:                                 # %while.cond
                                        #   in Loop: Header=BB282_4 Depth=2
	cmpb	$44, %cl
	jne	.LBB282_9
# BB#6:                                 # %if.then4
                                        #   in Loop: Header=BB282_3 Depth=1
	leal	8(,%eax,4), %ecx
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	movl	%ebp, %esi
	subl	%edx, %esi
	leal	1(%esi), %ebx
	movl	%eax, 24(%esp)          # 4-byte Spill
	movl	%edx, %edi
	calll	checking_realloc
	movl	%eax, 20(%esp)          # 4-byte Spill
	movl	%ebx, (%esp)
	calll	checking_malloc
	movl	%eax, %ebx
	movl	%esi, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	movl	24(%esp), %eax          # 4-byte Reload
	movb	$0, (%ebx,%esi)
	movl	20(%esp), %esi          # 4-byte Reload
	movl	%ebx, (%esi,%eax,4)
	movl	$0, 4(%esi,%eax,4)
	incl	%eax
	.align	16, 0x90
.LBB282_7:                              # %while.cond7
                                        #   Parent Loop BB282_3 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	1(%ebp), %ecx
	incl	%ebp
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB282_7
	jmp	.LBB282_8
.LBB282_10:                             # %while.end17
	leal	8(,%eax,4), %ecx
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	subl	%edx, %ebp
	leal	1(%ebp), %ebx
	movl	%eax, %esi
	movl	%edx, 24(%esp)          # 4-byte Spill
	calll	checking_realloc
	movl	%eax, %edi
	movl	%ebx, (%esp)
	calll	checking_malloc
	movl	%eax, %ebx
	movl	%ebp, 8(%esp)
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	movb	$0, (%ebx,%ebp)
	movl	%ebx, (%edi,%esi,4)
	movl	$0, 4(%edi,%esi,4)
	movl	%edi, %eax
.LBB282_11:                             # %return
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp282:
	.size	sepstring, .Ltmp282-sepstring

	.globl	aprintf
	.align	16, 0x90
	.type	aprintf,@function
aprintf:                                # @aprintf
# BB#0:                                 # %entry
	subl	$28, %esp
	leal	36(%esp), %eax
	movl	%eax, 24(%esp)
	movl	%eax, 8(%esp)
	movl	32(%esp), %eax
	movl	%eax, 4(%esp)
	leal	20(%esp), %eax
	movl	%eax, (%esp)
	calll	vasprintf
	testl	%eax, %eax
	js	.LBB283_1
# BB#3:                                 # %if.end7
	movl	20(%esp), %eax
	jmp	.LBB283_4
.LBB283_1:                              # %land.lhs.true
	calll	__errno_location
	movl	%eax, %ecx
	xorl	%eax, %eax
	cmpl	$12, (%ecx)
	je	.LBB283_2
.LBB283_4:                              # %return
	addl	$28, %esp
	ret
.LBB283_2:                              # %if.then
	calll	abort
.Ltmp283:
	.size	aprintf, .Ltmp283-aprintf

	.globl	concat_strings
	.align	16, 0x90
	.type	concat_strings,@function
concat_strings:                         # @concat_strings
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$44, %esp
	leal	68(%esp), %edi
	movl	%edi, 40(%esp)
	movl	$1, %esi
	movl	64(%esp), %ebx
	testl	%ebx, %ebx
	je	.LBB284_6
# BB#1:
	xorl	%ebp, %ebp
	movl	%ebx, %eax
	xorl	%esi, %esi
	.align	16, 0x90
.LBB284_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, (%esp)
	calll	strlen
	cmpl	$4, %ebp
	ja	.LBB284_4
# BB#3:                                 # %if.then
                                        #   in Loop: Header=BB284_2 Depth=1
	movl	%eax, 20(%esp,%ebp,4)
	incl	%ebp
.LBB284_4:                              # %if.end
                                        #   in Loop: Header=BB284_2 Depth=1
	movl	40(%esp), %ecx
	leal	4(%ecx), %edx
	movl	%edx, 40(%esp)
	addl	%eax, %esi
	movl	(%ecx), %eax
	testl	%eax, %eax
	jne	.LBB284_2
# BB#5:                                 # %for.cond.for.end_crit_edge
	incl	%esi
.LBB284_6:                              # %for.end
	movl	%esi, (%esp)
	calll	checking_malloc
	movl	%eax, 16(%esp)          # 4-byte Spill
	movl	%edi, 40(%esp)
	testl	%ebx, %ebx
	movl	%eax, %ebp
	je	.LBB284_12
# BB#7:
	xorl	%esi, %esi
	movl	16(%esp), %ebp          # 4-byte Reload
	.align	16, 0x90
.LBB284_8:                              # %for.body9
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$4, %esi
	ja	.LBB284_10
# BB#9:                                 # %if.then12
                                        #   in Loop: Header=BB284_8 Depth=1
	movl	20(%esp,%esi,4), %edi
	incl	%esi
	jmp	.LBB284_11
.LBB284_10:                             # %if.else
                                        #   in Loop: Header=BB284_8 Depth=1
	movl	%ebx, (%esp)
	calll	strlen
	movl	%eax, %edi
.LBB284_11:                             # %if.end16
                                        #   in Loop: Header=BB284_8 Depth=1
	movl	%edi, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	calll	memcpy
	movl	40(%esp), %eax
	leal	4(%eax), %ecx
	movl	%ecx, 40(%esp)
	addl	%edi, %ebp
	movl	(%eax), %ebx
	testl	%ebx, %ebx
	jne	.LBB284_8
.LBB284_12:                             # %for.end20
	movb	$0, (%ebp)
	movl	16(%esp), %eax          # 4-byte Reload
	addl	$44, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp284:
	.size	concat_strings, .Ltmp284-concat_strings

	.globl	time_str
	.align	16, 0x90
	.type	time_str,@function
time_str:                               # @time_str
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %eax
	movl	%eax, 24(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	localtime
	testl	%eax, %eax
	je	.LBB285_3
# BB#1:                                 # %if.end.i
	movl	%eax, 12(%esp)
	movl	$.L.str1164, 8(%esp)
	movl	$32, 4(%esp)
	movl	$fmttime.output, (%esp)
	calll	strftime
	testl	%eax, %eax
	je	.LBB285_3
# BB#2:                                 # %fmttime.exit
	movl	$fmttime.output, %eax
	addl	$28, %esp
	ret
.LBB285_3:                              # %if.then3.i
	calll	abort
.Ltmp285:
	.size	time_str, .Ltmp285-time_str

	.globl	datetime_str
	.align	16, 0x90
	.type	datetime_str,@function
datetime_str:                           # @datetime_str
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %eax
	movl	%eax, 24(%esp)
	leal	24(%esp), %eax
	movl	%eax, (%esp)
	calll	localtime
	testl	%eax, %eax
	je	.LBB286_3
# BB#1:                                 # %if.end.i
	movl	%eax, 12(%esp)
	movl	$.L.str11165, 8(%esp)
	movl	$32, 4(%esp)
	movl	$fmttime.output, (%esp)
	calll	strftime
	testl	%eax, %eax
	je	.LBB286_3
# BB#2:                                 # %fmttime.exit
	movl	$fmttime.output, %eax
	addl	$28, %esp
	ret
.LBB286_3:                              # %if.then3.i
	calll	abort
.Ltmp286:
	.size	datetime_str, .Ltmp286-datetime_str

	.globl	fork_to_background
	.align	16, 0x90
	.type	fork_to_background,@function
fork_to_background:                     # @fork_to_background
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%esi
	subl	$20, %esp
	xorb	%bl, %bl
	cmpl	$0, opt+48
	jne	.LBB287_3
# BB#1:                                 # %if.then
	movl	$opt+48, 8(%esp)
	movl	$0, 4(%esp)
	movl	$.L.str21166, (%esp)
	calll	unique_create
	xorb	%bl, %bl
	testl	%eax, %eax
	je	.LBB287_3
# BB#2:                                 # %if.then2
	movl	%eax, (%esp)
	calll	fclose
	movb	$1, %bl
.LBB287_3:                              # %if.end4
	calll	fork
	movl	%eax, %esi
	testl	%esi, %esi
	js	.LBB287_9
# BB#4:                                 # %if.else
	testl	%esi, %esi
	jne	.LBB287_5
# BB#8:                                 # %if.end17
	calll	setsid
	movl	stdin, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str71171, 4(%esp)
	movl	$.L.str61170, (%esp)
	calll	freopen64
	movl	stdout, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str81172, 4(%esp)
	movl	$.L.str61170, (%esp)
	calll	freopen64
	movl	stderr, %eax
	movl	%eax, 8(%esp)
	movl	$.L.str81172, 4(%esp)
	movl	$.L.str61170, (%esp)
	calll	freopen64
	addl	$20, %esp
	popl	%esi
	popl	%ebx
	ret
.LBB287_9:                              # %if.then6
	movl	$.L.str31167, (%esp)
	calll	perror
	movl	$1, (%esp)
	calll	exit
.LBB287_5:                              # %if.then8
	movl	$5, 8(%esp)
	movl	$.L.str41168, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
	cmpb	$1, %bl
	jne	.LBB287_7
# BB#6:                                 # %if.then12
	movl	$5, 8(%esp)
	movl	$.L.str51169, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	opt+48, %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	printf
.LBB287_7:                              # %if.end15
	movl	$0, (%esp)
	calll	exit
.Ltmp287:
	.size	fork_to_background, .Ltmp287-fork_to_background

	.globl	unique_create
	.align	16, 0x90
	.type	unique_create,@function
unique_create:                          # @unique_create
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$220, %esp
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	240(%esp), %esi
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	movb	244(%esp), %bl
	testl	%eax, %eax
	js	.LBB288_1
# BB#2:                                 # %if.end.i
	movl	%esi, %ecx
	calll	unique_name_1
	jmp	.LBB288_3
.LBB288_1:                              # %if.then.i
	movl	%esi, (%esp)
	calll	checking_strdup
.LBB288_3:                              # %if.end.i
	movl	%eax, %edi
	movl	$.L.str131177, %eax
	testb	%bl, %bl
	movl	$.L.str81172, %ebp
	cmovnel	%eax, %ebp
	jmp	.LBB288_4
	.align	16, 0x90
.LBB288_8:                              # %if.then.i17
                                        #   in Loop: Header=BB288_4 Depth=1
	movl	%esi, (%esp)
	calll	checking_strdup
	movl	%eax, %edi
	.align	16, 0x90
.LBB288_4:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, (%esp)
	movl	$438, 8(%esp)           # imm = 0x1B6
	movl	$193, 4(%esp)
	calll	open64
	testl	%eax, %eax
	js	.LBB288_6
# BB#5:                                 # %fopen_excl.exit
                                        #   in Loop: Header=BB288_4 Depth=1
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	calll	fdopen
	movl	%eax, %ebx
	testl	%ebx, %ebx
	jne	.LBB288_10
.LBB288_6:                              # %land.rhs
                                        #   in Loop: Header=BB288_4 Depth=1
	calll	__errno_location
	xorl	%ebx, %ebx
	cmpl	$17, (%eax)
	jne	.LBB288_12
# BB#7:                                 # %while.body
                                        #   in Loop: Header=BB288_4 Depth=1
	movl	%edi, (%esp)
	calll	checking_free
	leal	120(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	js	.LBB288_8
# BB#9:                                 # %if.end.i20
                                        #   in Loop: Header=BB288_4 Depth=1
	movl	%esi, %ecx
	calll	unique_name_1
	movl	%eax, %edi
	jmp	.LBB288_4
.LBB288_10:                             # %while.end
	movl	248(%esp), %eax
	testl	%eax, %eax
	je	.LBB288_12
# BB#11:                                # %if.then8
	movl	%edi, (%eax)
	jmp	.LBB288_13
.LBB288_12:                             # %if.else9
	movl	%edi, (%esp)
	calll	checking_free
.LBB288_13:                             # %if.end10
	movl	%ebx, %eax
	addl	$220, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp288:
	.size	unique_create, .Ltmp288-unique_create

	.globl	touch
	.align	16, 0x90
	.type	touch,@function
touch:                                  # @touch
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	36(%esp), %eax
	movl	%eax, 20(%esp)
	movl	$0, (%esp)
	calll	time
	movl	%eax, 16(%esp)
	leal	16(%esp), %eax
	movl	%eax, 4(%esp)
	movl	32(%esp), %esi
	movl	%esi, (%esp)
	calll	utime
	cmpl	$-1, %eax
	jne	.LBB289_2
# BB#1:                                 # %if.then
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%esi, 8(%esp)
	movl	$.L.str91173, 4(%esp)
	movl	$1, (%esp)
	calll	logprintf
.LBB289_2:                              # %if.end
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp289:
	.size	touch, .Ltmp289-touch

	.globl	remove_link
	.align	16, 0x90
	.type	remove_link,@function
remove_link:                            # @remove_link
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$112, %esp
	leal	16(%esp), %eax
	movl	%eax, 8(%esp)
	movl	128(%esp), %ebx
	movl	%ebx, 4(%esp)
	movl	$3, (%esp)
	calll	__lxstat64
	movl	%eax, %ecx
	xorl	%eax, %eax
	testl	%ecx, %ecx
	jne	.LBB290_6
# BB#1:                                 # %land.lhs.true
	movl	$61440, %ecx            # imm = 0xF000
	andl	32(%esp), %ecx
	xorl	%eax, %eax
	cmpl	$40960, %ecx            # imm = 0xA000
	jne	.LBB290_6
# BB#2:                                 # %do.body
	cmpb	$0, opt+250
	jne	.LBB290_3
	.align	16, 0x90
.LBB290_4:                              # %do.end
	movl	%ebx, (%esp)
	calll	unlink
	movl	%eax, %esi
	xorl	%eax, %eax
	testl	%esi, %esi
	je	.LBB290_6
# BB#5:                                 # %if.then7
	movl	$5, 8(%esp)
	movl	$.L.str111175, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	%eax, %edi
	calll	__errno_location
	movl	(%eax), %eax
	movl	%eax, (%esp)
	calll	strerror
	movl	%eax, 12(%esp)
	movl	%ebx, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$0, (%esp)
	calll	logprintf
	movl	%esi, %eax
.LBB290_6:                              # %if.end12
	addl	$112, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.LBB290_3:                              # %if.then3
	movl	%ebx, 4(%esp)
	movl	$.L.str101174, (%esp)
	calll	debug_logprintf
	jmp	.LBB290_4
.Ltmp290:
	.size	remove_link, .Ltmp290-remove_link

	.globl	file_exists_p
	.align	16, 0x90
	.type	file_exists_p,@function
file_exists_p:                          # @file_exists_p
# BB#0:                                 # %entry
	subl	$124, %esp
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	128(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	setns	%al
	movzbl	%al, %eax
	addl	$124, %esp
	ret
.Ltmp291:
	.size	file_exists_p, .Ltmp291-file_exists_p

	.globl	file_non_directory_p
	.align	16, 0x90
	.type	file_non_directory_p,@function
file_non_directory_p:                   # @file_non_directory_p
# BB#0:                                 # %entry
	subl	$124, %esp
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	128(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	__lxstat64
	xorb	%cl, %cl
	testl	%eax, %eax
	jne	.LBB292_2
# BB#1:                                 # %if.end
	movl	$61440, %eax            # imm = 0xF000
	andl	40(%esp), %eax
	cmpl	$16384, %eax            # imm = 0x4000
	setne	%cl
.LBB292_2:                              # %return
	movzbl	%cl, %eax
	addl	$124, %esp
	ret
.Ltmp292:
	.size	file_non_directory_p, .Ltmp292-file_non_directory_p

	.globl	file_size
	.align	16, 0x90
	.type	file_size,@function
file_size:                              # @file_size
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	movl	$.L.str121176, 4(%esp)
	calll	fopen64
	movl	%eax, %esi
	testl	%esi, %esi
	je	.LBB293_2
# BB#1:                                 # %if.end
	movl	%esi, (%esp)
	movl	$2, 12(%esp)
	movl	$0, 8(%esp)
	movl	$0, 4(%esp)
	calll	fseeko64
	movl	%esi, (%esp)
	calll	ftello64
	movl	%eax, %edi
	movl	%edx, %ebx
	movl	%esi, (%esp)
	calll	fclose
	movl	%edi, %eax
	movl	%ebx, %edx
	jmp	.LBB293_3
.LBB293_2:                              # %return
	movl	$-1, %eax
	movl	$-1, %edx
.LBB293_3:                              # %return
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp293:
	.size	file_size, .Ltmp293-file_size

	.globl	unique_name
	.align	16, 0x90
	.type	unique_name,@function
unique_name:                            # @unique_name
# BB#0:                                 # %entry
	pushl	%esi
	subl	$120, %esp
	leal	24(%esp), %eax
	movl	%eax, 8(%esp)
	movl	128(%esp), %esi
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	testl	%eax, %eax
	js	.LBB294_1
# BB#3:                                 # %if.end
	movl	%esi, %ecx
	calll	unique_name_1
	jmp	.LBB294_4
.LBB294_1:                              # %if.then
	movb	132(%esp), %al
	testb	%al, %al
	jne	.LBB294_5
# BB#2:                                 # %cond.false
	movl	%esi, (%esp)
	calll	checking_strdup
.LBB294_4:                              # %if.end
	movl	%eax, %esi
.LBB294_5:                              # %return
	movl	%esi, %eax
	addl	$120, %esp
	popl	%esi
	ret
.Ltmp294:
	.size	unique_name, .Ltmp294-unique_name

	.align	16, 0x90
	.type	unique_name_1,@function
unique_name_1:                          # @unique_name_1
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$108, %esp
	movl	%ecx, %esi
	subl	$16, %esp
	movl	%esi, (%esp)
	calll	strlen
	addl	$16, %esp
	movl	%eax, %edi
	leal	40(%edi), %eax
	andl	$-16, %eax
	movl	%esp, %ebx
	subl	%eax, %ebx
	movl	%ebx, %esp
	subl	$16, %esp
	movl	%edi, 8(%esp)
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	calll	memcpy
	addl	$16, %esp
	movb	$46, (%edi,%ebx)
	leal	1(%ebx,%edi), %esi
	movl	$1, %edi
	.align	16, 0x90
.LBB295_1:                              # %do.body
                                        # =>This Inner Loop Header: Depth=1
	subl	$16, %esp
	movl	%edi, %eax
	sarl	$31, %eax
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	number_to_string
	addl	$16, %esp
	subl	$16, %esp
	leal	-112(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, 4(%esp)
	movl	$3, (%esp)
	incl	%edi
	calll	__xstat64
	addl	$16, %esp
	testl	%eax, %eax
	jns	.LBB295_1
# BB#2:                                 # %do.end
	subl	$16, %esp
	movl	%ebx, (%esp)
	calll	checking_strdup
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp295:
	.size	unique_name_1, .Ltmp295-unique_name_1

	.globl	fopen_excl
	.align	16, 0x90
	.type	fopen_excl,@function
fopen_excl:                             # @fopen_excl
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	movl	$438, 8(%esp)           # imm = 0x1B6
	movl	$193, 4(%esp)
	calll	open64
	testl	%eax, %eax
	js	.LBB296_2
# BB#1:                                 # %if.end
	movb	20(%esp), %cl
	movl	%eax, (%esp)
	movl	$.L.str131177, %eax
	testb	%cl, %cl
	movl	$.L.str81172, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 4(%esp)
	calll	fdopen
	addl	$12, %esp
	ret
.LBB296_2:                              # %return
	xorl	%eax, %eax
	addl	$12, %esp
	ret
.Ltmp296:
	.size	fopen_excl, .Ltmp296-fopen_excl

	.globl	make_directory
	.align	16, 0x90
	.type	make_directory,@function
make_directory:                         # @make_directory
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$108, %esp
	subl	$16, %esp
	movl	8(%ebp), %edi
	movl	%edi, (%esp)
	calll	strlen
	addl	$16, %esp
	addl	$16, %eax
	andl	$-16, %eax
	movl	%esp, %esi
	subl	%eax, %esi
	movl	%esi, %esp
	subl	$16, %esp
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	calll	strcpy
	addl	$16, %esp
	cmpb	$47, (%esi)
	sete	%al
	movzbl	%al, %edi
	addl	%esi, %edi
	jmp	.LBB297_1
	.align	16, 0x90
.LBB297_7:                              # %if.else19
                                        #   in Loop: Header=BB297_1 Depth=1
	movb	$47, (%edi)
	incl	%edi
	.align	16, 0x90
.LBB297_1:                              # %for.cond3
                                        # =>This Inner Loop Header: Depth=1
	movb	(%edi), %bl
	testb	%bl, %bl
	je	.LBB297_4
# BB#2:                                 # %for.cond3
                                        #   in Loop: Header=BB297_1 Depth=1
	cmpb	$47, %bl
	jne	.LBB297_3
.LBB297_4:                              # %for.end
                                        #   in Loop: Header=BB297_1 Depth=1
	movb	$0, (%edi)
	subl	$16, %esp
	leal	-112(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	%esi, 4(%esp)
	movl	$3, (%esp)
	calll	__xstat64
	addl	$16, %esp
	movl	%eax, %ecx
	xorl	%eax, %eax
	testl	%ecx, %ecx
	jns	.LBB297_6
# BB#5:                                 # %if.then14
                                        #   in Loop: Header=BB297_1 Depth=1
	subl	$16, %esp
	movl	%esi, (%esp)
	movl	$511, 4(%esp)           # imm = 0x1FF
	calll	mkdir
	addl	$16, %esp
.LBB297_6:                              # %if.end16
                                        #   in Loop: Header=BB297_1 Depth=1
	testb	%bl, %bl
	je	.LBB297_8
	jmp	.LBB297_7
.LBB297_3:                              # %for.cond3.backedge
                                        #   in Loop: Header=BB297_1 Depth=1
	incl	%edi
	jmp	.LBB297_1
.LBB297_8:                              # %for.end24
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp297:
	.size	make_directory, .Ltmp297-make_directory

	.globl	file_merge
	.align	16, 0x90
	.type	file_merge,@function
file_merge:                             # @file_merge
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	32(%esp), %ebp
	movl	%ebp, (%esp)
	movl	$47, 4(%esp)
	calll	strrchr
	movl	%eax, %esi
	movl	36(%esp), %ebx
	testl	%esi, %esi
	je	.LBB298_1
# BB#2:                                 # %if.end
	movl	%ebx, (%esp)
	subl	%ebp, %esi
	calll	strlen
	leal	2(%esi,%eax), %eax
	movl	%eax, (%esp)
	calll	checking_malloc
	movl	%eax, %edi
	movl	%esi, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	calll	memcpy
	movb	$47, (%edi,%esi)
	movl	%ebx, 4(%esp)
	leal	1(%edi,%esi), %eax
	movl	%eax, (%esp)
	calll	strcpy
	movl	%edi, %eax
	jmp	.LBB298_3
.LBB298_1:                              # %if.then
	movl	%ebx, (%esp)
	calll	checking_strdup
.LBB298_3:                              # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp298:
	.size	file_merge, .Ltmp298-file_merge

	.globl	fnmatch_nocase
	.align	16, 0x90
	.type	fnmatch_nocase,@function
fnmatch_nocase:                         # @fnmatch_nocase
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	24(%esp), %eax
	orl	$16, %eax
	movl	%eax, 8(%esp)
	movl	20(%esp), %eax
	movl	%eax, 4(%esp)
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	fnmatch
	addl	$12, %esp
	ret
.Ltmp299:
	.size	fnmatch_nocase, .Ltmp299-fnmatch_nocase

	.globl	acceptable
	.align	16, 0x90
	.type	acceptable,@function
acceptable:                             # @acceptable
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	16(%esp), %esi
	movl	%esi, (%esp)
	calll	strlen
	.align	16, 0x90
.LBB300_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	testl	%ecx, %ecx
	je	.LBB300_3
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB300_1 Depth=1
	leal	-1(%ecx), %eax
	cmpb	$47, (%esi,%ecx)
	jne	.LBB300_1
	jmp	.LBB300_4
.LBB300_3:                              # %while.end
	cmpb	$47, (%esi)
	jne	.LBB300_5
.LBB300_4:                              # %if.then
	leal	1(%esi,%ecx), %esi
.LBB300_5:                              # %if.end
	movl	opt+64, %edi
	movl	opt+60, %ecx
	testl	%ecx, %ecx
	je	.LBB300_9
# BB#6:                                 # %if.then7
	movl	%esi, %edx
	calll	in_acclist
	movb	%al, %cl
	testl	%edi, %edi
	sete	%al
	andb	%cl, %al
	testl	%edi, %edi
	je	.LBB300_12
# BB#7:                                 # %if.then7
	xorb	$1, %cl
	testb	%cl, %cl
	jne	.LBB300_12
# BB#8:                                 # %land.rhs12
	movl	opt+64, %ecx
	jmp	.LBB300_11
.LBB300_9:                              # %if.else16
	movb	$1, %al
	testl	%edi, %edi
	je	.LBB300_12
# BB#10:                                # %if.then18
	movl	%edi, %ecx
.LBB300_11:                             # %if.then18
	movl	%esi, %edx
	calll	in_acclist
	xorb	$1, %al
.LBB300_12:                             # %return
	movzbl	%al, %eax
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp300:
	.size	acceptable, .Ltmp300-acceptable

	.align	16, 0x90
	.type	in_acclist,@function
in_acclist:                             # @in_acclist
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	%edx, %esi
	movl	$1342177281, %ebp       # imm = 0x50000001
	jmp	.LBB301_1
	.align	16, 0x90
.LBB301_22:                             # %for.inc
                                        #   in Loop: Header=BB301_1 Depth=1
	movl	24(%esp), %ecx          # 4-byte Reload
	addl	$4, %ecx
.LBB301_1:                              # %for.cond
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB301_2 Depth 2
                                        #     Child Loop BB301_18 Depth 2
                                        #     Child Loop BB301_5 Depth 2
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	(%ecx), %edi
	xorb	%cl, %cl
	testl	%edi, %edi
	movl	%edi, %eax
	je	.LBB301_17
	jmp	.LBB301_2
	.align	16, 0x90
.LBB301_14:                             # %for.inc.i
                                        #   in Loop: Header=BB301_2 Depth=2
	incl	%eax
.LBB301_2:                              # %for.cond.i
                                        #   Parent Loop BB301_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%eax), %cl
	cmpb	$41, %cl
	jg	.LBB301_8
# BB#3:                                 # %for.cond.i
                                        #   in Loop: Header=BB301_2 Depth=2
	testb	%cl, %cl
	jne	.LBB301_14
	jmp	.LBB301_4
.LBB301_8:                              # %for.cond.i
                                        #   in Loop: Header=BB301_2 Depth=2
	cmpb	$62, %cl
	jg	.LBB301_12
# BB#9:                                 # %for.cond.i
                                        #   in Loop: Header=BB301_2 Depth=2
	cmpb	$42, %cl
	jne	.LBB301_14
	jmp	.LBB301_10
.LBB301_12:                             # %for.cond.i
                                        #   in Loop: Header=BB301_2 Depth=2
	addb	$-63, %cl
	cmpb	$30, %cl
	ja	.LBB301_14
# BB#13:                                # %for.cond.i
                                        #   in Loop: Header=BB301_2 Depth=2
	movzbl	%cl, %ecx
	btl	%ecx, %ebp
	jae	.LBB301_14
.LBB301_10:                             # %if.then
                                        #   in Loop: Header=BB301_1 Depth=1
	cmpb	$0, opt+76
	jne	.LBB301_11
# BB#15:                                # %cond.false
                                        #   in Loop: Header=BB301_1 Depth=1
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 8(%esp)
	jmp	.LBB301_16
.LBB301_4:                              # %if.then6
                                        #   in Loop: Header=BB301_1 Depth=1
	movb	opt+76, %al
	movb	%al, 23(%esp)           # 1-byte Spill
	movl	%esi, (%esp)
	calll	strlen
	movl	%eax, %ebx
	movl	%edi, (%esp)
	calll	strlen
	cmpb	$0, 23(%esp)            # 1-byte Folded Reload
	jne	.LBB301_18
	jmp	.LBB301_5
	.align	16, 0x90
.LBB301_7:                              # %for.inc.i2
                                        #   in Loop: Header=BB301_5 Depth=2
	decl	%eax
	decl	%ebx
.LBB301_5:                              # %for.cond.i1
                                        #   Parent Loop BB301_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%eax, %ecx
	orl	%ebx, %ecx
	js	.LBB301_21
# BB#6:                                 # %for.body.i
                                        #   in Loop: Header=BB301_5 Depth=2
	movb	(%esi,%ebx), %cl
	cmpb	(%edi,%eax), %cl
	jne	.LBB301_21
	jmp	.LBB301_7
	.align	16, 0x90
.LBB301_20:                             # %for.inc32.i
                                        #   in Loop: Header=BB301_18 Depth=2
	decl	%eax
	decl	%ebx
.LBB301_18:                             # %for.cond11.i
                                        #   Parent Loop BB301_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%eax, %ecx
	orl	%ebx, %ecx
	js	.LBB301_21
# BB#19:                                # %for.body18.i
                                        #   in Loop: Header=BB301_18 Depth=2
	movzbl	(%edi,%eax), %ecx
	movzbl	(%esi,%ebx), %edx
	movb	_sch_tolower(%edx), %dl
	cmpb	_sch_tolower(%ecx), %dl
	je	.LBB301_20
.LBB301_21:                             # %match_tail.exit
                                        #   in Loop: Header=BB301_1 Depth=1
	movb	$1, %cl
	cmpl	$-1, %eax
	je	.LBB301_17
	jmp	.LBB301_22
.LBB301_11:                             # %cond.true
                                        #   in Loop: Header=BB301_1 Depth=1
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$16, 8(%esp)
.LBB301_16:                             # %cond.false
                                        #   in Loop: Header=BB301_1 Depth=1
	calll	fnmatch
	movb	$1, %cl
	testl	%eax, %eax
	jne	.LBB301_22
.LBB301_17:                             # %return
	movzbl	%cl, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp301:
	.size	in_acclist, .Ltmp301-in_acclist

	.globl	subdir_p
	.align	16, 0x90
	.type	subdir_p,@function
subdir_p:                               # @subdir_p
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%esi
	movl	12(%esp), %ecx
	movb	(%ecx), %dl
	movb	$1, %dh
	testb	%dl, %dl
	je	.LBB302_14
# BB#1:                                 # %if.end
	movl	16(%esp), %eax
	cmpb	$0, opt+76
	je	.LBB302_2
# BB#7:                                 # %for.cond12.preheader
	incl	%ecx
	jmp	.LBB302_8
	.align	16, 0x90
.LBB302_11:                             # %for.inc29
                                        #   in Loop: Header=BB302_8 Depth=1
	movb	(%ecx), %dl
	incl	%ecx
	incl	%eax
.LBB302_8:                              # %for.cond12
                                        # =>This Inner Loop Header: Depth=1
	testb	%dl, %dl
	je	.LBB302_13
# BB#9:                                 # %land.lhs.true15
                                        #   in Loop: Header=BB302_8 Depth=1
	movzbl	(%eax), %esi
	xorb	%dh, %dh
	testl	%esi, %esi
	je	.LBB302_14
# BB#10:                                # %land.rhs18
                                        #   in Loop: Header=BB302_8 Depth=1
	movzbl	%dl, %ebx
	movb	_sch_tolower(%ebx), %dl
	cmpb	_sch_tolower(%esi), %dl
	je	.LBB302_11
# BB#12:                                # %if.end33
	xorb	%dh, %dh
	testb	%bl, %bl
	jne	.LBB302_14
	jmp	.LBB302_13
.LBB302_2:                              # %for.cond.preheader
	incl	%ecx
	jmp	.LBB302_3
	.align	16, 0x90
.LBB302_6:                              # %for.inc
                                        #   in Loop: Header=BB302_3 Depth=1
	movb	(%ecx), %dl
	incl	%ecx
	incl	%eax
.LBB302_3:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	testb	%dl, %dl
	je	.LBB302_13
# BB#4:                                 # %land.lhs.true
                                        #   in Loop: Header=BB302_3 Depth=1
	movb	(%eax), %bl
	xorb	%dh, %dh
	testb	%bl, %bl
	je	.LBB302_14
# BB#5:                                 # %land.lhs.true
                                        #   in Loop: Header=BB302_3 Depth=1
	cmpb	%bl, %dl
	je	.LBB302_6
.LBB302_14:                             # %return
	movzbl	%dh, %eax
	jmp	.LBB302_15
.LBB302_13:                             # %land.rhs37
	movb	(%eax), %cl
	cmpb	$47, %cl
	sete	%al
	testb	%cl, %cl
	sete	%cl
	orb	%al, %cl
	movzbl	%cl, %eax
.LBB302_15:                             # %return
	popl	%esi
	popl	%ebx
	ret
.Ltmp302:
	.size	subdir_p, .Ltmp302-subdir_p

	.globl	accdir
	.align	16, 0x90
	.type	accdir,@function
accdir:                                 # @accdir
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$28, %esp
	movl	48(%esp), %eax
	leal	1(%eax), %ecx
	cmpb	$47, (%eax)
	cmovnel	%eax, %ecx
	movl	%ecx, 24(%esp)          # 4-byte Spill
	movl	opt+72, %edi
	testl	%edi, %edi
	je	.LBB303_18
# BB#1:                                 # %if.then2
	movl	$fnmatch_nocase, %eax
	cmpb	$0, opt+76
	movl	$fnmatch, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 20(%esp)          # 4-byte Spill
	movl	$1342177281, %ebp       # imm = 0x50000001
	jmp	.LBB303_2
	.align	16, 0x90
.LBB303_41:                             # %for.inc.i
                                        #   in Loop: Header=BB303_2 Depth=1
	addl	$4, %edi
.LBB303_2:                              # %for.cond.i
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB303_35 Depth 2
                                        #     Child Loop BB303_4 Depth 2
                                        #     Child Loop BB303_9 Depth 2
	movl	(%edi), %eax
	xorb	%cl, %cl
	testl	%eax, %eax
	je	.LBB303_48
# BB#3:                                 # %for.body.i
                                        #   in Loop: Header=BB303_2 Depth=1
	movb	(%eax), %dl
	cmpb	$47, %dl
	sete	%cl
	movzbl	%cl, %ebx
	addl	%eax, %ebx
	movl	%ebx, %ecx
	jmp	.LBB303_4
	.align	16, 0x90
.LBB303_33:                             # %for.inc.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	incl	%ecx
.LBB303_4:                              # %for.cond.i.i
                                        #   Parent Loop BB303_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%ecx), %dh
	cmpb	$41, %dh
	jg	.LBB303_13
# BB#5:                                 # %for.cond.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	testb	%dh, %dh
	jne	.LBB303_33
	jmp	.LBB303_6
.LBB303_13:                             # %for.cond.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	cmpb	$62, %dh
	jg	.LBB303_31
# BB#14:                                # %for.cond.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	cmpb	$42, %dh
	jne	.LBB303_33
	jmp	.LBB303_15
.LBB303_31:                             # %for.cond.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	addb	$-63, %dh
	cmpb	$30, %dh
	ja	.LBB303_33
# BB#32:                                # %for.cond.i.i
                                        #   in Loop: Header=BB303_4 Depth=2
	movzbl	%dh, %esi
	btl	%esi, %ebp
	jae	.LBB303_33
.LBB303_15:                             # %if.then.i
                                        #   in Loop: Header=BB303_2 Depth=1
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	$1, 8(%esp)
	calll	*20(%esp)               # 4-byte Folded Reload
	testl	%eax, %eax
	jne	.LBB303_41
	jmp	.LBB303_16
.LBB303_6:                              # %if.else.i
                                        #   in Loop: Header=BB303_2 Depth=1
	movb	(%ebx), %cl
	testb	%cl, %cl
	je	.LBB303_17
# BB#7:                                 # %if.end.i
                                        #   in Loop: Header=BB303_2 Depth=1
	cmpb	$0, opt+76
	jne	.LBB303_34
# BB#8:                                 # %for.cond.i38.preheader
                                        #   in Loop: Header=BB303_2 Depth=1
	cmpb	$47, %dl
	sete	%dl
	movzbl	%dl, %edx
	leal	1(%eax,%edx), %ebx
	movl	24(%esp), %edx          # 4-byte Reload
	jmp	.LBB303_9
	.align	16, 0x90
.LBB303_12:                             # %for.inc.i40
                                        #   in Loop: Header=BB303_9 Depth=2
	movb	(%ebx), %cl
	incl	%ebx
	incl	%edx
.LBB303_9:                              # %for.cond.i38
                                        #   Parent Loop BB303_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	je	.LBB303_39
# BB#10:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB303_9 Depth=2
	movb	(%edx), %ch
	testb	%ch, %ch
	je	.LBB303_41
# BB#11:                                # %land.lhs.true.i
                                        #   in Loop: Header=BB303_9 Depth=2
	cmpb	%ch, %cl
	jne	.LBB303_41
	jmp	.LBB303_12
.LBB303_34:                             # %for.cond12.i.preheader
                                        #   in Loop: Header=BB303_2 Depth=1
	cmpb	$47, %dl
	sete	%dl
	movzbl	%dl, %edx
	leal	1(%eax,%edx), %ebx
	movl	24(%esp), %edx          # 4-byte Reload
	jmp	.LBB303_35
	.align	16, 0x90
.LBB303_38:                             # %for.inc29.i
                                        #   in Loop: Header=BB303_35 Depth=2
	movb	(%ebx), %cl
	incl	%ebx
	incl	%edx
.LBB303_35:                             # %for.cond12.i
                                        #   Parent Loop BB303_2 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	je	.LBB303_39
# BB#36:                                # %land.lhs.true15.i
                                        #   in Loop: Header=BB303_35 Depth=2
	movzbl	(%edx), %esi
	testl	%esi, %esi
	je	.LBB303_41
# BB#37:                                # %land.rhs18.i
                                        #   in Loop: Header=BB303_35 Depth=2
	movzbl	%cl, %ecx
	movb	_sch_tolower(%ecx), %cl
	cmpb	_sch_tolower(%esi), %cl
	jne	.LBB303_41
	jmp	.LBB303_38
.LBB303_39:                             # %subdir_p.exit
                                        #   in Loop: Header=BB303_2 Depth=1
	movb	(%edx), %cl
	testb	%cl, %cl
	je	.LBB303_17
# BB#40:                                # %subdir_p.exit
                                        #   in Loop: Header=BB303_2 Depth=1
	cmpb	$47, %cl
	je	.LBB303_17
	jmp	.LBB303_41
.LBB303_16:                             # %if.then.for.end_crit_edge.i
	movl	(%edi), %eax
.LBB303_17:                             # %dir_matches_p.exit
	xorb	%cl, %cl
	testl	%eax, %eax
	je	.LBB303_48
.LBB303_18:                             # %if.end5
	movl	opt+68, %edi
	testl	%edi, %edi
	je	.LBB303_47
# BB#19:                                # %if.then7
	movl	$fnmatch_nocase, %eax
	cmpb	$0, opt+76
	movl	$fnmatch, %ecx
	cmovnel	%eax, %ecx
	movl	%ecx, 20(%esp)          # 4-byte Spill
	movl	$1342177281, %ebp       # imm = 0x50000001
	jmp	.LBB303_20
	.align	16, 0x90
.LBB303_59:                             # %for.inc.i33
                                        #   in Loop: Header=BB303_20 Depth=1
	addl	$4, %edi
.LBB303_20:                             # %for.cond.i16
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB303_53 Depth 2
                                        #     Child Loop BB303_22 Depth 2
                                        #     Child Loop BB303_27 Depth 2
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB303_47
# BB#21:                                # %for.body.i20
                                        #   in Loop: Header=BB303_20 Depth=1
	movb	(%eax), %dl
	cmpb	$47, %dl
	sete	%cl
	movzbl	%cl, %ebx
	addl	%eax, %ebx
	movl	%ebx, %ecx
	jmp	.LBB303_22
	.align	16, 0x90
.LBB303_51:                             # %for.inc.i.i24
                                        #   in Loop: Header=BB303_22 Depth=2
	incl	%ecx
.LBB303_22:                             # %for.cond.i.i22
                                        #   Parent Loop BB303_20 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movb	(%ecx), %dh
	cmpb	$41, %dh
	jg	.LBB303_42
# BB#23:                                # %for.cond.i.i22
                                        #   in Loop: Header=BB303_22 Depth=2
	testb	%dh, %dh
	jne	.LBB303_51
	jmp	.LBB303_24
.LBB303_42:                             # %for.cond.i.i22
                                        #   in Loop: Header=BB303_22 Depth=2
	cmpb	$62, %dh
	jg	.LBB303_49
# BB#43:                                # %for.cond.i.i22
                                        #   in Loop: Header=BB303_22 Depth=2
	cmpb	$42, %dh
	jne	.LBB303_51
	jmp	.LBB303_44
.LBB303_49:                             # %for.cond.i.i22
                                        #   in Loop: Header=BB303_22 Depth=2
	addb	$-63, %dh
	cmpb	$30, %dh
	ja	.LBB303_51
# BB#50:                                # %for.cond.i.i22
                                        #   in Loop: Header=BB303_22 Depth=2
	movzbl	%dh, %esi
	btl	%esi, %ebp
	jae	.LBB303_51
.LBB303_44:                             # %if.then.i27
                                        #   in Loop: Header=BB303_20 Depth=1
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	%ebx, (%esp)
	movl	$1, 8(%esp)
	calll	*20(%esp)               # 4-byte Folded Reload
	testl	%eax, %eax
	jne	.LBB303_59
	jmp	.LBB303_45
.LBB303_24:                             # %if.else.i31
                                        #   in Loop: Header=BB303_20 Depth=1
	movb	(%ebx), %cl
	testb	%cl, %cl
	je	.LBB303_46
# BB#25:                                # %if.end.i45
                                        #   in Loop: Header=BB303_20 Depth=1
	cmpb	$0, opt+76
	jne	.LBB303_52
# BB#26:                                # %for.cond.i49.preheader
                                        #   in Loop: Header=BB303_20 Depth=1
	cmpb	$47, %dl
	sete	%dl
	movzbl	%dl, %edx
	leal	1(%eax,%edx), %ebx
	movl	24(%esp), %edx          # 4-byte Reload
	jmp	.LBB303_27
	.align	16, 0x90
.LBB303_30:                             # %for.inc.i57
                                        #   in Loop: Header=BB303_27 Depth=2
	movb	(%ebx), %cl
	incl	%ebx
	incl	%edx
.LBB303_27:                             # %for.cond.i49
                                        #   Parent Loop BB303_20 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	je	.LBB303_57
# BB#28:                                # %land.lhs.true.i53
                                        #   in Loop: Header=BB303_27 Depth=2
	movb	(%edx), %ch
	testb	%ch, %ch
	je	.LBB303_59
# BB#29:                                # %land.lhs.true.i53
                                        #   in Loop: Header=BB303_27 Depth=2
	cmpb	%ch, %cl
	jne	.LBB303_59
	jmp	.LBB303_30
.LBB303_52:                             # %for.cond12.i62.preheader
                                        #   in Loop: Header=BB303_20 Depth=1
	cmpb	$47, %dl
	sete	%dl
	movzbl	%dl, %edx
	leal	1(%eax,%edx), %ebx
	movl	24(%esp), %edx          # 4-byte Reload
	jmp	.LBB303_53
	.align	16, 0x90
.LBB303_56:                             # %for.inc29.i73
                                        #   in Loop: Header=BB303_53 Depth=2
	movb	(%ebx), %cl
	incl	%ebx
	incl	%edx
.LBB303_53:                             # %for.cond12.i62
                                        #   Parent Loop BB303_20 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	testb	%cl, %cl
	je	.LBB303_57
# BB#54:                                # %land.lhs.true15.i64
                                        #   in Loop: Header=BB303_53 Depth=2
	movzbl	(%edx), %esi
	testl	%esi, %esi
	je	.LBB303_59
# BB#55:                                # %land.rhs18.i69
                                        #   in Loop: Header=BB303_53 Depth=2
	movzbl	%cl, %ecx
	movb	_sch_tolower(%ecx), %cl
	cmpb	_sch_tolower(%esi), %cl
	jne	.LBB303_59
	jmp	.LBB303_56
.LBB303_57:                             # %subdir_p.exit83
                                        #   in Loop: Header=BB303_20 Depth=1
	movb	(%edx), %cl
	testb	%cl, %cl
	je	.LBB303_46
# BB#58:                                # %subdir_p.exit83
                                        #   in Loop: Header=BB303_20 Depth=1
	cmpb	$47, %cl
	je	.LBB303_46
	jmp	.LBB303_59
.LBB303_45:                             # %if.then.for.end_crit_edge.i29
	movl	(%edi), %eax
.LBB303_46:                             # %dir_matches_p.exit35
	xorb	%cl, %cl
	testl	%eax, %eax
	jne	.LBB303_48
.LBB303_47:                             # %if.end11
	movb	$1, %cl
.LBB303_48:                             # %return
	movzbl	%cl, %eax
	addl	$28, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp303:
	.size	accdir, .Ltmp303-accdir

	.globl	match_tail
	.align	16, 0x90
	.type	match_tail,@function
match_tail:                             # @match_tail
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %edi
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %esi
	movl	36(%esp), %ebx
	movl	%ebx, (%esp)
	calll	strlen
	movb	40(%esp), %cl
	testb	%cl, %cl
	jne	.LBB304_4
	jmp	.LBB304_1
	.align	16, 0x90
.LBB304_6:                              # %for.inc32
                                        #   in Loop: Header=BB304_4 Depth=1
	decl	%eax
	decl	%esi
.LBB304_4:                              # %for.cond11
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	orl	%esi, %ecx
	js	.LBB304_7
# BB#5:                                 # %for.body18
                                        #   in Loop: Header=BB304_4 Depth=1
	movzbl	(%ebx,%eax), %ecx
	movzbl	(%edi,%esi), %edx
	movb	_sch_tolower(%edx), %dl
	cmpb	_sch_tolower(%ecx), %dl
	jne	.LBB304_7
	jmp	.LBB304_6
	.align	16, 0x90
.LBB304_3:                              # %for.inc
                                        #   in Loop: Header=BB304_1 Depth=1
	decl	%eax
	decl	%esi
.LBB304_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	orl	%esi, %ecx
	js	.LBB304_7
# BB#2:                                 # %for.body
                                        #   in Loop: Header=BB304_1 Depth=1
	movb	(%edi,%esi), %cl
	cmpb	(%ebx,%eax), %cl
	je	.LBB304_3
.LBB304_7:                              # %if.end36
	cmpl	$-1, %eax
	sete	%al
	movzbl	%al, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp304:
	.size	match_tail, .Ltmp304-match_tail

	.globl	suffix
	.align	16, 0x90
	.type	suffix,@function
suffix:                                 # @suffix
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	%esi, (%esp)
	calll	strlen
	.align	16, 0x90
.LBB305_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, %ecx
	testl	%ecx, %ecx
	je	.LBB305_2
# BB#3:                                 # %land.lhs.true
                                        #   in Loop: Header=BB305_1 Depth=1
	movb	(%esi,%ecx), %dl
	movb	%dl, %dh
	addb	$-46, %dh
	leal	-1(%ecx), %eax
	cmpb	$1, %dh
	ja	.LBB305_1
	jmp	.LBB305_4
.LBB305_2:                              # %for.cond.for.end_crit_edge
	movb	(%esi), %dl
.LBB305_4:                              # %for.end
	xorl	%eax, %eax
	cmpb	$46, %dl
	jne	.LBB305_6
# BB#5:                                 # %if.then
	leal	1(%esi,%ecx), %eax
.LBB305_6:                              # %return
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp305:
	.size	suffix, .Ltmp305-suffix

	.globl	has_wildcards_p
	.align	16, 0x90
	.type	has_wildcards_p,@function
has_wildcards_p:                        # @has_wildcards_p
# BB#0:                                 # %entry
	pushl	%esi
	movl	8(%esp), %eax
	movl	$1342177281, %ecx       # imm = 0x50000001
	jmp	.LBB306_1
	.align	16, 0x90
.LBB306_9:                              # %for.inc
                                        #   in Loop: Header=BB306_1 Depth=1
	incl	%eax
.LBB306_1:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	movb	(%eax), %dh
	cmpb	$41, %dh
	jg	.LBB306_4
# BB#2:                                 # %for.cond
                                        #   in Loop: Header=BB306_1 Depth=1
	testb	%dh, %dh
	jne	.LBB306_9
	jmp	.LBB306_3
.LBB306_4:                              # %for.cond
                                        #   in Loop: Header=BB306_1 Depth=1
	movb	$1, %dl
	cmpb	$62, %dh
	jg	.LBB306_7
# BB#5:                                 # %for.cond
                                        #   in Loop: Header=BB306_1 Depth=1
	cmpb	$42, %dh
	jne	.LBB306_9
	jmp	.LBB306_6
.LBB306_7:                              # %for.cond
                                        #   in Loop: Header=BB306_1 Depth=1
	addb	$-63, %dh
	cmpb	$30, %dh
	ja	.LBB306_9
# BB#8:                                 # %for.cond
                                        #   in Loop: Header=BB306_1 Depth=1
	movzbl	%dh, %esi
	btl	%esi, %ecx
	jb	.LBB306_6
	jmp	.LBB306_9
.LBB306_3:                              # %return.loopexit1
	xorb	%dl, %dl
.LBB306_6:                              # %return
	movzbl	%dl, %eax
	popl	%esi
	ret
.Ltmp306:
	.size	has_wildcards_p, .Ltmp306-has_wildcards_p

	.globl	has_html_suffix_p
	.align	16, 0x90
	.type	has_html_suffix_p,@function
has_html_suffix_p:                      # @has_html_suffix_p
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	32(%esp), %edi
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %esi
	incl	%esi
	.align	16, 0x90
.LBB307_1:                              # %for.cond.i
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$1, %esi
	je	.LBB307_2
# BB#3:                                 # %land.lhs.true.i
                                        #   in Loop: Header=BB307_1 Depth=1
	movb	-1(%edi,%esi), %al
	movb	%al, %cl
	addb	$-46, %cl
	decl	%esi
	cmpb	$1, %cl
	ja	.LBB307_1
	jmp	.LBB307_4
.LBB307_2:                              # %for.cond.for.end_crit_edge.i
	movb	(%edi), %al
	xorl	%esi, %esi
.LBB307_4:                              # %for.end.i
	xorb	%cl, %cl
	cmpb	$46, %al
	jne	.LBB307_11
# BB#5:                                 # %suffix.exit
	leal	(%esi,%edi), %ebx
	xorb	%cl, %cl
	incl	%ebx
	je	.LBB307_11
# BB#6:                                 # %if.end
	movl	%ebx, (%esp)
	movl	$.L.str141178, 4(%esp)
	calll	strcasecmp
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB307_11
# BB#7:                                 # %if.end3
	movl	%ebx, (%esp)
	movl	$.L.str151179, 4(%esp)
	calll	strcasecmp
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB307_11
# BB#8:                                 # %if.end7
	cmpb	$0, (%ebx)
	je	.LBB307_10
# BB#9:                                 # %land.lhs.true
	leal	2(%esi,%edi), %eax
	movl	%eax, (%esp)
	movl	$.L.str141178, 4(%esp)
	calll	strcasecmp
	movb	$1, %cl
	testl	%eax, %eax
	je	.LBB307_11
.LBB307_10:                             # %if.end12
	xorb	%cl, %cl
.LBB307_11:                             # %return
	movzbl	%cl, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp307:
	.size	has_html_suffix_p, .Ltmp307-has_html_suffix_p

	.globl	read_whole_line
	.align	16, 0x90
	.type	read_whole_line,@function
read_whole_line:                        # @read_whole_line
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	$82, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	xorl	%ebp, %ebp
	movl	$82, %ebx
	jmp	.LBB308_1
	.align	16, 0x90
.LBB308_5:                              # %if.end8
                                        #   in Loop: Header=BB308_1 Depth=1
	addl	%ebx, %ebx
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	calll	checking_realloc
	movl	%eax, %esi
	movl	%edi, %ebp
	.align	16, 0x90
.LBB308_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	32(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%ebx, %eax
	subl	%ebp, %eax
	movl	%eax, 4(%esp)
	leal	(%esi,%ebp), %edi
	movl	%edi, (%esp)
	calll	fgets
	testl	%eax, %eax
	je	.LBB308_6
# BB#2:                                 # %while.body
                                        #   in Loop: Header=BB308_1 Depth=1
	movl	%edi, (%esp)
	calll	strlen
	movl	%eax, %edi
	xorl	%eax, %eax
	addl	%ebp, %edi
	movl	%eax, %ebp
	je	.LBB308_1
# BB#3:                                 # %if.end
                                        #   in Loop: Header=BB308_1 Depth=1
	cmpb	$10, -1(%edi,%esi)
	jne	.LBB308_5
# BB#4:
	movl	%edi, %ebp
	jmp	.LBB308_7
.LBB308_6:                              # %while.end
	testl	%ebp, %ebp
	je	.LBB308_8
.LBB308_7:                              # %lor.lhs.false
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	ferror
	testl	%eax, %eax
	je	.LBB308_10
.LBB308_8:                              # %if.then14
	movl	%esi, (%esp)
	calll	checking_free
	xorl	%esi, %esi
	.align	16, 0x90
.LBB308_9:                              # %return
	movl	%esi, %eax
	.align	16, 0x90
.LBB308_12:                             # %return
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.LBB308_10:                             # %if.end15
	incl	%ebp
	cmpl	%ebx, %ebp
	jge	.LBB308_9
# BB#11:                                # %if.then19
	movl	%ebp, 4(%esp)
	movl	%esi, (%esp)
	calll	checking_realloc
	jmp	.LBB308_12
.Ltmp308:
	.size	read_whole_line, .Ltmp308-read_whole_line

	.globl	read_file
	.align	16, 0x90
	.type	read_file,@function
read_file:                              # @read_file
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$140, %esp
	movl	160(%esp), %eax
	cmpb	$45, (%eax)
	jne	.LBB309_3
# BB#1:                                 # %land.lhs.true
	cmpb	$0, 1(%eax)
	je	.LBB309_2
.LBB309_3:                              # %if.else
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	calll	open64
	movl	%eax, %edi
	movb	$0, 39(%esp)            # 1-byte Folded Spill
	jmp	.LBB309_4
.LBB309_2:                              # %if.then
	movl	stdin, %eax
	movl	%eax, (%esp)
	calll	fileno
	movl	%eax, %edi
	movb	$1, 39(%esp)            # 1-byte Folded Spill
.LBB309_4:                              # %if.end
	xorl	%esi, %esi
	testl	%edi, %edi
	js	.LBB309_26
# BB#5:                                 # %if.end6
	movl	$12, (%esp)
	calll	checking_malloc
	movl	%eax, %esi
	leal	40(%esp), %eax
	movl	%eax, 8(%esp)
	movl	%edi, 4(%esp)
	movl	$3, (%esp)
	calll	__fxstat64
	testl	%eax, %eax
	js	.LBB309_6
# BB#9:                                 # %if.end12
	movl	84(%esp), %eax
	movl	%eax, 4(%esi)
	movl	%edi, 16(%esp)
	movl	%eax, 4(%esp)
	movl	$0, 24(%esp)
	movl	$0, 20(%esp)
	movl	$2, 12(%esp)
	movl	$3, 8(%esp)
	movl	$0, (%esp)
	calll	mmap64
	movl	%eax, (%esi)
	cmpl	$-1, %eax
	je	.LBB309_6
# BB#10:                                # %if.end20
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	jne	.LBB309_12
# BB#11:                                # %if.then22
	movl	%edi, (%esp)
	calll	close
.LBB309_12:                             # %if.end24
	movl	$1, 8(%esi)
	jmp	.LBB309_26
.LBB309_6:                              # %if.end6.mmap_lose_crit_edge
	leal	4(%esi), %ebx
	movl	%esi, %ebp
	movl	%esi, 32(%esp)          # 4-byte Spill
	movl	$0, (%ebx)
	movl	$512, (%esp)            # imm = 0x200
	calll	checking_malloc
	movl	%eax, (%ebp)
	movl	(%ebx), %ecx
	movl	$512, %esi              # imm = 0x200
	jmp	.LBB309_7
	.align	16, 0x90
.LBB309_15:                             # %if.then44
                                        #   in Loop: Header=BB309_7 Depth=1
	movl	(%ebx), %ecx
	addl	%eax, %ecx
	movl	%ecx, (%ebx)
.LBB309_7:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, %eax
	shrl	$31, %eax
	addl	%esi, %eax
	sarl	%eax
	cmpl	%eax, %ecx
	jle	.LBB309_8
# BB#13:                                # %if.then31
                                        #   in Loop: Header=BB309_7 Depth=1
	movl	(%ebp), %eax
	addl	%esi, %esi
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, (%ebp)
	movl	(%ebx), %ecx
	jmp	.LBB309_14
.LBB309_8:                              # %while.body.if.end35_crit_edge
                                        #   in Loop: Header=BB309_7 Depth=1
	movl	(%ebp), %eax
.LBB309_14:                             # %if.end35
                                        #   in Loop: Header=BB309_7 Depth=1
	movl	%esi, %edx
	subl	%ecx, %edx
	movl	%edx, 8(%esp)
	addl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	%edi, (%esp)
	calll	read
	testl	%eax, %eax
	jg	.LBB309_15
# BB#16:                                # %if.else48
	testl	%eax, %eax
	js	.LBB309_23
# BB#17:                                # %while.end
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	jne	.LBB309_19
# BB#18:                                # %if.then55
	movl	%edi, (%esp)
	calll	close
.LBB309_19:                             # %if.end57
	movl	(%ebx), %eax
	cmpl	%eax, %esi
	jle	.LBB309_22
# BB#20:                                # %if.end57
	testl	%eax, %eax
	je	.LBB309_22
# BB#21:                                # %if.then65
	movl	(%ebp), %ecx
	movl	%eax, 4(%esp)
	movl	%ecx, (%esp)
	calll	checking_realloc
	movl	%eax, (%ebp)
.LBB309_22:                             # %if.end70
	movl	32(%esp), %esi          # 4-byte Reload
	movl	$0, 8(%esi)
	jmp	.LBB309_26
.LBB309_23:                             # %lose
	cmpb	$0, 39(%esp)            # 1-byte Folded Reload
	movl	32(%esp), %esi          # 4-byte Reload
	jne	.LBB309_25
# BB#24:                                # %if.then73
	movl	%edi, (%esp)
	calll	close
.LBB309_25:                             # %if.end75
	movl	(%esi), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	%esi, (%esp)
	calll	checking_free
	xorl	%esi, %esi
.LBB309_26:                             # %return
	movl	%esi, %eax
	addl	$140, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp309:
	.size	read_file, .Ltmp309-read_file

	.globl	read_file_free
	.align	16, 0x90
	.type	read_file_free,@function
read_file_free:                         # @read_file_free
# BB#0:                                 # %entry
	subl	$12, %esp
	movl	16(%esp), %ecx
	movl	(%ecx), %eax
	cmpl	$0, 8(%ecx)
	je	.LBB310_2
# BB#1:                                 # %if.then
	movl	4(%ecx), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	munmap
	addl	$12, %esp
	jmp	checking_free           # TAILCALL
.LBB310_2:                              # %if.else
	movl	%eax, (%esp)
	calll	checking_free
	addl	$12, %esp
	jmp	checking_free           # TAILCALL
.Ltmp310:
	.size	read_file_free, .Ltmp310-read_file_free

	.globl	free_vec
	.align	16, 0x90
	.type	free_vec,@function
free_vec:                               # @free_vec
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	testl	%esi, %esi
	je	.LBB311_5
# BB#1:                                 # %while.cond.preheader
	movl	(%esi), %eax
	testl	%eax, %eax
	je	.LBB311_4
# BB#2:                                 # %while.body.preheader
	addl	$4, %esi
	.align	16, 0x90
.LBB311_3:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%eax, (%esp)
	calll	checking_free
	movl	(%esi), %eax
	addl	$4, %esi
	testl	%eax, %eax
	jne	.LBB311_3
.LBB311_4:                              # %while.end
	addl	$8, %esp
	popl	%esi
	jmp	checking_free           # TAILCALL
.LBB311_5:                              # %if.end
	addl	$8, %esp
	popl	%esi
	ret
.Ltmp311:
	.size	free_vec, .Ltmp311-free_vec

	.globl	merge_vecs
	.align	16, 0x90
	.type	merge_vecs,@function
merge_vecs:                             # @merge_vecs
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	36(%esp), %edi
	movl	32(%esp), %esi
	testl	%esi, %esi
	je	.LBB312_1
# BB#2:                                 # %if.end
	testl	%edi, %edi
	je	.LBB312_11
# BB#3:                                 # %if.end3
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.LBB312_10
# BB#4:
	xorl	%ebx, %ebx
	movl	$4, %ebp
	.align	16, 0x90
.LBB312_5:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$0, (%esi,%ebx)
	leal	4(%ebx), %ebx
	jne	.LBB312_5
# BB#6:
	movl	%ebx, %ecx
	jmp	.LBB312_7
	.align	16, 0x90
.LBB312_8:                              # %for.cond8.for.cond8_crit_edge
                                        #   in Loop: Header=BB312_7 Depth=1
	movl	(%edi,%ebp), %eax
	addl	$4, %ecx
	addl	$4, %ebp
.LBB312_7:                              # %for.cond8
                                        # =>This Inner Loop Header: Depth=1
	testl	%eax, %eax
	jne	.LBB312_8
# BB#9:                                 # %for.end14
	movl	%ecx, 4(%esp)
	movl	%esi, (%esp)
	calll	checking_realloc
	movl	%eax, %esi
	movl	%ebp, 8(%esp)
	movl	%edi, 4(%esp)
	leal	-4(%esi,%ebx), %eax
	movl	%eax, (%esp)
	calll	memcpy
.LBB312_10:                             # %for.end14
	movl	%edi, (%esp)
	calll	checking_free
	jmp	.LBB312_11
.LBB312_1:
	movl	%edi, %esi
.LBB312_11:                             # %return
	movl	%esi, %eax
	addl	$12, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp312:
	.size	merge_vecs, .Ltmp312-merge_vecs

	.globl	vec_append
	.align	16, 0x90
	.type	vec_append,@function
vec_append:                             # @vec_append
# BB#0:                                 # %entry
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$16, %esp
	movl	$1, %edi
	movl	32(%esp), %eax
	testl	%eax, %eax
	je	.LBB313_3
# BB#1:
	xorl	%edi, %edi
	.align	16, 0x90
.LBB313_2:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	cmpl	$0, (%eax,%edi,4)
	leal	1(%edi), %edi
	jne	.LBB313_2
.LBB313_3:                              # %if.end
	movl	36(%esp), %ebx
	leal	4(,%edi,4), %ecx
	movl	%ecx, 4(%esp)
	movl	%eax, (%esp)
	calll	checking_realloc
	movl	%eax, %esi
	movl	%ebx, (%esp)
	calll	checking_strdup
	movl	%eax, -4(%esi,%edi,4)
	movl	$0, (%esi,%edi,4)
	movl	%esi, %eax
	addl	$16, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	ret
.Ltmp313:
	.size	vec_append, .Ltmp313-vec_append

	.globl	string_set_add
	.align	16, 0x90
	.type	string_set_add,@function
string_set_add:                         # @string_set_add
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	36(%esp), %edi
	movl	%edi, 4(%esp)
	movl	32(%esp), %esi
	movl	%esi, (%esp)
	calll	hash_table_contains
	testl	%eax, %eax
	jne	.LBB314_2
# BB#1:                                 # %if.end
	movl	%edi, (%esp)
	calll	checking_strdup
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	movl	$.L.str161180, 8(%esp)
	calll	hash_table_put
.LBB314_2:                              # %return
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp314:
	.size	string_set_add, .Ltmp314-string_set_add

	.globl	string_set_contains
	.align	16, 0x90
	.type	string_set_contains,@function
string_set_contains:                    # @string_set_contains
# BB#0:                                 # %entry
	jmp	hash_table_contains     # TAILCALL
.Ltmp315:
	.size	string_set_contains, .Ltmp315-string_set_contains

	.globl	string_set_to_array
	.align	16, 0x90
	.type	string_set_to_array,@function
string_set_to_array:                    # @string_set_to_array
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$36, %esp
	leal	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	48(%esp), %eax
	movl	%eax, (%esp)
	calll	hash_table_iterate
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	je	.LBB316_3
# BB#1:                                 # %for.body.lr.ph
	movl	52(%esp), %edi
	.align	16, 0x90
.LBB316_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	16(%esp), %eax
	movl	%eax, (%edi)
	movl	%esi, (%esp)
	addl	$4, %edi
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB316_2
.LBB316_3:                              # %for.end
	addl	$36, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp316:
	.size	string_set_to_array, .Ltmp316-string_set_to_array

	.globl	string_set_free
	.align	16, 0x90
	.type	string_set_free,@function
string_set_free:                        # @string_set_free
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$36, %esp
	leal	16(%esp), %edi
	movl	%edi, 4(%esp)
	movl	48(%esp), %esi
	movl	%esi, (%esp)
	calll	hash_table_iterate
	jmp	.LBB317_2
	.align	16, 0x90
.LBB317_1:                              # %for.body
                                        #   in Loop: Header=BB317_2 Depth=1
	movl	16(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
.LBB317_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%edi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB317_1
# BB#3:                                 # %for.end
	movl	%esi, (%esp)
	calll	hash_table_destroy
	addl	$36, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp317:
	.size	string_set_free, .Ltmp317-string_set_free

	.globl	free_keys_and_values
	.align	16, 0x90
	.type	free_keys_and_values,@function
free_keys_and_values:                   # @free_keys_and_values
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	leal	8(%esp), %esi
	movl	%esi, 4(%esp)
	movl	32(%esp), %eax
	movl	%eax, (%esp)
	calll	hash_table_iterate
	jmp	.LBB318_2
	.align	16, 0x90
.LBB318_1:                              # %for.body
                                        #   in Loop: Header=BB318_2 Depth=1
	movl	8(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
	movl	12(%esp), %eax
	movl	%eax, (%esp)
	calll	checking_free
.LBB318_2:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, (%esp)
	calll	hash_table_iter_next
	testl	%eax, %eax
	jne	.LBB318_1
# BB#3:                                 # %for.end
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp318:
	.size	free_keys_and_values, .Ltmp318-free_keys_and_values

	.globl	with_thousand_seps
	.align	16, 0x90
	.type	with_thousand_seps,@function
with_thousand_seps:                     # @with_thousand_seps
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	84(%esp), %esi
	movl	80(%esp), %edi
	movb	get_grouping_data.initialized.b, %al
	cmpb	$1, %al
	jne	.LBB319_2
# BB#1:                                 # %entry.if.end7_crit_edge.i
	movl	get_grouping_data.cached_grouping, %ebx
	movl	get_grouping_data.cached_sep, %ecx
	jmp	.LBB319_5
.LBB319_2:                              # %if.then.i
	calll	localeconv
	movl	4(%eax), %ecx
	movl	%ecx, get_grouping_data.cached_sep
	movl	8(%eax), %ebx
	movl	%ebx, get_grouping_data.cached_grouping
	cmpb	$0, (%ecx)
	jne	.LBB319_4
# BB#3:                                 # %if.then3.i
	movl	(%eax), %ecx
	movl	$.L.str271190, %eax
	cmpb	$44, (%ecx)
	movl	$.L.str261189, %ecx
	cmovel	%eax, %ecx
	movl	%ecx, get_grouping_data.cached_sep
	movl	$.L.str281191, get_grouping_data.cached_grouping
	movl	$.L.str281191, %ebx
.LBB319_4:                              # %if.end6.i
	movb	$1, get_grouping_data.initialized.b
.LBB319_5:                              # %get_grouping_data.exit
	movl	%ecx, 36(%esp)          # 4-byte Spill
	movl	%esi, %eax
	sarl	$31, %eax
	addl	%eax, %edi
	adcl	%eax, %esi
	xorl	%eax, %edi
	movl	%edi, 56(%esp)          # 4-byte Spill
	movl	%ecx, (%esp)
	xorl	%eax, %esi
	movl	%esi, 52(%esp)          # 4-byte Spill
	calll	strlen
	movl	%eax, 32(%esp)          # 4-byte Spill
	movb	(%ebx), %cl
	movb	$0, with_thousand_seps.outbuf+47
	notl	%eax
	movl	%eax, 28(%esp)          # 4-byte Spill
	movl	$with_thousand_seps.outbuf+47, %edi
	.align	16, 0x90
.LBB319_6:                              # %while.body.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB319_7 Depth 2
	movsbl	%cl, %eax
	movl	%eax, 40(%esp)          # 4-byte Spill
	incl	%ebx
	movl	%ebx, 44(%esp)          # 4-byte Spill
	xorl	%edx, %edx
	.align	16, 0x90
.LBB319_7:                              # %while.body
                                        #   Parent Loop BB319_6 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	%edi, %ebp
	movl	52(%esp), %esi          # 4-byte Reload
	movl	%esi, 4(%esp)
	movl	56(%esp), %edi          # 4-byte Reload
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	addl	$48, %eax
	movb	%al, -1(%ebp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	addl	$9, %edi
	adcl	$0, %esi
	cmpl	$19, %edi
	setb	%bl
	testl	%esi, %esi
	je	.LBB319_9
# BB#8:                                 # %while.body
                                        #   in Loop: Header=BB319_7 Depth=2
	xorb	%bl, %bl
.LBB319_9:                              # %while.body
                                        #   in Loop: Header=BB319_7 Depth=2
	leal	-1(%ebp), %edi
	calll	__divdi3
	movl	%eax, 56(%esp)          # 4-byte Spill
	movl	%edx, 52(%esp)          # 4-byte Spill
	testb	%bl, %bl
	jne	.LBB319_15
# BB#10:                                # %if.end7
                                        #   in Loop: Header=BB319_7 Depth=2
	movl	48(%esp), %edx          # 4-byte Reload
	incl	%edx
	cmpl	40(%esp), %edx          # 4-byte Folded Reload
	movl	36(%esp), %eax          # 4-byte Reload
	movl	44(%esp), %ebx          # 4-byte Reload
	jne	.LBB319_7
# BB#11:                                # %if.then10
                                        #   in Loop: Header=BB319_7 Depth=2
	movl	32(%esp), %ecx          # 4-byte Reload
	cmpl	$1, %ecx
	jne	.LBB319_13
# BB#12:                                # %if.then13
                                        #   in Loop: Header=BB319_7 Depth=2
	movb	(%eax), %al
	movb	%al, -2(%ebp)
	addl	$-2, %ebp
	jmp	.LBB319_14
.LBB319_13:                             # %if.else
                                        #   in Loop: Header=BB319_7 Depth=2
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	addl	28(%esp), %ebp          # 4-byte Folded Reload
	movl	%ebp, (%esp)
	calll	memcpy
.LBB319_14:                             # %if.else
                                        #   in Loop: Header=BB319_7 Depth=2
	movl	%ebp, %edi
	movb	(%ebx), %cl
	xorl	%edx, %edx
	testb	%cl, %cl
	jne	.LBB319_6
	jmp	.LBB319_7
.LBB319_15:                             # %while.end
	cmpl	$0, 84(%esp)
	jns	.LBB319_17
# BB#16:                                # %if.then23
	movb	$45, -2(%ebp)
	addl	$-2, %ebp
	movl	%ebp, %edi
.LBB319_17:                             # %if.end25
	movl	%edi, %eax
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp319:
	.size	with_thousand_seps, .Ltmp319-with_thousand_seps

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI320_0:
	.quad	4562146422526312448     # double 9.765625e-04
                                        #  (0x0)
.LCPI320_1:
	.quad	4621819117588971520     # double 1.000000e+01
                                        #  (0x0)
	.text
	.globl	human_readable
	.align	16, 0x90
	.type	human_readable,@function
human_readable:                         # @human_readable
# BB#0:                                 # %entry
	pushl	%esi
	subl	$56, %esp
	movl	64(%esp), %ecx
	cmpl	$1023, %ecx             # imm = 0x3FF
	seta	%al
	movl	68(%esp), %edx
	testl	%edx, %edx
	setg	%ah
	je	.LBB320_2
# BB#1:                                 # %entry
	movb	%ah, %al
.LBB320_2:                              # %entry
	testb	%al, %al
	jne	.LBB320_3
# BB#10:                                # %if.then
	movl	%ecx, 12(%esp)
	movl	$.L.str171181, 8(%esp)
	jmp	.LBB320_11
.LBB320_3:
	xorl	%esi, %esi
	jmp	.LBB320_4
	.align	16, 0x90
.LBB320_13:                             # %if.end14
                                        #   in Loop: Header=BB320_4 Depth=1
	movl	%edx, %eax
	sarl	$31, %eax
	shrl	$22, %eax
	addl	%eax, %ecx
	adcl	$0, %edx
	shrdl	$10, %edx, %ecx
	sarl	$10, %edx
	incl	%esi
.LBB320_4:                              # %for.cond
                                        # =>This Inner Loop Header: Depth=1
	xorl	%eax, %eax
	cmpl	$5, %esi
	ja	.LBB320_12
# BB#5:                                 # %for.body
                                        #   in Loop: Header=BB320_4 Depth=1
	cmpl	$1048576, %ecx          # imm = 0x100000
	setb	%al
	testl	%edx, %edx
	sets	%ah
	je	.LBB320_7
# BB#6:                                 # %for.body
                                        #   in Loop: Header=BB320_4 Depth=1
	movb	%ah, %al
.LBB320_7:                              # %for.body
                                        #   in Loop: Header=BB320_4 Depth=1
	testb	%al, %al
	jne	.LBB320_9
# BB#8:                                 # %for.body
                                        #   in Loop: Header=BB320_4 Depth=1
	cmpl	$5, %esi
	jne	.LBB320_13
.LBB320_9:                              # %if.then7
	movsbl	human_readable.powers(%esi), %eax
	movl	%eax, 24(%esp)
	movl	%ecx, 48(%esp)
	movl	%edx, 52(%esp)
	fildll	48(%esp)
	fstpl	40(%esp)
	movsd	40(%esp), %xmm0
	mulsd	.LCPI320_0, %xmm0
	movsd	%xmm0, 16(%esp)
	movsd	.LCPI320_1, %xmm1
	ucomisd	%xmm0, %xmm1
	seta	%al
	movzbl	%al, %eax
	movl	%eax, 12(%esp)
	movl	$.L.str181182, 8(%esp)
.LBB320_11:                             # %if.then
	movl	$8, 4(%esp)
	movl	$human_readable.buf, (%esp)
	calll	snprintf
	movl	$human_readable.buf, %eax
.LBB320_12:                             # %return
	addl	$56, %esp
	popl	%esi
	ret
.Ltmp320:
	.size	human_readable, .Ltmp320-human_readable

	.globl	numdigit
	.align	16, 0x90
	.type	numdigit,@function
numdigit:                               # @numdigit
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	36(%esp), %edx
	movl	32(%esp), %eax
	movl	%eax, %ecx
	addl	$9, %ecx
	movl	%edx, %esi
	adcl	$0, %esi
	cmpl	$19, %ecx
	setb	%cl
	testl	%esi, %esi
	je	.LBB321_2
# BB#1:                                 # %entry
	xorb	%cl, %cl
.LBB321_2:                              # %entry
	movl	%edx, %esi
	shrl	$31, %esi
	incl	%esi
	testb	%cl, %cl
	jne	.LBB321_6
	.align	16, 0x90
.LBB321_3:                              # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, %ecx
	addl	$9, %ecx
	movl	%edx, %edi
	adcl	$0, %edi
	cmpl	$18, %ecx
	seta	%cl
	testl	%edi, %edi
	setne	%ch
	je	.LBB321_5
# BB#4:                                 # %while.body
                                        #   in Loop: Header=BB321_3 Depth=1
	movb	%ch, %cl
.LBB321_5:                              # %while.body
                                        #   in Loop: Header=BB321_3 Depth=1
	incl	%esi
	testb	%cl, %cl
	jne	.LBB321_3
.LBB321_6:                              # %while.end
	movl	%esi, %eax
	addl	$20, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp321:
	.size	numdigit, .Ltmp321-numdigit

	.globl	number_to_string
	.align	16, 0x90
	.type	number_to_string,@function
number_to_string:                       # @number_to_string
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$172, %esp
	movl	200(%esp), %ebp
	movl	196(%esp), %edx
	xorl	%ebx, %ebx
	movl	192(%esp), %esi
	testl	%ebp, %ebp
	jns	.LBB322_2
# BB#1:                                 # %if.then
	xorl	%eax, %eax
	xorl	%ecx, %ecx
	subl	%edx, %ecx
	movl	%edx, %edi
	movl	$0, %edx
	sbbl	%ebp, %edx
	xorl	$-2147483648, %ebp      # imm = 0xFFFFFFFF80000000
	orl	%edi, %ebp
	movl	$214748364, %ebp        # imm = 0xCCCCCCC
	cmovnel	%edx, %ebp
	movl	$-858993460, %edx       # imm = 0xFFFFFFFFCCCCCCCC
	cmovnel	%ecx, %edx
	movl	$56, %ebx
	cmovnel	%eax, %ebx
	movb	$45, (%esi)
	incl	%esi
.LBB322_2:                              # %if.end8
	cmpl	$9, %edx
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_4
# BB#3:                                 # %if.end8
	movb	%cl, %al
.LBB322_4:                              # %if.end8
	testb	%al, %al
	jne	.LBB322_6
# BB#5:                                 # %if.then11
	addl	$48, %edx
	movb	%dl, (%esi)
	incl	%esi
	jmp	.LBB322_76
.LBB322_6:                              # %if.else16
	cmpl	$99, %edx
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_8
# BB#7:                                 # %if.else16
	movb	%cl, %al
.LBB322_8:                              # %if.else16
	testb	%al, %al
	jne	.LBB322_10
# BB#9:                                 # %if.then19
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	movl	%edx, %edi
	calll	__divdi3
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	addl	$48, %eax
	movb	%al, (%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$2, %esi
	jmp	.LBB322_76
.LBB322_10:                             # %if.else29
	movl	%ebx, 156(%esp)         # 4-byte Spill
	movl	%esi, 160(%esp)         # 4-byte Spill
	cmpl	$999, %edx              # imm = 0x3E7
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_12
# BB#11:                                # %if.else29
	movb	%cl, %al
.LBB322_12:                             # %if.else29
	testb	%al, %al
	jne	.LBB322_14
# BB#13:                                # %if.then32
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, %esi
	movl	%edx, %edi
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, %ebx
	movl	%ebp, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%edi, 4(%esp)
	movl	%esi, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	addl	$48, %ebx
	movb	%bl, 1(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$3, %esi
	jmp	.LBB322_75
.LBB322_14:                             # %if.else47
	cmpl	$9999, %edx             # imm = 0x270F
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_16
# BB#15:                                # %if.else47
	movb	%cl, %al
.LBB322_16:                             # %if.else47
	testb	%al, %al
	jne	.LBB322_18
# BB#17:                                # %if.then50
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, %esi
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%ebx, 4(%esp)
	movl	%esi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	%ebp, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 2(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$4, %esi
	jmp	.LBB322_75
.LBB322_18:                             # %if.else70
	cmpl	$99999, %edx            # imm = 0x1869F
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_20
# BB#19:                                # %if.else70
	movb	%cl, %al
.LBB322_20:                             # %if.else70
	testb	%al, %al
	jne	.LBB322_22
# BB#21:                                # %if.then73
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 164(%esp)         # 4-byte Spill
	movl	%edx, 152(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%ebp, %ebx
	movl	%eax, %ebp
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%ebx, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	164(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 3(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$5, %esi
	jmp	.LBB322_75
.LBB322_22:                             # %if.else98
	cmpl	$999999, %edx           # imm = 0xF423F
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_24
# BB#23:                                # %if.else98
	movb	%cl, %al
.LBB322_24:                             # %if.else98
	testb	%al, %al
	jne	.LBB322_26
# BB#25:                                # %if.then101
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 136(%esp)         # 4-byte Spill
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %ebx
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%edx, 140(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %ebx
	movl	%ebp, 4(%esp)
	movl	136(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebx
	movb	%bl, 3(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 4(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$6, %esi
	jmp	.LBB322_75
.LBB322_26:                             # %if.else131
	cmpl	$9999999, %edx          # imm = 0x98967F
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_28
# BB#27:                                # %if.else131
	movb	%cl, %al
.LBB322_28:                             # %if.else131
	testb	%al, %al
	jne	.LBB322_30
# BB#29:                                # %if.then134
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 164(%esp)         # 4-byte Spill
	movl	%edx, 152(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%eax, 128(%esp)         # 4-byte Spill
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%edx, 140(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 136(%esp)         # 4-byte Spill
	movl	%edx, 132(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%ebx, 4(%esp)
	movl	128(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %ebx
	movl	%ebp, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	164(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %ebx
	movb	%bl, 2(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 4(%esi)
	movl	148(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 5(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$7, %esi
	jmp	.LBB322_75
.LBB322_30:                             # %if.else169
	cmpl	$99999999, %edx         # imm = 0x5F5E0FF
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_32
# BB#31:                                # %if.else169
	movb	%cl, %al
.LBB322_32:                             # %if.else169
	testb	%al, %al
	jne	.LBB322_34
# BB#33:                                # %if.then172
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %edi
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %ebx
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %ebx
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %edi
	movl	120(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	124(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 3(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %ebx
	movb	%bl, 5(%esi)
	movl	152(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 6(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 7(%esi)
	addl	$8, %esi
	jmp	.LBB322_75
.LBB322_34:                             # %if.else212
	cmpl	$999999999, %edx        # imm = 0x3B9AC9FF
	seta	%al
	testl	%ebp, %ebp
	setg	%cl
	je	.LBB322_36
# BB#35:                                # %if.else212
	movb	%cl, %al
.LBB322_36:                             # %if.else212
	testb	%al, %al
	jne	.LBB322_38
# BB#37:                                # %if.then215
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%eax, %ebx
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %ebx
	movl	112(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	116(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %ebp
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 2(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %ebx
	movb	%bl, 4(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 6(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 8(%esi)
	addl	$9, %esi
	jmp	.LBB322_75
.LBB322_38:                             # %if.else260
	cmpl	$1410065407, %edx       # imm = 0x540BE3FF
	seta	%al
	cmpl	$2, %ebp
	setg	%cl
	je	.LBB322_40
# BB#39:                                # %if.else260
	movb	%cl, %al
.LBB322_40:                             # %if.else260
	testb	%al, %al
	jne	.LBB322_42
# BB#41:                                # %if.then263
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, %edi
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %ebp
	movl	104(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	108(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %ebx
	movl	112(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	116(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebx
	movb	%bl, 3(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 5(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 7(%esi)
	movl	152(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 9(%esi)
	addl	$10, %esi
	jmp	.LBB322_75
.LBB322_42:                             # %if.else313
	cmpl	$1215752191, %edx       # imm = 0x4876E7FF
	seta	%al
	cmpl	$23, %ebp
	setg	%cl
	je	.LBB322_44
# BB#43:                                # %if.else313
	movb	%cl, %al
.LBB322_44:                             # %if.else313
	testb	%al, %al
	jne	.LBB322_46
# BB#45:                                # %if.then316
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 104(%esp)         # 4-byte Spill
	movl	%edx, 100(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 96(%esp)          # 4-byte Spill
	movl	%edx, 92(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %edi
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %ebx
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %ebp
	movl	92(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	96(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %edi
	movl	100(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	104(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %ebx
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %ebx
	movb	%bl, 2(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 4(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 6(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	108(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 10(%esi)
	addl	$11, %esi
	jmp	.LBB322_75
.LBB322_46:                             # %if.else371
	cmpl	$-727379969, %edx       # imm = 0xFFFFFFFFD4A50FFF
	seta	%al
	cmpl	$232, %ebp
	setg	%cl
	je	.LBB322_48
# BB#47:                                # %if.else371
	movb	%cl, %al
.LBB322_48:                             # %if.else371
	testb	%al, %al
	jne	.LBB322_50
# BB#49:                                # %if.then374
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 96(%esp)          # 4-byte Spill
	movl	%edx, 92(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 88(%esp)          # 4-byte Spill
	movl	%edx, 84(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%eax, %ebx
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, %ebx
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %edi
	movl	92(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	96(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %ebp
	movl	104(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	108(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 3(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 5(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$48, %ebx
	movb	%bl, 7(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	100(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	152(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 11(%esi)
	addl	$12, %esi
	jmp	.LBB322_75
.LBB322_50:                             # %if.else434
	cmpl	$1316134911, %edx       # imm = 0x4E729FFF
	seta	%al
	cmpl	$2328, %ebp             # imm = 0x918
	setg	%cl
	je	.LBB322_52
# BB#51:                                # %if.else434
	movb	%cl, %al
.LBB322_52:                             # %if.else434
	testb	%al, %al
	jne	.LBB322_54
# BB#53:                                # %if.then437
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 96(%esp)          # 4-byte Spill
	movl	%edx, 92(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	%edx, 80(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%edx, 72(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 88(%esp)          # 4-byte Spill
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %ebx
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %edi
	movl	92(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	96(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebp
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 2(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 4(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %ebx
	movb	%bl, 6(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	88(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	100(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 12(%esi)
	addl	$13, %esi
	jmp	.LBB322_75
.LBB322_54:                             # %if.else502
	cmpl	$276447231, %edx        # imm = 0x107A3FFF
	seta	%al
	cmpl	$23283, %ebp            # imm = 0x5AF3
	setg	%cl
	je	.LBB322_56
# BB#55:                                # %if.else502
	movb	%cl, %al
.LBB322_56:                             # %if.else502
	testb	%al, %al
	jne	.LBB322_58
# BB#57:                                # %if.then505
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 88(%esp)          # 4-byte Spill
	movl	%edx, 84(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%edx, 72(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	%edx, 64(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 80(%esp)          # 4-byte Spill
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, %ebx
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %edi
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebp
	movl	96(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	100(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 3(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 5(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$48, %ebx
	movb	%bl, 7(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	80(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	92(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	152(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 13(%esi)
	addl	$14, %esi
	jmp	.LBB322_75
.LBB322_58:                             # %if.else575
	cmpl	$-1530494977, %edx      # imm = 0xFFFFFFFFA4C67FFF
	seta	%al
	cmpl	$232830, %ebp           # imm = 0x38D7E
	setg	%cl
	je	.LBB322_60
# BB#59:                                # %if.else575
	movb	%cl, %al
.LBB322_60:                             # %if.else575
	testb	%al, %al
	jne	.LBB322_62
# BB#61:                                # %if.then578
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__moddi3
	movl	%eax, 88(%esp)          # 4-byte Spill
	movl	%edx, 84(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%edx, 72(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 64(%esp)          # 4-byte Spill
	movl	%edx, 60(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	%edx, 56(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %edi
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %ebx
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%edi, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 80(%esp)          # 4-byte Spill
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %ebx
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebp
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %edi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 2(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 4(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %ebx
	movb	%bl, 6(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	68(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	80(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	96(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	100(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	92(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 13(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 14(%esi)
	addl	$15, %esi
	jmp	.LBB322_75
.LBB322_62:                             # %if.else653
	cmpl	$1874919423, %edx       # imm = 0x6FC0FFFF
	seta	%al
	cmpl	$2328306, %ebp          # imm = 0x2386F2
	setg	%cl
	je	.LBB322_64
# BB#63:                                # %if.else653
	movb	%cl, %al
.LBB322_64:                             # %if.else653
	testb	%al, %al
	jne	.LBB322_66
# BB#65:                                # %if.then656
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%edx, 88(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__moddi3
	movl	%eax, 148(%esp)         # 4-byte Spill
	movl	%edx, 144(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__moddi3
	movl	%eax, 80(%esp)          # 4-byte Spill
	movl	%edx, 76(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	%edx, 64(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 56(%esp)          # 4-byte Spill
	movl	%edx, 52(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%eax, %edi
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %ebx
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	%ebp, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, %edi
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebx
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %ebp
	movl	88(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	92(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__divdi3
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 3(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %ebx
	movb	%bl, 5(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 7(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	60(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	72(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	96(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	100(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	84(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 13(%esi)
	movl	152(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 14(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 15(%esi)
	addl	$16, %esi
	jmp	.LBB322_75
.LBB322_66:                             # %if.else736
	cmpl	$1569325055, %edx       # imm = 0x5D89FFFF
	seta	%al
	cmpl	$23283064, %ebp         # imm = 0x1634578
	setg	%cl
	je	.LBB322_68
# BB#67:                                # %if.else736
	movb	%cl, %al
.LBB322_68:                             # %if.else736
	testb	%al, %al
	jne	.LBB322_70
# BB#69:                                # %if.then739
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__moddi3
	movl	%eax, 80(%esp)          # 4-byte Spill
	movl	%edx, 76(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__moddi3
	movl	%eax, 68(%esp)          # 4-byte Spill
	movl	%edx, 64(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 56(%esp)          # 4-byte Spill
	movl	%edx, 52(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	%edx, 44(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%edx, 40(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%eax, %ebx
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%edx, %ebp
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%edx, 88(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	%ebp, 4(%esp)
	movl	%ebx, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebx
	movl	64(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %ebp
	movl	76(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__divdi3
	movl	%eax, %edi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 2(%esi)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 4(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %ebx
	movb	%bl, 6(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	48(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	60(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	96(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	100(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	72(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	92(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 13(%esi)
	movl	84(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 14(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 15(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 16(%esi)
	addl	$17, %esi
	jmp	.LBB322_75
.LBB322_70:                             # %if.else824
	cmpl	$-1486618625, %edx      # imm = 0xFFFFFFFFA763FFFF
	seta	%al
	cmpl	$232830643, %ebp        # imm = 0xDE0B6B3
	setg	%cl
	je	.LBB322_72
# BB#71:                                # %if.else824
	movb	%cl, %al
.LBB322_72:                             # %if.else824
	testb	%al, %al
	jne	.LBB322_74
# BB#73:                                # %if.then827
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$23283064, 12(%esp)     # imm = 0x1634578
	movl	$1569325056, 8(%esp)    # imm = 0x5D8A0000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	%edx, 80(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__moddi3
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	%edx, 68(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__moddi3
	movl	%eax, 140(%esp)         # 4-byte Spill
	movl	%edx, 136(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__moddi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%edx, 56(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	%edx, 44(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	%edx, 36(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	%edx, 32(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%edx, 88(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 64(%esp)          # 4-byte Spill
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	36(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, %ebp
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %ebx
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__divdi3
	movl	%eax, %edi
	movl	80(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	84(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	calll	__divdi3
	movl	%eax, %esi
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283064, 12(%esp)     # imm = 0x1634578
	movl	$1569325056, 8(%esp)    # imm = 0x5D8A0000
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %ecx         # 4-byte Reload
	movb	%al, (%ecx)
	addl	$48, %esi
	movl	%esi, %eax
	movl	%ecx, %esi
	movb	%al, 1(%esi)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__divdi3
	movl	136(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 2(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 3(%esi)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 4(%esi)
	addl	$48, %ebx
	movb	%bl, 5(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 6(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 7(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	40(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	52(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	96(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	100(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	64(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 13(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	92(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 14(%esi)
	movl	76(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 15(%esi)
	movl	144(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 16(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 17(%esi)
	addl	$18, %esi
	jmp	.LBB322_75
.LBB322_74:                             # %if.else917
	movl	%ebp, 4(%esp)
	movl	%edx, (%esp)
	movl	$232830643, 12(%esp)    # imm = 0xDE0B6B3
	movl	$-1486618624, 8(%esp)   # imm = 0xFFFFFFFFA7640000
	movl	%edx, 168(%esp)         # 4-byte Spill
	calll	__moddi3
	movl	%eax, 152(%esp)         # 4-byte Spill
	movl	%edx, 148(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23283064, 12(%esp)     # imm = 0x1634578
	movl	$1569325056, 8(%esp)    # imm = 0x5D8A0000
	calll	__moddi3
	movl	%eax, 72(%esp)          # 4-byte Spill
	movl	%edx, 68(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	calll	__moddi3
	movl	%eax, 144(%esp)         # 4-byte Spill
	movl	%edx, 140(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__moddi3
	movl	%eax, 60(%esp)          # 4-byte Spill
	movl	%edx, 56(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__moddi3
	movl	%eax, 132(%esp)         # 4-byte Spill
	movl	%edx, 128(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__moddi3
	movl	%eax, 48(%esp)          # 4-byte Spill
	movl	%edx, 44(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__moddi3
	movl	%eax, 124(%esp)         # 4-byte Spill
	movl	%edx, 120(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__moddi3
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	%edx, 32(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__moddi3
	movl	%eax, 116(%esp)         # 4-byte Spill
	movl	%edx, 112(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__moddi3
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	%edx, 28(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__moddi3
	movl	%eax, 108(%esp)         # 4-byte Spill
	movl	%edx, 104(%esp)         # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__moddi3
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	%edx, 24(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__moddi3
	movl	%eax, 100(%esp)         # 4-byte Spill
	movl	%edx, 96(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__moddi3
	movl	%ebp, 164(%esp)         # 4-byte Spill
	movl	%eax, %ebp
	movl	%edx, %ebx
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__moddi3
	movl	%eax, 92(%esp)          # 4-byte Spill
	movl	%edx, 88(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__moddi3
	movl	%eax, %edi
	movl	%edx, %esi
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__moddi3
	movl	%eax, 84(%esp)          # 4-byte Spill
	movl	%edx, 80(%esp)          # 4-byte Spill
	movl	%edx, 4(%esp)
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__divdi3
	movl	%eax, 136(%esp)         # 4-byte Spill
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	movl	$0, 12(%esp)
	movl	$100, 8(%esp)
	calll	__divdi3
	movl	%eax, 76(%esp)          # 4-byte Spill
	movl	%ebx, 4(%esp)
	movl	%ebp, (%esp)
	movl	$0, 12(%esp)
	movl	$10000, 8(%esp)         # imm = 0x2710
	calll	__divdi3
	movl	%eax, 64(%esp)          # 4-byte Spill
	movl	24(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$1000000, 8(%esp)       # imm = 0xF4240
	calll	__divdi3
	movl	%eax, 52(%esp)          # 4-byte Spill
	movl	28(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	40(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$0, 12(%esp)
	movl	$100000000, 8(%esp)     # imm = 0x5F5E100
	calll	__divdi3
	movl	%eax, 40(%esp)          # 4-byte Spill
	movl	32(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	36(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2, 12(%esp)
	movl	$1410065408, 8(%esp)    # imm = 0x540BE400
	calll	__divdi3
	movl	%eax, 36(%esp)          # 4-byte Spill
	movl	44(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232, 12(%esp)
	movl	$-727379968, 8(%esp)    # imm = 0xFFFFFFFFD4A51000
	calll	__divdi3
	movl	%eax, %ebx
	movl	56(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	60(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$23283, 12(%esp)        # imm = 0x5AF3
	movl	$276447232, 8(%esp)     # imm = 0x107A4000
	calll	__divdi3
	movl	%eax, %edi
	movl	68(%esp), %eax          # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	72(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	$2328306, 12(%esp)      # imm = 0x2386F2
	movl	$1874919424, 8(%esp)    # imm = 0x6FC10000
	calll	__divdi3
	movl	%eax, %ebp
	movl	164(%esp), %eax         # 4-byte Reload
	movl	%eax, 4(%esp)
	movl	168(%esp), %eax         # 4-byte Reload
	movl	%eax, (%esp)
	movl	$232830643, 12(%esp)    # imm = 0xDE0B6B3
	movl	$-1486618624, 8(%esp)   # imm = 0xFFFFFFFFA7640000
	calll	__divdi3
	movl	148(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	152(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movl	160(%esp), %esi         # 4-byte Reload
	movb	%al, (%esi)
	movl	$23283064, 12(%esp)     # imm = 0x1634578
	movl	$1569325056, 8(%esp)    # imm = 0x5D8A0000
	calll	__divdi3
	movl	140(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	144(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 1(%esi)
	addl	$48, %ebp
	movl	%ebp, %eax
	movb	%al, 2(%esi)
	movl	$232830, 12(%esp)       # imm = 0x38D7E
	movl	$-1530494976, 8(%esp)   # imm = 0xFFFFFFFFA4C68000
	calll	__divdi3
	movl	128(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	132(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 3(%esi)
	addl	$48, %edi
	movl	%edi, %eax
	movb	%al, 4(%esi)
	movl	$2328, 12(%esp)         # imm = 0x918
	movl	$1316134912, 8(%esp)    # imm = 0x4E72A000
	calll	__divdi3
	movl	120(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	124(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 5(%esi)
	addl	$48, %ebx
	movb	%bl, 6(%esi)
	movl	$23, 12(%esp)
	movl	$1215752192, 8(%esp)    # imm = 0x4876E800
	calll	__divdi3
	movl	112(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	116(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 7(%esi)
	movl	36(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 8(%esi)
	movl	$0, 12(%esp)
	movl	$1000000000, 8(%esp)    # imm = 0x3B9ACA00
	calll	__divdi3
	movl	104(%esp), %ecx         # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	108(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 9(%esi)
	movl	40(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 10(%esi)
	movl	$0, 12(%esp)
	movl	$10000000, 8(%esp)      # imm = 0x989680
	calll	__divdi3
	movl	96(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	100(%esp), %ecx         # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 11(%esi)
	movl	52(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 12(%esi)
	movl	$0, 12(%esp)
	movl	$100000, 8(%esp)        # imm = 0x186A0
	calll	__divdi3
	movl	88(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	92(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 13(%esi)
	movl	64(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 14(%esi)
	movl	$0, 12(%esp)
	movl	$1000, 8(%esp)          # imm = 0x3E8
	calll	__divdi3
	movl	80(%esp), %ecx          # 4-byte Reload
	movl	%ecx, 4(%esp)
	movl	84(%esp), %ecx          # 4-byte Reload
	movl	%ecx, (%esp)
	addl	$48, %eax
	movb	%al, 15(%esi)
	movl	76(%esp), %eax          # 4-byte Reload
	addl	$48, %eax
	movb	%al, 16(%esi)
	movl	136(%esp), %eax         # 4-byte Reload
	addl	$48, %eax
	movb	%al, 17(%esi)
	movl	$0, 12(%esp)
	movl	$10, 8(%esp)
	calll	__moddi3
	addl	$48, %eax
	movb	%al, 18(%esi)
	addl	$19, %esi
.LBB322_75:                             # %if.else917
	movl	156(%esp), %ebx         # 4-byte Reload
.LBB322_76:                             # %if.end1029
	testl	%ebx, %ebx
	je	.LBB322_78
# BB#77:                                # %if.then1030
	movb	%bl, (%esi)
	incl	%esi
.LBB322_78:                             # %if.end1033
	movb	$0, (%esi)
	movl	%esi, %eax
	addl	$172, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp322:
	.size	number_to_string, .Ltmp322-number_to_string

	.globl	number_to_static_string
	.align	16, 0x90
	.type	number_to_static_string,@function
number_to_static_string:                # @number_to_static_string
# BB#0:                                 # %entry
	pushl	%esi
	subl	$24, %esp
	movl	number_to_static_string.ringpos, %eax
	movl	36(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	32(%esp), %ecx
	movl	%ecx, 4(%esp)
	imull	$24, %eax, %eax
	leal	number_to_static_string.ring(%eax), %esi
	movl	%esi, (%esp)
	calll	number_to_string
	movl	number_to_static_string.ringpos, %ecx
	leal	1(%ecx), %eax
	movl	$1431655766, %edx       # imm = 0x55555556
	imull	%edx
	movl	%edx, %eax
	shrl	$31, %eax
	addl	%edx, %eax
	leal	(%eax,%eax,2), %eax
	negl	%eax
	leal	1(%ecx,%eax), %eax
	movl	%eax, number_to_static_string.ringpos
	movl	%esi, %eax
	addl	$24, %esp
	popl	%esi
	ret
.Ltmp323:
	.size	number_to_static_string, .Ltmp323-number_to_static_string

	.globl	determine_screen_width
	.align	16, 0x90
	.type	determine_screen_width,@function
determine_screen_width:                 # @determine_screen_width
# BB#0:                                 # %entry
	subl	$28, %esp
	xorl	%eax, %eax
	cmpl	$0, opt+48
	jne	.LBB324_3
# BB#1:                                 # %if.end
	movl	stderr, %eax
	movl	%eax, (%esp)
	calll	fileno
	leal	16(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, (%esp)
	movl	$21523, 4(%esp)         # imm = 0x5413
	calll	ioctl
	movl	%eax, %ecx
	xorl	%eax, %eax
	testl	%ecx, %ecx
	js	.LBB324_3
# BB#2:                                 # %if.end4
	movzwl	18(%esp), %eax
.LBB324_3:                              # %return
	addl	$28, %esp
	ret
.Ltmp324:
	.size	determine_screen_width, .Ltmp324-determine_screen_width

	.globl	random_number
	.align	16, 0x90
	.type	random_number,@function
random_number:                          # @random_number
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	pushl	%eax
	movl	16(%esp), %edi
	movb	rnd_seeded.b, %al
	testb	%al, %al
	jne	.LBB325_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	time
	movl	%eax, %esi
	calll	getpid
	xorl	%esi, %eax
	movl	%eax, (%esp)
	calll	srand48
	movb	$1, rnd_seeded.b
.LBB325_2:                              # %if.end
	calll	lrand48
	cltd
	idivl	%edi
	movl	%edx, %eax
	addl	$4, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp325:
	.size	random_number, .Ltmp325-random_number

	.globl	random_float
	.align	16, 0x90
	.type	random_float,@function
random_float:                           # @random_float
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movb	rnd_seeded.b, %al
	testb	%al, %al
	jne	.LBB326_2
# BB#1:                                 # %if.then
	movl	$0, (%esp)
	calll	time
	movl	%eax, %esi
	calll	getpid
	xorl	%esi, %eax
	movl	%eax, (%esp)
	calll	srand48
	movb	$1, rnd_seeded.b
.LBB326_2:                              # %if.end
	addl	$8, %esp
	popl	%esi
	jmp	drand48                 # TAILCALL
.Ltmp326:
	.size	random_float, .Ltmp326-random_float

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI327_0:
	.quad	4696837146684686336     # double 1.000000e+06
                                        #  (0x0)
	.text
	.globl	run_with_timeout
	.align	16, 0x90
	.type	run_with_timeout,@function
run_with_timeout:                       # @run_with_timeout
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$52, %esp
	movl	76(%esp), %edi
	movl	72(%esp), %esi
	movsd	64(%esp), %xmm1
	xorpd	%xmm0, %xmm0
	ucomisd	%xmm0, %xmm1
	jne	.LBB327_2
	jp	.LBB327_2
# BB#1:                                 # %if.then
	movl	%edi, (%esp)
	calll	*%esi
	jmp	.LBB327_5
.LBB327_2:                              # %if.end
	movl	$abort_run_with_timeout, 4(%esp)
	movl	$14, (%esp)
	calll	signal
	movl	$1, 4(%esp)
	movl	$run_with_timeout_env, (%esp)
	calll	__sigsetjmp
	testl	%eax, %eax
	je	.LBB327_4
# BB#3:                                 # %if.then3
	movl	$0, 4(%esp)
	movl	$14, (%esp)
	calll	signal
	movb	$1, %al
	jmp	.LBB327_6
.LBB327_4:                              # %if.end5
	movl	$0, 20(%esp)
	movl	$0, 16(%esp)
	movl	$0, 24(%esp)
	movsd	64(%esp), %xmm1
	cvttsd2si	%xmm1, %eax
	movl	%eax, 24(%esp)
	cvtsi2sd	%eax, %xmm0
	subsd	%xmm0, %xmm1
	mulsd	.LCPI327_0, %xmm1
	cvttsd2si	%xmm1, %ecx
	orl	%ecx, %eax
	movl	$1, %eax
	cmovnel	%ecx, %eax
	movl	%eax, 28(%esp)
	leal	16(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	$0, (%esp)
	calll	setitimer
	movl	%edi, (%esp)
	calll	*%esi
	calll	__errno_location
	movl	%eax, %esi
	movl	(%esi), %edi
	xorpd	%xmm0, %xmm0
	movapd	%xmm0, 32(%esp)
	leal	32(%esp), %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	$0, (%esp)
	calll	setitimer
	movl	$0, 4(%esp)
	movl	$14, (%esp)
	calll	signal
	movl	%edi, (%esi)
.LBB327_5:                              # %if.end5
	xorb	%al, %al
.LBB327_6:                              # %return
	movzbl	%al, %eax
	addl	$52, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp327:
	.size	run_with_timeout, .Ltmp327-run_with_timeout

	.align	16, 0x90
	.type	abort_run_with_timeout,@function
abort_run_with_timeout:                 # @abort_run_with_timeout
# BB#0:                                 # %entry
	subl	$28, %esp
	cmpl	$14, 32(%esp)
	jne	.LBB328_1
# BB#2:                                 # %cond.end
	movl	$-1, 4(%esp)
	movl	$run_with_timeout_env, (%esp)
	calll	siglongjmp
.LBB328_1:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.abort_run_with_timeout, 12(%esp)
	movl	$1695, 8(%esp)          # imm = 0x69F
	movl	$.L.str251188, 4(%esp)
	movl	$.L.str241187, (%esp)
	calll	__assert_fail
.Ltmp328:
	.size	abort_run_with_timeout, .Ltmp328-abort_run_with_timeout

	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI329_0:
	.quad	4741671816366391296     # double 1.000000e+09
                                        #  (0x0)
	.text
	.globl	xsleep
	.align	16, 0x90
	.type	xsleep,@function
xsleep:                                 # @xsleep
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$36, %esp
	movsd	48(%esp), %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 24(%esp)
	cvtsi2sd	%eax, %xmm1
	subsd	%xmm1, %xmm0
	mulsd	.LCPI329_0, %xmm0
	cvttsd2si	%xmm0, %eax
	movl	%eax, 28(%esp)
	leal	16(%esp), %esi
	leal	24(%esp), %edi
	jmp	.LBB329_1
	.align	16, 0x90
.LBB329_3:                              # %while.body
                                        #   in Loop: Header=BB329_1 Depth=1
	movsd	16(%esp), %xmm0
	movsd	%xmm0, 24(%esp)
.LBB329_1:                              # %while.cond
                                        # =>This Inner Loop Header: Depth=1
	movl	%esi, 4(%esp)
	movl	%edi, (%esp)
	calll	nanosleep
	testl	%eax, %eax
	jns	.LBB329_4
# BB#2:                                 # %land.rhs
                                        #   in Loop: Header=BB329_1 Depth=1
	calll	__errno_location
	cmpl	$4, (%eax)
	je	.LBB329_3
.LBB329_4:                              # %while.end
	addl	$36, %esp
	popl	%esi
	popl	%edi
	ret
.Ltmp329:
	.size	xsleep, .Ltmp329-xsleep

	.globl	base64_encode
	.align	16, 0x90
	.type	base64_encode,@function
base64_encode:                          # @base64_encode
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	movl	24(%esp), %esi
	movl	20(%esp), %ebx
	leal	-2(%esi), %eax
	movl	28(%esp), %edi
	testl	%eax, %eax
	jle	.LBB330_1
# BB#2:
	leal	-2(%ebx,%esi), %eax
	movl	%edi, %ecx
	.align	16, 0x90
.LBB330_3:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movzbl	(%ebx), %edx
	shrl	$2, %edx
	movb	base64_encode.tbl(%edx), %dl
	movb	%dl, (%ecx)
	movzbl	1(%ebx), %edx
	shrl	$4, %edx
	movzbl	(%ebx), %ebp
	shll	$4, %ebp
	andl	$48, %ebp
	orl	%edx, %ebp
	movb	base64_encode.tbl(%ebp), %dl
	movb	%dl, 1(%ecx)
	movzbl	2(%ebx), %edx
	shrl	$6, %edx
	movzbl	1(%ebx), %ebp
	shll	$2, %ebp
	andl	$60, %ebp
	orl	%edx, %ebp
	movb	base64_encode.tbl(%ebp), %dl
	movb	%dl, 2(%ecx)
	movzbl	2(%ebx), %edx
	andl	$63, %edx
	movb	base64_encode.tbl(%edx), %dl
	movb	%dl, 3(%ecx)
	addl	$4, %ecx
	addl	$3, %ebx
	cmpl	%eax, %ebx
	jb	.LBB330_3
	jmp	.LBB330_4
.LBB330_1:
	movl	%edi, %ecx
.LBB330_4:                              # %for.end
	movl	$1431655766, %edx       # imm = 0x55555556
	movl	%esi, %eax
	imull	%edx
	movl	%edx, %eax
	shrl	$31, %eax
	addl	%edx, %eax
	leal	(%eax,%eax,2), %eax
	subl	%eax, %esi
	cmpl	$2, %esi
	jne	.LBB330_5
# BB#7:                                 # %sw.bb39
	movzbl	(%ebx), %eax
	shrl	$2, %eax
	movb	base64_encode.tbl(%eax), %al
	movb	%al, (%ecx)
	movzbl	1(%ebx), %eax
	shrl	$4, %eax
	movzbl	(%ebx), %edx
	shll	$4, %edx
	andl	$48, %edx
	orl	%eax, %edx
	movb	base64_encode.tbl(%edx), %al
	movb	%al, 1(%ecx)
	movzbl	1(%ebx), %eax
	andl	$15, %eax
	movb	base64_encode.tbl(,%eax,4), %al
	movb	%al, 2(%ecx)
	jmp	.LBB330_8
.LBB330_5:                              # %for.end
	cmpl	$1, %esi
	jne	.LBB330_9
# BB#6:                                 # %sw.bb
	movzbl	(%ebx), %eax
	shrl	$2, %eax
	movb	base64_encode.tbl(%eax), %al
	movb	%al, (%ecx)
	movzbl	(%ebx), %eax
	shll	$4, %eax
	andl	$48, %eax
	movb	base64_encode.tbl(%eax), %al
	movb	%al, 1(%ecx)
	movb	$61, 2(%ecx)
.LBB330_8:                              # %sw.bb39
	movb	$61, 3(%ecx)
	addl	$4, %ecx
.LBB330_9:                              # %sw.epilog
	movb	$0, (%ecx)
	subl	%edi, %ecx
	movl	%ecx, %eax
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp330:
	.size	base64_encode, .Ltmp330-base64_encode

	.globl	base64_decode
	.align	16, 0x90
	.type	base64_decode,@function
base64_decode:                          # @base64_decode
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	movl	24(%esp), %edi
	movl	20(%esp), %edx
	jmp	.LBB331_1
	.align	16, 0x90
.LBB331_27:                             # %if.end156
                                        #   in Loop: Header=BB331_1 Depth=1
	orl	%ebp, %ecx
	movb	%cl, 2(%esi)
	addl	$3, %esi
	movl	%esi, %edi
	.align	16, 0x90
.LBB331_1:                              # %do.body.outer
                                        # =>This Loop Header: Depth=1
                                        #     Child Loop BB331_19 Depth 2
                                        #     Child Loop BB331_13 Depth 2
                                        #     Child Loop BB331_7 Depth 2
                                        #     Child Loop BB331_2 Depth 2
                                        #     Child Loop BB331_22 Depth 2
	movl	%edi, %esi
	.align	16, 0x90
.LBB331_2:                              # %do.body
                                        #   Parent Loop BB331_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%edx), %ecx
	incl	%edx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB331_2
# BB#3:                                 # %do.end
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	testb	%bl, %bl
	je	.LBB331_28
# BB#4:                                 # %do.end
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	$-1, %eax
	cmpb	$61, %bl
	je	.LBB331_29
# BB#5:                                 # %lor.lhs.false
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	movl	$-1, %eax
	testb	$-128, %bl
	jne	.LBB331_29
# BB#6:                                 # %land.lhs.true
                                        #   in Loop: Header=BB331_1 Depth=1
	movsbl	base64_decode.base64_char_to_value(%ecx), %edi
	movl	$-1, %eax
	testl	%edi, %edi
	js	.LBB331_29
	.align	16, 0x90
.LBB331_7:                              # %do.body23
                                        #   Parent Loop BB331_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%edx), %ecx
	incl	%edx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB331_7
# BB#8:                                 # %do.end32
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	movl	$-1, %eax
	testb	%bl, %bl
	je	.LBB331_29
# BB#9:                                 # %do.end32
                                        #   in Loop: Header=BB331_1 Depth=1
	cmpb	$61, %bl
	je	.LBB331_29
# BB#10:                                # %lor.lhs.false39
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	movl	$-1, %eax
	testb	$-128, %bl
	jne	.LBB331_29
# BB#11:                                # %land.lhs.true44
                                        #   in Loop: Header=BB331_1 Depth=1
	movsbl	base64_decode.base64_char_to_value(%ecx), %ecx
	movl	$-1, %eax
	testl	%ecx, %ecx
	js	.LBB331_29
# BB#12:                                # %if.end55
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%edi, %eax
	shll	$18, %eax
	shll	$12, %ecx
	orl	%ecx, %eax
	shrl	$16, %eax
	movb	%al, (%esi)
	.align	16, 0x90
.LBB331_13:                             # %do.body62
                                        #   Parent Loop BB331_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%edx), %ebx
	incl	%edx
	testb	$64, _sch_istable(%ebx,%ebx)
	jne	.LBB331_13
# BB#14:                                # %do.end71
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	$-1, %eax
	testb	%bl, %bl
	je	.LBB331_29
# BB#15:                                # %if.end74
                                        #   in Loop: Header=BB331_1 Depth=1
	leal	1(%esi), %edi
	testb	$-128, %bl
	jne	.LBB331_30
# BB#16:                                # %land.lhs.true79
                                        #   in Loop: Header=BB331_1 Depth=1
	movsbl	base64_decode.base64_char_to_value(%ebx), %ebp
	testl	%ebp, %ebp
	js	.LBB331_17
	.align	16, 0x90
.LBB331_18:                             # %if.end90
                                        #   in Loop: Header=BB331_1 Depth=1
	cmpb	$61, %bl
	je	.LBB331_19
# BB#21:                                # %if.end113
                                        #   in Loop: Header=BB331_1 Depth=1
	shll	$6, %ebp
	orl	%ebp, %ecx
	movb	%ch, (%edi)
	.align	16, 0x90
.LBB331_22:                             # %do.body123
                                        #   Parent Loop BB331_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%edx), %ecx
	incl	%edx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB331_22
# BB#23:                                # %do.end132
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	movl	$-1, %eax
	testb	%bl, %bl
	je	.LBB331_29
# BB#24:                                # %do.end132
                                        #   in Loop: Header=BB331_1 Depth=1
	leal	2(%esi), %edi
	cmpb	$61, %bl
	je	.LBB331_1
# BB#25:                                # %if.end140
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	%ecx, %ebx
	movl	$-1, %eax
	testb	$-128, %bl
	jne	.LBB331_29
# BB#26:                                # %land.lhs.true145
                                        #   in Loop: Header=BB331_1 Depth=1
	movzbl	base64_decode.base64_char_to_value(%ecx), %ecx
	movl	$-1, %eax
	testb	%cl, %cl
	js	.LBB331_29
	jmp	.LBB331_27
.LBB331_30:                             # %lor.lhs.false85
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	$-1, %eax
	cmpb	$61, %bl
	jne	.LBB331_29
	.align	16, 0x90
.LBB331_19:                             # %do.body95
                                        #   Parent Loop BB331_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
	movzbl	(%edx), %ecx
	incl	%edx
	testb	$64, _sch_istable(%ecx,%ecx)
	jne	.LBB331_19
# BB#20:                                # %do.end104
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	$-1, %eax
	cmpb	$61, %cl
	je	.LBB331_1
	jmp	.LBB331_29
.LBB331_17:                             # %land.lhs.true79
                                        #   in Loop: Header=BB331_1 Depth=1
	movl	$-1, %eax
	cmpb	$61, %bl
	jne	.LBB331_29
	jmp	.LBB331_18
.LBB331_28:                             # %while.end
	subl	24(%esp), %esi
	movl	%esi, %eax
.LBB331_29:                             # %return
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp331:
	.size	base64_decode, .Ltmp331-base64_decode

	.globl	stable_sort
	.align	16, 0x90
	.type	stable_sort,@function
stable_sort:                            # @stable_sort
# BB#0:                                 # %entry
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$12, %esp
	movl	16(%ebp), %eax
	cmpl	$2, %eax
	jb	.LBB332_2
# BB#1:                                 # %if.then
	movl	20(%ebp), %edi
	movl	12(%ebp), %esi
	movl	8(%ebp), %ecx
	movl	%esi, %edx
	imull	%eax, %edx
	leal	15(,%edx,4), %ebx
	andl	$-16, %ebx
	movl	%esp, %edx
	subl	%ebx, %edx
	movl	%edx, %esp
	subl	$16, %esp
	movl	%edi, 12(%esp)
	decl	%esi
	movl	%esi, 8(%esp)
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	calll	mergesort_internal
	addl	$16, %esp
.LBB332_2:                              # %if.end
	leal	-12(%ebp), %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp332:
	.size	stable_sort, .Ltmp332-stable_sort

	.align	16, 0x90
	.type	mergesort_internal,@function
mergesort_internal:                     # @mergesort_internal
# BB#0:                                 # %entry
	pushl	%ebp
	pushl	%ebx
	pushl	%edi
	pushl	%esi
	subl	$60, %esp
	movl	88(%esp), %ebp
	movl	84(%esp), %eax
	cmpl	%ebp, %eax
	jae	.LBB333_22
# BB#1:                                 # %if.then
	movl	92(%esp), %edi
	movl	80(%esp), %esi
	movl	%edi, 12(%esp)
	movl	%eax, 4(%esp)
	movl	%esi, (%esp)
	leal	(%ebp,%eax), %ebx
	shrl	%ebx
	movl	%ebx, 40(%esp)          # 4-byte Spill
	movl	%ebx, 8(%esp)
	movl	%ecx, 44(%esp)          # 4-byte Spill
	movl	%edx, %esi
	calll	mergesort_internal
	movl	%edi, 12(%esp)
	movl	%ebp, 8(%esp)
	leal	1(%ebx), %edi
	movl	%edi, 4(%esp)
	movl	80(%esp), %eax
	movl	%eax, (%esp)
	movl	44(%esp), %ecx          # 4-byte Reload
	movl	%esi, %edx
	calll	mergesort_internal
	movl	%ebx, %edx
	movl	84(%esp), %eax
	cmpl	%eax, %edx
	jb	.LBB333_2
# BB#3:                                 # %if.then
	cmpl	%ebp, %edi
	movl	%edi, %ecx
	ja	.LBB333_4
# BB#8:                                 # %for.body.preheader
	movl	%eax, %edx
	movl	80(%esp), %ebp
	imull	%ebp, %edx
	addl	%esi, %edx
	movl	%edx, 48(%esp)          # 4-byte Spill
	movl	%esi, 36(%esp)          # 4-byte Spill
	movl	%eax, %edi
	movl	%ecx, %ebx
	movl	%eax, %ecx
	.align	16, 0x90
.LBB333_9:                              # %for.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ecx, 56(%esp)          # 4-byte Spill
	movl	%edi, 52(%esp)          # 4-byte Spill
	movl	%ebx, %esi
	imull	%ebp, %esi
	movl	44(%esp), %eax          # 4-byte Reload
	addl	%eax, %esi
	movl	%esi, 4(%esp)
	movl	%ebx, %edi
	movl	%ebp, %ebx
	movl	%ecx, %ebp
	imull	%ebx, %ebp
	addl	%eax, %ebp
	movl	%ebp, (%esp)
	calll	*92(%esp)
	testl	%eax, %eax
	jg	.LBB333_11
# BB#10:                                # %if.then8
                                        #   in Loop: Header=BB333_9 Depth=1
	movl	%edi, %esi
	movl	%ebx, 8(%esp)
	movl	%ebp, 4(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	movl	56(%esp), %edi          # 4-byte Reload
	incl	%edi
	calll	memcpy
	movl	%edi, %eax
	jmp	.LBB333_12
.LBB333_11:                             # %if.else
                                        #   in Loop: Header=BB333_9 Depth=1
	movl	%ebx, 8(%esp)
	movl	%esi, 4(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	movl	%eax, (%esp)
	incl	%edi
	movl	%edi, %esi
	calll	memcpy
	movl	56(%esp), %eax          # 4-byte Reload
.LBB333_12:                             # %for.inc
                                        #   in Loop: Header=BB333_9 Depth=1
	movl	52(%esp), %edi          # 4-byte Reload
	incl	%edi
	movl	40(%esp), %edx          # 4-byte Reload
	cmpl	%edx, %eax
	movl	%ebx, %ebp
	movl	%eax, %ecx
	ja	.LBB333_13
# BB#14:                                # %for.inc
                                        #   in Loop: Header=BB333_9 Depth=1
	addl	%ebp, 48(%esp)          # 4-byte Folded Spill
	movl	%esi, %ebx
	cmpl	88(%esp), %ebx
	ja	.LBB333_6
	jmp	.LBB333_9
.LBB333_2:
	movl	%esi, 36(%esp)          # 4-byte Spill
	movl	%eax, %ecx
	movl	80(%esp), %ebp
	movl	%edi, %ebx
	movl	%ecx, %edi
	jmp	.LBB333_5
.LBB333_4:
	movl	%esi, 36(%esp)          # 4-byte Spill
	movl	%eax, %edi
	movl	80(%esp), %ebp
	movl	%ecx, %ebx
.LBB333_5:
	movl	%eax, %ecx
	jmp	.LBB333_6
.LBB333_13:
	movl	%esi, %ebx
.LBB333_6:                              # %while.cond.preheader
	cmpl	%edx, %ecx
	ja	.LBB333_7
# BB#23:                                # %while.body.lr.ph
	leal	1(%edi,%edx), %eax
	movl	%eax, 32(%esp)          # 4-byte Spill
	movl	%ecx, %eax
	imull	%ebp, %eax
	addl	44(%esp), %eax          # 4-byte Folded Reload
	movl	%eax, 48(%esp)          # 4-byte Spill
	imull	%ebp, %edi
	addl	36(%esp), %edi          # 4-byte Folded Reload
	movl	%edi, 52(%esp)          # 4-byte Spill
	xorl	%edi, %edi
	movl	%ecx, %esi
	movl	%ecx, 56(%esp)          # 4-byte Spill
	.align	16, 0x90
.LBB333_24:                             # %while.body
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, 8(%esp)
	movl	48(%esp), %eax          # 4-byte Reload
	leal	(%eax,%edi), %eax
	movl	%eax, 4(%esp)
	movl	52(%esp), %eax          # 4-byte Reload
	leal	(%eax,%edi), %eax
	movl	%eax, (%esp)
	addl	%ebp, %edi
	incl	%esi
	calll	memcpy
	movl	40(%esp), %eax          # 4-byte Reload
	cmpl	%eax, %esi
	jbe	.LBB333_24
# BB#15:                                # %while.cond.while.cond26.preheader_crit_edge
	movl	%ebp, %eax
	movl	32(%esp), %ecx          # 4-byte Reload
	subl	56(%esp), %ecx          # 4-byte Folded Reload
	jmp	.LBB333_16
.LBB333_7:
	movl	%ebp, %eax
	movl	%edi, %ecx
.LBB333_16:                             # %while.cond26.preheader
	movl	88(%esp), %ebp
	movl	%ebp, %edx
	cmpl	%edx, %ebx
	movl	%eax, %ebp
	ja	.LBB333_19
# BB#17:                                # %while.body28.preheader
	movl	%ebx, %eax
	imull	%ebp, %eax
	addl	44(%esp), %eax          # 4-byte Folded Reload
	movl	%eax, 56(%esp)          # 4-byte Spill
	imull	%ebp, %ecx
	addl	36(%esp), %ecx          # 4-byte Folded Reload
	xorl	%edi, %edi
	.align	16, 0x90
.LBB333_18:                             # %while.body28
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, 8(%esp)
	movl	56(%esp), %eax          # 4-byte Reload
	leal	(%eax,%edi), %eax
	movl	%eax, 4(%esp)
	leal	(%ecx,%edi), %eax
	movl	%eax, (%esp)
	addl	%ebp, %edi
	incl	%ebx
	movl	%ecx, %esi
	movl	%edx, %ebp
	calll	memcpy
	movl	%ebp, %edx
	movl	80(%esp), %ebp
	movl	%esi, %ecx
	cmpl	%edx, %ebx
	jbe	.LBB333_18
.LBB333_19:                             # %for.cond36.preheader
	movl	84(%esp), %ecx
	cmpl	%edx, %ecx
	movl	44(%esp), %edx          # 4-byte Reload
	movl	36(%esp), %eax          # 4-byte Reload
	ja	.LBB333_22
# BB#20:                                # %for.body38.preheader
	movl	%ecx, %esi
	imull	%ebp, %esi
	.align	16, 0x90
.LBB333_21:                             # %for.body38
                                        # =>This Inner Loop Header: Depth=1
	movl	%ebp, 8(%esp)
	movl	%eax, %edi
	leal	(%edi,%esi), %eax
	movl	%eax, 4(%esp)
	leal	(%edx,%esi), %eax
	movl	%eax, (%esp)
	addl	%ebp, %esi
	incl	%ecx
	movl	%ecx, %ebx
	calll	memcpy
	movl	88(%esp), %eax
	movl	%ebx, %ecx
	movl	44(%esp), %edx          # 4-byte Reload
	cmpl	%eax, %ecx
	movl	%edi, %eax
	jbe	.LBB333_21
.LBB333_22:                             # %if.end46
	addl	$60, %esp
	popl	%esi
	popl	%edi
	popl	%ebx
	popl	%ebp
	ret
.Ltmp333:
	.size	mergesort_internal, .Ltmp333-mergesort_internal

	.section	.rodata.cst16,"aM",@progbits,16
	.align	16
.LCPI334_0:
	.quad	-9223372036854775808    # double -0.000000e+00
	.quad	-9223372036854775808    # double -0.000000e+00
	.section	.rodata.cst8,"aM",@progbits,8
	.align	8
.LCPI334_1:
	.quad	4621790970091300454     # double 9.950000e+00
                                        #  (0x66666666)
.LCPI334_2:
	.quad	4606732058837280358     # double 9.500000e-01
                                        #  (0x66666666)
.LCPI334_3:
	.quad	4562254508917369340     # double 1.000000e-03
                                        #  (0xd2f1a9fc)
.LCPI334_4:
	.quad	4557750909289998844     # double 5.000000e-04
                                        #  (0xd2f1a9fc)
	.text
	.globl	print_decimal
	.align	16, 0x90
	.type	print_decimal,@function
print_decimal:                          # @print_decimal
# BB#0:                                 # %entry
	subl	$28, %esp
	movsd	32(%esp), %xmm0
	xorpd	%xmm1, %xmm1
	ucomisd	%xmm1, %xmm0
	movapd	%xmm0, %xmm1
	jae	.LBB334_2
# BB#1:                                 # %cond.false
	movsd	.LCPI334_0, %xmm1
	xorpd	%xmm0, %xmm1
.LBB334_2:                              # %cond.end
	ucomisd	.LCPI334_1, %xmm1
	jae	.LBB334_3
# BB#5:                                 # %if.else
	ucomisd	.LCPI334_2, %xmm1
	jae	.LBB334_6
# BB#7:                                 # %if.else5
	ucomisd	.LCPI334_3, %xmm1
	jae	.LBB334_8
# BB#9:                                 # %if.else9
	ucomisd	.LCPI334_4, %xmm1
	jae	.LBB334_10
# BB#11:                                # %if.else13
	movw	$48, print_decimal.buf
	jmp	.LBB334_12
.LBB334_3:                              # %if.then
	movsd	%xmm0, 12(%esp)
	movl	$.L.str191183, 8(%esp)
	jmp	.LBB334_4
.LBB334_6:                              # %if.then3
	movsd	%xmm0, 12(%esp)
	movl	$.L.str201184, 8(%esp)
	jmp	.LBB334_4
.LBB334_8:                              # %if.then7
	movsd	%xmm0, 12(%esp)
	movl	$.L.str211185, 8(%esp)
	jmp	.LBB334_4
.LBB334_10:                             # %if.then11
	movsd	%xmm0, 12(%esp)
	movl	$.L.str221186, 8(%esp)
.LBB334_4:                              # %if.then
	movl	$32, 4(%esp)
	movl	$print_decimal.buf, (%esp)
	calll	snprintf
.LBB334_12:                             # %if.end17
	movl	$print_decimal.buf, %eax
	addl	$28, %esp
	ret
.Ltmp334:
	.size	print_decimal, .Ltmp334-print_decimal

	.globl	checking_malloc
	.align	16, 0x90
	.type	checking_malloc,@function
checking_malloc:                        # @checking_malloc
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	%esi, (%esp)
	calll	malloc
	testl	%eax, %eax
	je	.LBB335_2
# BB#1:                                 # %if.end
	addl	$8, %esp
	popl	%esi
	ret
.LBB335_2:                              # %if.then
	movl	$.L.str1289, %ecx
	movl	%esi, %edx
	calll	memfatal
.Ltmp335:
	.size	checking_malloc, .Ltmp335-checking_malloc

	.align	16, 0x90
	.type	memfatal,@function
memfatal:                               # @memfatal
# BB#0:                                 # %entry
	pushl	%edi
	pushl	%esi
	subl	$20, %esp
	movl	%edx, %edi
	movl	%ecx, %esi
	movl	$0, (%esp)
	calll	log_set_save_context
	movl	$5, 8(%esp)
	movl	$.L.str61295, 4(%esp)
	movl	$0, (%esp)
	calll	dcgettext
	movl	exec_name, %ecx
	movl	%edi, 16(%esp)
	movl	%esi, 12(%esp)
	movl	%ecx, 8(%esp)
	movl	%eax, 4(%esp)
	movl	$3, (%esp)
	calll	logprintf
	movl	$1, (%esp)
	calll	exit
.Ltmp336:
	.size	memfatal, .Ltmp336-memfatal

	.globl	checking_malloc0
	.align	16, 0x90
	.type	checking_malloc0,@function
checking_malloc0:                       # @checking_malloc0
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	%esi, 4(%esp)
	movl	$1, (%esp)
	calll	calloc
	testl	%eax, %eax
	je	.LBB337_2
# BB#1:                                 # %if.end
	addl	$8, %esp
	popl	%esi
	ret
.LBB337_2:                              # %if.then
	movl	$.L.str11290, %ecx
	movl	%esi, %edx
	calll	memfatal
.Ltmp337:
	.size	checking_malloc0, .Ltmp337-checking_malloc0

	.globl	checking_realloc
	.align	16, 0x90
	.type	checking_realloc,@function
checking_realloc:                       # @checking_realloc
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	20(%esp), %esi
	movl	16(%esp), %eax
	testl	%eax, %eax
	je	.LBB338_2
# BB#1:                                 # %if.then
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	calll	realloc
	jmp	.LBB338_3
.LBB338_2:                              # %if.else
	movl	%esi, (%esp)
	calll	malloc
.LBB338_3:                              # %if.end
	testl	%eax, %eax
	je	.LBB338_5
# BB#4:                                 # %if.end4
	addl	$8, %esp
	popl	%esi
	ret
.LBB338_5:                              # %if.then3
	movl	$.L.str21291, %ecx
	movl	%esi, %edx
	calll	memfatal
.Ltmp338:
	.size	checking_realloc, .Ltmp338-checking_realloc

	.globl	checking_strdup
	.align	16, 0x90
	.type	checking_strdup,@function
checking_strdup:                        # @checking_strdup
# BB#0:                                 # %entry
	pushl	%esi
	subl	$8, %esp
	movl	16(%esp), %esi
	movl	%esi, (%esp)
	calll	__strdup
	testl	%eax, %eax
	je	.LBB339_2
# BB#1:                                 # %if.end
	addl	$8, %esp
	popl	%esi
	ret
.LBB339_2:                              # %if.then
	movl	%esi, (%esp)
	calll	strlen
	leal	1(%eax), %edx
	movl	$.L.str31292, %ecx
	calll	memfatal
.Ltmp339:
	.size	checking_strdup, .Ltmp339-checking_strdup

	.globl	checking_free
	.align	16, 0x90
	.type	checking_free,@function
checking_free:                          # @checking_free
# BB#0:                                 # %entry
	subl	$28, %esp
	movl	32(%esp), %eax
	testl	%eax, %eax
	je	.LBB340_1
# BB#2:                                 # %cond.end
	addl	$28, %esp
	jmp	free                    # TAILCALL
.LBB340_1:                              # %cond.false
	movl	$.L__PRETTY_FUNCTION__.checking_free, 12(%esp)
	movl	$182, 8(%esp)
	movl	$.L.str51294, 4(%esp)
	movl	$.L.str41293, (%esp)
	calll	__assert_fail
.Ltmp340:
	.size	checking_free, .Ltmp340-checking_free

	.type	.L.str,@object          # @.str
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str:
	.asciz	 "Connecting to %s|%s|:%d... "
	.size	.L.str, 28

	.type	.L.str1,@object         # @.str1
.L.str1:
	.asciz	 "Connecting to %s:%d... "
	.size	.L.str1, 24

	.type	.L.str2,@object         # @.str2
.L.str2:
	.asciz	 "Failed setting IPV6_V6ONLY: %s"
	.size	.L.str2, 31

	.type	.L.str3,@object         # @.str3
.L.str3:
	.asciz	 "sock >= 0"
	.size	.L.str3, 10

	.type	.L.str4,@object         # @.str4
.L.str4:
	.asciz	 "connect.c"
	.size	.L.str4, 10

	.type	.L__PRETTY_FUNCTION__.connect_to_ip,@object # @__PRETTY_FUNCTION__.connect_to_ip
.L__PRETTY_FUNCTION__.connect_to_ip:
	.asciz	 "int connect_to_ip(const ip_address *, int, const char *)"
	.size	.L__PRETTY_FUNCTION__.connect_to_ip, 57

	.type	.L.str5,@object         # @.str5
.L.str5:
	.asciz	 "connected.\n"
	.size	.L.str5, 12

	.type	.L.str6,@object         # @.str6
.L.str6:
	.asciz	 "Created socket %d.\n"
	.size	.L.str6, 20

	.type	.L.str7,@object         # @.str7
.L.str7:
	.asciz	 "failed: %s.\n"
	.size	.L.str7, 13

	.type	.L.str8,@object         # @.str8
.L.str8:
	.asciz	 "%s: unable to resolve host address `%s'\n"
	.size	.L.str8, 41

	.type	.L.str9,@object         # @.str9
.L.str9:
	.asciz	 "Local socket fd %d bound.\n"
	.size	.L.str9, 27

	.type	.L.str10,@object        # @.str10
.L.str10:
	.asciz	 "binding to address %s using port %i.\n"
	.size	.L.str10, 38

	.type	.L.str11,@object        # @.str11
.L.str11:
	.asciz	 "Accepted client at socket %d.\n"
	.size	.L.str11, 31

	.type	.L.str12,@object        # @.str12
.L.str12:
	.asciz	 "conaddr is: %s\n"
	.size	.L.str12, 16

	.type	.L.str13,@object        # @.str13
.L.str13:
	.asciz	 "fd >= 0"
	.size	.L.str13, 8

	.type	.L__PRETTY_FUNCTION__.fd_register_transport,@object # @__PRETTY_FUNCTION__.fd_register_transport
.L__PRETTY_FUNCTION__.fd_register_transport:
	.asciz	 "void fd_register_transport(int, struct transport_implementation *, void *)"
	.size	.L__PRETTY_FUNCTION__.fd_register_transport, 75

	.type	transport_map,@object   # @transport_map
	.local	transport_map
	.comm	transport_map,4,4
	.type	transport_map_modified_tick,@object # @transport_map_modified_tick
	.local	transport_map_modified_tick
	.comm	transport_map_modified_tick,4,4
	.type	fd_read.last_info,@object # @fd_read.last_info
	.local	fd_read.last_info
	.comm	fd_read.last_info,4,4
	.type	fd_read.last_fd,@object # @fd_read.last_fd
	.data
	.align	4
fd_read.last_fd:
	.long	4294967295              # 0xffffffff
	.size	fd_read.last_fd, 4

	.type	fd_read.last_tick,@object # @fd_read.last_tick
	.local	fd_read.last_tick
	.comm	fd_read.last_tick,4,4
	.type	fd_peek.last_info,@object # @fd_peek.last_info
	.local	fd_peek.last_info
	.comm	fd_peek.last_info,4,4
	.type	fd_peek.last_fd,@object # @fd_peek.last_fd
	.align	4
fd_peek.last_fd:
	.long	4294967295              # 0xffffffff
	.size	fd_peek.last_fd, 4

	.type	fd_peek.last_tick,@object # @fd_peek.last_tick
	.local	fd_peek.last_tick
	.comm	fd_peek.last_tick,4,4
	.type	fd_write.last_info,@object # @fd_write.last_info
	.local	fd_write.last_info
	.comm	fd_write.last_info,4,4
	.type	fd_write.last_fd,@object # @fd_write.last_fd
	.align	4
fd_write.last_fd:
	.long	4294967295              # 0xffffffff
	.size	fd_write.last_fd, 4

	.type	fd_write.last_tick,@object # @fd_write.last_tick
	.local	fd_write.last_tick
	.comm	fd_write.last_tick,4,4
	.type	.L.str14,@object        # @.str14
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str14:
	.asciz	 "Closed fd %d\n"
	.size	.L.str14, 14

	.type	resolve_bind_address.called.b,@object # @resolve_bind_address.called.b
	.local	resolve_bind_address.called.b
	.comm	resolve_bind_address.called.b,1,1
	.type	resolve_bind_address.should_bind.b,@object # @resolve_bind_address.should_bind.b
	.local	resolve_bind_address.should_bind.b
	.comm	resolve_bind_address.should_bind.b,1,1
	.type	resolve_bind_address.ip,@object # @resolve_bind_address.ip
	.local	resolve_bind_address.ip
	.comm	resolve_bind_address.ip,24,4
	.type	.L.str15,@object        # @.str15
.L.str15:
	.asciz	 "%s: unable to resolve bind address `%s'; disabling bind.\n"
	.size	.L.str15, 58

	.type	downloaded_html_set,@object # @downloaded_html_set
	.comm	downloaded_html_set,4,4
	.type	dl_file_url_map,@object # @dl_file_url_map
	.local	dl_file_url_map
	.comm	dl_file_url_map,4,4
	.type	.L.str16,@object        # @.str16
.L.str16:
	.asciz	 "Apparently %s has been removed.\n"
	.size	.L.str16, 33

	.type	.L.str117,@object       # @.str117
.L.str117:
	.asciz	 "Scanning %s (from %s)\n"
	.size	.L.str117, 23

	.type	dl_url_file_map,@object # @dl_url_file_map
	.comm	dl_url_file_map,4,4
	.type	.L.str218,@object       # @.str218
.L.str218:
	.asciz	 "will convert url %s to local %s\n"
	.size	.L.str218, 33

	.type	.L.str319,@object       # @.str319
.L.str319:
	.asciz	 "will convert url %s to complete\n"
	.size	.L.str319, 33

	.type	.L.str420,@object       # @.str420
.L.str420:
	.asciz	 "Converted %d files in %s seconds.\n"
	.size	.L.str420, 35

	.type	.L.str521,@object       # @.str521
.L.str521:
	.asciz	 "file != ((void*)0)"
	.size	.L.str521, 19

	.type	.L.str622,@object       # @.str622
.L.str622:
	.asciz	 "convert.c"
	.size	.L.str622, 10

	.type	.L__PRETTY_FUNCTION__.register_redirection,@object # @__PRETTY_FUNCTION__.register_redirection
.L__PRETTY_FUNCTION__.register_redirection:
	.asciz	 "void register_redirection(const char *, const char *)"
	.size	.L__PRETTY_FUNCTION__.register_redirection, 54

	.type	converted_files,@object # @converted_files
	.local	converted_files
	.comm	converted_files,4,4
	.type	downloaded_files_hash,@object # @downloaded_files_hash
	.local	downloaded_files_hash
	.comm	downloaded_files_hash,4,4
	.type	downloaded_mode_to_ptr.v1,@object # @downloaded_mode_to_ptr.v1
	.local	downloaded_mode_to_ptr.v1
	.comm	downloaded_mode_to_ptr.v1,4,4
	.type	downloaded_mode_to_ptr.v2,@object # @downloaded_mode_to_ptr.v2
	.data
	.align	4
downloaded_mode_to_ptr.v2:
	.long	1                       # 0x1
	.size	downloaded_mode_to_ptr.v2, 4

	.type	downloaded_mode_to_ptr.v3,@object # @downloaded_mode_to_ptr.v3
	.align	4
downloaded_mode_to_ptr.v3:
	.long	2                       # 0x2
	.size	downloaded_mode_to_ptr.v3, 4

	.type	downloaded_mode_to_ptr.v4,@object # @downloaded_mode_to_ptr.v4
	.align	4
downloaded_mode_to_ptr.v4:
	.long	3                       # 0x3
	.size	downloaded_mode_to_ptr.v4, 4

	.type	.L.str723,@object       # @.str723
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str723:
	.asciz	 "/index.html"
	.size	.L.str723, 12

	.type	.L.str824,@object       # @.str824
.L.str824:
	.asciz	 "Converting %s... "
	.size	.L.str824, 18

	.type	.L.str925,@object       # @.str925
.L.str925:
	.asciz	 "nothing to do.\n"
	.size	.L.str925, 16

	.type	.L.str1026,@object      # @.str1026
.L.str1026:
	.asciz	 "Cannot convert links in %s: %s\n"
	.size	.L.str1026, 32

	.type	.L.str1127,@object      # @.str1127
.L.str1127:
	.asciz	 "Unable to delete `%s': %s\n"
	.size	.L.str1127, 27

	.type	.L.str1228,@object      # @.str1228
.L.str1228:
	.asciz	 "wb"
	.size	.L.str1228, 3

	.type	.L.str1329,@object      # @.str1329
.L.str1329:
	.asciz	 "Something strange is going on.  Please investigate."
	.size	.L.str1329, 52

	.type	.L.str1430,@object      # @.str1430
.L.str1430:
	.asciz	 "Skipping %s at position %d.\n"
	.size	.L.str1430, 29

	.type	.L.str1531,@object      # @.str1531
.L.str1531:
	.asciz	 "TO_RELATIVE: %s to %s at position %d in %s.\n"
	.size	.L.str1531, 45

	.type	.L.str1632,@object      # @.str1632
.L.str1632:
	.asciz	 "TO_COMPLETE: <something> to %s at position %d in %s.\n"
	.size	.L.str1632, 54

	.type	.L.str17,@object        # @.str17
.L.str17:
	.zero	1
	.size	.L.str17, 1

	.type	.L.str18,@object        # @.str18
.L.str18:
	.asciz	 "%d-%d\n"
	.size	.L.str18, 7

	.type	.L.str19,@object        # @.str19
.L.str19:
	.asciz	 "%d; URL=%s"
	.size	.L.str19, 11

	.type	.L.str21,@object        # @.str21
.L.str21:
	.asciz	 "../"
	.size	.L.str21, 4

	.type	.L.str22,@object        # @.str22
.L.str22:
	.asciz	 "orig"
	.size	.L.str22, 5

	.type	.L.str23,@object        # @.str23
.L.str23:
	.asciz	 ".orig"
	.size	.L.str23, 6

	.type	.L.str24,@object        # @.str24
.L.str24:
	.asciz	 "Cannot back up %s as %s: %s\n"
	.size	.L.str24, 29

	.type	cookies_now,@object     # @cookies_now
	.local	cookies_now
	.comm	cookies_now,4,4
	.type	.L.str33,@object        # @.str33
.L.str33:
	.asciz	 "Cookie coming from %s attempted to set domain to %s\n"
	.size	.L.str33, 53

	.type	.L.str134,@object       # @.str134
.L.str134:
	.asciz	 "Attempt to fake the path: %s, %s\n"
	.size	.L.str134, 34

	.type	.L.str235,@object       # @.str235
.L.str235:
	.asciz	 "ocnt == count"
	.size	.L.str235, 14

	.type	.L.str336,@object       # @.str336
.L.str336:
	.asciz	 "cookies.c"
	.size	.L.str336, 10

	.type	.L__PRETTY_FUNCTION__.cookie_header,@object # @__PRETTY_FUNCTION__.cookie_header
.L__PRETTY_FUNCTION__.cookie_header:
	.asciz	 "char *cookie_header(struct cookie_jar *, const char *, int, const char *, _Bool)"
	.size	.L__PRETTY_FUNCTION__.cookie_header, 81

	.type	.L.str437,@object       # @.str437
.L.str437:
	.asciz	 "pos == result_size"
	.size	.L.str437, 19

	.type	.L.str538,@object       # @.str538
.L.str538:
	.asciz	 "r"
	.size	.L.str538, 2

	.type	.L.str639,@object       # @.str639
.L.str639:
	.asciz	 "Cannot open cookies file `%s': %s\n"
	.size	.L.str639, 35

	.type	.L.str740,@object       # @.str740
.L.str740:
	.asciz	 "TRUE"
	.size	.L.str740, 5

	.type	.L.str841,@object       # @.str841
.L.str841:
	.asciz	 "%lf"
	.size	.L.str841, 4

	.type	.L.str942,@object       # @.str942
.L.str942:
	.asciz	 "Saving cookies to %s.\n"
	.size	.L.str942, 23

	.type	.L.str1043,@object      # @.str1043
.L.str1043:
	.asciz	 "w"
	.size	.L.str1043, 2

	.type	.L.str1144,@object      # @.str1144
.L.str1144:
	.asciz	 "# HTTP cookie file.\n"
	.size	.L.str1144, 21

	.type	.L.str1245,@object      # @.str1245
.L.str1245:
	.asciz	 "# Generated by Wget on %s.\n"
	.size	.L.str1245, 28

	.type	.L.str1346,@object      # @.str1346
.L.str1346:
	.asciz	 "# Edit at your own risk.\n\n"
	.size	.L.str1346, 27

	.type	.L.str1447,@object      # @.str1447
.L.str1447:
	.asciz	 ":%d"
	.size	.L.str1447, 4

	.type	.L.str1548,@object      # @.str1548
.L.str1548:
	.asciz	 "\t%s\t%s\t%s\t%.0f\t%s\t%s\n"
	.size	.L.str1548, 22

	.type	.L.str1649,@object      # @.str1649
.L.str1649:
	.asciz	 "FALSE"
	.size	.L.str1649, 6

	.type	.L.str1750,@object      # @.str1750
.L.str1750:
	.asciz	 "Error writing to `%s': %s\n"
	.size	.L.str1750, 27

	.type	.L.str1851,@object      # @.str1851
.L.str1851:
	.asciz	 "Error closing `%s': %s\n"
	.size	.L.str1851, 24

	.type	.L.str1952,@object      # @.str1952
.L.str1952:
	.asciz	 "Done saving cookies.\n"
	.size	.L.str1952, 22

	.type	.L.str20,@object        # @.str20
.L.str20:
	.asciz	 "Deleted old cookie (to be replaced.)\n"
	.size	.L.str20, 38

	.type	.L.str2153,@object      # @.str2153
.L.str2153:
	.asciz	 "\nStored cookie %s %d%s %s <%s> <%s> [expiry %s] %s %s\n"
	.size	.L.str2153, 55

	.type	.L.str2254,@object      # @.str2254
.L.str2254:
	.asciz	 " (ANY)"
	.size	.L.str2254, 7

	.type	.L.str2355,@object      # @.str2355
.L.str2355:
	.zero	1
	.size	.L.str2355, 1

	.type	.L.str2456,@object      # @.str2456
.L.str2456:
	.asciz	 "permanent"
	.size	.L.str2456, 10

	.type	.L.str25,@object        # @.str25
.L.str25:
	.asciz	 "session"
	.size	.L.str25, 8

	.type	.L.str26,@object        # @.str26
.L.str26:
	.asciz	 "secure"
	.size	.L.str26, 7

	.type	.L.str27,@object        # @.str27
.L.str27:
	.asciz	 "insecure"
	.size	.L.str27, 9

	.type	.L.str28,@object        # @.str28
.L.str28:
	.asciz	 "none"
	.size	.L.str28, 5

	.type	.L.str29,@object        # @.str29
.L.str29:
	.asciz	 "res != 0"
	.size	.L.str29, 9

	.type	.L__PRETTY_FUNCTION__.discard_matching_cookie,@object # @__PRETTY_FUNCTION__.discard_matching_cookie
.L__PRETTY_FUNCTION__.discard_matching_cookie:
	.asciz	 "void discard_matching_cookie(struct cookie_jar *, struct cookie *)"
	.size	.L__PRETTY_FUNCTION__.discard_matching_cookie, 67

	.type	.L.str30,@object        # @.str30
.L.str30:
	.asciz	 "Discarded old cookie.\n"
	.size	.L.str30, 23

	.type	.L.str31,@object        # @.str31
.L.str31:
	.asciz	 "cdm: 1"
	.size	.L.str31, 7

	.type	.L.str32,@object        # @.str32
.L.str32:
	.asciz	 " 2"
	.size	.L.str32, 3

	.type	.L.str3357,@object      # @.str3357
.L.str3357:
	.asciz	 " 3"
	.size	.L.str3357, 3

	.type	.L.str34,@object        # @.str34
.L.str34:
	.asciz	 " 4"
	.size	.L.str34, 3

	.type	.L.str35,@object        # @.str35
.L.str35:
	.asciz	 " 5"
	.size	.L.str35, 3

	.type	.L.str36,@object        # @.str36
.L.str36:
	.asciz	 " 6"
	.size	.L.str36, 3

	.type	check_domain_match.known_toplevel_domains,@object # @check_domain_match.known_toplevel_domains
	.section	.rodata,"a",@progbits
	.align	4
check_domain_match.known_toplevel_domains:
	.long	.L.str37
	.long	.L.str38
	.long	.L.str39
	.long	.L.str40
	.long	.L.str41
	.long	.L.str42
	.long	.L.str43
	.size	check_domain_match.known_toplevel_domains, 28

	.type	.L.str37,@object        # @.str37
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str37:
	.asciz	 ".com"
	.size	.L.str37, 5

	.type	.L.str38,@object        # @.str38
.L.str38:
	.asciz	 ".edu"
	.size	.L.str38, 5

	.type	.L.str39,@object        # @.str39
.L.str39:
	.asciz	 ".net"
	.size	.L.str39, 5

	.type	.L.str40,@object        # @.str40
.L.str40:
	.asciz	 ".org"
	.size	.L.str40, 5

	.type	.L.str41,@object        # @.str41
.L.str41:
	.asciz	 ".gov"
	.size	.L.str41, 5

	.type	.L.str42,@object        # @.str42
.L.str42:
	.asciz	 ".mil"
	.size	.L.str42, 5

	.type	.L.str43,@object        # @.str43
.L.str43:
	.asciz	 ".int"
	.size	.L.str43, 5

	.type	.L.str44,@object        # @.str44
.L.str44:
	.asciz	 " 7"
	.size	.L.str44, 3

	.type	.L.str45,@object        # @.str45
.L.str45:
	.asciz	 " 8"
	.size	.L.str45, 3

	.type	.L.str46,@object        # @.str46
.L.str46:
	.asciz	 "domain"
	.size	.L.str46, 7

	.type	.L.str47,@object        # @.str47
.L.str47:
	.asciz	 "path"
	.size	.L.str47, 5

	.type	.L.str48,@object        # @.str48
.L.str48:
	.asciz	 "expires"
	.size	.L.str48, 8

	.type	.L.str49,@object        # @.str49
.L.str49:
	.asciz	 "max-age"
	.size	.L.str49, 8

	.type	.L.str50,@object        # @.str50
.L.str50:
	.asciz	 "Syntax error in Set-Cookie: %s at position %d.\n"
	.size	.L.str50, 48

	.type	.L.str58,@object        # @.str58
.L.str58:
	.asciz	 "Wrote HTML-ized index to `%s' [%s].\n"
	.size	.L.str58, 37

	.type	.L.str159,@object       # @.str159
.L.str159:
	.asciz	 "Wrote HTML-ized index to `%s'.\n"
	.size	.L.str159, 32

	.type	.L.str260,@object       # @.str260
.L.str260:
	.asciz	 "File `%s' already there; not retrieving.\n"
	.size	.L.str260, 42

	.type	.L.str361,@object       # @.str361
.L.str361:
	.asciz	 "        "
	.size	.L.str361, 9

	.type	.L.str462,@object       # @.str462
.L.str462:
	.asciz	 "(try:%2d)"
	.size	.L.str462, 10

	.type	.L.str563,@object       # @.str563
.L.str563:
	.asciz	 "--%s--  %s\n  %s => `%s'\n"
	.size	.L.str563, 25

	.type	.L.str664,@object       # @.str664
.L.str664:
	.asciz	 "%s (%s) - `%s' saved [%s]\n\n"
	.size	.L.str664, 28

	.type	.L.str765,@object       # @.str765
.L.str765:
	.asciz	 "%s URL: %s [%s] -> \"%s\" [%d]\n"
	.size	.L.str765, 30

	.type	.L.str866,@object       # @.str866
.L.str866:
	.asciz	 "Removing file due to --delete-after in ftp_loop_internal():\n"
	.size	.L.str866, 61

	.type	.L.str967,@object       # @.str967
.L.str967:
	.asciz	 "Removing %s.\n"
	.size	.L.str967, 14

	.type	.L.str1068,@object      # @.str1068
.L.str1068:
	.asciz	 "unlink: %s\n"
	.size	.L.str1068, 12

	.type	.L.str1169,@object      # @.str1169
.L.str1169:
	.asciz	 "con != ((void*)0)"
	.size	.L.str1169, 18

	.type	.L.str1270,@object      # @.str1270
.L.str1270:
	.asciz	 "ftp.c"
	.size	.L.str1270, 6

	.type	.L__PRETTY_FUNCTION__.getftp,@object # @__PRETTY_FUNCTION__.getftp
.L__PRETTY_FUNCTION__.getftp:
	.asciz	 "uerr_t getftp(struct url *, wgint *, wgint, ccon *)"
	.size	.L__PRETTY_FUNCTION__.getftp, 52

	.type	.L.str1371,@object      # @.str1371
.L.str1371:
	.asciz	 "con->target != ((void*)0)"
	.size	.L.str1371, 26

	.type	.L.str1472,@object      # @.str1472
.L.str1472:
	.asciz	 "!((cmd & DO_LIST) && (cmd & DO_RETR))"
	.size	.L.str1472, 38

	.type	.L.str1573,@object      # @.str1573
.L.str1573:
	.asciz	 "(cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0"
	.size	.L.str1573, 53

	.type	.L.str1674,@object      # @.str1674
.L.str1674:
	.asciz	 "anonymous"
	.size	.L.str1674, 10

	.type	.L.str1775,@object      # @.str1775
.L.str1775:
	.asciz	 "-wget@"
	.size	.L.str1775, 7

	.type	.L.str1876,@object      # @.str1876
.L.str1876:
	.asciz	 "@"
	.size	.L.str1876, 2

	.type	.L.str1977,@object      # @.str1977
.L.str1977:
	.asciz	 "Logging in as %s ... "
	.size	.L.str1977, 22

	.type	.L.str2078,@object      # @.str2078
.L.str2078:
	.asciz	 "\n"
	.size	.L.str2078, 2

	.type	.L.str2179,@object      # @.str2179
.L.str2179:
	.asciz	 "Error in server response, closing control connection.\n"
	.size	.L.str2179, 55

	.type	.L.str2280,@object      # @.str2280
.L.str2280:
	.asciz	 "Error in server greeting.\n"
	.size	.L.str2280, 27

	.type	.L.str2381,@object      # @.str2381
.L.str2381:
	.asciz	 "Write failed, closing control connection.\n"
	.size	.L.str2381, 43

	.type	.L.str2482,@object      # @.str2482
.L.str2482:
	.asciz	 "The server refuses login.\n"
	.size	.L.str2482, 27

	.type	.L.str2583,@object      # @.str2583
.L.str2583:
	.asciz	 "Login incorrect.\n"
	.size	.L.str2583, 18

	.type	.L.str2684,@object      # @.str2684
.L.str2684:
	.asciz	 "Logged in!\n"
	.size	.L.str2684, 12

	.type	.L.str2785,@object      # @.str2785
.L.str2785:
	.asciz	 "==> SYST ... "
	.size	.L.str2785, 14

	.type	.L.str2886,@object      # @.str2886
.L.str2886:
	.asciz	 "Server error, can't determine system type.\n"
	.size	.L.str2886, 44

	.type	.L.str2987,@object      # @.str2987
.L.str2987:
	.asciz	 "done.    "
	.size	.L.str2987, 10

	.type	.L.str3088,@object      # @.str3088
.L.str3088:
	.asciz	 "==> PWD ... "
	.size	.L.str3088, 13

	.type	.L.str3189,@object      # @.str3189
.L.str3189:
	.asciz	 "/"
	.size	.L.str3189, 2

	.type	.L.str3290,@object      # @.str3290
.L.str3290:
	.asciz	 "Initial VMS directory not in the form [...]!\n"
	.size	.L.str3290, 46

	.type	.L.str3391,@object      # @.str3391
.L.str3391:
	.asciz	 "Preprocessing the initial VMS directory\n"
	.size	.L.str3391, 41

	.type	.L.str3492,@object      # @.str3492
.L.str3492:
	.asciz	 "  old = '%s'\n"
	.size	.L.str3492, 14

	.type	.L.str3593,@object      # @.str3593
.L.str3593:
	.asciz	 "  new = '%s'\n\n"
	.size	.L.str3593, 15

	.type	.L.str3694,@object      # @.str3694
.L.str3694:
	.asciz	 "done.\n"
	.size	.L.str3694, 7

	.type	.L.str3795,@object      # @.str3795
.L.str3795:
	.asciz	 "==> TYPE %c ... "
	.size	.L.str3795, 17

	.type	.L.str3896,@object      # @.str3896
.L.str3896:
	.asciz	 "Unknown type `%c', closing control connection.\n"
	.size	.L.str3896, 48

	.type	.L.str3997,@object      # @.str3997
.L.str3997:
	.asciz	 "done.  "
	.size	.L.str3997, 8

	.type	.L.str4098,@object      # @.str4098
.L.str4098:
	.asciz	 "==> CWD not needed.\n"
	.size	.L.str4098, 21

	.type	.L.str4199,@object      # @.str4199
.L.str4199:
	.asciz	 "changing working directory\n"
	.size	.L.str4199, 28

	.type	.L.str42100,@object     # @.str42100
.L.str42100:
	.asciz	 "Prepended initial PWD to relative path:\n"
	.size	.L.str42100, 41

	.type	.L.str43101,@object     # @.str43101
.L.str43101:
	.asciz	 "   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"
	.size	.L.str43101, 39

	.type	.L.str44102,@object     # @.str44102
.L.str44102:
	.asciz	 "*ntarget == '/'"
	.size	.L.str44102, 16

	.type	.L.str45103,@object     # @.str45103
.L.str45103:
	.asciz	 "Changed file name to VMS syntax:\n"
	.size	.L.str45103, 34

	.type	.L.str46104,@object     # @.str46104
.L.str46104:
	.asciz	 "  Unix: '%s'\n  VMS: '%s'\n"
	.size	.L.str46104, 26

	.type	.L.str47105,@object     # @.str47105
.L.str47105:
	.asciz	 "==> CWD %s ... "
	.size	.L.str47105, 16

	.type	.L.str48106,@object     # @.str48106
.L.str48106:
	.asciz	 "No such directory `%s'.\n\n"
	.size	.L.str48106, 26

	.type	.L.str49107,@object     # @.str49107
.L.str49107:
	.asciz	 "==> CWD not required.\n"
	.size	.L.str49107, 23

	.type	.L.str50108,@object     # @.str50108
.L.str50108:
	.asciz	 "==> SIZE %s ... "
	.size	.L.str50108, 17

	.type	.L.str51,@object        # @.str51
.L.str51:
	.asciz	 "%s\n"
	.size	.L.str51, 4

	.type	.L.str52,@object        # @.str52
.L.str52:
	.asciz	 "Cannot initiate PASV transfer.\n"
	.size	.L.str52, 32

	.type	.L.str53,@object        # @.str53
.L.str53:
	.asciz	 "Cannot parse PASV response.\n"
	.size	.L.str53, 29

	.type	.L.str54,@object        # @.str54
.L.str54:
	.asciz	 "trying to connect to %s port %d\n"
	.size	.L.str54, 33

	.type	.L.str55,@object        # @.str55
.L.str55:
	.asciz	 "couldn't connect to %s port %d: %s\n"
	.size	.L.str55, 36

	.type	.L.str56,@object        # @.str56
.L.str56:
	.asciz	 "socket: %s\n"
	.size	.L.str56, 12

	.type	.L.str57,@object        # @.str57
.L.str57:
	.asciz	 "Bind error (%s).\n"
	.size	.L.str57, 18

	.type	.L.str58109,@object     # @.str58109
.L.str58109:
	.asciz	 "Invalid PORT.\n"
	.size	.L.str58109, 15

	.type	.L.str59,@object        # @.str59
.L.str59:
	.asciz	 "==> REST %s ... "
	.size	.L.str59, 17

	.type	.L.str60,@object        # @.str60
.L.str60:
	.asciz	 "\nREST failed, starting from scratch.\n"
	.size	.L.str60, 38

	.type	.L.str61,@object        # @.str61
.L.str61:
	.asciz	 "==> RETR %s ... "
	.size	.L.str61, 17

	.type	.L.str62,@object        # @.str62
.L.str62:
	.asciz	 "No such file `%s'.\n\n"
	.size	.L.str62, 21

	.type	.L.str63,@object        # @.str63
.L.str63:
	.asciz	 "==> LIST ... "
	.size	.L.str63, 14

	.type	.L.str64,@object        # @.str64
.L.str64:
	.asciz	 "No such file or directory `%s'.\n\n"
	.size	.L.str64, 34

	.type	.L.str65,@object        # @.str65
.L.str65:
	.asciz	 "."
	.size	.L.str65, 2

	.type	.L.str66,@object        # @.str66
.L.str66:
	.asciz	 "Lying FTP server found, adjusting.\n"
	.size	.L.str66, 36

	.type	.L.str67,@object        # @.str67
.L.str67:
	.asciz	 "accept: %s\n"
	.size	.L.str67, 12

	.type	.L.str68,@object        # @.str68
.L.str68:
	.asciz	 "ab"
	.size	.L.str68, 3

	.type	.L.str69,@object        # @.str69
.L.str69:
	.asciz	 "wb"
	.size	.L.str69, 3

	.type	.L.str70,@object        # @.str70
.L.str70:
	.asciz	 "%s has sprung into existence.\n"
	.size	.L.str70, 31

	.type	.L.str71,@object        # @.str71
.L.str71:
	.asciz	 "%s: %s\n"
	.size	.L.str71, 8

	.type	.L.str72,@object        # @.str72
.L.str72:
	.asciz	 "%s: %s, closing control connection.\n"
	.size	.L.str72, 37

	.type	.L.str73,@object        # @.str73
.L.str73:
	.asciz	 "%s (%s) - Data connection: %s; "
	.size	.L.str73, 32

	.type	.L.str74,@object        # @.str74
.L.str74:
	.asciz	 "%s (%s) - "
	.size	.L.str74, 11

	.type	.L.str75,@object        # @.str75
.L.str75:
	.asciz	 "Control connection closed.\n"
	.size	.L.str75, 28

	.type	.L.str76,@object        # @.str76
.L.str76:
	.asciz	 "Data transfer aborted.\n"
	.size	.L.str76, 24

	.type	.L.str77,@object        # @.str77
.L.str77:
	.asciz	 "r"
	.size	.L.str77, 2

	.type	.L.str78,@object        # @.str78
.L.str78:
	.asciz	 "Length: %s"
	.size	.L.str78, 11

	.type	.L.str79,@object        # @.str79
.L.str79:
	.asciz	 " (%s)"
	.size	.L.str79, 6

	.type	.L.str80,@object        # @.str80
.L.str80:
	.asciz	 ", %s (%s) remaining"
	.size	.L.str80, 20

	.type	.L.str81,@object        # @.str81
.L.str81:
	.asciz	 ", %s remaining"
	.size	.L.str81, 15

	.type	.L.str82,@object        # @.str82
.L.str82:
	.asciz	 " (unauthoritative)\n"
	.size	.L.str82, 20

	.type	.L.str83,@object        # @.str83
.L.str83:
	.asciz	 "byte"
	.size	.L.str83, 5

	.type	.L.str84,@object        # @.str84
.L.str84:
	.asciz	 "==> PORT ... "
	.size	.L.str84, 14

	.type	.L.str85,@object        # @.str85
.L.str85:
	.asciz	 "==> EPRT ... "
	.size	.L.str85, 14

	.type	.L.str86,@object        # @.str86
.L.str86:
	.asciz	 "==> LPRT ... "
	.size	.L.str86, 14

	.type	.L.str87,@object        # @.str87
.L.str87:
	.asciz	 "==> PASV ... "
	.size	.L.str87, 14

	.type	.L.str88,@object        # @.str88
.L.str88:
	.asciz	 "==> EPSV ... "
	.size	.L.str88, 14

	.type	.L.str89,@object        # @.str89
.L.str89:
	.asciz	 "==> LPSV ... "
	.size	.L.str89, 14

	.type	.L.str90,@object        # @.str90
.L.str90:
	.asciz	 "Rejecting `%s'.\n"
	.size	.L.str90, 17

	.type	.L.str91,@object        # @.str91
.L.str91:
	.asciz	 "Error matching %s against %s: %s\n"
	.size	.L.str91, 34

	.type	.L.str92,@object        # @.str92
.L.str92:
	.asciz	 "No matches on pattern `%s'.\n"
	.size	.L.str92, 29

	.type	ftp_retrieve_list.depth,@object # @ftp_retrieve_list.depth
	.local	ftp_retrieve_list.depth
	.comm	ftp_retrieve_list.depth,4,4
	.type	.L.str93,@object        # @.str93
.L.str93:
	.asciz	 "Recursion depth %d exceeded max. depth %d.\n"
	.size	.L.str93, 44

	.type	.L.str94,@object        # @.str94
.L.str94:
	.asciz	 "f != ((void*)0)"
	.size	.L.str94, 16

	.type	.L__PRETTY_FUNCTION__.ftp_retrieve_list,@object # @__PRETTY_FUNCTION__.ftp_retrieve_list
.L__PRETTY_FUNCTION__.ftp_retrieve_list:
	.asciz	 "uerr_t ftp_retrieve_list(struct url *, struct fileinfo *, ccon *)"
	.size	.L__PRETTY_FUNCTION__.ftp_retrieve_list, 66

	.type	.L.str95,@object        # @.str95
.L.str95:
	.asciz	 "Remote file no newer than local file `%s' -- not retrieving.\n"
	.size	.L.str95, 62

	.type	.L.str96,@object        # @.str96
.L.str96:
	.asciz	 "Remote file is newer than local file `%s' -- retrieving.\n\n"
	.size	.L.str96, 59

	.type	.L.str97,@object        # @.str97
.L.str97:
	.asciz	 "The sizes do not match (local %s) -- retrieving.\n\n"
	.size	.L.str97, 51

	.type	.L.str98,@object        # @.str98
.L.str98:
	.asciz	 "Invalid name of the symlink, skipping.\n"
	.size	.L.str98, 40

	.type	.L.str99,@object        # @.str99
.L.str99:
	.asciz	 "Already have correct symlink %s -> %s\n\n"
	.size	.L.str99, 40

	.type	.L.str100,@object       # @.str100
.L.str100:
	.asciz	 "Creating symlink %s -> %s\n"
	.size	.L.str100, 27

	.type	.L.str101,@object       # @.str101
.L.str101:
	.asciz	 "symlink: %s\n"
	.size	.L.str101, 13

	.type	.L.str102,@object       # @.str102
.L.str102:
	.asciz	 "Skipping directory `%s'.\n"
	.size	.L.str102, 26

	.type	.L.str103,@object       # @.str103
.L.str103:
	.asciz	 "%s: unknown/unsupported file type.\n"
	.size	.L.str103, 36

	.type	.L.str104,@object       # @.str104
.L.str104:
	.asciz	 "%s: corrupt time-stamp.\n"
	.size	.L.str104, 25

	.type	.L.str105,@object       # @.str105
.L.str105:
	.asciz	 "Unrecognized permissions for %s.\n"
	.size	.L.str105, 34

	.type	.L.str106,@object       # @.str106
.L.str106:
	.asciz	 "Will not retrieve dirs since depth is %d (max %d).\n"
	.size	.L.str106, 52

	.type	.L.str107,@object       # @.str107
.L.str107:
	.asciz	 "%s%s"
	.size	.L.str107, 5

	.type	.L.str108,@object       # @.str108
.L.str108:
	.asciz	 "%s/%s"
	.size	.L.str108, 6

	.type	.L.str109,@object       # @.str109
.L.str109:
	.asciz	 "Composing new CWD relative to the initial directory.\n"
	.size	.L.str109, 54

	.type	.L.str110,@object       # @.str110
.L.str110:
	.asciz	 "  odir = '%s'\n  f->name = '%s'\n  newdir = '%s'\n\n"
	.size	.L.str110, 49

	.type	.L.str111,@object       # @.str111
.L.str111:
	.asciz	 "Not descending to `%s' as it is excluded/not-included.\n"
	.size	.L.str111, 56

	.type	.L.str112,@object       # @.str112
.L.str112:
	.asciz	 "../"
	.size	.L.str112, 4

	.type	.L.str113,@object       # @.str113
.L.str113:
	.asciz	 ".listing"
	.size	.L.str113, 9

	.type	.L.str114,@object       # @.str114
.L.str114:
	.asciz	 "Using `%s' as listing tmp file.\n"
	.size	.L.str114, 33

	.type	.L.str115,@object       # @.str115
.L.str115:
	.asciz	 "Removed `%s'.\n"
	.size	.L.str115, 15

	.type	.L.str116,@object       # @.str116
.L.str116:
	.asciz	 "%s\n"
	.size	.L.str116, 4

	.type	ftp_last_respline,@object # @ftp_last_respline
	.comm	ftp_last_respline,128,1
	.type	.L.str1119,@object      # @.str1119
.L.str1119:
	.asciz	 "USER"
	.size	.L.str1119, 5

	.type	ftp_login.skey_head,@object # @ftp_login.skey_head
	.section	.rodata,"a",@progbits
	.align	4
ftp_login.skey_head:
	.long	.L.str2120
	.long	.L.str3121
	.size	ftp_login.skey_head, 8

	.type	.L.str2120,@object      # @.str2120
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str2120:
	.asciz	 "331 s/key "
	.size	.L.str2120, 11

	.type	.L.str3121,@object      # @.str3121
.L.str3121:
	.asciz	 "331 opiekey "
	.size	.L.str3121, 13

	.type	.L.str4122,@object      # @.str4122
.L.str4122:
	.asciz	 "PASS"
	.size	.L.str4122, 5

	.type	.L.str5123,@object      # @.str5123
.L.str5123:
	.asciz	 "addr.family == 2"
	.size	.L.str5123, 17

	.type	.L.str6124,@object      # @.str6124
.L.str6124:
	.asciz	 "ftp-basic.c"
	.size	.L.str6124, 12

	.type	.L__PRETTY_FUNCTION__.ftp_port,@object # @__PRETTY_FUNCTION__.ftp_port
.L__PRETTY_FUNCTION__.ftp_port:
	.asciz	 "uerr_t ftp_port(int, int *)"
	.size	.L__PRETTY_FUNCTION__.ftp_port, 28

	.type	.L.str7125,@object      # @.str7125
.L.str7125:
	.asciz	 "PORT"
	.size	.L.str7125, 5

	.type	.L.str8126,@object      # @.str8126
.L.str8126:
	.asciz	 "addr.family == 2 || addr.family == 10"
	.size	.L.str8126, 38

	.type	.L__PRETTY_FUNCTION__.ftp_lprt,@object # @__PRETTY_FUNCTION__.ftp_lprt
.L__PRETTY_FUNCTION__.ftp_lprt:
	.asciz	 "uerr_t ftp_lprt(int, int *)"
	.size	.L__PRETTY_FUNCTION__.ftp_lprt, 28

	.type	.L.str9127,@object      # @.str9127
.L.str9127:
	.asciz	 "LPRT"
	.size	.L.str9127, 5

	.type	.L.str10128,@object     # @.str10128
.L.str10128:
	.asciz	 "EPRT"
	.size	.L.str10128, 5

	.type	.L.str11129,@object     # @.str11129
.L.str11129:
	.asciz	 "addr != ((void*)0)"
	.size	.L.str11129, 19

	.type	.L__PRETTY_FUNCTION__.ftp_pasv,@object # @__PRETTY_FUNCTION__.ftp_pasv
.L__PRETTY_FUNCTION__.ftp_pasv:
	.asciz	 "uerr_t ftp_pasv(int, ip_address *, int *)"
	.size	.L__PRETTY_FUNCTION__.ftp_pasv, 42

	.type	.L.str12130,@object     # @.str12130
.L.str12130:
	.asciz	 "port != ((void*)0)"
	.size	.L.str12130, 19

	.type	.L.str13131,@object     # @.str13131
.L.str13131:
	.asciz	 "PASV"
	.size	.L.str13131, 5

	.type	.L__PRETTY_FUNCTION__.ftp_lpsv,@object # @__PRETTY_FUNCTION__.ftp_lpsv
.L__PRETTY_FUNCTION__.ftp_lpsv:
	.asciz	 "uerr_t ftp_lpsv(int, ip_address *, int *)"
	.size	.L__PRETTY_FUNCTION__.ftp_lpsv, 42

	.type	.L.str14132,@object     # @.str14132
.L.str14132:
	.asciz	 "LPSV"
	.size	.L.str14132, 5

	.type	.L.str15133,@object     # @.str15133
.L.str15133:
	.asciz	 "s != ((void*)0)"
	.size	.L.str15133, 16

	.type	.L.str16134,@object     # @.str16134
.L.str16134:
	.asciz	 "lpsv addr is: %s\n"
	.size	.L.str16134, 18

	.type	.L.str17135,@object     # @.str17135
.L.str17135:
	.asciz	 "tmpprt[0] is: %d\n"
	.size	.L.str17135, 18

	.type	.L.str18136,@object     # @.str18136
.L.str18136:
	.asciz	 "tmpprt[1] is: %d\n"
	.size	.L.str18136, 18

	.type	.L.str19137,@object     # @.str19137
.L.str19137:
	.asciz	 "*port is: %d\n"
	.size	.L.str19137, 14

	.type	.L.str20138,@object     # @.str20138
.L.str20138:
	.asciz	 "af == 6"
	.size	.L.str20138, 8

	.type	.L.str21139,@object     # @.str21139
.L.str21139:
	.asciz	 "ip != ((void*)0)"
	.size	.L.str21139, 17

	.type	.L__PRETTY_FUNCTION__.ftp_epsv,@object # @__PRETTY_FUNCTION__.ftp_epsv
.L__PRETTY_FUNCTION__.ftp_epsv:
	.asciz	 "uerr_t ftp_epsv(int, ip_address *, int *)"
	.size	.L__PRETTY_FUNCTION__.ftp_epsv, 42

	.type	.L.str22140,@object     # @.str22140
.L.str22140:
	.asciz	 "EPSV"
	.size	.L.str22140, 5

	.type	.L.str23141,@object     # @.str23141
.L.str23141:
	.asciz	 "1"
	.size	.L.str23141, 2

	.type	.L.str24142,@object     # @.str24142
.L.str24142:
	.asciz	 "2"
	.size	.L.str24142, 2

	.type	.L.str25143,@object     # @.str25143
.L.str25143:
	.asciz	 "respline != ((void*)0)"
	.size	.L.str25143, 23

	.type	.L.str26144,@object     # @.str26144
.L.str26144:
	.asciz	 "respline is %s\n"
	.size	.L.str26144, 16

	.type	.L.str27145,@object     # @.str27145
.L.str27145:
	.asciz	 "TYPE"
	.size	.L.str27145, 5

	.type	.L.str28146,@object     # @.str28146
.L.str28146:
	.asciz	 "CWD"
	.size	.L.str28146, 4

	.type	.L.str29147,@object     # @.str29147
.L.str29147:
	.asciz	 "REST"
	.size	.L.str29147, 5

	.type	.L.str30148,@object     # @.str30148
.L.str30148:
	.asciz	 "RETR"
	.size	.L.str30148, 5

	.type	.L.str31149,@object     # @.str31149
.L.str31149:
	.asciz	 "LIST -a"
	.size	.L.str31149, 8

	.type	.L.str32150,@object     # @.str32150
.L.str32150:
	.asciz	 "LIST"
	.size	.L.str32150, 5

	.type	.Lftp_list.list_commands,@object # @ftp_list.list_commands
	.section	.rodata,"a",@progbits
	.align	4
.Lftp_list.list_commands:
	.long	.L.str31149
	.long	.L.str32150
	.size	.Lftp_list.list_commands, 8

	.type	.L.str33151,@object     # @.str33151
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str33151:
	.asciz	 "SYST"
	.size	.L.str33151, 5

	.type	.L.str34152,@object     # @.str34152
.L.str34152:
	.asciz	 " "
	.size	.L.str34152, 2

	.type	.L.str35153,@object     # @.str35153
.L.str35153:
	.asciz	 "VMS"
	.size	.L.str35153, 4

	.type	.L.str36154,@object     # @.str36154
.L.str36154:
	.asciz	 "UNIX"
	.size	.L.str36154, 5

	.type	.L.str37155,@object     # @.str37155
.L.str37155:
	.asciz	 "WINDOWS_NT"
	.size	.L.str37155, 11

	.type	.L.str38156,@object     # @.str38156
.L.str38156:
	.asciz	 "WINDOWS2000"
	.size	.L.str38156, 12

	.type	.L.str39157,@object     # @.str39157
.L.str39157:
	.asciz	 "MACOS"
	.size	.L.str39157, 6

	.type	.L.str40158,@object     # @.str40158
.L.str40158:
	.asciz	 "OS/400"
	.size	.L.str40158, 7

	.type	.L.str41159,@object     # @.str41159
.L.str41159:
	.asciz	 "PWD"
	.size	.L.str41159, 4

	.type	.L.str42160,@object     # @.str42160
.L.str42160:
	.asciz	 "\""
	.size	.L.str42160, 2

	.type	.L.str43161,@object     # @.str43161
.L.str43161:
	.asciz	 "SIZE"
	.size	.L.str43161, 5

	.type	.L.str44162,@object     # @.str44162
.L.str44162:
	.asciz	 "type="
	.size	.L.str44162, 6

	.type	.L.str46163,@object     # @.str46163
.L.str46163:
	.asciz	 "|%d|%s|%d|"
	.size	.L.str46163, 11

	.type	.L.str48164,@object     # @.str48164
.L.str48164:
	.asciz	 "%d,%d,%d,%d,%d,%d,%d,%d,%d"
	.size	.L.str48164, 27

	.type	.L.str49165,@object     # @.str49165
.L.str49165:
	.asciz	 "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d"
	.size	.L.str49165, 63

	.type	.L.str50166,@object     # @.str50166
.L.str50166:
	.asciz	 "addr->family == 2"
	.size	.L.str50166, 18

	.type	.L__PRETTY_FUNCTION__.ip_address_to_port_repr,@object # @__PRETTY_FUNCTION__.ip_address_to_port_repr
.L__PRETTY_FUNCTION__.ip_address_to_port_repr:
	.asciz	 "void ip_address_to_port_repr(const ip_address *, int, char *, size_t)"
	.size	.L__PRETTY_FUNCTION__.ip_address_to_port_repr, 70

	.type	.L.str52167,@object     # @.str52167
.L.str52167:
	.asciz	 "%d,%d,%d,%d,%d,%d"
	.size	.L.str52167, 18

	.type	.L.str53168,@object     # @.str53168
.L.str53168:
	.asciz	 "\r\n"
	.size	.L.str53168, 3

	.type	.L.str54169,@object     # @.str54169
.L.str54169:
	.asciz	 "\nDetected newlines in %s \"%s\"; changing to %s \"%s\"\n"
	.size	.L.str54169, 52

	.type	.L.str55170,@object     # @.str55170
.L.str55170:
	.asciz	 "--> %s\n"
	.size	.L.str55170, 8

	.type	.L.str56171,@object     # @.str56171
.L.str56171:
	.asciz	 "--> PASS Turtle Power!\n\n"
	.size	.L.str56171, 25

	.type	.L.str57172,@object     # @.str57172
.L.str57172:
	.asciz	 "\n--> %s\n"
	.size	.L.str57172, 9

	.type	.L.str207,@object       # @.str207
.L.str207:
	.asciz	 "rb"
	.size	.L.str207, 3

	.type	.L.str1208,@object      # @.str1208
.L.str1208:
	.asciz	 "%s: %s\n"
	.size	.L.str1208, 8

	.type	.L.str2209,@object      # @.str2209
.L.str2209:
	.asciz	 "Unsupported listing type, trying Unix listing parser.\n"
	.size	.L.str2209, 55

	.type	.L.str3210,@object      # @.str3210
.L.str3210:
	.asciz	 "wb"
	.size	.L.str3210, 3

	.type	.L.str4211,@object      # @.str4211
.L.str4211:
	.asciz	 ":"
	.size	.L.str4211, 2

	.type	.L.str5212,@object      # @.str5212
.L.str5212:
	.asciz	 "@"
	.size	.L.str5212, 2

	.type	.L.str6213,@object      # @.str6213
.L.str6213:
	.zero	1
	.size	.L.str6213, 1

	.type	.L.str7214,@object      # @.str7214
.L.str7214:
	.asciz	 "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n"
	.size	.L.str7214, 52

	.type	.L.str8215,@object      # @.str8215
.L.str8215:
	.asciz	 "<html>\n<head>\n<title>"
	.size	.L.str8215, 22

	.type	.L.str9216,@object      # @.str9216
.L.str9216:
	.asciz	 "Index of /%s on %s:%d"
	.size	.L.str9216, 22

	.type	.L.str10217,@object     # @.str10217
.L.str10217:
	.asciz	 "</title>\n</head>\n<body>\n<h1>"
	.size	.L.str10217, 29

	.type	.L.str11218,@object     # @.str11218
.L.str11218:
	.asciz	 "</h1>\n<hr>\n<pre>\n"
	.size	.L.str11218, 18

	.type	.L.str12219,@object     # @.str12219
.L.str12219:
	.asciz	 "  "
	.size	.L.str12219, 3

	.type	.L.str13220,@object     # @.str13220
.L.str13220:
	.asciz	 "Jan"
	.size	.L.str13220, 4

	.type	.L.str14221,@object     # @.str14221
.L.str14221:
	.asciz	 "Feb"
	.size	.L.str14221, 4

	.type	.L.str15222,@object     # @.str15222
.L.str15222:
	.asciz	 "Mar"
	.size	.L.str15222, 4

	.type	.L.str16223,@object     # @.str16223
.L.str16223:
	.asciz	 "Apr"
	.size	.L.str16223, 4

	.type	.L.str17224,@object     # @.str17224
.L.str17224:
	.asciz	 "May"
	.size	.L.str17224, 4

	.type	.L.str18225,@object     # @.str18225
.L.str18225:
	.asciz	 "Jun"
	.size	.L.str18225, 4

	.type	.L.str19226,@object     # @.str19226
.L.str19226:
	.asciz	 "Jul"
	.size	.L.str19226, 4

	.type	.L.str20227,@object     # @.str20227
.L.str20227:
	.asciz	 "Aug"
	.size	.L.str20227, 4

	.type	.L.str21228,@object     # @.str21228
.L.str21228:
	.asciz	 "Sep"
	.size	.L.str21228, 4

	.type	.L.str22229,@object     # @.str22229
.L.str22229:
	.asciz	 "Oct"
	.size	.L.str22229, 4

	.type	.L.str23230,@object     # @.str23230
.L.str23230:
	.asciz	 "Nov"
	.size	.L.str23230, 4

	.type	.L.str24231,@object     # @.str24231
.L.str24231:
	.asciz	 "Dec"
	.size	.L.str24231, 4

	.type	.L.str25232,@object     # @.str25232
.L.str25232:
	.asciz	 "%d %s %02d "
	.size	.L.str25232, 12

	.type	.L.str26233,@object     # @.str26233
.L.str26233:
	.asciz	 "%02d:%02d  "
	.size	.L.str26233, 12

	.type	.L.str27234,@object     # @.str27234
.L.str27234:
	.asciz	 "       "
	.size	.L.str27234, 8

	.type	.L.str28235,@object     # @.str28235
.L.str28235:
	.asciz	 "time unknown       "
	.size	.L.str28235, 20

	.type	.L.str29236,@object     # @.str29236
.L.str29236:
	.asciz	 "File        "
	.size	.L.str29236, 13

	.type	.L.str30237,@object     # @.str30237
.L.str30237:
	.asciz	 "Directory   "
	.size	.L.str30237, 13

	.type	.L.str31238,@object     # @.str31238
.L.str31238:
	.asciz	 "Link        "
	.size	.L.str31238, 13

	.type	.L.str32239,@object     # @.str32239
.L.str32239:
	.asciz	 "Not sure    "
	.size	.L.str32239, 13

	.type	.L.str33240,@object     # @.str33240
.L.str33240:
	.asciz	 "<a href=\"ftp://%s%s:%d"
	.size	.L.str33240, 23

	.type	.L.str35241,@object     # @.str35241
.L.str35241:
	.asciz	 "\">%s"
	.size	.L.str35241, 5

	.type	.L.str36242,@object     # @.str36242
.L.str36242:
	.asciz	 "</a> "
	.size	.L.str36242, 6

	.type	.L.str37243,@object     # @.str37243
.L.str37243:
	.asciz	 " (%s bytes)"
	.size	.L.str37243, 12

	.type	.L.str38244,@object     # @.str38244
.L.str38244:
	.asciz	 "-> %s"
	.size	.L.str38244, 6

	.type	.L.str39245,@object     # @.str39245
.L.str39245:
	.asciz	 "(nil)"
	.size	.L.str39245, 6

	.type	.L.str40246,@object     # @.str40246
.L.str40246:
	.asciz	 "</pre>\n</body>\n</html>\n"
	.size	.L.str40246, 24

	.type	ftp_parse_vms_ls.months,@object # @ftp_parse_vms_ls.months
	.section	.rodata,"a",@progbits
	.align	4
ftp_parse_vms_ls.months:
	.long	.L.str41247
	.long	.L.str42248
	.long	.L.str43249
	.long	.L.str44250
	.long	.L.str45251
	.long	.L.str46252
	.long	.L.str47253
	.long	.L.str48254
	.long	.L.str49255
	.long	.L.str50256
	.long	.L.str51257
	.long	.L.str52258
	.size	ftp_parse_vms_ls.months, 48

	.type	.L.str41247,@object     # @.str41247
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str41247:
	.asciz	 "JAN"
	.size	.L.str41247, 4

	.type	.L.str42248,@object     # @.str42248
.L.str42248:
	.asciz	 "FEB"
	.size	.L.str42248, 4

	.type	.L.str43249,@object     # @.str43249
.L.str43249:
	.asciz	 "MAR"
	.size	.L.str43249, 4

	.type	.L.str44250,@object     # @.str44250
.L.str44250:
	.asciz	 "APR"
	.size	.L.str44250, 4

	.type	.L.str45251,@object     # @.str45251
.L.str45251:
	.asciz	 "MAY"
	.size	.L.str45251, 4

	.type	.L.str46252,@object     # @.str46252
.L.str46252:
	.asciz	 "JUN"
	.size	.L.str46252, 4

	.type	.L.str47253,@object     # @.str47253
.L.str47253:
	.asciz	 "JUL"
	.size	.L.str47253, 4

	.type	.L.str48254,@object     # @.str48254
.L.str48254:
	.asciz	 "AUG"
	.size	.L.str48254, 4

	.type	.L.str49255,@object     # @.str49255
.L.str49255:
	.asciz	 "SEP"
	.size	.L.str49255, 4

	.type	.L.str50256,@object     # @.str50256
.L.str50256:
	.asciz	 "OCT"
	.size	.L.str50256, 4

	.type	.L.str51257,@object     # @.str51257
.L.str51257:
	.asciz	 "NOV"
	.size	.L.str51257, 4

	.type	.L.str52258,@object     # @.str52258
.L.str52258:
	.asciz	 "DEC"
	.size	.L.str52258, 4

	.type	.L.str53259,@object     # @.str53259
.L.str53259:
	.asciz	 " "
	.size	.L.str53259, 2

	.type	.L.str54260,@object     # @.str54260
.L.str54260:
	.asciz	 "file name: '%s'\n"
	.size	.L.str54260, 17

	.type	.L.str55261,@object     # @.str55261
.L.str55261:
	.asciz	 ".DIR"
	.size	.L.str55261, 5

	.type	.L.str56262,@object     # @.str56262
.L.str56262:
	.asciz	 "Name: '%s'\n"
	.size	.L.str56262, 12

	.type	.L.str57263,@object     # @.str57263
.L.str57263:
	.asciz	 "Directory\n"
	.size	.L.str57263, 11

	.type	.L.str58264,@object     # @.str58264
.L.str58264:
	.asciz	 "File\n"
	.size	.L.str58264, 6

	.type	.L.str59265,@object     # @.str59265
.L.str59265:
	.asciz	 "Getting additional line\n"
	.size	.L.str59265, 25

	.type	.L.str60266,@object     # @.str60266
.L.str60266:
	.asciz	 "empty line read, leaving listing parser\n"
	.size	.L.str60266, 41

	.type	.L.str61267,@object     # @.str61267
.L.str61267:
	.asciz	 "confusing VMS listing item, leaving listing parser\n"
	.size	.L.str61267, 52

	.type	.L.str62268,@object     # @.str62268
.L.str62268:
	.asciz	 "second token: '%s'\n"
	.size	.L.str62268, 20

	.type	.L.str63269,@object     # @.str63269
.L.str63269:
	.asciz	 "-"
	.size	.L.str63269, 2

	.type	.L.str64270,@object     # @.str64270
.L.str64270:
	.asciz	 "day: '%s'\n"
	.size	.L.str64270, 11

	.type	.L.str65271,@object     # @.str65271
.L.str65271:
	.asciz	 "nonsense in VMS listing, skipping this line\n"
	.size	.L.str65271, 45

	.type	.L.str66272,@object     # @.str66272
.L.str66272:
	.asciz	 "date parsed\n"
	.size	.L.str66272, 13

	.type	.L.str67273,@object     # @.str67273
.L.str67273:
	.asciz	 "YYYY/MM/DD HH:MM:SS - %d/%02d/%02d %02d:%02d:%02d\n"
	.size	.L.str67273, 51

	.type	.L.str68274,@object     # @.str68274
.L.str68274:
	.asciz	 "Timestamp: %ld\n"
	.size	.L.str68274, 16

	.type	.L.str69275,@object     # @.str69275
.L.str69275:
	.asciz	 ","
	.size	.L.str69275, 2

	.type	.L.str70276,@object     # @.str70276
.L.str70276:
	.asciz	 ")"
	.size	.L.str70276, 2

	.type	.L.str71277,@object     # @.str71277
.L.str71277:
	.asciz	 "confusing VMS permissions, skipping line\n"
	.size	.L.str71277, 42

	.type	.L.str72278,@object     # @.str72278
.L.str72278:
	.asciz	 "permissions: %s -> 0%o\n"
	.size	.L.str72278, 24

	.type	.L.str73279,@object     # @.str73279
.L.str73279:
	.asciz	 "wrong VMS permissons!\n"
	.size	.L.str73279, 23

	.type	.L.str74280,@object     # @.str74280
.L.str74280:
	.asciz	 "M"
	.size	.L.str74280, 2

	.type	.L.str75281,@object     # @.str75281
.L.str75281:
	.asciz	 "YYYY/MM/DD HH:MM - %d/%02d/%02d %02d:%02d\n"
	.size	.L.str75281, 43

	.type	.L.str76282,@object     # @.str76282
.L.str76282:
	.asciz	 "File, size %s bytes\n"
	.size	.L.str76282, 21

	.type	ftp_parse_unix_ls.months,@object # @ftp_parse_unix_ls.months
	.section	.rodata,"a",@progbits
	.align	4
ftp_parse_unix_ls.months:
	.long	.L.str13220
	.long	.L.str14221
	.long	.L.str15222
	.long	.L.str16223
	.long	.L.str17224
	.long	.L.str18225
	.long	.L.str19226
	.long	.L.str20227
	.long	.L.str21228
	.long	.L.str22229
	.long	.L.str23230
	.long	.L.str24231
	.size	ftp_parse_unix_ls.months, 48

	.type	.L.str77283,@object     # @.str77283
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str77283:
	.asciz	 "total"
	.size	.L.str77283, 6

	.type	.L.str78284,@object     # @.str78284
.L.str78284:
	.asciz	 "PLAINFILE; "
	.size	.L.str78284, 12

	.type	.L.str79285,@object     # @.str79285
.L.str79285:
	.asciz	 "DIRECTORY; "
	.size	.L.str79285, 12

	.type	.L.str80286,@object     # @.str80286
.L.str80286:
	.asciz	 "SYMLINK; "
	.size	.L.str80286, 10

	.type	.L.str81287,@object     # @.str81287
.L.str81287:
	.asciz	 "UNKNOWN; "
	.size	.L.str81287, 10

	.type	.L.str82288,@object     # @.str82288
.L.str82288:
	.asciz	 "implicit perms %0o; "
	.size	.L.str82288, 21

	.type	.L.str83289,@object     # @.str83289
.L.str83289:
	.asciz	 "perms %0o; "
	.size	.L.str83289, 12

	.type	.L.str84290,@object     # @.str84290
.L.str84290:
	.asciz	 "size: %s; "
	.size	.L.str84290, 11

	.type	.L.str85291,@object     # @.str85291
.L.str85291:
	.asciz	 "month: %s; "
	.size	.L.str85291, 12

	.type	.L.str86292,@object     # @.str86292
.L.str86292:
	.asciz	 "day: %d; "
	.size	.L.str86292, 10

	.type	.L.str87293,@object     # @.str87293
.L.str87293:
	.asciz	 "year: %d (no tm); "
	.size	.L.str87293, 19

	.type	.L.str88294,@object     # @.str88294
.L.str88294:
	.asciz	 "time: %02d:%02d:%02d (no yr); "
	.size	.L.str88294, 31

	.type	.L.str89295,@object     # @.str89295
.L.str89295:
	.asciz	 " -> "
	.size	.L.str89295, 5

	.type	.L.str90296,@object     # @.str90296
.L.str90296:
	.asciz	 "link to: %s\n"
	.size	.L.str90296, 13

	.type	.L.str93297,@object     # @.str93297
.L.str93297:
	.asciz	 "\nIgnoring `.' and `..'; "
	.size	.L.str93297, 25

	.type	.L.str94298,@object     # @.str94298
.L.str94298:
	.asciz	 "trailing `/' on dir.\n"
	.size	.L.str94298, 22

	.type	.L.str95299,@object     # @.str95299
.L.str95299:
	.asciz	 "trailing `@' on link.\n"
	.size	.L.str95299, 23

	.type	.L.str96300,@object     # @.str96300
.L.str96300:
	.asciz	 "trailing `*' on exec.\n"
	.size	.L.str96300, 23

	.type	.L.str97301,@object     # @.str97301
.L.str97301:
	.asciz	 "%s\n"
	.size	.L.str97301, 4

	.type	.L.str98302,@object     # @.str98302
.L.str98302:
	.asciz	 "Skipping.\n"
	.size	.L.str98302, 11

	.type	skey_response.english,@object # @skey_response.english
	.local	skey_response.english
	.comm	skey_response.english,30,4
	.type	Wp,@object              # @Wp
	.section	.rodata,"a",@progbits
Wp:
	.asciz	 "A\000\000"
	.asciz	 "ABE"
	.asciz	 "ACE"
	.asciz	 "ACT"
	.asciz	 "AD\000"
	.asciz	 "ADA"
	.asciz	 "ADD"
	.asciz	 "AGO"
	.asciz	 "AID"
	.asciz	 "AIM"
	.asciz	 "AIR"
	.asciz	 "ALL"
	.asciz	 "ALP"
	.asciz	 "AM\000"
	.asciz	 "AMY"
	.asciz	 "AN\000"
	.asciz	 "ANA"
	.asciz	 "AND"
	.asciz	 "ANN"
	.asciz	 "ANT"
	.asciz	 "ANY"
	.asciz	 "APE"
	.asciz	 "APS"
	.asciz	 "APT"
	.asciz	 "ARC"
	.asciz	 "ARE"
	.asciz	 "ARK"
	.asciz	 "ARM"
	.asciz	 "ART"
	.asciz	 "AS\000"
	.asciz	 "ASH"
	.asciz	 "ASK"
	.asciz	 "AT\000"
	.asciz	 "ATE"
	.asciz	 "AUG"
	.asciz	 "AUK"
	.asciz	 "AVE"
	.asciz	 "AWE"
	.asciz	 "AWK"
	.asciz	 "AWL"
	.asciz	 "AWN"
	.asciz	 "AX\000"
	.asciz	 "AYE"
	.asciz	 "BAD"
	.asciz	 "BAG"
	.asciz	 "BAH"
	.asciz	 "BAM"
	.asciz	 "BAN"
	.asciz	 "BAR"
	.asciz	 "BAT"
	.asciz	 "BAY"
	.asciz	 "BE\000"
	.asciz	 "BED"
	.asciz	 "BEE"
	.asciz	 "BEG"
	.asciz	 "BEN"
	.asciz	 "BET"
	.asciz	 "BEY"
	.asciz	 "BIB"
	.asciz	 "BID"
	.asciz	 "BIG"
	.asciz	 "BIN"
	.asciz	 "BIT"
	.asciz	 "BOB"
	.asciz	 "BOG"
	.asciz	 "BON"
	.asciz	 "BOO"
	.asciz	 "BOP"
	.asciz	 "BOW"
	.asciz	 "BOY"
	.asciz	 "BUB"
	.asciz	 "BUD"
	.asciz	 "BUG"
	.asciz	 "BUM"
	.asciz	 "BUN"
	.asciz	 "BUS"
	.asciz	 "BUT"
	.asciz	 "BUY"
	.asciz	 "BY\000"
	.asciz	 "BYE"
	.asciz	 "CAB"
	.asciz	 "CAL"
	.asciz	 "CAM"
	.asciz	 "CAN"
	.asciz	 "CAP"
	.asciz	 "CAR"
	.asciz	 "CAT"
	.asciz	 "CAW"
	.asciz	 "COD"
	.asciz	 "COG"
	.asciz	 "COL"
	.asciz	 "CON"
	.asciz	 "COO"
	.asciz	 "COP"
	.asciz	 "COT"
	.asciz	 "COW"
	.asciz	 "COY"
	.asciz	 "CRY"
	.asciz	 "CUB"
	.asciz	 "CUE"
	.asciz	 "CUP"
	.asciz	 "CUR"
	.asciz	 "CUT"
	.asciz	 "DAB"
	.asciz	 "DAD"
	.asciz	 "DAM"
	.asciz	 "DAN"
	.asciz	 "DAR"
	.asciz	 "DAY"
	.asciz	 "DEE"
	.asciz	 "DEL"
	.asciz	 "DEN"
	.asciz	 "DES"
	.asciz	 "DEW"
	.asciz	 "DID"
	.asciz	 "DIE"
	.asciz	 "DIG"
	.asciz	 "DIN"
	.asciz	 "DIP"
	.asciz	 "DO\000"
	.asciz	 "DOE"
	.asciz	 "DOG"
	.asciz	 "DON"
	.asciz	 "DOT"
	.asciz	 "DOW"
	.asciz	 "DRY"
	.asciz	 "DUB"
	.asciz	 "DUD"
	.asciz	 "DUE"
	.asciz	 "DUG"
	.asciz	 "DUN"
	.asciz	 "EAR"
	.asciz	 "EAT"
	.asciz	 "ED\000"
	.asciz	 "EEL"
	.asciz	 "EGG"
	.asciz	 "EGO"
	.asciz	 "ELI"
	.asciz	 "ELK"
	.asciz	 "ELM"
	.asciz	 "ELY"
	.asciz	 "EM\000"
	.asciz	 "END"
	.asciz	 "EST"
	.asciz	 "ETC"
	.asciz	 "EVA"
	.asciz	 "EVE"
	.asciz	 "EWE"
	.asciz	 "EYE"
	.asciz	 "FAD"
	.asciz	 "FAN"
	.asciz	 "FAR"
	.asciz	 "FAT"
	.asciz	 "FAY"
	.asciz	 "FED"
	.asciz	 "FEE"
	.asciz	 "FEW"
	.asciz	 "FIB"
	.asciz	 "FIG"
	.asciz	 "FIN"
	.asciz	 "FIR"
	.asciz	 "FIT"
	.asciz	 "FLO"
	.asciz	 "FLY"
	.asciz	 "FOE"
	.asciz	 "FOG"
	.asciz	 "FOR"
	.asciz	 "FRY"
	.asciz	 "FUM"
	.asciz	 "FUN"
	.asciz	 "FUR"
	.asciz	 "GAB"
	.asciz	 "GAD"
	.asciz	 "GAG"
	.asciz	 "GAL"
	.asciz	 "GAM"
	.asciz	 "GAP"
	.asciz	 "GAS"
	.asciz	 "GAY"
	.asciz	 "GEE"
	.asciz	 "GEL"
	.asciz	 "GEM"
	.asciz	 "GET"
	.asciz	 "GIG"
	.asciz	 "GIL"
	.asciz	 "GIN"
	.asciz	 "GO\000"
	.asciz	 "GOT"
	.asciz	 "GUM"
	.asciz	 "GUN"
	.asciz	 "GUS"
	.asciz	 "GUT"
	.asciz	 "GUY"
	.asciz	 "GYM"
	.asciz	 "GYP"
	.asciz	 "HA\000"
	.asciz	 "HAD"
	.asciz	 "HAL"
	.asciz	 "HAM"
	.asciz	 "HAN"
	.asciz	 "HAP"
	.asciz	 "HAS"
	.asciz	 "HAT"
	.asciz	 "HAW"
	.asciz	 "HAY"
	.asciz	 "HE\000"
	.asciz	 "HEM"
	.asciz	 "HEN"
	.asciz	 "HER"
	.asciz	 "HEW"
	.asciz	 "HEY"
	.asciz	 "HI\000"
	.asciz	 "HID"
	.asciz	 "HIM"
	.asciz	 "HIP"
	.asciz	 "HIS"
	.asciz	 "HIT"
	.asciz	 "HO\000"
	.asciz	 "HOB"
	.asciz	 "HOC"
	.asciz	 "HOE"
	.asciz	 "HOG"
	.asciz	 "HOP"
	.asciz	 "HOT"
	.asciz	 "HOW"
	.asciz	 "HUB"
	.asciz	 "HUE"
	.asciz	 "HUG"
	.asciz	 "HUH"
	.asciz	 "HUM"
	.asciz	 "HUT"
	.asciz	 "I\000\000"
	.asciz	 "ICY"
	.asciz	 "IDA"
	.asciz	 "IF\000"
	.asciz	 "IKE"
	.asciz	 "ILL"
	.asciz	 "INK"
	.asciz	 "INN"
	.asciz	 "IO\000"
	.asciz	 "ION"
	.asciz	 "IQ\000"
	.asciz	 "IRA"
	.asciz	 "IRE"
	.asciz	 "IRK"
	.asciz	 "IS\000"
	.asciz	 "IT\000"
	.asciz	 "ITS"
	.asciz	 "IVY"
	.asciz	 "JAB"
	.asciz	 "JAG"
	.asciz	 "JAM"
	.asciz	 "JAN"
	.asciz	 "JAR"
	.asciz	 "JAW"
	.asciz	 "JAY"
	.asciz	 "JET"
	.asciz	 "JIG"
	.asciz	 "JIM"
	.asciz	 "JO\000"
	.asciz	 "JOB"
	.asciz	 "JOE"
	.asciz	 "JOG"
	.asciz	 "JOT"
	.asciz	 "JOY"
	.asciz	 "JUG"
	.asciz	 "JUT"
	.asciz	 "KAY"
	.asciz	 "KEG"
	.asciz	 "KEN"
	.asciz	 "KEY"
	.asciz	 "KID"
	.asciz	 "KIM"
	.asciz	 "KIN"
	.asciz	 "KIT"
	.asciz	 "LA\000"
	.asciz	 "LAB"
	.asciz	 "LAC"
	.asciz	 "LAD"
	.asciz	 "LAG"
	.asciz	 "LAM"
	.asciz	 "LAP"
	.asciz	 "LAW"
	.asciz	 "LAY"
	.asciz	 "LEA"
	.asciz	 "LED"
	.asciz	 "LEE"
	.asciz	 "LEG"
	.asciz	 "LEN"
	.asciz	 "LEO"
	.asciz	 "LET"
	.asciz	 "LEW"
	.asciz	 "LID"
	.asciz	 "LIE"
	.asciz	 "LIN"
	.asciz	 "LIP"
	.asciz	 "LIT"
	.asciz	 "LO\000"
	.asciz	 "LOB"
	.asciz	 "LOG"
	.asciz	 "LOP"
	.asciz	 "LOS"
	.asciz	 "LOT"
	.asciz	 "LOU"
	.asciz	 "LOW"
	.asciz	 "LOY"
	.asciz	 "LUG"
	.asciz	 "LYE"
	.asciz	 "MA\000"
	.asciz	 "MAC"
	.asciz	 "MAD"
	.asciz	 "MAE"
	.asciz	 "MAN"
	.asciz	 "MAO"
	.asciz	 "MAP"
	.asciz	 "MAT"
	.asciz	 "MAW"
	.asciz	 "MAY"
	.asciz	 "ME\000"
	.asciz	 "MEG"
	.asciz	 "MEL"
	.asciz	 "MEN"
	.asciz	 "MET"
	.asciz	 "MEW"
	.asciz	 "MID"
	.asciz	 "MIN"
	.asciz	 "MIT"
	.asciz	 "MOB"
	.asciz	 "MOD"
	.asciz	 "MOE"
	.asciz	 "MOO"
	.asciz	 "MOP"
	.asciz	 "MOS"
	.asciz	 "MOT"
	.asciz	 "MOW"
	.asciz	 "MUD"
	.asciz	 "MUG"
	.asciz	 "MUM"
	.asciz	 "MY\000"
	.asciz	 "NAB"
	.asciz	 "NAG"
	.asciz	 "NAN"
	.asciz	 "NAP"
	.asciz	 "NAT"
	.asciz	 "NAY"
	.asciz	 "NE\000"
	.asciz	 "NED"
	.asciz	 "NEE"
	.asciz	 "NET"
	.asciz	 "NEW"
	.asciz	 "NIB"
	.asciz	 "NIL"
	.asciz	 "NIP"
	.asciz	 "NIT"
	.asciz	 "NO\000"
	.asciz	 "NOB"
	.asciz	 "NOD"
	.asciz	 "NON"
	.asciz	 "NOR"
	.asciz	 "NOT"
	.asciz	 "NOV"
	.asciz	 "NOW"
	.asciz	 "NU\000"
	.asciz	 "NUN"
	.asciz	 "NUT"
	.asciz	 "O\000\000"
	.asciz	 "OAF"
	.asciz	 "OAK"
	.asciz	 "OAR"
	.asciz	 "OAT"
	.asciz	 "ODD"
	.asciz	 "ODE"
	.asciz	 "OF\000"
	.asciz	 "OFF"
	.asciz	 "OFT"
	.asciz	 "OH\000"
	.asciz	 "OIL"
	.asciz	 "OK\000"
	.asciz	 "OLD"
	.asciz	 "ON\000"
	.asciz	 "ONE"
	.asciz	 "OR\000"
	.asciz	 "ORB"
	.asciz	 "ORE"
	.asciz	 "ORR"
	.asciz	 "OS\000"
	.asciz	 "OTT"
	.asciz	 "OUR"
	.asciz	 "OUT"
	.asciz	 "OVA"
	.asciz	 "OW\000"
	.asciz	 "OWE"
	.asciz	 "OWL"
	.asciz	 "OWN"
	.asciz	 "OX\000"
	.asciz	 "PA\000"
	.asciz	 "PAD"
	.asciz	 "PAL"
	.asciz	 "PAM"
	.asciz	 "PAN"
	.asciz	 "PAP"
	.asciz	 "PAR"
	.asciz	 "PAT"
	.asciz	 "PAW"
	.asciz	 "PAY"
	.asciz	 "PEA"
	.asciz	 "PEG"
	.asciz	 "PEN"
	.asciz	 "PEP"
	.asciz	 "PER"
	.asciz	 "PET"
	.asciz	 "PEW"
	.asciz	 "PHI"
	.asciz	 "PI\000"
	.asciz	 "PIE"
	.asciz	 "PIN"
	.asciz	 "PIT"
	.asciz	 "PLY"
	.asciz	 "PO\000"
	.asciz	 "POD"
	.asciz	 "POE"
	.asciz	 "POP"
	.asciz	 "POT"
	.asciz	 "POW"
	.asciz	 "PRO"
	.asciz	 "PRY"
	.asciz	 "PUB"
	.asciz	 "PUG"
	.asciz	 "PUN"
	.asciz	 "PUP"
	.asciz	 "PUT"
	.asciz	 "QUO"
	.asciz	 "RAG"
	.asciz	 "RAM"
	.asciz	 "RAN"
	.asciz	 "RAP"
	.asciz	 "RAT"
	.asciz	 "RAW"
	.asciz	 "RAY"
	.asciz	 "REB"
	.asciz	 "RED"
	.asciz	 "REP"
	.asciz	 "RET"
	.asciz	 "RIB"
	.asciz	 "RID"
	.asciz	 "RIG"
	.asciz	 "RIM"
	.asciz	 "RIO"
	.asciz	 "RIP"
	.asciz	 "ROB"
	.asciz	 "ROD"
	.asciz	 "ROE"
	.asciz	 "RON"
	.asciz	 "ROT"
	.asciz	 "ROW"
	.asciz	 "ROY"
	.asciz	 "RUB"
	.asciz	 "RUE"
	.asciz	 "RUG"
	.asciz	 "RUM"
	.asciz	 "RUN"
	.asciz	 "RYE"
	.asciz	 "SAC"
	.asciz	 "SAD"
	.asciz	 "SAG"
	.asciz	 "SAL"
	.asciz	 "SAM"
	.asciz	 "SAN"
	.asciz	 "SAP"
	.asciz	 "SAT"
	.asciz	 "SAW"
	.asciz	 "SAY"
	.asciz	 "SEA"
	.asciz	 "SEC"
	.asciz	 "SEE"
	.asciz	 "SEN"
	.asciz	 "SET"
	.asciz	 "SEW"
	.asciz	 "SHE"
	.asciz	 "SHY"
	.asciz	 "SIN"
	.asciz	 "SIP"
	.asciz	 "SIR"
	.asciz	 "SIS"
	.asciz	 "SIT"
	.asciz	 "SKI"
	.asciz	 "SKY"
	.asciz	 "SLY"
	.asciz	 "SO\000"
	.asciz	 "SOB"
	.asciz	 "SOD"
	.asciz	 "SON"
	.asciz	 "SOP"
	.asciz	 "SOW"
	.asciz	 "SOY"
	.asciz	 "SPA"
	.asciz	 "SPY"
	.asciz	 "SUB"
	.asciz	 "SUD"
	.asciz	 "SUE"
	.asciz	 "SUM"
	.asciz	 "SUN"
	.asciz	 "SUP"
	.asciz	 "TAB"
	.asciz	 "TAD"
	.asciz	 "TAG"
	.asciz	 "TAN"
	.asciz	 "TAP"
	.asciz	 "TAR"
	.asciz	 "TEA"
	.asciz	 "TED"
	.asciz	 "TEE"
	.asciz	 "TEN"
	.asciz	 "THE"
	.asciz	 "THY"
	.asciz	 "TIC"
	.asciz	 "TIE"
	.asciz	 "TIM"
	.asciz	 "TIN"
	.asciz	 "TIP"
	.asciz	 "TO\000"
	.asciz	 "TOE"
	.asciz	 "TOG"
	.asciz	 "TOM"
	.asciz	 "TON"
	.asciz	 "TOO"
	.asciz	 "TOP"
	.asciz	 "TOW"
	.asciz	 "TOY"
	.asciz	 "TRY"
	.asciz	 "TUB"
	.asciz	 "TUG"
	.asciz	 "TUM"
	.asciz	 "TUN"
	.asciz	 "TWO"
	.asciz	 "UN\000"
	.asciz	 "UP\000"
	.asciz	 "US\000"
	.asciz	 "USE"
	.asciz	 "VAN"
	.asciz	 "VAT"
	.asciz	 "VET"
	.asciz	 "VIE"
	.asciz	 "WAD"
	.asciz	 "WAG"
	.asciz	 "WAR"
	.asciz	 "WAS"
	.asciz	 "WAY"
	.asciz	 "WE\000"
	.asciz	 "WEB"
	.asciz	 "WED"
	.asciz	 "WEE"
	.asciz	 "WET"
	.asciz	 "WHO"
	.asciz	 "WHY"
	.asciz	 "WIN"
	.asciz	 "WIT"
	.asciz	 "WOK"
	.asciz	 "WON"
	.asciz	 "WOO"
	.asciz	 "WOW"
	.asciz	 "WRY"
	.asciz	 "WU\000"
	.asciz	 "YAM"
	.asciz	 "YAP"
	.asciz	 "YAW"
	.asciz	 "YE\000"
	.asciz	 "YEA"
	.asciz	 "YES"
	.asciz	 "YET"
	.asciz	 "YOU"
	.ascii	 "ABED"
	.ascii	 "ABEL"
	.ascii	 "ABET"
	.ascii	 "ABLE"
	.ascii	 "ABUT"
	.ascii	 "ACHE"
	.ascii	 "ACID"
	.ascii	 "ACME"
	.ascii	 "ACRE"
	.ascii	 "ACTA"
	.ascii	 "ACTS"
	.ascii	 "ADAM"
	.ascii	 "ADDS"
	.ascii	 "ADEN"
	.ascii	 "AFAR"
	.ascii	 "AFRO"
	.ascii	 "AGEE"
	.ascii	 "AHEM"
	.ascii	 "AHOY"
	.ascii	 "AIDA"
	.ascii	 "AIDE"
	.ascii	 "AIDS"
	.ascii	 "AIRY"
	.ascii	 "AJAR"
	.ascii	 "AKIN"
	.ascii	 "ALAN"
	.ascii	 "ALEC"
	.ascii	 "ALGA"
	.ascii	 "ALIA"
	.ascii	 "ALLY"
	.ascii	 "ALMA"
	.ascii	 "ALOE"
	.ascii	 "ALSO"
	.ascii	 "ALTO"
	.ascii	 "ALUM"
	.ascii	 "ALVA"
	.ascii	 "AMEN"
	.ascii	 "AMES"
	.ascii	 "AMID"
	.ascii	 "AMMO"
	.ascii	 "AMOK"
	.ascii	 "AMOS"
	.ascii	 "AMRA"
	.ascii	 "ANDY"
	.ascii	 "ANEW"
	.ascii	 "ANNA"
	.ascii	 "ANNE"
	.ascii	 "ANTE"
	.ascii	 "ANTI"
	.ascii	 "AQUA"
	.ascii	 "ARAB"
	.ascii	 "ARCH"
	.ascii	 "AREA"
	.ascii	 "ARGO"
	.ascii	 "ARID"
	.ascii	 "ARMY"
	.ascii	 "ARTS"
	.ascii	 "ARTY"
	.ascii	 "ASIA"
	.ascii	 "ASKS"
	.ascii	 "ATOM"
	.ascii	 "AUNT"
	.ascii	 "AURA"
	.ascii	 "AUTO"
	.ascii	 "AVER"
	.ascii	 "AVID"
	.ascii	 "AVIS"
	.ascii	 "AVON"
	.ascii	 "AVOW"
	.ascii	 "AWAY"
	.ascii	 "AWRY"
	.ascii	 "BABE"
	.ascii	 "BABY"
	.ascii	 "BACH"
	.ascii	 "BACK"
	.ascii	 "BADE"
	.ascii	 "BAIL"
	.ascii	 "BAIT"
	.ascii	 "BAKE"
	.ascii	 "BALD"
	.ascii	 "BALE"
	.ascii	 "BALI"
	.ascii	 "BALK"
	.ascii	 "BALL"
	.ascii	 "BALM"
	.ascii	 "BAND"
	.ascii	 "BANE"
	.ascii	 "BANG"
	.ascii	 "BANK"
	.ascii	 "BARB"
	.ascii	 "BARD"
	.ascii	 "BARE"
	.ascii	 "BARK"
	.ascii	 "BARN"
	.ascii	 "BARR"
	.ascii	 "BASE"
	.ascii	 "BASH"
	.ascii	 "BASK"
	.ascii	 "BASS"
	.ascii	 "BATE"
	.ascii	 "BATH"
	.ascii	 "BAWD"
	.ascii	 "BAWL"
	.ascii	 "BEAD"
	.ascii	 "BEAK"
	.ascii	 "BEAM"
	.ascii	 "BEAN"
	.ascii	 "BEAR"
	.ascii	 "BEAT"
	.ascii	 "BEAU"
	.ascii	 "BECK"
	.ascii	 "BEEF"
	.ascii	 "BEEN"
	.ascii	 "BEER"
	.ascii	 "BEET"
	.ascii	 "BELA"
	.ascii	 "BELL"
	.ascii	 "BELT"
	.ascii	 "BEND"
	.ascii	 "BENT"
	.ascii	 "BERG"
	.ascii	 "BERN"
	.ascii	 "BERT"
	.ascii	 "BESS"
	.ascii	 "BEST"
	.ascii	 "BETA"
	.ascii	 "BETH"
	.ascii	 "BHOY"
	.ascii	 "BIAS"
	.ascii	 "BIDE"
	.ascii	 "BIEN"
	.ascii	 "BILE"
	.ascii	 "BILK"
	.ascii	 "BILL"
	.ascii	 "BIND"
	.ascii	 "BING"
	.ascii	 "BIRD"
	.ascii	 "BITE"
	.ascii	 "BITS"
	.ascii	 "BLAB"
	.ascii	 "BLAT"
	.ascii	 "BLED"
	.ascii	 "BLEW"
	.ascii	 "BLOB"
	.ascii	 "BLOC"
	.ascii	 "BLOT"
	.ascii	 "BLOW"
	.ascii	 "BLUE"
	.ascii	 "BLUM"
	.ascii	 "BLUR"
	.ascii	 "BOAR"
	.ascii	 "BOAT"
	.ascii	 "BOCA"
	.ascii	 "BOCK"
	.ascii	 "BODE"
	.ascii	 "BODY"
	.ascii	 "BOGY"
	.ascii	 "BOHR"
	.ascii	 "BOIL"
	.ascii	 "BOLD"
	.ascii	 "BOLO"
	.ascii	 "BOLT"
	.ascii	 "BOMB"
	.ascii	 "BONA"
	.ascii	 "BOND"
	.ascii	 "BONE"
	.ascii	 "BONG"
	.ascii	 "BONN"
	.ascii	 "BONY"
	.ascii	 "BOOK"
	.ascii	 "BOOM"
	.ascii	 "BOON"
	.ascii	 "BOOT"
	.ascii	 "BORE"
	.ascii	 "BORG"
	.ascii	 "BORN"
	.ascii	 "BOSE"
	.ascii	 "BOSS"
	.ascii	 "BOTH"
	.ascii	 "BOUT"
	.ascii	 "BOWL"
	.ascii	 "BOYD"
	.ascii	 "BRAD"
	.ascii	 "BRAE"
	.ascii	 "BRAG"
	.ascii	 "BRAN"
	.ascii	 "BRAY"
	.ascii	 "BRED"
	.ascii	 "BREW"
	.ascii	 "BRIG"
	.ascii	 "BRIM"
	.ascii	 "BROW"
	.ascii	 "BUCK"
	.ascii	 "BUDD"
	.ascii	 "BUFF"
	.ascii	 "BULB"
	.ascii	 "BULK"
	.ascii	 "BULL"
	.ascii	 "BUNK"
	.ascii	 "BUNT"
	.ascii	 "BUOY"
	.ascii	 "BURG"
	.ascii	 "BURL"
	.ascii	 "BURN"
	.ascii	 "BURR"
	.ascii	 "BURT"
	.ascii	 "BURY"
	.ascii	 "BUSH"
	.ascii	 "BUSS"
	.ascii	 "BUST"
	.ascii	 "BUSY"
	.ascii	 "BYTE"
	.ascii	 "CADY"
	.ascii	 "CAFE"
	.ascii	 "CAGE"
	.ascii	 "CAIN"
	.ascii	 "CAKE"
	.ascii	 "CALF"
	.ascii	 "CALL"
	.ascii	 "CALM"
	.ascii	 "CAME"
	.ascii	 "CANE"
	.ascii	 "CANT"
	.ascii	 "CARD"
	.ascii	 "CARE"
	.ascii	 "CARL"
	.ascii	 "CARR"
	.ascii	 "CART"
	.ascii	 "CASE"
	.ascii	 "CASH"
	.ascii	 "CASK"
	.ascii	 "CAST"
	.ascii	 "CAVE"
	.ascii	 "CEIL"
	.ascii	 "CELL"
	.ascii	 "CENT"
	.ascii	 "CERN"
	.ascii	 "CHAD"
	.ascii	 "CHAR"
	.ascii	 "CHAT"
	.ascii	 "CHAW"
	.ascii	 "CHEF"
	.ascii	 "CHEN"
	.ascii	 "CHEW"
	.ascii	 "CHIC"
	.ascii	 "CHIN"
	.ascii	 "CHOU"
	.ascii	 "CHOW"
	.ascii	 "CHUB"
	.ascii	 "CHUG"
	.ascii	 "CHUM"
	.ascii	 "CITE"
	.ascii	 "CITY"
	.ascii	 "CLAD"
	.ascii	 "CLAM"
	.ascii	 "CLAN"
	.ascii	 "CLAW"
	.ascii	 "CLAY"
	.ascii	 "CLOD"
	.ascii	 "CLOG"
	.ascii	 "CLOT"
	.ascii	 "CLUB"
	.ascii	 "CLUE"
	.ascii	 "COAL"
	.ascii	 "COAT"
	.ascii	 "COCA"
	.ascii	 "COCK"
	.ascii	 "COCO"
	.ascii	 "CODA"
	.ascii	 "CODE"
	.ascii	 "CODY"
	.ascii	 "COED"
	.ascii	 "COIL"
	.ascii	 "COIN"
	.ascii	 "COKE"
	.ascii	 "COLA"
	.ascii	 "COLD"
	.ascii	 "COLT"
	.ascii	 "COMA"
	.ascii	 "COMB"
	.ascii	 "COME"
	.ascii	 "COOK"
	.ascii	 "COOL"
	.ascii	 "COON"
	.ascii	 "COOT"
	.ascii	 "CORD"
	.ascii	 "CORE"
	.ascii	 "CORK"
	.ascii	 "CORN"
	.ascii	 "COST"
	.ascii	 "COVE"
	.ascii	 "COWL"
	.ascii	 "CRAB"
	.ascii	 "CRAG"
	.ascii	 "CRAM"
	.ascii	 "CRAY"
	.ascii	 "CREW"
	.ascii	 "CRIB"
	.ascii	 "CROW"
	.ascii	 "CRUD"
	.ascii	 "CUBA"
	.ascii	 "CUBE"
	.ascii	 "CUFF"
	.ascii	 "CULL"
	.ascii	 "CULT"
	.ascii	 "CUNY"
	.ascii	 "CURB"
	.ascii	 "CURD"
	.ascii	 "CURE"
	.ascii	 "CURL"
	.ascii	 "CURT"
	.ascii	 "CUTS"
	.ascii	 "DADE"
	.ascii	 "DALE"
	.ascii	 "DAME"
	.ascii	 "DANA"
	.ascii	 "DANE"
	.ascii	 "DANG"
	.ascii	 "DANK"
	.ascii	 "DARE"
	.ascii	 "DARK"
	.ascii	 "DARN"
	.ascii	 "DART"
	.ascii	 "DASH"
	.ascii	 "DATA"
	.ascii	 "DATE"
	.ascii	 "DAVE"
	.ascii	 "DAVY"
	.ascii	 "DAWN"
	.ascii	 "DAYS"
	.ascii	 "DEAD"
	.ascii	 "DEAF"
	.ascii	 "DEAL"
	.ascii	 "DEAN"
	.ascii	 "DEAR"
	.ascii	 "DEBT"
	.ascii	 "DECK"
	.ascii	 "DEED"
	.ascii	 "DEEM"
	.ascii	 "DEER"
	.ascii	 "DEFT"
	.ascii	 "DEFY"
	.ascii	 "DELL"
	.ascii	 "DENT"
	.ascii	 "DENY"
	.ascii	 "DESK"
	.ascii	 "DIAL"
	.ascii	 "DICE"
	.ascii	 "DIED"
	.ascii	 "DIET"
	.ascii	 "DIME"
	.ascii	 "DINE"
	.ascii	 "DING"
	.ascii	 "DINT"
	.ascii	 "DIRE"
	.ascii	 "DIRT"
	.ascii	 "DISC"
	.ascii	 "DISH"
	.ascii	 "DISK"
	.ascii	 "DIVE"
	.ascii	 "DOCK"
	.ascii	 "DOES"
	.ascii	 "DOLE"
	.ascii	 "DOLL"
	.ascii	 "DOLT"
	.ascii	 "DOME"
	.ascii	 "DONE"
	.ascii	 "DOOM"
	.ascii	 "DOOR"
	.ascii	 "DORA"
	.ascii	 "DOSE"
	.ascii	 "DOTE"
	.ascii	 "DOUG"
	.ascii	 "DOUR"
	.ascii	 "DOVE"
	.ascii	 "DOWN"
	.ascii	 "DRAB"
	.ascii	 "DRAG"
	.ascii	 "DRAM"
	.ascii	 "DRAW"
	.ascii	 "DREW"
	.ascii	 "DRUB"
	.ascii	 "DRUG"
	.ascii	 "DRUM"
	.ascii	 "DUAL"
	.ascii	 "DUCK"
	.ascii	 "DUCT"
	.ascii	 "DUEL"
	.ascii	 "DUET"
	.ascii	 "DUKE"
	.ascii	 "DULL"
	.ascii	 "DUMB"
	.ascii	 "DUNE"
	.ascii	 "DUNK"
	.ascii	 "DUSK"
	.ascii	 "DUST"
	.ascii	 "DUTY"
	.ascii	 "EACH"
	.ascii	 "EARL"
	.ascii	 "EARN"
	.ascii	 "EASE"
	.ascii	 "EAST"
	.ascii	 "EASY"
	.ascii	 "EBEN"
	.ascii	 "ECHO"
	.ascii	 "EDDY"
	.ascii	 "EDEN"
	.ascii	 "EDGE"
	.ascii	 "EDGY"
	.ascii	 "EDIT"
	.ascii	 "EDNA"
	.ascii	 "EGAN"
	.ascii	 "ELAN"
	.ascii	 "ELBA"
	.ascii	 "ELLA"
	.ascii	 "ELSE"
	.ascii	 "EMIL"
	.ascii	 "EMIT"
	.ascii	 "EMMA"
	.ascii	 "ENDS"
	.ascii	 "ERIC"
	.ascii	 "EROS"
	.ascii	 "EVEN"
	.ascii	 "EVER"
	.ascii	 "EVIL"
	.ascii	 "EYED"
	.ascii	 "FACE"
	.ascii	 "FACT"
	.ascii	 "FADE"
	.ascii	 "FAIL"
	.ascii	 "FAIN"
	.ascii	 "FAIR"
	.ascii	 "FAKE"
	.ascii	 "FALL"
	.ascii	 "FAME"
	.ascii	 "FANG"
	.ascii	 "FARM"
	.ascii	 "FAST"
	.ascii	 "FATE"
	.ascii	 "FAWN"
	.ascii	 "FEAR"
	.ascii	 "FEAT"
	.ascii	 "FEED"
	.ascii	 "FEEL"
	.ascii	 "FEET"
	.ascii	 "FELL"
	.ascii	 "FELT"
	.ascii	 "FEND"
	.ascii	 "FERN"
	.ascii	 "FEST"
	.ascii	 "FEUD"
	.ascii	 "FIEF"
	.ascii	 "FIGS"
	.ascii	 "FILE"
	.ascii	 "FILL"
	.ascii	 "FILM"
	.ascii	 "FIND"
	.ascii	 "FINE"
	.ascii	 "FINK"
	.ascii	 "FIRE"
	.ascii	 "FIRM"
	.ascii	 "FISH"
	.ascii	 "FISK"
	.ascii	 "FIST"
	.ascii	 "FITS"
	.ascii	 "FIVE"
	.ascii	 "FLAG"
	.ascii	 "FLAK"
	.ascii	 "FLAM"
	.ascii	 "FLAT"
	.ascii	 "FLAW"
	.ascii	 "FLEA"
	.ascii	 "FLED"
	.ascii	 "FLEW"
	.ascii	 "FLIT"
	.ascii	 "FLOC"
	.ascii	 "FLOG"
	.ascii	 "FLOW"
	.ascii	 "FLUB"
	.ascii	 "FLUE"
	.ascii	 "FOAL"
	.ascii	 "FOAM"
	.ascii	 "FOGY"
	.ascii	 "FOIL"
	.ascii	 "FOLD"
	.ascii	 "FOLK"
	.ascii	 "FOND"
	.ascii	 "FONT"
	.ascii	 "FOOD"
	.ascii	 "FOOL"
	.ascii	 "FOOT"
	.ascii	 "FORD"
	.ascii	 "FORE"
	.ascii	 "FORK"
	.ascii	 "FORM"
	.ascii	 "FORT"
	.ascii	 "FOSS"
	.ascii	 "FOUL"
	.ascii	 "FOUR"
	.ascii	 "FOWL"
	.ascii	 "FRAU"
	.ascii	 "FRAY"
	.ascii	 "FRED"
	.ascii	 "FREE"
	.ascii	 "FRET"
	.ascii	 "FREY"
	.ascii	 "FROG"
	.ascii	 "FROM"
	.ascii	 "FUEL"
	.ascii	 "FULL"
	.ascii	 "FUME"
	.ascii	 "FUND"
	.ascii	 "FUNK"
	.ascii	 "FURY"
	.ascii	 "FUSE"
	.ascii	 "FUSS"
	.ascii	 "GAFF"
	.ascii	 "GAGE"
	.ascii	 "GAIL"
	.ascii	 "GAIN"
	.ascii	 "GAIT"
	.ascii	 "GALA"
	.ascii	 "GALE"
	.ascii	 "GALL"
	.ascii	 "GALT"
	.ascii	 "GAME"
	.ascii	 "GANG"
	.ascii	 "GARB"
	.ascii	 "GARY"
	.ascii	 "GASH"
	.ascii	 "GATE"
	.ascii	 "GAUL"
	.ascii	 "GAUR"
	.ascii	 "GAVE"
	.ascii	 "GAWK"
	.ascii	 "GEAR"
	.ascii	 "GELD"
	.ascii	 "GENE"
	.ascii	 "GENT"
	.ascii	 "GERM"
	.ascii	 "GETS"
	.ascii	 "GIBE"
	.ascii	 "GIFT"
	.ascii	 "GILD"
	.ascii	 "GILL"
	.ascii	 "GILT"
	.ascii	 "GINA"
	.ascii	 "GIRD"
	.ascii	 "GIRL"
	.ascii	 "GIST"
	.ascii	 "GIVE"
	.ascii	 "GLAD"
	.ascii	 "GLEE"
	.ascii	 "GLEN"
	.ascii	 "GLIB"
	.ascii	 "GLOB"
	.ascii	 "GLOM"
	.ascii	 "GLOW"
	.ascii	 "GLUE"
	.ascii	 "GLUM"
	.ascii	 "GLUT"
	.ascii	 "GOAD"
	.ascii	 "GOAL"
	.ascii	 "GOAT"
	.ascii	 "GOER"
	.ascii	 "GOES"
	.ascii	 "GOLD"
	.ascii	 "GOLF"
	.ascii	 "GONE"
	.ascii	 "GONG"
	.ascii	 "GOOD"
	.ascii	 "GOOF"
	.ascii	 "GORE"
	.ascii	 "GORY"
	.ascii	 "GOSH"
	.ascii	 "GOUT"
	.ascii	 "GOWN"
	.ascii	 "GRAB"
	.ascii	 "GRAD"
	.ascii	 "GRAY"
	.ascii	 "GREG"
	.ascii	 "GREW"
	.ascii	 "GREY"
	.ascii	 "GRID"
	.ascii	 "GRIM"
	.ascii	 "GRIN"
	.ascii	 "GRIT"
	.ascii	 "GROW"
	.ascii	 "GRUB"
	.ascii	 "GULF"
	.ascii	 "GULL"
	.ascii	 "GUNK"
	.ascii	 "GURU"
	.ascii	 "GUSH"
	.ascii	 "GUST"
	.ascii	 "GWEN"
	.ascii	 "GWYN"
	.ascii	 "HAAG"
	.ascii	 "HAAS"
	.ascii	 "HACK"
	.ascii	 "HAIL"
	.ascii	 "HAIR"
	.ascii	 "HALE"
	.ascii	 "HALF"
	.ascii	 "HALL"
	.ascii	 "HALO"
	.ascii	 "HALT"
	.ascii	 "HAND"
	.ascii	 "HANG"
	.ascii	 "HANK"
	.ascii	 "HANS"
	.ascii	 "HARD"
	.ascii	 "HARK"
	.ascii	 "HARM"
	.ascii	 "HART"
	.ascii	 "HASH"
	.ascii	 "HAST"
	.ascii	 "HATE"
	.ascii	 "HATH"
	.ascii	 "HAUL"
	.ascii	 "HAVE"
	.ascii	 "HAWK"
	.ascii	 "HAYS"
	.ascii	 "HEAD"
	.ascii	 "HEAL"
	.ascii	 "HEAR"
	.ascii	 "HEAT"
	.ascii	 "HEBE"
	.ascii	 "HECK"
	.ascii	 "HEED"
	.ascii	 "HEEL"
	.ascii	 "HEFT"
	.ascii	 "HELD"
	.ascii	 "HELL"
	.ascii	 "HELM"
	.ascii	 "HERB"
	.ascii	 "HERD"
	.ascii	 "HERE"
	.ascii	 "HERO"
	.ascii	 "HERS"
	.ascii	 "HESS"
	.ascii	 "HEWN"
	.ascii	 "HICK"
	.ascii	 "HIDE"
	.ascii	 "HIGH"
	.ascii	 "HIKE"
	.ascii	 "HILL"
	.ascii	 "HILT"
	.ascii	 "HIND"
	.ascii	 "HINT"
	.ascii	 "HIRE"
	.ascii	 "HISS"
	.ascii	 "HIVE"
	.ascii	 "HOBO"
	.ascii	 "HOCK"
	.ascii	 "HOFF"
	.ascii	 "HOLD"
	.ascii	 "HOLE"
	.ascii	 "HOLM"
	.ascii	 "HOLT"
	.ascii	 "HOME"
	.ascii	 "HONE"
	.ascii	 "HONK"
	.ascii	 "HOOD"
	.ascii	 "HOOF"
	.ascii	 "HOOK"
	.ascii	 "HOOT"
	.ascii	 "HORN"
	.ascii	 "HOSE"
	.ascii	 "HOST"
	.ascii	 "HOUR"
	.ascii	 "HOVE"
	.ascii	 "HOWE"
	.ascii	 "HOWL"
	.ascii	 "HOYT"
	.ascii	 "HUCK"
	.ascii	 "HUED"
	.ascii	 "HUFF"
	.ascii	 "HUGE"
	.ascii	 "HUGH"
	.ascii	 "HUGO"
	.ascii	 "HULK"
	.ascii	 "HULL"
	.ascii	 "HUNK"
	.ascii	 "HUNT"
	.ascii	 "HURD"
	.ascii	 "HURL"
	.ascii	 "HURT"
	.ascii	 "HUSH"
	.ascii	 "HYDE"
	.ascii	 "HYMN"
	.ascii	 "IBIS"
	.ascii	 "ICON"
	.ascii	 "IDEA"
	.ascii	 "IDLE"
	.ascii	 "IFFY"
	.ascii	 "INCA"
	.ascii	 "INCH"
	.ascii	 "INTO"
	.ascii	 "IONS"
	.ascii	 "IOTA"
	.ascii	 "IOWA"
	.ascii	 "IRIS"
	.ascii	 "IRMA"
	.ascii	 "IRON"
	.ascii	 "ISLE"
	.ascii	 "ITCH"
	.ascii	 "ITEM"
	.ascii	 "IVAN"
	.ascii	 "JACK"
	.ascii	 "JADE"
	.ascii	 "JAIL"
	.ascii	 "JAKE"
	.ascii	 "JANE"
	.ascii	 "JAVA"
	.ascii	 "JEAN"
	.ascii	 "JEFF"
	.ascii	 "JERK"
	.ascii	 "JESS"
	.ascii	 "JEST"
	.ascii	 "JIBE"
	.ascii	 "JILL"
	.ascii	 "JILT"
	.ascii	 "JIVE"
	.ascii	 "JOAN"
	.ascii	 "JOBS"
	.ascii	 "JOCK"
	.ascii	 "JOEL"
	.ascii	 "JOEY"
	.ascii	 "JOHN"
	.ascii	 "JOIN"
	.ascii	 "JOKE"
	.ascii	 "JOLT"
	.ascii	 "JOVE"
	.ascii	 "JUDD"
	.ascii	 "JUDE"
	.ascii	 "JUDO"
	.ascii	 "JUDY"
	.ascii	 "JUJU"
	.ascii	 "JUKE"
	.ascii	 "JULY"
	.ascii	 "JUNE"
	.ascii	 "JUNK"
	.ascii	 "JUNO"
	.ascii	 "JURY"
	.ascii	 "JUST"
	.ascii	 "JUTE"
	.ascii	 "KAHN"
	.ascii	 "KALE"
	.ascii	 "KANE"
	.ascii	 "KANT"
	.ascii	 "KARL"
	.ascii	 "KATE"
	.ascii	 "KEEL"
	.ascii	 "KEEN"
	.ascii	 "KENO"
	.ascii	 "KENT"
	.ascii	 "KERN"
	.ascii	 "KERR"
	.ascii	 "KEYS"
	.ascii	 "KICK"
	.ascii	 "KILL"
	.ascii	 "KIND"
	.ascii	 "KING"
	.ascii	 "KIRK"
	.ascii	 "KISS"
	.ascii	 "KITE"
	.ascii	 "KLAN"
	.ascii	 "KNEE"
	.ascii	 "KNEW"
	.ascii	 "KNIT"
	.ascii	 "KNOB"
	.ascii	 "KNOT"
	.ascii	 "KNOW"
	.ascii	 "KOCH"
	.ascii	 "KONG"
	.ascii	 "KUDO"
	.ascii	 "KURD"
	.ascii	 "KURT"
	.ascii	 "KYLE"
	.ascii	 "LACE"
	.ascii	 "LACK"
	.ascii	 "LACY"
	.ascii	 "LADY"
	.ascii	 "LAID"
	.ascii	 "LAIN"
	.ascii	 "LAIR"
	.ascii	 "LAKE"
	.ascii	 "LAMB"
	.ascii	 "LAME"
	.ascii	 "LAND"
	.ascii	 "LANE"
	.ascii	 "LANG"
	.ascii	 "LARD"
	.ascii	 "LARK"
	.ascii	 "LASS"
	.ascii	 "LAST"
	.ascii	 "LATE"
	.ascii	 "LAUD"
	.ascii	 "LAVA"
	.ascii	 "LAWN"
	.ascii	 "LAWS"
	.ascii	 "LAYS"
	.ascii	 "LEAD"
	.ascii	 "LEAF"
	.ascii	 "LEAK"
	.ascii	 "LEAN"
	.ascii	 "LEAR"
	.ascii	 "LEEK"
	.ascii	 "LEER"
	.ascii	 "LEFT"
	.ascii	 "LEND"
	.ascii	 "LENS"
	.ascii	 "LENT"
	.ascii	 "LEON"
	.ascii	 "LESK"
	.ascii	 "LESS"
	.ascii	 "LEST"
	.ascii	 "LETS"
	.ascii	 "LIAR"
	.ascii	 "LICE"
	.ascii	 "LICK"
	.ascii	 "LIED"
	.ascii	 "LIEN"
	.ascii	 "LIES"
	.ascii	 "LIEU"
	.ascii	 "LIFE"
	.ascii	 "LIFT"
	.ascii	 "LIKE"
	.ascii	 "LILA"
	.ascii	 "LILT"
	.ascii	 "LILY"
	.ascii	 "LIMA"
	.ascii	 "LIMB"
	.ascii	 "LIME"
	.ascii	 "LIND"
	.ascii	 "LINE"
	.ascii	 "LINK"
	.ascii	 "LINT"
	.ascii	 "LION"
	.ascii	 "LISA"
	.ascii	 "LIST"
	.ascii	 "LIVE"
	.ascii	 "LOAD"
	.ascii	 "LOAF"
	.ascii	 "LOAM"
	.ascii	 "LOAN"
	.ascii	 "LOCK"
	.ascii	 "LOFT"
	.ascii	 "LOGE"
	.ascii	 "LOIS"
	.ascii	 "LOLA"
	.ascii	 "LONE"
	.ascii	 "LONG"
	.ascii	 "LOOK"
	.ascii	 "LOON"
	.ascii	 "LOOT"
	.ascii	 "LORD"
	.ascii	 "LORE"
	.ascii	 "LOSE"
	.ascii	 "LOSS"
	.ascii	 "LOST"
	.ascii	 "LOUD"
	.ascii	 "LOVE"
	.ascii	 "LOWE"
	.ascii	 "LUCK"
	.ascii	 "LUCY"
	.ascii	 "LUGE"
	.ascii	 "LUKE"
	.ascii	 "LULU"
	.ascii	 "LUND"
	.ascii	 "LUNG"
	.ascii	 "LURA"
	.ascii	 "LURE"
	.ascii	 "LURK"
	.ascii	 "LUSH"
	.ascii	 "LUST"
	.ascii	 "LYLE"
	.ascii	 "LYNN"
	.ascii	 "LYON"
	.ascii	 "LYRA"
	.ascii	 "MACE"
	.ascii	 "MADE"
	.ascii	 "MAGI"
	.ascii	 "MAID"
	.ascii	 "MAIL"
	.ascii	 "MAIN"
	.ascii	 "MAKE"
	.ascii	 "MALE"
	.ascii	 "MALI"
	.ascii	 "MALL"
	.ascii	 "MALT"
	.ascii	 "MANA"
	.ascii	 "MANN"
	.ascii	 "MANY"
	.ascii	 "MARC"
	.ascii	 "MARE"
	.ascii	 "MARK"
	.ascii	 "MARS"
	.ascii	 "MART"
	.ascii	 "MARY"
	.ascii	 "MASH"
	.ascii	 "MASK"
	.ascii	 "MASS"
	.ascii	 "MAST"
	.ascii	 "MATE"
	.ascii	 "MATH"
	.ascii	 "MAUL"
	.ascii	 "MAYO"
	.ascii	 "MEAD"
	.ascii	 "MEAL"
	.ascii	 "MEAN"
	.ascii	 "MEAT"
	.ascii	 "MEEK"
	.ascii	 "MEET"
	.ascii	 "MELD"
	.ascii	 "MELT"
	.ascii	 "MEMO"
	.ascii	 "MEND"
	.ascii	 "MENU"
	.ascii	 "MERT"
	.ascii	 "MESH"
	.ascii	 "MESS"
	.ascii	 "MICE"
	.ascii	 "MIKE"
	.ascii	 "MILD"
	.ascii	 "MILE"
	.ascii	 "MILK"
	.ascii	 "MILL"
	.ascii	 "MILT"
	.ascii	 "MIMI"
	.ascii	 "MIND"
	.ascii	 "MINE"
	.ascii	 "MINI"
	.ascii	 "MINK"
	.ascii	 "MINT"
	.ascii	 "MIRE"
	.ascii	 "MISS"
	.ascii	 "MIST"
	.ascii	 "MITE"
	.ascii	 "MITT"
	.ascii	 "MOAN"
	.ascii	 "MOAT"
	.ascii	 "MOCK"
	.ascii	 "MODE"
	.ascii	 "MOLD"
	.ascii	 "MOLE"
	.ascii	 "MOLL"
	.ascii	 "MOLT"
	.ascii	 "MONA"
	.ascii	 "MONK"
	.ascii	 "MONT"
	.ascii	 "MOOD"
	.ascii	 "MOON"
	.ascii	 "MOOR"
	.ascii	 "MOOT"
	.ascii	 "MORE"
	.ascii	 "MORN"
	.ascii	 "MORT"
	.ascii	 "MOSS"
	.ascii	 "MOST"
	.ascii	 "MOTH"
	.ascii	 "MOVE"
	.ascii	 "MUCH"
	.ascii	 "MUCK"
	.ascii	 "MUDD"
	.ascii	 "MUFF"
	.ascii	 "MULE"
	.ascii	 "MULL"
	.ascii	 "MURK"
	.ascii	 "MUSH"
	.ascii	 "MUST"
	.ascii	 "MUTE"
	.ascii	 "MUTT"
	.ascii	 "MYRA"
	.ascii	 "MYTH"
	.ascii	 "NAGY"
	.ascii	 "NAIL"
	.ascii	 "NAIR"
	.ascii	 "NAME"
	.ascii	 "NARY"
	.ascii	 "NASH"
	.ascii	 "NAVE"
	.ascii	 "NAVY"
	.ascii	 "NEAL"
	.ascii	 "NEAR"
	.ascii	 "NEAT"
	.ascii	 "NECK"
	.ascii	 "NEED"
	.ascii	 "NEIL"
	.ascii	 "NELL"
	.ascii	 "NEON"
	.ascii	 "NERO"
	.ascii	 "NESS"
	.ascii	 "NEST"
	.ascii	 "NEWS"
	.ascii	 "NEWT"
	.ascii	 "NIBS"
	.ascii	 "NICE"
	.ascii	 "NICK"
	.ascii	 "NILE"
	.ascii	 "NINA"
	.ascii	 "NINE"
	.ascii	 "NOAH"
	.ascii	 "NODE"
	.ascii	 "NOEL"
	.ascii	 "NOLL"
	.ascii	 "NONE"
	.ascii	 "NOOK"
	.ascii	 "NOON"
	.ascii	 "NORM"
	.ascii	 "NOSE"
	.ascii	 "NOTE"
	.ascii	 "NOUN"
	.ascii	 "NOVA"
	.ascii	 "NUDE"
	.ascii	 "NULL"
	.ascii	 "NUMB"
	.ascii	 "OATH"
	.ascii	 "OBEY"
	.ascii	 "OBOE"
	.ascii	 "ODIN"
	.ascii	 "OHIO"
	.ascii	 "OILY"
	.ascii	 "OINT"
	.ascii	 "OKAY"
	.ascii	 "OLAF"
	.ascii	 "OLDY"
	.ascii	 "OLGA"
	.ascii	 "OLIN"
	.ascii	 "OMAN"
	.ascii	 "OMEN"
	.ascii	 "OMIT"
	.ascii	 "ONCE"
	.ascii	 "ONES"
	.ascii	 "ONLY"
	.ascii	 "ONTO"
	.ascii	 "ONUS"
	.ascii	 "ORAL"
	.ascii	 "ORGY"
	.ascii	 "OSLO"
	.ascii	 "OTIS"
	.ascii	 "OTTO"
	.ascii	 "OUCH"
	.ascii	 "OUST"
	.ascii	 "OUTS"
	.ascii	 "OVAL"
	.ascii	 "OVEN"
	.ascii	 "OVER"
	.ascii	 "OWLY"
	.ascii	 "OWNS"
	.ascii	 "QUAD"
	.ascii	 "QUIT"
	.ascii	 "QUOD"
	.ascii	 "RACE"
	.ascii	 "RACK"
	.ascii	 "RACY"
	.ascii	 "RAFT"
	.ascii	 "RAGE"
	.ascii	 "RAID"
	.ascii	 "RAIL"
	.ascii	 "RAIN"
	.ascii	 "RAKE"
	.ascii	 "RANK"
	.ascii	 "RANT"
	.ascii	 "RARE"
	.ascii	 "RASH"
	.ascii	 "RATE"
	.ascii	 "RAVE"
	.ascii	 "RAYS"
	.ascii	 "READ"
	.ascii	 "REAL"
	.ascii	 "REAM"
	.ascii	 "REAR"
	.ascii	 "RECK"
	.ascii	 "REED"
	.ascii	 "REEF"
	.ascii	 "REEK"
	.ascii	 "REEL"
	.ascii	 "REID"
	.ascii	 "REIN"
	.ascii	 "RENA"
	.ascii	 "REND"
	.ascii	 "RENT"
	.ascii	 "REST"
	.ascii	 "RICE"
	.ascii	 "RICH"
	.ascii	 "RICK"
	.ascii	 "RIDE"
	.ascii	 "RIFT"
	.ascii	 "RILL"
	.ascii	 "RIME"
	.ascii	 "RING"
	.ascii	 "RINK"
	.ascii	 "RISE"
	.ascii	 "RISK"
	.ascii	 "RITE"
	.ascii	 "ROAD"
	.ascii	 "ROAM"
	.ascii	 "ROAR"
	.ascii	 "ROBE"
	.ascii	 "ROCK"
	.ascii	 "RODE"
	.ascii	 "ROIL"
	.ascii	 "ROLL"
	.ascii	 "ROME"
	.ascii	 "ROOD"
	.ascii	 "ROOF"
	.ascii	 "ROOK"
	.ascii	 "ROOM"
	.ascii	 "ROOT"
	.ascii	 "ROSA"
	.ascii	 "ROSE"
	.ascii	 "ROSS"
	.ascii	 "ROSY"
	.ascii	 "ROTH"
	.ascii	 "ROUT"
	.ascii	 "ROVE"
	.ascii	 "ROWE"
	.ascii	 "ROWS"
	.ascii	 "RUBE"
	.ascii	 "RUBY"
	.ascii	 "RUDE"
	.ascii	 "RUDY"
	.ascii	 "RUIN"
	.ascii	 "RULE"
	.ascii	 "RUNG"
	.ascii	 "RUNS"
	.ascii	 "RUNT"
	.ascii	 "RUSE"
	.ascii	 "RUSH"
	.ascii	 "RUSK"
	.ascii	 "RUSS"
	.ascii	 "RUST"
	.ascii	 "RUTH"
	.ascii	 "SACK"
	.ascii	 "SAFE"
	.ascii	 "SAGE"
	.ascii	 "SAID"
	.ascii	 "SAIL"
	.ascii	 "SALE"
	.ascii	 "SALK"
	.ascii	 "SALT"
	.ascii	 "SAME"
	.ascii	 "SAND"
	.ascii	 "SANE"
	.ascii	 "SANG"
	.ascii	 "SANK"
	.ascii	 "SARA"
	.ascii	 "SAUL"
	.ascii	 "SAVE"
	.ascii	 "SAYS"
	.ascii	 "SCAN"
	.ascii	 "SCAR"
	.ascii	 "SCAT"
	.ascii	 "SCOT"
	.ascii	 "SEAL"
	.ascii	 "SEAM"
	.ascii	 "SEAR"
	.ascii	 "SEAT"
	.ascii	 "SEED"
	.ascii	 "SEEK"
	.ascii	 "SEEM"
	.ascii	 "SEEN"
	.ascii	 "SEES"
	.ascii	 "SELF"
	.ascii	 "SELL"
	.ascii	 "SEND"
	.ascii	 "SENT"
	.ascii	 "SETS"
	.ascii	 "SEWN"
	.ascii	 "SHAG"
	.ascii	 "SHAM"
	.ascii	 "SHAW"
	.ascii	 "SHAY"
	.ascii	 "SHED"
	.ascii	 "SHIM"
	.ascii	 "SHIN"
	.ascii	 "SHOD"
	.ascii	 "SHOE"
	.ascii	 "SHOT"
	.ascii	 "SHOW"
	.ascii	 "SHUN"
	.ascii	 "SHUT"
	.ascii	 "SICK"
	.ascii	 "SIDE"
	.ascii	 "SIFT"
	.ascii	 "SIGH"
	.ascii	 "SIGN"
	.ascii	 "SILK"
	.ascii	 "SILL"
	.ascii	 "SILO"
	.ascii	 "SILT"
	.ascii	 "SINE"
	.ascii	 "SING"
	.ascii	 "SINK"
	.ascii	 "SIRE"
	.ascii	 "SITE"
	.ascii	 "SITS"
	.ascii	 "SITU"
	.ascii	 "SKAT"
	.ascii	 "SKEW"
	.ascii	 "SKID"
	.ascii	 "SKIM"
	.ascii	 "SKIN"
	.ascii	 "SKIT"
	.ascii	 "SLAB"
	.ascii	 "SLAM"
	.ascii	 "SLAT"
	.ascii	 "SLAY"
	.ascii	 "SLED"
	.ascii	 "SLEW"
	.ascii	 "SLID"
	.ascii	 "SLIM"
	.ascii	 "SLIT"
	.ascii	 "SLOB"
	.ascii	 "SLOG"
	.ascii	 "SLOT"
	.ascii	 "SLOW"
	.ascii	 "SLUG"
	.ascii	 "SLUM"
	.ascii	 "SLUR"
	.ascii	 "SMOG"
	.ascii	 "SMUG"
	.ascii	 "SNAG"
	.ascii	 "SNOB"
	.ascii	 "SNOW"
	.ascii	 "SNUB"
	.ascii	 "SNUG"
	.ascii	 "SOAK"
	.ascii	 "SOAR"
	.ascii	 "SOCK"
	.ascii	 "SODA"
	.ascii	 "SOFA"
	.ascii	 "SOFT"
	.ascii	 "SOIL"
	.ascii	 "SOLD"
	.ascii	 "SOME"
	.ascii	 "SONG"
	.ascii	 "SOON"
	.ascii	 "SOOT"
	.ascii	 "SORE"
	.ascii	 "SORT"
	.ascii	 "SOUL"
	.ascii	 "SOUR"
	.ascii	 "SOWN"
	.ascii	 "STAB"
	.ascii	 "STAG"
	.ascii	 "STAN"
	.ascii	 "STAR"
	.ascii	 "STAY"
	.ascii	 "STEM"
	.ascii	 "STEW"
	.ascii	 "STIR"
	.ascii	 "STOW"
	.ascii	 "STUB"
	.ascii	 "STUN"
	.ascii	 "SUCH"
	.ascii	 "SUDS"
	.ascii	 "SUIT"
	.ascii	 "SULK"
	.ascii	 "SUMS"
	.ascii	 "SUNG"
	.ascii	 "SUNK"
	.ascii	 "SURE"
	.ascii	 "SURF"
	.ascii	 "SWAB"
	.ascii	 "SWAG"
	.ascii	 "SWAM"
	.ascii	 "SWAN"
	.ascii	 "SWAT"
	.ascii	 "SWAY"
	.ascii	 "SWIM"
	.ascii	 "SWUM"
	.ascii	 "TACK"
	.ascii	 "TACT"
	.ascii	 "TAIL"
	.ascii	 "TAKE"
	.ascii	 "TALE"
	.ascii	 "TALK"
	.ascii	 "TALL"
	.ascii	 "TANK"
	.ascii	 "TASK"
	.ascii	 "TATE"
	.ascii	 "TAUT"
	.ascii	 "TEAL"
	.ascii	 "TEAM"
	.ascii	 "TEAR"
	.ascii	 "TECH"
	.ascii	 "TEEM"
	.ascii	 "TEEN"
	.ascii	 "TEET"
	.ascii	 "TELL"
	.ascii	 "TEND"
	.ascii	 "TENT"
	.ascii	 "TERM"
	.ascii	 "TERN"
	.ascii	 "TESS"
	.ascii	 "TEST"
	.ascii	 "THAN"
	.ascii	 "THAT"
	.ascii	 "THEE"
	.ascii	 "THEM"
	.ascii	 "THEN"
	.ascii	 "THEY"
	.ascii	 "THIN"
	.ascii	 "THIS"
	.ascii	 "THUD"
	.ascii	 "THUG"
	.ascii	 "TICK"
	.ascii	 "TIDE"
	.ascii	 "TIDY"
	.ascii	 "TIED"
	.ascii	 "TIER"
	.ascii	 "TILE"
	.ascii	 "TILL"
	.ascii	 "TILT"
	.ascii	 "TIME"
	.ascii	 "TINA"
	.ascii	 "TINE"
	.ascii	 "TINT"
	.ascii	 "TINY"
	.ascii	 "TIRE"
	.ascii	 "TOAD"
	.ascii	 "TOGO"
	.ascii	 "TOIL"
	.ascii	 "TOLD"
	.ascii	 "TOLL"
	.ascii	 "TONE"
	.ascii	 "TONG"
	.ascii	 "TONY"
	.ascii	 "TOOK"
	.ascii	 "TOOL"
	.ascii	 "TOOT"
	.ascii	 "TORE"
	.ascii	 "TORN"
	.ascii	 "TOTE"
	.ascii	 "TOUR"
	.ascii	 "TOUT"
	.ascii	 "TOWN"
	.ascii	 "TRAG"
	.ascii	 "TRAM"
	.ascii	 "TRAY"
	.ascii	 "TREE"
	.ascii	 "TREK"
	.ascii	 "TRIG"
	.ascii	 "TRIM"
	.ascii	 "TRIO"
	.ascii	 "TROD"
	.ascii	 "TROT"
	.ascii	 "TROY"
	.ascii	 "TRUE"
	.ascii	 "TUBA"
	.ascii	 "TUBE"
	.ascii	 "TUCK"
	.ascii	 "TUFT"
	.ascii	 "TUNA"
	.ascii	 "TUNE"
	.ascii	 "TUNG"
	.ascii	 "TURF"
	.ascii	 "TURN"
	.ascii	 "TUSK"
	.ascii	 "TWIG"
	.ascii	 "TWIN"
	.ascii	 "TWIT"
	.ascii	 "ULAN"
	.ascii	 "UNIT"
	.ascii	 "URGE"
	.ascii	 "USED"
	.ascii	 "USER"
	.ascii	 "USES"
	.ascii	 "UTAH"
	.ascii	 "VAIL"
	.ascii	 "VAIN"
	.ascii	 "VALE"
	.ascii	 "VARY"
	.ascii	 "VASE"
	.ascii	 "VAST"
	.ascii	 "VEAL"
	.ascii	 "VEDA"
	.ascii	 "VEIL"
	.ascii	 "VEIN"
	.ascii	 "VEND"
	.ascii	 "VENT"
	.ascii	 "VERB"
	.ascii	 "VERY"
	.ascii	 "VETO"
	.ascii	 "VICE"
	.ascii	 "VIEW"
	.ascii	 "VINE"
	.ascii	 "VISE"
	.ascii	 "VOID"
	.ascii	 "VOLT"
	.ascii	 "VOTE"
	.ascii	 "WACK"
	.ascii	 "WADE"
	.ascii	 "WAGE"
	.ascii	 "WAIL"
	.ascii	 "WAIT"
	.ascii	 "WAKE"
	.ascii	 "WALE"
	.ascii	 "WALK"
	.ascii	 "WALL"
	.ascii	 "WALT"
	.ascii	 "WAND"
	.ascii	 "WANE"
	.ascii	 "WANG"
	.ascii	 "WANT"
	.ascii	 "WARD"
	.ascii	 "WARM"
	.ascii	 "WARN"
	.ascii	 "WART"
	.ascii	 "WASH"
	.ascii	 "WAST"
	.ascii	 "WATS"
	.ascii	 "WATT"
	.ascii	 "WAVE"
	.ascii	 "WAVY"
	.ascii	 "WAYS"
	.ascii	 "WEAK"
	.ascii	 "WEAL"
	.ascii	 "WEAN"
	.ascii	 "WEAR"
	.ascii	 "WEED"
	.ascii	 "WEEK"
	.ascii	 "WEIR"
	.ascii	 "WELD"
	.ascii	 "WELL"
	.ascii	 "WELT"
	.ascii	 "WENT"
	.ascii	 "WERE"
	.ascii	 "WERT"
	.ascii	 "WEST"
	.ascii	 "WHAM"
	.ascii	 "WHAT"
	.ascii	 "WHEE"
	.ascii	 "WHEN"
	.ascii	 "WHET"
	.ascii	 "WHOA"
	.ascii	 "WHOM"
	.ascii	 "WICK"
	.ascii	 "WIFE"
	.ascii	 "WILD"
	.ascii	 "WILL"
	.ascii	 "WIND"
	.ascii	 "WINE"
	.ascii	 "WING"
	.ascii	 "WINK"
	.ascii	 "WINO"
	.ascii	 "WIRE"
	.ascii	 "WISE"
	.ascii	 "WISH"
	.ascii	 "WITH"
	.ascii	 "WOLF"
	.ascii	 "WONT"
	.ascii	 "WOOD"
	.ascii	 "WOOL"
	.ascii	 "WORD"
	.ascii	 "WORE"
	.ascii	 "WORK"
	.ascii	 "WORM"
	.ascii	 "WORN"
	.ascii	 "WOVE"
	.ascii	 "WRIT"
	.ascii	 "WYNN"
	.ascii	 "YALE"
	.ascii	 "YANG"
	.ascii	 "YANK"
	.ascii	 "YARD"
	.ascii	 "YARN"
	.ascii	 "YAWL"
	.ascii	 "YAWN"
	.ascii	 "YEAH"
	.ascii	 "YEAR"
	.ascii	 "YELL"
	.ascii	 "YOGA"
	.ascii	 "YOKE"
	.size	Wp, 8192

	.type	.L.str307,@object       # @.str307
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str307:
	.asciz	 "wrote `%s' to STORE\n"
	.size	.L.str307, 21

	.type	prime_size.primes,@object # @prime_size.primes
	.section	.rodata,"a",@progbits
	.align	4
prime_size.primes:
	.long	13                      # 0xd
	.long	19                      # 0x13
	.long	29                      # 0x1d
	.long	41                      # 0x29
	.long	59                      # 0x3b
	.long	79                      # 0x4f
	.long	107                     # 0x6b
	.long	149                     # 0x95
	.long	197                     # 0xc5
	.long	263                     # 0x107
	.long	347                     # 0x15b
	.long	457                     # 0x1c9
	.long	599                     # 0x257
	.long	787                     # 0x313
	.long	1031                    # 0x407
	.long	1361                    # 0x551
	.long	1777                    # 0x6f1
	.long	2333                    # 0x91d
	.long	3037                    # 0xbdd
	.long	3967                    # 0xf7f
	.long	5167                    # 0x142f
	.long	6719                    # 0x1a3f
	.long	8737                    # 0x2221
	.long	11369                   # 0x2c69
	.long	14783                   # 0x39bf
	.long	19219                   # 0x4b13
	.long	24989                   # 0x619d
	.long	32491                   # 0x7eeb
	.long	42257                   # 0xa511
	.long	54941                   # 0xd69d
	.long	71429                   # 0x11705
	.long	92861                   # 0x16abd
	.long	120721                  # 0x1d791
	.long	156941                  # 0x2650d
	.long	204047                  # 0x31d0f
	.long	265271                  # 0x40c37
	.long	344857                  # 0x54319
	.long	448321                  # 0x6d741
	.long	582821                  # 0x8e4a5
	.long	757693                  # 0xb8fbd
	.long	985003                  # 0xf07ab
	.long	1280519                 # 0x138a07
	.long	1664681                 # 0x1966a9
	.long	2164111                 # 0x21058f
	.long	2813353                 # 0x2aeda9
	.long	3657361                 # 0x37ce91
	.long	4754591                 # 0x488c9f
	.long	6180989                 # 0x5e507d
	.long	8035301                 # 0x7a9be5
	.long	10445899                # 0x9f644b
	.long	13579681                # 0xcf35a1
	.long	17653589                # 0x10d5f55
	.long	22949669                # 0x15e2f25
	.long	29834603                # 0x1c73d6b
	.long	38784989                # 0x24fcfdd
	.long	50420551                # 0x3015b47
	.long	65546729                # 0x3e829e9
	.long	85210757                # 0x5143685
	.long	110774011               # 0x69a46fb
	.long	144006217               # 0x8955c49
	.long	187208107               # 0xb2891ab
	.long	243370577               # 0xe818a51
	.long	316381771               # 0x12db9a4b
	.long	411296309               # 0x1883e235
	.long	534685237               # 0x1fdea635
	.long	695090819               # 0x296e3e83
	.long	903618083               # 0x35dc1e23
	.long	1174703521              # 0x46048da1
	.long	1527114613              # 0x5b05eb75
	.long	1837299131              # 0x6d82f5bb
	.long	2147483647              # 0x7fffffff
	.size	prime_size.primes, 284

	.type	.L.str337,@object       # @.str337
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str337:
	.asciz	 "pos >= al->faulty && pos < al->count"
	.size	.L.str337, 37

	.type	.L.str1338,@object      # @.str1338
.L.str1338:
	.asciz	 "host.c"
	.size	.L.str1338, 7

	.type	.L__PRETTY_FUNCTION__.address_list_address_at,@object # @__PRETTY_FUNCTION__.address_list_address_at
.L__PRETTY_FUNCTION__.address_list_address_at:
	.asciz	 "const ip_address *address_list_address_at(const struct address_list *, int)"
	.size	.L__PRETTY_FUNCTION__.address_list_address_at, 76

	.type	.L.str2339,@object      # @.str2339
.L.str2339:
	.asciz	 "index == al->faulty"
	.size	.L.str2339, 20

	.type	.L__PRETTY_FUNCTION__.address_list_set_faulty,@object # @__PRETTY_FUNCTION__.address_list_set_faulty
.L__PRETTY_FUNCTION__.address_list_set_faulty:
	.asciz	 "void address_list_set_faulty(struct address_list *, int)"
	.size	.L__PRETTY_FUNCTION__.address_list_set_faulty, 57

	.type	.L.str3340,@object      # @.str3340
.L.str3340:
	.asciz	 "Releasing 0x%0*lx (new refcount %d).\n"
	.size	.L.str3340, 38

	.type	.L.str4341,@object      # @.str4341
.L.str4341:
	.asciz	 "Deleting unused 0x%0*lx.\n"
	.size	.L.str4341, 26

	.type	print_address.buf,@object # @print_address.buf
	.local	print_address.buf
	.comm	print_address.buf,64,1
	.type	.L.str5342,@object      # @.str5342
.L.str5342:
	.asciz	 "<error: %s>"
	.size	.L.str5342, 12

	.type	.L.str6343,@object      # @.str6343
.L.str6343:
	.asciz	 "Resolving %s... "
	.size	.L.str6343, 17

	.type	.L.str7344,@object      # @.str7344
.L.str7344:
	.asciz	 "failed: %s.\n"
	.size	.L.str7344, 13

	.type	.L.str8345,@object      # @.str8345
.L.str8345:
	.asciz	 "failed: No IPv4/IPv6 addresses for host.\n"
	.size	.L.str8345, 42

	.type	.L.str9346,@object      # @.str9346
.L.str9346:
	.asciz	 ", "
	.size	.L.str9346, 3

	.type	.L.str10347,@object     # @.str10347
.L.str10347:
	.asciz	 ", ..."
	.size	.L.str10347, 6

	.type	.L.str11348,@object     # @.str11348
.L.str11348:
	.asciz	 "\n"
	.size	.L.str11348, 2

	.type	.L.str12349,@object     # @.str12349
.L.str12349:
	.asciz	 "u->host != ((void*)0)"
	.size	.L.str12349, 22

	.type	.L__PRETTY_FUNCTION__.accept_domain,@object # @__PRETTY_FUNCTION__.accept_domain
.L__PRETTY_FUNCTION__.accept_domain:
	.asciz	 "_Bool accept_domain(struct url *)"
	.size	.L__PRETTY_FUNCTION__.accept_domain, 34

	.type	host_name_addresses_map,@object # @host_name_addresses_map
	.local	host_name_addresses_map
	.comm	host_name_addresses_map,4,4
	.type	.L.str13350,@object     # @.str13350
.L.str13350:
	.asciz	 "al->refcount == 1"
	.size	.L.str13350, 18

	.type	.L__PRETTY_FUNCTION__.host_cleanup,@object # @__PRETTY_FUNCTION__.host_cleanup
.L__PRETTY_FUNCTION__.host_cleanup:
	.asciz	 "void host_cleanup()"
	.size	.L__PRETTY_FUNCTION__.host_cleanup, 20

	.type	.L.str14351,@object     # @.str14351
.L.str14351:
	.asciz	 "Caching %s =>"
	.size	.L.str14351, 14

	.type	.L.str15352,@object     # @.str15352
.L.str15352:
	.asciz	 " %s"
	.size	.L.str15352, 4

	.type	.L.str16353,@object     # @.str16353
.L.str16353:
	.asciz	 "ip - al->addresses == cnt"
	.size	.L.str16353, 26

	.type	.L__PRETTY_FUNCTION__.address_list_from_addrinfo,@object # @__PRETTY_FUNCTION__.address_list_from_addrinfo
.L__PRETTY_FUNCTION__.address_list_from_addrinfo:
	.asciz	 "struct address_list *address_list_from_addrinfo(const struct addrinfo *)"
	.size	.L__PRETTY_FUNCTION__.address_list_from_addrinfo, 73

	.type	.L.str17354,@object     # @.str17354
.L.str17354:
	.asciz	 "Found %s in host_name_addresses_map (%p)\n"
	.size	.L.str17354, 42

	.type	.L.str371,@object       # @.str371
.L.str371:
	.asciz	 "to - (pool->contents + pool->tail) <= end - beg"
	.size	.L.str371, 48

	.type	.L.str1372,@object      # @.str1372
.L.str1372:
	.asciz	 "html-parse.c"
	.size	.L.str1372, 13

	.type	.L__PRETTY_FUNCTION__.convert_and_copy,@object # @__PRETTY_FUNCTION__.convert_and_copy
.L__PRETTY_FUNCTION__.convert_and_copy:
	.asciz	 "void convert_and_copy(struct pool *, const char *, const char *, int)"
	.size	.L__PRETTY_FUNCTION__.convert_and_copy, 70

	.type	.L.str2373,@object      # @.str2373
.L.str2373:
	.asciz	 "ch == '\\'' || ch == 0x22"
	.size	.L.str2373, 25

	.type	.L__PRETTY_FUNCTION__.advance_declaration,@object # @__PRETTY_FUNCTION__.advance_declaration
.L__PRETTY_FUNCTION__.advance_declaration:
	.asciz	 "const char *advance_declaration(const char *, const char *)"
	.size	.L__PRETTY_FUNCTION__.advance_declaration, 60

	.type	.L.str3374,@object      # @.str3374
.L.str3374:
	.asciz	 "ch == quote_char"
	.size	.L.str3374, 17

	.type	.L.str4375,@object      # @.str4375
.L.str4375:
	.asciz	 "ch == '-'"
	.size	.L.str4375, 10

	.type	.L.str376,@object       # @.str376
.L.str376:
	.asciz	 "%s: %s\n"
	.size	.L.str376, 8

	.type	.L.str1377,@object      # @.str1377
.L.str1377:
	.asciz	 "Loaded %s (size %s).\n"
	.size	.L.str1377, 22

	.type	interesting_tags,@object # @interesting_tags
	.local	interesting_tags
	.comm	interesting_tags,4,4
	.type	interesting_attributes,@object # @interesting_attributes
	.local	interesting_attributes
	.comm	interesting_attributes,4,4
	.type	.L.str2378,@object      # @.str2378
.L.str2378:
	.asciz	 "no-follow in %s: %d\n"
	.size	.L.str2378, 21

	.type	.L.str3379,@object      # @.str3379
.L.str3379:
	.asciz	 "%s: Invalid URL %s: %s\n"
	.size	.L.str3379, 24

	.type	.L.str4380,@object      # @.str4380
.L.str4380:
	.asciz	 "t != ((void*)0)"
	.size	.L.str4380, 16

	.type	.L.str5381,@object      # @.str5381
.L.str5381:
	.asciz	 "html-url.c"
	.size	.L.str5381, 11

	.type	.L__PRETTY_FUNCTION__.collect_tags_mapper,@object # @__PRETTY_FUNCTION__.collect_tags_mapper
.L__PRETTY_FUNCTION__.collect_tags_mapper:
	.asciz	 "void collect_tags_mapper(struct taginfo *, void *)"
	.size	.L__PRETTY_FUNCTION__.collect_tags_mapper, 51

	.type	known_tags,@object      # @known_tags
	.data
	.align	4
known_tags:
	.long	0                       # 0x0
	.long	.L.str18394
	.long	tag_find_urls
	.long	1                       # 0x1
	.long	.L.str19395
	.long	tag_find_urls
	.long	2                       # 0x2
	.long	.L.str20396
	.long	tag_find_urls
	.long	3                       # 0x3
	.long	.L.str21397
	.long	tag_handle_base
	.long	4                       # 0x4
	.long	.L.str22398
	.long	tag_find_urls
	.long	5                       # 0x5
	.long	.L.str23399
	.long	tag_find_urls
	.long	6                       # 0x6
	.long	.L.str24400
	.long	tag_find_urls
	.long	7                       # 0x7
	.long	.L.str25401
	.long	tag_find_urls
	.long	8                       # 0x8
	.long	.L.str26402
	.long	tag_handle_form
	.long	9                       # 0x9
	.long	.L.str27403
	.long	tag_find_urls
	.long	10                      # 0xa
	.long	.L.str28404
	.long	tag_find_urls
	.long	11                      # 0xb
	.long	.L.str29405
	.long	tag_find_urls
	.long	12                      # 0xc
	.long	.L.str30406
	.long	tag_find_urls
	.long	13                      # 0xd
	.long	.L.str31407
	.long	tag_find_urls
	.long	14                      # 0xe
	.long	.L.str32408
	.long	tag_handle_link
	.long	15                      # 0xf
	.long	.L.str33409
	.long	tag_handle_meta
	.long	16                      # 0x10
	.long	.L.str34410
	.long	tag_find_urls
	.long	17                      # 0x11
	.long	.L.str35411
	.long	tag_find_urls
	.long	18                      # 0x12
	.long	.L.str36412
	.long	tag_find_urls
	.long	19                      # 0x13
	.long	.L.str37413
	.long	tag_find_urls
	.long	20                      # 0x14
	.long	.L.str38414
	.long	tag_find_urls
	.long	21                      # 0x15
	.long	.L.str39415
	.long	tag_find_urls
	.size	known_tags, 264

	.type	.L.str6382,@object      # @.str6382
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str6382:
	.asciz	 "1"
	.size	.L.str6382, 2

	.type	tag_url_attributes,@object # @tag_url_attributes
	.section	.rodata,"a",@progbits
	.align	4
tag_url_attributes:
	.long	0                       # 0x0
	.long	.L.str7383
	.long	2                       # 0x2
	.long	1                       # 0x1
	.long	.L.str8384
	.long	1                       # 0x1
	.long	2                       # 0x2
	.long	.L.str7383
	.long	2                       # 0x2
	.long	4                       # 0x4
	.long	.L.str9385
	.long	1                       # 0x1
	.long	5                       # 0x5
	.long	.L.str10386
	.long	1                       # 0x1
	.long	6                       # 0x6
	.long	.L.str7383
	.long	2                       # 0x2
	.long	6                       # 0x6
	.long	.L.str9385
	.long	3                       # 0x3
	.long	7                       # 0x7
	.long	.L.str9385
	.long	1                       # 0x1
	.long	9                       # 0x9
	.long	.L.str9385
	.long	3                       # 0x3
	.long	10                      # 0xa
	.long	.L.str9385
	.long	3                       # 0x3
	.long	11                      # 0xb
	.long	.L.str7383
	.long	1                       # 0x1
	.long	11                      # 0xb
	.long	.L.str11387
	.long	1                       # 0x1
	.long	11                      # 0xb
	.long	.L.str9385
	.long	1                       # 0x1
	.long	12                      # 0xc
	.long	.L.str9385
	.long	1                       # 0x1
	.long	13                      # 0xd
	.long	.L.str9385
	.long	3                       # 0x3
	.long	16                      # 0x10
	.long	.L.str12388
	.long	1                       # 0x1
	.long	17                      # 0x11
	.long	.L.str9385
	.long	3                       # 0x3
	.long	18                      # 0x12
	.long	.L.str9385
	.long	1                       # 0x1
	.long	19                      # 0x13
	.long	.L.str10386
	.long	1                       # 0x1
	.long	20                      # 0x14
	.long	.L.str10386
	.long	1                       # 0x1
	.long	21                      # 0x15
	.long	.L.str10386
	.long	1                       # 0x1
	.size	tag_url_attributes, 252

	.type	.L.str7383,@object      # @.str7383
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str7383:
	.asciz	 "href"
	.size	.L.str7383, 5

	.type	.L.str8384,@object      # @.str8384
.L.str8384:
	.asciz	 "code"
	.size	.L.str8384, 5

	.type	.L.str9385,@object      # @.str9385
.L.str9385:
	.asciz	 "src"
	.size	.L.str9385, 4

	.type	.L.str10386,@object     # @.str10386
.L.str10386:
	.asciz	 "background"
	.size	.L.str10386, 11

	.type	.L.str11387,@object     # @.str11387
.L.str11387:
	.asciz	 "lowsrc"
	.size	.L.str11387, 7

	.type	.L.str12388,@object     # @.str12388
.L.str12388:
	.asciz	 "data"
	.size	.L.str12388, 5

	.type	.L.str13389,@object     # @.str13389
.L.str13389:
	.asciz	 "rel"
	.size	.L.str13389, 4

	.type	.L.str14390,@object     # @.str14390
.L.str14390:
	.asciz	 "http-equiv"
	.size	.L.str14390, 11

	.type	.L.str15391,@object     # @.str15391
.L.str15391:
	.asciz	 "name"
	.size	.L.str15391, 5

	.type	.L.str16392,@object     # @.str16392
.L.str16392:
	.asciz	 "content"
	.size	.L.str16392, 8

	.type	.L.str17393,@object     # @.str17393
.L.str17393:
	.asciz	 "action"
	.size	.L.str17393, 7

	.type	.L.str18394,@object     # @.str18394
.L.str18394:
	.asciz	 "a"
	.size	.L.str18394, 2

	.type	.L.str19395,@object     # @.str19395
.L.str19395:
	.asciz	 "applet"
	.size	.L.str19395, 7

	.type	.L.str20396,@object     # @.str20396
.L.str20396:
	.asciz	 "area"
	.size	.L.str20396, 5

	.type	.L.str21397,@object     # @.str21397
.L.str21397:
	.asciz	 "base"
	.size	.L.str21397, 5

	.type	.L.str22398,@object     # @.str22398
.L.str22398:
	.asciz	 "bgsound"
	.size	.L.str22398, 8

	.type	.L.str23399,@object     # @.str23399
.L.str23399:
	.asciz	 "body"
	.size	.L.str23399, 5

	.type	.L.str24400,@object     # @.str24400
.L.str24400:
	.asciz	 "embed"
	.size	.L.str24400, 6

	.type	.L.str25401,@object     # @.str25401
.L.str25401:
	.asciz	 "fig"
	.size	.L.str25401, 4

	.type	.L.str26402,@object     # @.str26402
.L.str26402:
	.asciz	 "form"
	.size	.L.str26402, 5

	.type	.L.str27403,@object     # @.str27403
.L.str27403:
	.asciz	 "frame"
	.size	.L.str27403, 6

	.type	.L.str28404,@object     # @.str28404
.L.str28404:
	.asciz	 "iframe"
	.size	.L.str28404, 7

	.type	.L.str29405,@object     # @.str29405
.L.str29405:
	.asciz	 "img"
	.size	.L.str29405, 4

	.type	.L.str30406,@object     # @.str30406
.L.str30406:
	.asciz	 "input"
	.size	.L.str30406, 6

	.type	.L.str31407,@object     # @.str31407
.L.str31407:
	.asciz	 "layer"
	.size	.L.str31407, 6

	.type	.L.str32408,@object     # @.str32408
.L.str32408:
	.asciz	 "link"
	.size	.L.str32408, 5

	.type	.L.str33409,@object     # @.str33409
.L.str33409:
	.asciz	 "meta"
	.size	.L.str33409, 5

	.type	.L.str34410,@object     # @.str34410
.L.str34410:
	.asciz	 "object"
	.size	.L.str34410, 7

	.type	.L.str35411,@object     # @.str35411
.L.str35411:
	.asciz	 "overlay"
	.size	.L.str35411, 8

	.type	.L.str36412,@object     # @.str36412
.L.str36412:
	.asciz	 "script"
	.size	.L.str36412, 7

	.type	.L.str37413,@object     # @.str37413
.L.str37413:
	.asciz	 "table"
	.size	.L.str37413, 6

	.type	.L.str38414,@object     # @.str38414
.L.str38414:
	.asciz	 "td"
	.size	.L.str38414, 3

	.type	.L.str39415,@object     # @.str39415
.L.str39415:
	.asciz	 "th"
	.size	.L.str39415, 3

	.type	.L.str40416,@object     # @.str40416
.L.str40416:
	.asciz	 "refresh"
	.size	.L.str40416, 8

	.type	.L.str41417,@object     # @.str41417
.L.str41417:
	.asciz	 "robots"
	.size	.L.str41417, 7

	.type	.L.str42418,@object     # @.str42418
.L.str42418:
	.asciz	 "none"
	.size	.L.str42418, 5

	.type	.L.str43419,@object     # @.str43419
.L.str43419:
	.asciz	 "nofollow"
	.size	.L.str43419, 9

	.type	.L.str44420,@object     # @.str44420
.L.str44420:
	.asciz	 "%s: no base, merge will use \"%s\".\n"
	.size	.L.str44420, 35

	.type	.L.str45421,@object     # @.str45421
.L.str45421:
	.asciz	 "%s: Cannot resolve incomplete link %s.\n"
	.size	.L.str45421, 40

	.type	.L.str46422,@object     # @.str46422
.L.str46422:
	.asciz	 "%s: link \"%s\" doesn't parse.\n"
	.size	.L.str46422, 30

	.type	.L.str47423,@object     # @.str47423
.L.str47423:
	.asciz	 "%s: merge(\"%s\", \"%s\") -> %s\n"
	.size	.L.str47423, 29

	.type	.L.str48424,@object     # @.str48424
.L.str48424:
	.asciz	 "%s: merged link \"%s\" doesn't parse.\n"
	.size	.L.str48424, 37

	.type	.L.str49425,@object     # @.str49425
.L.str49425:
	.asciz	 "appending \"%s\" to urlpos.\n"
	.size	.L.str49425, 27

	.type	.L.str50426,@object     # @.str50426
.L.str50426:
	.asciz	 "stylesheet"
	.size	.L.str50426, 11

	.type	.L.str51427,@object     # @.str51427
.L.str51427:
	.asciz	 "shortcut icon"
	.size	.L.str51427, 14

	.type	.L.str52428,@object     # @.str52428
.L.str52428:
	.asciz	 "first != -1"
	.size	.L.str52428, 12

	.type	.L__PRETTY_FUNCTION__.tag_find_urls,@object # @__PRETTY_FUNCTION__.tag_find_urls
.L__PRETTY_FUNCTION__.tag_find_urls:
	.asciz	 "void tag_find_urls(int, struct taginfo *, struct map_context *)"
	.size	.L__PRETTY_FUNCTION__.tag_find_urls, 64

	.type	.L.str431,@object       # @.str431
.L.str431:
	.asciz	 "local_file == ((void*)0) || *local_file == ((void*)0)"
	.size	.L.str431, 54

	.type	.L.str1432,@object      # @.str1432
.L.str1432:
	.asciz	 "http.c"
	.size	.L.str1432, 7

	.type	.L__PRETTY_FUNCTION__.http_loop,@object # @__PRETTY_FUNCTION__.http_loop
.L__PRETTY_FUNCTION__.http_loop:
	.asciz	 "uerr_t http_loop(struct url *, char **, char **, const char *, int *, struct url *)"
	.size	.L__PRETTY_FUNCTION__.http_loop, 84

	.type	.L.str2433,@object      # @.str2433
.L.str2433:
	.asciz	 "Warning: wildcards not supported in HTTP.\n"
	.size	.L.str2433, 43

	.type	.L.str3434,@object      # @.str3434
.L.str3434:
	.asciz	 "File `%s' already there; not retrieving.\n\n"
	.size	.L.str3434, 43

	.type	.L.str4435,@object      # @.str4435
.L.str4435:
	.asciz	 "Spider mode enabled. Check if remote file exists.\n"
	.size	.L.str4435, 51

	.type	.L.str5436,@object      # @.str5436
.L.str5436:
	.asciz	 "(try:%2d)"
	.size	.L.str5436, 10

	.type	.L.str6437,@object      # @.str6437
.L.str6437:
	.asciz	 "--%s--  %s  %s\n"
	.size	.L.str6437, 16

	.type	.L.str7438,@object      # @.str7438
.L.str7438:
	.asciz	 "--%s--  %s\n"
	.size	.L.str7438, 12

	.type	.L.str8439,@object      # @.str8439
.L.str8439:
	.asciz	 "\n"
	.size	.L.str8439, 2

	.type	.L.str9440,@object      # @.str9440
.L.str9440:
	.asciz	 "Cannot write to `%s' (%s).\n"
	.size	.L.str9440, 28

	.type	.L.str10441,@object     # @.str10441
.L.str10441:
	.asciz	 "Unable to establish SSL connection.\n"
	.size	.L.str10441, 37

	.type	.L.str11442,@object     # @.str11442
.L.str11442:
	.asciz	 "ERROR: Redirection (%d) without location.\n"
	.size	.L.str11442, 43

	.type	.L.str12443,@object     # @.str12443
.L.str12443:
	.asciz	 "%s:\n"
	.size	.L.str12443, 5

	.type	.L.str13444,@object     # @.str13444
.L.str13444:
	.asciz	 "Remote file does not exist -- broken link!!!\n"
	.size	.L.str13444, 46

	.type	.L.str14445,@object     # @.str14445
.L.str14445:
	.asciz	 "%s ERROR %d: %s.\n"
	.size	.L.str14445, 18

	.type	.L.str15446,@object     # @.str15446
.L.str15446:
	.asciz	 "Last-modified header missing -- time-stamps turned off.\n"
	.size	.L.str15446, 57

	.type	.L.str16447,@object     # @.str16447
.L.str16447:
	.asciz	 "Last-modified header invalid -- time-stamp ignored.\n"
	.size	.L.str16447, 53

	.type	.L.str17448,@object     # @.str17448
.L.str17448:
	.asciz	 "Server file no newer than local file `%s' -- not retrieving.\n\n"
	.size	.L.str17448, 63

	.type	.L.str18449,@object     # @.str18449
.L.str18449:
	.asciz	 "The sizes do not match (local %s) -- retrieving.\n"
	.size	.L.str18449, 50

	.type	.L.str19450,@object     # @.str19450
.L.str19450:
	.asciz	 "Remote file is newer, retrieving.\n"
	.size	.L.str19450, 35

	.type	.L.str20451,@object     # @.str20451
.L.str20451:
	.asciz	 "Remote file exists and could contain links to other resources -- retrieving.\n\n"
	.size	.L.str20451, 79

	.type	.L.str21452,@object     # @.str21452
.L.str21452:
	.asciz	 "Remote file exists but does not contain any link -- not retrieving.\n\n"
	.size	.L.str21452, 70

	.type	.L.str22453,@object     # @.str22453
.L.str22453:
	.asciz	 "Remote file exists and could contain further links,\nbut recursion is disabled -- not retrieving.\n\n"
	.size	.L.str22453, 99

	.type	.L.str23454,@object     # @.str23454
.L.str23454:
	.asciz	 "Remote file exists.\n\n"
	.size	.L.str23454, 22

	.type	.L.str24455,@object     # @.str24455
.L.str24455:
	.asciz	 "%s (%s) - `%s' saved [%s/%s]\n\n"
	.size	.L.str24455, 31

	.type	.L.str25456,@object     # @.str25456
.L.str25456:
	.asciz	 "%s URL:%s [%s/%s] -> \"%s\" [%d]\n"
	.size	.L.str25456, 32

	.type	.L.str26457,@object     # @.str26457
.L.str26457:
	.asciz	 "%s (%s) - `%s' saved [%s]\n\n"
	.size	.L.str26457, 28

	.type	.L.str27458,@object     # @.str27458
.L.str27458:
	.asciz	 "%s URL:%s [%s] -> \"%s\" [%d]\n"
	.size	.L.str27458, 29

	.type	.L.str28459,@object     # @.str28459
.L.str28459:
	.asciz	 "%s (%s) - Connection closed at byte %s. "
	.size	.L.str28459, 41

	.type	.L.str29460,@object     # @.str29460
.L.str29460:
	.asciz	 "%s (%s) - Read error at byte %s (%s)."
	.size	.L.str29460, 38

	.type	.L.str30461,@object     # @.str30461
.L.str30461:
	.asciz	 "%s (%s) - Read error at byte %s/%s (%s). "
	.size	.L.str30461, 42

	.type	http_atotm.time_formats,@object # @http_atotm.time_formats
	.section	.rodata,"a",@progbits
	.align	4
http_atotm.time_formats:
	.long	.L.str31462
	.long	.L.str32463
	.long	.L.str33464
	.long	.L.str34465
	.size	http_atotm.time_formats, 16

	.type	.L.str31462,@object     # @.str31462
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str31462:
	.asciz	 "%a, %d %b %Y %T"
	.size	.L.str31462, 16

	.type	.L.str32463,@object     # @.str32463
.L.str32463:
	.asciz	 "%A, %d-%b-%y %T"
	.size	.L.str32463, 16

	.type	.L.str33464,@object     # @.str33464
.L.str33464:
	.asciz	 "%a %b %d %T %Y"
	.size	.L.str33464, 15

	.type	.L.str34465,@object     # @.str34465
.L.str34465:
	.asciz	 "%a, %d-%b-%Y %T"
	.size	.L.str34465, 16

	.type	.L.str35466,@object     # @.str35466
.L.str35466:
	.asciz	 "C"
	.size	.L.str35466, 2

	.type	wget_cookie_jar,@object # @wget_cookie_jar
	.local	wget_cookie_jar
	.comm	wget_cookie_jar,4,4
	.type	pconn,@object           # @pconn
	.local	pconn
	.comm	pconn,16,4
	.type	cookies_loaded_p.b,@object # @cookies_loaded_p.b
	.local	cookies_loaded_p.b
	.comm	cookies_loaded_p.b,1,1
	.type	.L.str36467,@object     # @.str36467
.L.str36467:
	.asciz	 "GET"
	.size	.L.str36467, 4

	.type	.L.str37468,@object     # @.str37468
.L.str37468:
	.asciz	 "HEAD"
	.size	.L.str37468, 5

	.type	.L.str38469,@object     # @.str38469
.L.str38469:
	.asciz	 "POST"
	.size	.L.str38469, 5

	.type	.L.str39470,@object     # @.str39470
.L.str39470:
	.asciz	 "Referer"
	.size	.L.str39470, 8

	.type	.L.str40471,@object     # @.str40471
.L.str40471:
	.asciz	 "Pragma"
	.size	.L.str40471, 7

	.type	.L.str41472,@object     # @.str41472
.L.str41472:
	.asciz	 "no-cache"
	.size	.L.str41472, 9

	.type	.L.str42473,@object     # @.str42473
.L.str42473:
	.asciz	 "Range"
	.size	.L.str42473, 6

	.type	.L.str43474,@object     # @.str43474
.L.str43474:
	.asciz	 "bytes=%s-"
	.size	.L.str43474, 10

	.type	.L.str44475,@object     # @.str44475
.L.str44475:
	.asciz	 "User-Agent"
	.size	.L.str44475, 11

	.type	.L.str45476,@object     # @.str45476
.L.str45476:
	.asciz	 "Wget/%s"
	.size	.L.str45476, 8

	.type	.L.str46477,@object     # @.str46477
.L.str46477:
	.asciz	 "Accept"
	.size	.L.str46477, 7

	.type	.L.str47478,@object     # @.str47478
.L.str47478:
	.asciz	 "*/*"
	.size	.L.str47478, 4

	.type	gethttp.hfmt,@object    # @gethttp.hfmt
	.section	.rodata,"a",@progbits
	.align	4
gethttp.hfmt:
	.long	.L.str48479
	.long	.L.str49480
	.long	.L.str50481
	.long	.L.str51482
	.size	gethttp.hfmt, 16

	.type	.L.str48479,@object     # @.str48479
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str48479:
	.asciz	 "%s"
	.size	.L.str48479, 3

	.type	.L.str49480,@object     # @.str49480
.L.str49480:
	.asciz	 "[%s]"
	.size	.L.str49480, 5

	.type	.L.str50481,@object     # @.str50481
.L.str50481:
	.asciz	 "%s:%d"
	.size	.L.str50481, 6

	.type	.L.str51482,@object     # @.str51482
.L.str51482:
	.asciz	 "[%s]:%d"
	.size	.L.str51482, 8

	.type	.L.str52483,@object     # @.str52483
.L.str52483:
	.asciz	 "Host"
	.size	.L.str52483, 5

	.type	.L.str53484,@object     # @.str53484
.L.str53484:
	.asciz	 "Connection"
	.size	.L.str53484, 11

	.type	.L.str54485,@object     # @.str54485
.L.str54485:
	.asciz	 "Keep-Alive"
	.size	.L.str54485, 11

	.type	.L.str55486,@object     # @.str55486
.L.str55486:
	.asciz	 "Cookie"
	.size	.L.str55486, 7

	.type	.L.str56487,@object     # @.str56487
.L.str56487:
	.asciz	 "Content-Type"
	.size	.L.str56487, 13

	.type	.L.str57488,@object     # @.str57488
.L.str57488:
	.asciz	 "application/x-www-form-urlencoded"
	.size	.L.str57488, 34

	.type	.L.str58489,@object     # @.str58489
.L.str58489:
	.asciz	 "POST data file `%s' missing: %s\n"
	.size	.L.str58489, 33

	.type	.L.str59490,@object     # @.str59490
.L.str59490:
	.asciz	 "Content-Length"
	.size	.L.str59490, 15

	.type	.L.str60491,@object     # @.str60491
.L.str60491:
	.asciz	 "Proxy-Authorization"
	.size	.L.str60491, 20

	.type	.L.str61492,@object     # @.str61492
.L.str61492:
	.asciz	 "Reusing existing connection to %s:%d.\n"
	.size	.L.str61492, 39

	.type	.L.str62493,@object     # @.str62493
.L.str62493:
	.asciz	 "Reusing fd %d.\n"
	.size	.L.str62493, 16

	.type	.L.str63494,@object     # @.str63494
.L.str63494:
	.asciz	 "Authorization"
	.size	.L.str63494, 14

	.type	.L.str64495,@object     # @.str64495
.L.str64495:
	.asciz	 "%s: unable to resolve host address `%s'\n"
	.size	.L.str64495, 41

	.type	.L.str65496,@object     # @.str65496
.L.str65496:
	.asciz	 "[POST data: %s]\n"
	.size	.L.str65496, 17

	.type	pconn_active.b,@object  # @pconn_active.b
	.local	pconn_active.b
	.comm	pconn_active.b,1,1
	.type	.L.str66497,@object     # @.str66497
.L.str66497:
	.asciz	 "%s request sent, awaiting response... "
	.size	.L.str66497, 39

	.type	.L.str67498,@object     # @.str67498
.L.str67498:
	.asciz	 "Proxy"
	.size	.L.str67498, 6

	.type	.L.str68499,@object     # @.str68499
.L.str68499:
	.asciz	 "HTTP"
	.size	.L.str68499, 5

	.type	.L.str69500,@object     # @.str69500
.L.str69500:
	.asciz	 "No data received.\n"
	.size	.L.str69500, 19

	.type	.L.str70501,@object     # @.str70501
.L.str70501:
	.asciz	 "Read error (%s) in headers.\n"
	.size	.L.str70501, 29

	.type	.L.str71502,@object     # @.str71502
.L.str71502:
	.asciz	 "\n---response begin---\n%s---response end---\n"
	.size	.L.str71502, 44

	.type	.L.str72503,@object     # @.str72503
.L.str72503:
	.asciz	 "%2d %s\n"
	.size	.L.str72503, 8

	.type	.L.str73504,@object     # @.str73504
.L.str73504:
	.zero	1
	.size	.L.str73504, 1

	.type	.L.str74505,@object     # @.str74505
.L.str74505:
	.asciz	 "  "
	.size	.L.str74505, 3

	.type	.L.str75506,@object     # @.str75506
.L.str75506:
	.asciz	 "Content-Disposition"
	.size	.L.str75506, 20

	.type	.L.str76507,@object     # @.str76507
.L.str76507:
	.asciz	 ".orig"
	.size	.L.str76507, 6

	.type	.L.str77508,@object     # @.str77508
.L.str77508:
	.asciz	 "WWW-Authenticate"
	.size	.L.str77508, 17

	.type	.L.str78509,@object     # @.str78509
.L.str78509:
	.asciz	 "Unknown authentication scheme.\n"
	.size	.L.str78509, 32

	.type	.L.str79510,@object     # @.str79510
.L.str79510:
	.asciz	 "Basic"
	.size	.L.str79510, 6

	.type	.L.str80511,@object     # @.str80511
.L.str80511:
	.asciz	 "NTLM"
	.size	.L.str80511, 5

	.type	.L.str81512,@object     # @.str81512
.L.str81512:
	.asciz	 "Authorization failed.\n"
	.size	.L.str81512, 23

	.type	.L.str82513,@object     # @.str82513
.L.str82513:
	.asciz	 "Malformed status line"
	.size	.L.str82513, 22

	.type	.L.str83514,@object     # @.str83514
.L.str83514:
	.asciz	 "(no description)"
	.size	.L.str83514, 17

	.type	.L.str84515,@object     # @.str84515
.L.str84515:
	.asciz	 "Location"
	.size	.L.str84515, 9

	.type	.L.str85516,@object     # @.str85516
.L.str85516:
	.asciz	 "Last-Modified"
	.size	.L.str85516, 14

	.type	.L.str86517,@object     # @.str86517
.L.str86517:
	.asciz	 "wget_cookie_jar != ((void*)0)"
	.size	.L.str86517, 30

	.type	.L__PRETTY_FUNCTION__.gethttp,@object # @__PRETTY_FUNCTION__.gethttp
.L__PRETTY_FUNCTION__.gethttp:
	.asciz	 "uerr_t gethttp(struct url *, struct http_stat *, int *, struct url *)"
	.size	.L__PRETTY_FUNCTION__.gethttp, 70

	.type	.L.str87518,@object     # @.str87518
.L.str87518:
	.asciz	 "Set-Cookie"
	.size	.L.str87518, 11

	.type	.L.str88519,@object     # @.str88519
.L.str88519:
	.asciz	 "Content-Range"
	.size	.L.str88519, 14

	.type	.L.str89520,@object     # @.str89520
.L.str89520:
	.asciz	 "Location: %s%s\n"
	.size	.L.str89520, 16

	.type	.L.str90521,@object     # @.str90521
.L.str90521:
	.asciz	 "unspecified"
	.size	.L.str90521, 12

	.type	.L.str91522,@object     # @.str91522
.L.str91522:
	.asciz	 " [following]"
	.size	.L.str91522, 13

	.type	.L.str92523,@object     # @.str92523
.L.str92523:
	.asciz	 "text/html"
	.size	.L.str92523, 10

	.type	.L.str93524,@object     # @.str93524
.L.str93524:
	.asciz	 "application/xhtml+xml"
	.size	.L.str93524, 22

	.type	.L.str94525,@object     # @.str94525
.L.str94525:
	.asciz	 ".htm"
	.size	.L.str94525, 5

	.type	.L.str95526,@object     # @.str95526
.L.str95526:
	.asciz	 ".html"
	.size	.L.str95526, 6

	.type	.L.str96527,@object     # @.str96527
.L.str96527:
	.asciz	 ".%d.html"
	.size	.L.str96527, 9

	.type	.L.str97528,@object     # @.str97528
.L.str97528:
	.asciz	 "\n    The file is already fully retrieved; nothing to do.\n\n"
	.size	.L.str97528, 59

	.type	.L.str98529,@object     # @.str98529
.L.str98529:
	.asciz	 "Length: "
	.size	.L.str98529, 9

	.type	.L.str99530,@object     # @.str99530
.L.str99530:
	.asciz	 " (%s)"
	.size	.L.str99530, 6

	.type	.L.str100531,@object    # @.str100531
.L.str100531:
	.asciz	 ", %s (%s) remaining"
	.size	.L.str100531, 20

	.type	.L.str101532,@object    # @.str101532
.L.str101532:
	.asciz	 ", %s remaining"
	.size	.L.str101532, 15

	.type	.L.str102533,@object    # @.str102533
.L.str102533:
	.asciz	 "ignored"
	.size	.L.str102533, 8

	.type	.L.str103534,@object    # @.str103534
.L.str103534:
	.asciz	 " [%s]\n"
	.size	.L.str103534, 7

	.type	.L.str104535,@object    # @.str104535
.L.str104535:
	.asciz	 "ab"
	.size	.L.str104535, 3

	.type	.L.str105536,@object    # @.str105536
.L.str105536:
	.asciz	 "wb"
	.size	.L.str105536, 3

	.type	.L.str106537,@object    # @.str106537
.L.str106537:
	.asciz	 "%s has sprung into existence.\n"
	.size	.L.str106537, 31

	.type	.L.str107538,@object    # @.str107538
.L.str107538:
	.asciz	 "%s: %s\n"
	.size	.L.str107538, 8

	.type	.L.str108539,@object    # @.str108539
.L.str108539:
	.asciz	 "Saving to: `%s'\n"
	.size	.L.str108539, 17

	.type	.L.str109540,@object    # @.str109540
.L.str109540:
	.asciz	 "STDOUT"
	.size	.L.str109540, 7

	.type	.L.str110541,@object    # @.str110541
.L.str110541:
	.asciz	 "bytes"
	.size	.L.str110541, 6

	.type	basic_authed_hosts,@object # @basic_authed_hosts
	.local	basic_authed_hosts
	.comm	basic_authed_hosts,4,4
	.type	.L.str111542,@object    # @.str111542
.L.str111542:
	.asciz	 "Inserted `%s' into basic_authed_hosts\n"
	.size	.L.str111542, 39

	.type	digest_authentication_encode.realm,@object # @digest_authentication_encode.realm
	.local	digest_authentication_encode.realm
	.comm	digest_authentication_encode.realm,4,4
	.type	digest_authentication_encode.opaque,@object # @digest_authentication_encode.opaque
	.local	digest_authentication_encode.opaque
	.comm	digest_authentication_encode.opaque,4,4
	.type	digest_authentication_encode.nonce,@object # @digest_authentication_encode.nonce
	.local	digest_authentication_encode.nonce
	.comm	digest_authentication_encode.nonce,4,4
	.type	digest_authentication_encode.options,@object # @digest_authentication_encode.options
	.section	.rodata,"a",@progbits
	.align	4
digest_authentication_encode.options:
	.long	.L.str112543
	.long	digest_authentication_encode.realm
	.long	.L.str113544
	.long	digest_authentication_encode.opaque
	.long	.L.str114545
	.long	digest_authentication_encode.nonce
	.size	digest_authentication_encode.options, 24

	.type	.L.str112543,@object    # @.str112543
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str112543:
	.asciz	 "realm"
	.size	.L.str112543, 6

	.type	.L.str113544,@object    # @.str113544
.L.str113544:
	.asciz	 "opaque"
	.size	.L.str113544, 7

	.type	.L.str114545,@object    # @.str114545
.L.str114545:
	.asciz	 "nonce"
	.size	.L.str114545, 6

	.type	.L.str115546,@object    # @.str115546
.L.str115546:
	.asciz	 ":"
	.size	.L.str115546, 2

	.type	.L.str116547,@object    # @.str116547
.L.str116547:
	.asciz	 "Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\""
	.size	.L.str116547, 70

	.type	.L.str117548,@object    # @.str117548
.L.str117548:
	.asciz	 ", opaque=\""
	.size	.L.str117548, 11

	.type	.L.str119,@object       # @.str119
.L.str119:
	.asciz	 "0123456789abcdef"
	.size	.L.str119, 17

	.type	.L.str120,@object       # @.str120
.L.str120:
	.asciz	 "Digest"
	.size	.L.str120, 7

	.type	.L.str121,@object       # @.str121
.L.str121:
	.asciz	 "contlen != -1"
	.size	.L.str121, 14

	.type	.L__PRETTY_FUNCTION__.skip_short_body,@object # @__PRETTY_FUNCTION__.skip_short_body
.L__PRETTY_FUNCTION__.skip_short_body:
	.asciz	 "_Bool skip_short_body(int, wgint)"
	.size	.L__PRETTY_FUNCTION__.skip_short_body, 34

	.type	.L.str122,@object       # @.str122
.L.str122:
	.asciz	 "Skipping %s bytes of body: ["
	.size	.L.str122, 29

	.type	.L.str123,@object       # @.str123
.L.str123:
	.asciz	 "] aborting (%s).\n"
	.size	.L.str123, 18

	.type	.L.str124,@object       # @.str124
.L.str124:
	.asciz	 "EOF received"
	.size	.L.str124, 13

	.type	.L.str125,@object       # @.str125
.L.str125:
	.asciz	 "%.*s"
	.size	.L.str125, 5

	.type	.L.str126,@object       # @.str126
.L.str126:
	.asciz	 "] done.\n"
	.size	.L.str126, 9

	.type	.L.str127,@object       # @.str127
.L.str127:
	.asciz	 "Registered socket %d for persistent reuse.\n"
	.size	.L.str127, 44

	.type	.L.str128,@object       # @.str128
.L.str128:
	.asciz	 "filename"
	.size	.L.str128, 9

	.type	.L.str129,@object       # @.str129
.L.str129:
	.asciz	 "%s%s\n"
	.size	.L.str129, 6

	.type	.L.str130,@object       # @.str130
.L.str130:
	.asciz	 "No headers, assuming HTTP/0.9"
	.size	.L.str130, 30

	.type	.L.str131,@object       # @.str131
.L.str131:
	.asciz	 "Disabling further reuse of socket %d.\n"
	.size	.L.str131, 39

	.type	post_file.chunk,@object # @post_file.chunk
	.local	post_file.chunk
	.comm	post_file.chunk,8192,1
	.type	.L.str132,@object       # @.str132
.L.str132:
	.asciz	 "[writing POST file %s ... "
	.size	.L.str132, 27

	.type	.L.str133,@object       # @.str133
.L.str133:
	.asciz	 "rb"
	.size	.L.str133, 3

	.type	.L.str134549,@object    # @.str134549
.L.str134549:
	.asciz	 "written == promised_size"
	.size	.L.str134549, 25

	.type	.L__PRETTY_FUNCTION__.post_file,@object # @__PRETTY_FUNCTION__.post_file
.L__PRETTY_FUNCTION__.post_file:
	.asciz	 "int post_file(int, const char *, wgint)"
	.size	.L__PRETTY_FUNCTION__.post_file, 40

	.type	.L.str135,@object       # @.str135
.L.str135:
	.asciz	 "done]\n"
	.size	.L.str135, 7

	.type	.L.str136,@object       # @.str136
.L.str136:
	.asciz	 "HTTP/1.0\r\n"
	.size	.L.str136, 11

	.type	.L.str137,@object       # @.str137
.L.str137:
	.asciz	 "p - request_string == size"
	.size	.L.str137, 27

	.type	.L__PRETTY_FUNCTION__.request_send,@object # @__PRETTY_FUNCTION__.request_send
.L__PRETTY_FUNCTION__.request_send:
	.asciz	 "int request_send(const struct request *, int)"
	.size	.L__PRETTY_FUNCTION__.request_send, 46

	.type	.L.str138,@object       # @.str138
.L.str138:
	.asciz	 "\n---request begin---\n%s---request end---\n"
	.size	.L.str138, 42

	.type	.L.str139,@object       # @.str139
.L.str139:
	.asciz	 "Failed writing HTTP request: %s.\n"
	.size	.L.str139, 34

	.type	.L.str140,@object       # @.str140
.L.str140:
	.asciz	 "%s:%s"
	.size	.L.str140, 6

	.type	.L.str141,@object       # @.str141
.L.str141:
	.asciz	 "Basic "
	.size	.L.str141, 7

	.type	.L.str142,@object       # @.str142
.L.str142:
	.asciz	 "Auth-without-challenge set, sending Basic credentials.\n"
	.size	.L.str142, 56

	.type	.L.str143,@object       # @.str143
.L.str143:
	.asciz	 "Found `%s' in basic_authed_hosts.\n"
	.size	.L.str143, 35

	.type	.L.str144,@object       # @.str144
.L.str144:
	.asciz	 "Host `%s' has not issued a general basic challenge.\n"
	.size	.L.str144, 53

	.type	.L.str554,@object       # @.str554
.L.str554:
	.asciz	 "HOME"
	.size	.L.str554, 5

	.type	.L.str1555,@object      # @.str1555
.L.str1555:
	.asciz	 "/usr/local/etc/wgetrc"
	.size	.L.str1555, 22

	.type	.L.str2556,@object      # @.str2556
.L.str2556:
	.asciz	 "%s: Warning: Both system and user wgetrc point to `%s'.\n"
	.size	.L.str2556, 57

	.type	.L.str3557,@object      # @.str3557
.L.str3557:
	.asciz	 "val != ((void*)0)"
	.size	.L.str3557, 18

	.type	.L.str4558,@object      # @.str4558
.L.str4558:
	.asciz	 "init.c"
	.size	.L.str4558, 7

	.type	.L__PRETTY_FUNCTION__.setoptval,@object # @__PRETTY_FUNCTION__.setoptval
.L__PRETTY_FUNCTION__.setoptval:
	.asciz	 "void setoptval(const char *, const char *, const char *)"
	.size	.L__PRETTY_FUNCTION__.setoptval, 57

	.type	.L.str5559,@object      # @.str5559
.L.str5559:
	.asciz	 "%s: Invalid --execute command `%s'\n"
	.size	.L.str5559, 36

	.type	commands,@object        # @commands
	.section	.rodata,"a",@progbits
	.align	4
commands:
	.long	.L.str6560
	.long	opt+60
	.long	cmd_vector
	.long	.L.str7561
	.long	opt+40
	.long	cmd_boolean
	.long	.L.str8562
	.long	opt+116
	.long	cmd_boolean
	.long	.L.str9563
	.long	opt+341
	.long	cmd_boolean
	.long	.L.str10564
	.long	opt+13
	.long	cmd_boolean
	.long	.L.str11565
	.long	opt+252
	.long	cmd_boolean
	.long	.L.str12566
	.long	opt+253
	.long	cmd_number
	.long	.L.str13567
	.long	opt+164
	.long	cmd_string
	.long	.L.str14568
	.long	opt+292
	.long	cmd_string
	.long	.L.str15569
	.long	opt+146
	.long	cmd_boolean
	.long	.L.str16570
	.long	opt+196
	.long	cmd_time
	.long	.L.str17571
	.long	opt+340
	.long	cmd_boolean
	.long	.L.str18572
	.long	opt+116
	.long	cmd_boolean
	.long	.L.str19573
	.long	opt+264
	.long	cmd_boolean
	.long	.L.str20574
	.long	opt+296
	.long	cmd_boolean
	.long	.L.str21575
	.long	opt+36
	.long	cmd_number
	.long	.L.str22576
	.long	opt+250
	.long	cmd_boolean
	.long	.L.str23577
	.long	opt+288
	.long	cmd_boolean
	.long	.L.str24578
	.long	opt+44
	.long	cmd_directory
	.long	.L.str25579
	.long	0
	.long	cmd_spec_dirstruct
	.long	.L.str26580
	.long	opt+88
	.long	cmd_boolean
	.long	.L.str27581
	.long	opt+188
	.long	cmd_time
	.long	.L.str28582
	.long	opt+80
	.long	cmd_vector
	.long	.L.str29583
	.long	opt+272
	.long	cmd_bytes
	.long	.L.str30584
	.long	opt+280
	.long	cmd_number
	.long	.L.str31585
	.long	opt+284
	.long	cmd_number
	.long	.L.str32586
	.long	opt+268
	.long	cmd_string
	.long	.L.str33587
	.long	opt+68
	.long	cmd_directory_vector
	.long	.L.str34588
	.long	opt+84
	.long	cmd_vector
	.long	.L.str35589
	.long	opt+100
	.long	cmd_boolean
	.long	.L.str36590
	.long	opt+92
	.long	cmd_vector
	.long	.L.str37591
	.long	opt+56
	.long	cmd_boolean
	.long	.L.str38592
	.long	opt+124
	.long	cmd_string
	.long	.L.str39593
	.long	opt+124
	.long	cmd_string
	.long	.L.str40594
	.long	opt+152
	.long	cmd_string
	.long	.L.str41595
	.long	opt+120
	.long	cmd_string
	.long	.L.str42596
	.long	opt+129
	.long	cmd_boolean
	.long	.L.str43597
	.long	0
	.long	cmd_spec_header
	.long	.L.str44598
	.long	opt+289
	.long	cmd_boolean
	.long	.L.str45599
	.long	0
	.long	cmd_spec_htmlify
	.long	.L.str46600
	.long	opt+144
	.long	cmd_boolean
	.long	.L.str47601
	.long	opt+136
	.long	cmd_string
	.long	.L.str48602
	.long	opt+136
	.long	cmd_string
	.long	.L.str49603
	.long	opt+148
	.long	cmd_string
	.long	.L.str50604
	.long	opt+156
	.long	cmd_string
	.long	.L.str51605
	.long	opt+132
	.long	cmd_string
	.long	.L.str52606
	.long	opt+76
	.long	cmd_boolean
	.long	.L.str53607
	.long	opt+14
	.long	cmd_boolean
	.long	.L.str54608
	.long	opt+96
	.long	cmd_vector
	.long	.L.str55609
	.long	opt+72
	.long	cmd_directory_vector
	.long	.L.str56610
	.long	opt+334
	.long	cmd_boolean
	.long	.L.str57611
	.long	opt+335
	.long	cmd_boolean
	.long	.L.str58612
	.long	opt+52
	.long	cmd_file
	.long	.L.str59613
	.long	opt+308
	.long	cmd_boolean
	.long	.L.str60614
	.long	opt+228
	.long	cmd_bytes
	.long	.L.str61615
	.long	opt+300
	.long	cmd_file
	.long	.L.str62616
	.long	opt+48
	.long	cmd_file
	.long	.L.str63617
	.long	opt+120
	.long	cmd_string
	.long	.L.str64618
	.long	opt+20
	.long	cmd_number
	.long	.L.str65619
	.long	0
	.long	cmd_spec_mirror
	.long	.L.str66620
	.long	opt+128
	.long	cmd_boolean
	.long	.L.str67621
	.long	opt+42
	.long	cmd_boolean
	.long	.L.str68622
	.long	opt+25
	.long	cmd_boolean
	.long	.L.str69623
	.long	opt+160
	.long	cmd_vector
	.long	.L.str70624
	.long	opt+8
	.long	cmd_number_inf
	.long	.L.str71625
	.long	opt+104
	.long	cmd_file
	.long	.L.str72626
	.long	opt+290
	.long	cmd_boolean
	.long	.L.str73627
	.long	opt+130
	.long	cmd_boolean
	.long	.L.str74628
	.long	opt+124
	.long	cmd_string
	.long	.L.str75629
	.long	opt+112
	.long	cmd_string
	.long	.L.str76630
	.long	opt+312
	.long	cmd_string
	.long	.L.str77631
	.long	opt+316
	.long	cmd_file
	.long	.L.str78632
	.long	0
	.long	cmd_spec_prefer_family
	.long	.L.str79633
	.long	opt+333
	.long	cmd_boolean
	.long	.L.str80634
	.long	opt+168
	.long	cmd_spec_progress
	.long	.L.str81635
	.long	opt+41
	.long	cmd_boolean
	.long	.L.str82636
	.long	opt+176
	.long	cmd_string
	.long	.L.str83637
	.long	opt+176
	.long	cmd_string
	.long	.L.str84638
	.long	opt+172
	.long	cmd_string
	.long	.L.str85639
	.long	opt+4
	.long	cmd_boolean
	.long	.L.str86640
	.long	opt+236
	.long	cmd_bytes_sum
	.long	.L.str87641
	.long	opt+204
	.long	cmd_boolean
	.long	.L.str88642
	.long	opt+180
	.long	cmd_time
	.long	.L.str89643
	.long	opt+28
	.long	cmd_number_inf
	.long	.L.str90644
	.long	0
	.long	cmd_spec_recursive
	.long	.L.str91645
	.long	opt+260
	.long	cmd_string
	.long	.L.str92646
	.long	opt+64
	.long	cmd_vector
	.long	.L.str93647
	.long	opt+24
	.long	cmd_boolean
	.long	.L.str94648
	.long	opt+265
	.long	cmd_boolean
	.long	.L.str95649
	.long	0
	.long	cmd_spec_restrict_file_names
	.long	.L.str96650
	.long	opt+101
	.long	cmd_boolean
	.long	.L.str97651
	.long	opt+12
	.long	cmd_boolean
	.long	.L.str98652
	.long	opt+224
	.long	cmd_boolean
	.long	.L.str99653
	.long	opt+304
	.long	cmd_file
	.long	.L.str100654
	.long	opt+249
	.long	cmd_boolean
	.long	.L.str101655
	.long	opt+248
	.long	cmd_boolean
	.long	.L.str102656
	.long	opt+16
	.long	cmd_boolean
	.long	.L.str103657
	.long	opt+57
	.long	cmd_boolean
	.long	.L.str104658
	.long	opt+332
	.long	cmd_boolean
	.long	.L.str105659
	.long	0
	.long	cmd_spec_timeout
	.long	.L.str106660
	.long	opt+251
	.long	cmd_boolean
	.long	.L.str107661
	.long	opt+8
	.long	cmd_number_inf
	.long	.L.str108662
	.long	opt+145
	.long	cmd_boolean
	.long	.L.str109663
	.long	opt+108
	.long	cmd_string
	.long	.L.str110664
	.long	0
	.long	cmd_spec_useragent
	.long	.L.str111665
	.long	0
	.long	cmd_spec_verbose
	.long	.L.str112666
	.long	opt+208
	.long	cmd_time
	.long	.L.str113667
	.long	opt+216
	.long	cmd_time
	.size	commands, 1296

	.type	.L.str6560,@object      # @.str6560
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str6560:
	.asciz	 "accept"
	.size	.L.str6560, 7

	.type	.L.str7561,@object      # @.str7561
.L.str7561:
	.asciz	 "addhostdir"
	.size	.L.str7561, 11

	.type	.L.str8562,@object      # @.str8562
.L.str8562:
	.asciz	 "alwaysrest"
	.size	.L.str8562, 11

	.type	.L.str9563,@object      # @.str9563
.L.str9563:
	.asciz	 "authnochallenge"
	.size	.L.str9563, 16

	.type	.L.str10564,@object     # @.str10564
.L.str10564:
	.asciz	 "background"
	.size	.L.str10564, 11

	.type	.L.str11565,@object     # @.str11565
.L.str11565:
	.asciz	 "backupconverted"
	.size	.L.str11565, 16

	.type	.L.str12566,@object     # @.str12566
.L.str12566:
	.asciz	 "backups"
	.size	.L.str12566, 8

	.type	.L.str13567,@object     # @.str13567
.L.str13567:
	.asciz	 "base"
	.size	.L.str13567, 5

	.type	.L.str14568,@object     # @.str14568
.L.str14568:
	.asciz	 "bindaddress"
	.size	.L.str14568, 12

	.type	.L.str15569,@object     # @.str15569
.L.str15569:
	.asciz	 "cache"
	.size	.L.str15569, 6

	.type	.L.str16570,@object     # @.str16570
.L.str16570:
	.asciz	 "connecttimeout"
	.size	.L.str16570, 15

	.type	.L.str17571,@object     # @.str17571
.L.str17571:
	.asciz	 "contentdisposition"
	.size	.L.str17571, 19

	.type	.L.str18572,@object     # @.str18572
.L.str18572:
	.asciz	 "continue"
	.size	.L.str18572, 9

	.type	.L.str19573,@object     # @.str19573
.L.str19573:
	.asciz	 "convertlinks"
	.size	.L.str19573, 13

	.type	.L.str20574,@object     # @.str20574
.L.str20574:
	.asciz	 "cookies"
	.size	.L.str20574, 8

	.type	.L.str21575,@object     # @.str21575
.L.str21575:
	.asciz	 "cutdirs"
	.size	.L.str21575, 8

	.type	.L.str22576,@object     # @.str22576
.L.str22576:
	.asciz	 "debug"
	.size	.L.str22576, 6

	.type	.L.str23577,@object     # @.str23577
.L.str23577:
	.asciz	 "deleteafter"
	.size	.L.str23577, 12

	.type	.L.str24578,@object     # @.str24578
.L.str24578:
	.asciz	 "dirprefix"
	.size	.L.str24578, 10

	.type	.L.str25579,@object     # @.str25579
.L.str25579:
	.asciz	 "dirstruct"
	.size	.L.str25579, 10

	.type	.L.str26580,@object     # @.str26580
.L.str26580:
	.asciz	 "dnscache"
	.size	.L.str26580, 9

	.type	.L.str27581,@object     # @.str27581
.L.str27581:
	.asciz	 "dnstimeout"
	.size	.L.str27581, 11

	.type	.L.str28582,@object     # @.str28582
.L.str28582:
	.asciz	 "domains"
	.size	.L.str28582, 8

	.type	.L.str29583,@object     # @.str29583
.L.str29583:
	.asciz	 "dotbytes"
	.size	.L.str29583, 9

	.type	.L.str30584,@object     # @.str30584
.L.str30584:
	.asciz	 "dotsinline"
	.size	.L.str30584, 11

	.type	.L.str31585,@object     # @.str31585
.L.str31585:
	.asciz	 "dotspacing"
	.size	.L.str31585, 11

	.type	.L.str32586,@object     # @.str32586
.L.str32586:
	.asciz	 "dotstyle"
	.size	.L.str32586, 9

	.type	.L.str33587,@object     # @.str33587
.L.str33587:
	.asciz	 "excludedirectories"
	.size	.L.str33587, 19

	.type	.L.str34588,@object     # @.str34588
.L.str34588:
	.asciz	 "excludedomains"
	.size	.L.str34588, 15

	.type	.L.str35589,@object     # @.str35589
.L.str35589:
	.asciz	 "followftp"
	.size	.L.str35589, 10

	.type	.L.str36590,@object     # @.str36590
.L.str36590:
	.asciz	 "followtags"
	.size	.L.str36590, 11

	.type	.L.str37591,@object     # @.str37591
.L.str37591:
	.asciz	 "forcehtml"
	.size	.L.str37591, 10

	.type	.L.str38592,@object     # @.str38592
.L.str38592:
	.asciz	 "ftppasswd"
	.size	.L.str38592, 10

	.type	.L.str39593,@object     # @.str39593
.L.str39593:
	.asciz	 "ftppassword"
	.size	.L.str39593, 12

	.type	.L.str40594,@object     # @.str40594
.L.str40594:
	.asciz	 "ftpproxy"
	.size	.L.str40594, 9

	.type	.L.str41595,@object     # @.str41595
.L.str41595:
	.asciz	 "ftpuser"
	.size	.L.str41595, 8

	.type	.L.str42596,@object     # @.str42596
.L.str42596:
	.asciz	 "glob"
	.size	.L.str42596, 5

	.type	.L.str43597,@object     # @.str43597
.L.str43597:
	.asciz	 "header"
	.size	.L.str43597, 7

	.type	.L.str44598,@object     # @.str44598
.L.str44598:
	.asciz	 "htmlextension"
	.size	.L.str44598, 14

	.type	.L.str45599,@object     # @.str45599
.L.str45599:
	.asciz	 "htmlify"
	.size	.L.str45599, 8

	.type	.L.str46600,@object     # @.str46600
.L.str46600:
	.asciz	 "httpkeepalive"
	.size	.L.str46600, 14

	.type	.L.str47601,@object     # @.str47601
.L.str47601:
	.asciz	 "httppasswd"
	.size	.L.str47601, 11

	.type	.L.str48602,@object     # @.str48602
.L.str48602:
	.asciz	 "httppassword"
	.size	.L.str48602, 13

	.type	.L.str49603,@object     # @.str49603
.L.str49603:
	.asciz	 "httpproxy"
	.size	.L.str49603, 10

	.type	.L.str50604,@object     # @.str50604
.L.str50604:
	.asciz	 "httpsproxy"
	.size	.L.str50604, 11

	.type	.L.str51605,@object     # @.str51605
.L.str51605:
	.asciz	 "httpuser"
	.size	.L.str51605, 9

	.type	.L.str52606,@object     # @.str52606
.L.str52606:
	.asciz	 "ignorecase"
	.size	.L.str52606, 11

	.type	.L.str53607,@object     # @.str53607
.L.str53607:
	.asciz	 "ignorelength"
	.size	.L.str53607, 13

	.type	.L.str54608,@object     # @.str54608
.L.str54608:
	.asciz	 "ignoretags"
	.size	.L.str54608, 11

	.type	.L.str55609,@object     # @.str55609
.L.str55609:
	.asciz	 "includedirectories"
	.size	.L.str55609, 19

	.type	.L.str56610,@object     # @.str56610
.L.str56610:
	.asciz	 "inet4only"
	.size	.L.str56610, 10

	.type	.L.str57611,@object     # @.str57611
.L.str57611:
	.asciz	 "inet6only"
	.size	.L.str57611, 10

	.type	.L.str58612,@object     # @.str58612
.L.str58612:
	.asciz	 "input"
	.size	.L.str58612, 6

	.type	.L.str59613,@object     # @.str59613
.L.str59613:
	.asciz	 "keepsessioncookies"
	.size	.L.str59613, 19

	.type	.L.str60614,@object     # @.str60614
.L.str60614:
	.asciz	 "limitrate"
	.size	.L.str60614, 10

	.type	.L.str61615,@object     # @.str61615
.L.str61615:
	.asciz	 "loadcookies"
	.size	.L.str61615, 12

	.type	.L.str62616,@object     # @.str62616
.L.str62616:
	.asciz	 "logfile"
	.size	.L.str62616, 8

	.type	.L.str63617,@object     # @.str63617
.L.str63617:
	.asciz	 "login"
	.size	.L.str63617, 6

	.type	.L.str64618,@object     # @.str64618
.L.str64618:
	.asciz	 "maxredirect"
	.size	.L.str64618, 12

	.type	.L.str65619,@object     # @.str65619
.L.str65619:
	.asciz	 "mirror"
	.size	.L.str65619, 7

	.type	.L.str66620,@object     # @.str66620
.L.str66620:
	.asciz	 "netrc"
	.size	.L.str66620, 6

	.type	.L.str67621,@object     # @.str67621
.L.str67621:
	.asciz	 "noclobber"
	.size	.L.str67621, 10

	.type	.L.str68622,@object     # @.str68622
.L.str68622:
	.asciz	 "noparent"
	.size	.L.str68622, 9

	.type	.L.str69623,@object     # @.str69623
.L.str69623:
	.asciz	 "noproxy"
	.size	.L.str69623, 8

	.type	.L.str70624,@object     # @.str70624
.L.str70624:
	.asciz	 "numtries"
	.size	.L.str70624, 9

	.type	.L.str71625,@object     # @.str71625
.L.str71625:
	.asciz	 "outputdocument"
	.size	.L.str71625, 15

	.type	.L.str72626,@object     # @.str72626
.L.str72626:
	.asciz	 "pagerequisites"
	.size	.L.str72626, 15

	.type	.L.str73627,@object     # @.str73627
.L.str73627:
	.asciz	 "passiveftp"
	.size	.L.str73627, 11

	.type	.L.str74628,@object     # @.str74628
.L.str74628:
	.asciz	 "passwd"
	.size	.L.str74628, 7

	.type	.L.str75629,@object     # @.str75629
.L.str75629:
	.asciz	 "password"
	.size	.L.str75629, 9

	.type	.L.str76630,@object     # @.str76630
.L.str76630:
	.asciz	 "postdata"
	.size	.L.str76630, 9

	.type	.L.str77631,@object     # @.str77631
.L.str77631:
	.asciz	 "postfile"
	.size	.L.str77631, 9

	.type	.L.str78632,@object     # @.str78632
.L.str78632:
	.asciz	 "preferfamily"
	.size	.L.str78632, 13

	.type	.L.str79633,@object     # @.str79633
.L.str79633:
	.asciz	 "preservepermissions"
	.size	.L.str79633, 20

	.type	.L.str80634,@object     # @.str80634
.L.str80634:
	.asciz	 "progress"
	.size	.L.str80634, 9

	.type	.L.str81635,@object     # @.str81635
.L.str81635:
	.asciz	 "protocoldirectories"
	.size	.L.str81635, 20

	.type	.L.str82636,@object     # @.str82636
.L.str82636:
	.asciz	 "proxypasswd"
	.size	.L.str82636, 12

	.type	.L.str83637,@object     # @.str83637
.L.str83637:
	.asciz	 "proxypassword"
	.size	.L.str83637, 14

	.type	.L.str84638,@object     # @.str84638
.L.str84638:
	.asciz	 "proxyuser"
	.size	.L.str84638, 10

	.type	.L.str85639,@object     # @.str85639
.L.str85639:
	.asciz	 "quiet"
	.size	.L.str85639, 6

	.type	.L.str86640,@object     # @.str86640
.L.str86640:
	.asciz	 "quota"
	.size	.L.str86640, 6

	.type	.L.str87641,@object     # @.str87641
.L.str87641:
	.asciz	 "randomwait"
	.size	.L.str87641, 11

	.type	.L.str88642,@object     # @.str88642
.L.str88642:
	.asciz	 "readtimeout"
	.size	.L.str88642, 12

	.type	.L.str89643,@object     # @.str89643
.L.str89643:
	.asciz	 "reclevel"
	.size	.L.str89643, 9

	.type	.L.str90644,@object     # @.str90644
.L.str90644:
	.asciz	 "recursive"
	.size	.L.str90644, 10

	.type	.L.str91645,@object     # @.str91645
.L.str91645:
	.asciz	 "referer"
	.size	.L.str91645, 8

	.type	.L.str92646,@object     # @.str92646
.L.str92646:
	.asciz	 "reject"
	.size	.L.str92646, 7

	.type	.L.str93647,@object     # @.str93647
.L.str93647:
	.asciz	 "relativeonly"
	.size	.L.str93647, 13

	.type	.L.str94648,@object     # @.str94648
.L.str94648:
	.asciz	 "removelisting"
	.size	.L.str94648, 14

	.type	.L.str95649,@object     # @.str95649
.L.str95649:
	.asciz	 "restrictfilenames"
	.size	.L.str95649, 18

	.type	.L.str96650,@object     # @.str96650
.L.str96650:
	.asciz	 "retrsymlinks"
	.size	.L.str96650, 13

	.type	.L.str97651,@object     # @.str97651
.L.str97651:
	.asciz	 "retryconnrefused"
	.size	.L.str97651, 17

	.type	.L.str98652,@object     # @.str98652
.L.str98652:
	.asciz	 "robots"
	.size	.L.str98652, 7

	.type	.L.str99653,@object     # @.str99653
.L.str99653:
	.asciz	 "savecookies"
	.size	.L.str99653, 12

	.type	.L.str100654,@object    # @.str100654
.L.str100654:
	.asciz	 "saveheaders"
	.size	.L.str100654, 12

	.type	.L.str101655,@object    # @.str101655
.L.str101655:
	.asciz	 "serverresponse"
	.size	.L.str101655, 15

	.type	.L.str102656,@object    # @.str102656
.L.str102656:
	.asciz	 "spanhosts"
	.size	.L.str102656, 10

	.type	.L.str103657,@object    # @.str103657
.L.str103657:
	.asciz	 "spider"
	.size	.L.str103657, 7

	.type	.L.str104658,@object    # @.str104658
.L.str104658:
	.asciz	 "strictcomments"
	.size	.L.str104658, 15

	.type	.L.str105659,@object    # @.str105659
.L.str105659:
	.asciz	 "timeout"
	.size	.L.str105659, 8

	.type	.L.str106660,@object    # @.str106660
.L.str106660:
	.asciz	 "timestamping"
	.size	.L.str106660, 13

	.type	.L.str107661,@object    # @.str107661
.L.str107661:
	.asciz	 "tries"
	.size	.L.str107661, 6

	.type	.L.str108662,@object    # @.str108662
.L.str108662:
	.asciz	 "useproxy"
	.size	.L.str108662, 9

	.type	.L.str109663,@object    # @.str109663
.L.str109663:
	.asciz	 "user"
	.size	.L.str109663, 5

	.type	.L.str110664,@object    # @.str110664
.L.str110664:
	.asciz	 "useragent"
	.size	.L.str110664, 10

	.type	.L.str111665,@object    # @.str111665
.L.str111665:
	.asciz	 "verbose"
	.size	.L.str111665, 8

	.type	.L.str112666,@object    # @.str112666
.L.str112666:
	.asciz	 "wait"
	.size	.L.str112666, 5

	.type	.L.str113667,@object    # @.str113667
.L.str113667:
	.asciz	 "waitretry"
	.size	.L.str113667, 10

	.type	.L.str114668,@object    # @.str114668
.L.str114668:
	.asciz	 "%s: %s: Invalid value `%s'.\n"
	.size	.L.str114668, 29

	.type	.L.str115669,@object    # @.str115669
.L.str115669:
	.asciz	 "unix"
	.size	.L.str115669, 5

	.type	.L.str116670,@object    # @.str116670
.L.str116670:
	.asciz	 "windows"
	.size	.L.str116670, 8

	.type	.L.str117671,@object    # @.str117671
.L.str117671:
	.asciz	 "lowercase"
	.size	.L.str117671, 10

	.type	.L.str118,@object       # @.str118
.L.str118:
	.asciz	 "uppercase"
	.size	.L.str118, 10

	.type	.L.str119672,@object    # @.str119672
.L.str119672:
	.asciz	 "nocontrol"
	.size	.L.str119672, 10

	.type	.L.str120673,@object    # @.str120673
.L.str120673:
	.asciz	 "%s: %s: Invalid restriction `%s', use [unix|windows],[lowercase|uppercase],[nocontrol].\n"
	.size	.L.str120673, 89

	.type	.L.str121674,@object    # @.str121674
.L.str121674:
	.asciz	 "%s: %s: Invalid byte value `%s'\n"
	.size	.L.str121674, 33

	.type	.L.str122675,@object    # @.str122675
.L.str122675:
	.asciz	 "inf"
	.size	.L.str122675, 4

	.type	.L.str123676,@object    # @.str123676
.L.str123676:
	.asciz	 "%s: %s: Invalid progress type `%s'.\n"
	.size	.L.str123676, 37

	.type	cmd_spec_prefer_family.choices,@object # @cmd_spec_prefer_family.choices
	.section	.rodata,"a",@progbits
	.align	4
cmd_spec_prefer_family.choices:
	.long	.L.str124677
	.long	0                       # 0x0
	.long	.L.str125678
	.long	1                       # 0x1
	.long	.L.str126679
	.long	2                       # 0x2
	.size	cmd_spec_prefer_family.choices, 24

	.type	.L.str124677,@object    # @.str124677
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str124677:
	.asciz	 "IPv4"
	.size	.L.str124677, 5

	.type	.L.str125678,@object    # @.str125678
.L.str125678:
	.asciz	 "IPv6"
	.size	.L.str125678, 5

	.type	.L.str126679,@object    # @.str126679
.L.str126679:
	.asciz	 "none"
	.size	.L.str126679, 5

	.type	enable_tilde_expansion.b,@object # @enable_tilde_expansion.b
	.local	enable_tilde_expansion.b
	.comm	enable_tilde_expansion.b,1,1
	.type	.L.str127680,@object    # @.str127680
.L.str127680:
	.asciz	 "/"
	.size	.L.str127680, 2

	.type	.L.str128681,@object    # @.str128681
.L.str128681:
	.asciz	 "%s: %s: Invalid header `%s'.\n"
	.size	.L.str128681, 30

	.type	.L.str129682,@object    # @.str129682
.L.str129682:
	.asciz	 "%s: %s: Invalid time period `%s'\n"
	.size	.L.str129682, 34

	.type	.L.str130683,@object    # @.str130683
.L.str130683:
	.asciz	 "%s: %s: Invalid number `%s'.\n"
	.size	.L.str130683, 30

	.type	.L.str131684,@object    # @.str131684
.L.str131684:
	.asciz	 "%s: %s: Invalid boolean `%s'; use `on' or `off'.\n"
	.size	.L.str131684, 50

	.type	.L.str132685,@object    # @.str132685
.L.str132685:
	.asciz	 "0 <= comind && comind < (sizeof (commands) / sizeof ((commands)[0]))"
	.size	.L.str132685, 69

	.type	.L__PRETTY_FUNCTION__.setval_internal,@object # @__PRETTY_FUNCTION__.setval_internal
.L__PRETTY_FUNCTION__.setval_internal:
	.asciz	 "_Bool setval_internal(int, const char *, const char *)"
	.size	.L__PRETTY_FUNCTION__.setval_internal, 55

	.type	.L.str133686,@object    # @.str133686
.L.str133686:
	.asciz	 "Setting %s (%s) to %s\n"
	.size	.L.str133686, 23

	.type	.L.str134687,@object    # @.str134687
.L.str134687:
	.asciz	 "WGETRC"
	.size	.L.str134687, 7

	.type	.L.str135688,@object    # @.str135688
.L.str135688:
	.asciz	 "%s: WGETRC points to %s, which doesn't exist.\n"
	.size	.L.str135688, 47

	.type	.L.str136689,@object    # @.str136689
.L.str136689:
	.asciz	 "%s/.wgetrc"
	.size	.L.str136689, 11

	.type	.L.str137690,@object    # @.str137690
.L.str137690:
	.asciz	 "rb"
	.size	.L.str137690, 3

	.type	.L.str138691,@object    # @.str138691
.L.str138691:
	.asciz	 "%s: Cannot read %s (%s).\n"
	.size	.L.str138691, 26

	.type	.L.str139692,@object    # @.str139692
.L.str139692:
	.asciz	 "%s: Error in %s at line %d.\n"
	.size	.L.str139692, 29

	.type	.L.str140693,@object    # @.str140693
.L.str140693:
	.asciz	 "%s: Syntax error in %s at line %d.\n"
	.size	.L.str140693, 36

	.type	.L.str141694,@object    # @.str141694
.L.str141694:
	.asciz	 "%s: Unknown command `%s' in %s at line %d.\n"
	.size	.L.str141694, 44

	.type	.L.str142695,@object    # @.str142695
.L.str142695:
	.asciz	 "no_proxy"
	.size	.L.str142695, 9

	.type	save_context_p,@object  # @save_context_p
	.local	save_context_p
	.comm	save_context_p,1,1
	.type	flush_log_p.b,@object   # @flush_log_p.b
	.local	flush_log_p.b
	.comm	flush_log_p.b,1,1
	.type	needs_flushing.b,@object # @needs_flushing.b
	.local	needs_flushing.b
	.comm	needs_flushing.b,1,1
	.type	inhibit_logging.b,@object # @inhibit_logging.b
	.local	inhibit_logging.b
	.comm	inhibit_logging.b,1,1
	.type	.L.str696,@object       # @.str696
.L.str696:
	.asciz	 "a"
	.size	.L.str696, 2

	.type	.L.str1697,@object      # @.str1697
.L.str1697:
	.asciz	 "w"
	.size	.L.str1697, 2

	.type	logfp,@object           # @logfp
	.local	logfp
	.comm	logfp,4,4
	.type	.L.str2698,@object      # @.str2698
.L.str2698:
	.asciz	 "%s: %s: %s\n"
	.size	.L.str2698, 12

	.type	log_line_current,@object # @log_line_current
	.data
	.align	4
log_line_current:
	.long	4294967295              # 0xffffffff
	.size	log_line_current, 4

	.type	trailing_line,@object   # @trailing_line
	.local	trailing_line
	.comm	trailing_line,1,1
	.type	ring,@object            # @ring
	.local	ring
	.comm	ring,24,4
	.type	redirect_request,@object # @redirect_request
	.local	redirect_request
	.comm	redirect_request,4,4
	.type	redirect_request_signal_name,@object # @redirect_request_signal_name
	.local	redirect_request_signal_name
	.comm	redirect_request_signal_name,4,4
	.type	.L.str3699,@object      # @.str3699
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str3699:
	.asciz	 "wget-log"
	.size	.L.str3699, 9

	.type	.L.str4700,@object      # @.str4700
.L.str4700:
	.asciz	 "\n%s received, redirecting output to `%s'.\n"
	.size	.L.str4700, 43

	.type	.L.str5701,@object      # @.str5701
.L.str5701:
	.asciz	 "\n%s received.\n"
	.size	.L.str5701, 15

	.type	.L.str6702,@object      # @.str6702
.L.str6702:
	.asciz	 "%s: %s; disabling logging.\n"
	.size	.L.str6702, 28

	.type	log_lines,@object       # @log_lines
	.local	log_lines
	.comm	log_lines,3360,4
	.type	escnonprint_internal.ringpos,@object # @escnonprint_internal.ringpos
	.local	escnonprint_internal.ringpos
	.comm	escnonprint_internal.ringpos,4,4
	.type	.L.str7703,@object      # @.str7703
.L.str7703:
	.asciz	 "base == 8 || base == 16"
	.size	.L.str7703, 24

	.type	.L.str8704,@object      # @.str8704
.L.str8704:
	.asciz	 "log.c"
	.size	.L.str8704, 6

	.type	.L__PRETTY_FUNCTION__.escnonprint_internal,@object # @__PRETTY_FUNCTION__.escnonprint_internal
.L__PRETTY_FUNCTION__.escnonprint_internal:
	.asciz	 "const char *escnonprint_internal(const char *, char, int)"
	.size	.L__PRETTY_FUNCTION__.escnonprint_internal, 58

	.type	.L.str9705,@object      # @.str9705
.L.str9705:
	.asciz	 "0123456789ABCDEF"
	.size	.L.str9705, 17

	.type	exec_name,@object       # @exec_name
	.comm	exec_name,4,4
	.type	short_options,@object   # @short_options
	.local	short_options
	.comm	short_options,128,1
	.type	long_options,@object    # @long_options
	.local	long_options
	.comm	long_options,3696,4
	.type	.L.str718,@object       # @.str718
.L.str718:
	.asciz	 "\n"
	.size	.L.str718, 2

	.type	.L.str1719,@object      # @.str1719
.L.str1719:
	.asciz	 "Try `%s --help' for more options.\n"
	.size	.L.str1719, 35

	.type	optmap,@object          # @optmap
	.local	optmap
	.comm	optmap,96,1
	.type	option_data,@object     # @option_data
	.section	.rodata,"a",@progbits
	.align	4
option_data:
	.long	.L.str38758
	.byte	65                      # 0x41
	.zero	3
	.long	0                       # 0x0
	.long	.L.str38758
	.long	4294967295              # 0xffffffff
	.long	.L.str39759
	.byte	97                      # 0x61
	.zero	3
	.long	3                       # 0x3
	.long	0
	.long	1                       # 0x1
	.long	.L.str40760
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str41761
	.long	4294967295              # 0xffffffff
	.long	.L.str42762
	.byte	98                      # 0x62
	.zero	3
	.long	1                       # 0x1
	.long	.L.str42762
	.long	4294967295              # 0xffffffff
	.long	.L.str43763
	.byte	75                      # 0x4b
	.zero	3
	.long	1                       # 0x1
	.long	.L.str44764
	.long	4294967295              # 0xffffffff
	.long	.L.str45765
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str45765
	.long	4294967295              # 0xffffffff
	.long	.L.str46766
	.byte	66                      # 0x42
	.zero	3
	.long	0                       # 0x0
	.long	.L.str46766
	.long	4294967295              # 0xffffffff
	.long	.L.str47767
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str48768
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str49769
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str50770
	.long	4294967295              # 0xffffffff
	.long	.L.str51771
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str51771
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str52772
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str53773
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str54774
	.long	4294967295              # 0xffffffff
	.long	.L.str55775
	.byte	0                       # 0x0
	.zero	3
	.long	4                       # 0x4
	.long	0
	.long	2                       # 0x2
	.long	.L.str56776
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str57777
	.long	4294967295              # 0xffffffff
	.long	.L.str58778
	.byte	99                      # 0x63
	.zero	3
	.long	1                       # 0x1
	.long	.L.str58778
	.long	4294967295              # 0xffffffff
	.long	.L.str59779
	.byte	107                     # 0x6b
	.zero	3
	.long	1                       # 0x1
	.long	.L.str60780
	.long	4294967295              # 0xffffffff
	.long	.L.str61781
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str62782
	.long	4294967295              # 0xffffffff
	.long	.L.str63783
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str63783
	.long	4294967295              # 0xffffffff
	.long	.L.str64784
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str65785
	.long	4294967295              # 0xffffffff
	.long	.L.str66786
	.byte	100                     # 0x64
	.zero	3
	.long	1                       # 0x1
	.long	.L.str66786
	.long	4294967295              # 0xffffffff
	.long	.L.str67787
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str68788
	.long	4294967295              # 0xffffffff
	.long	.L.str69789
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str7725
	.long	4294967295              # 0xffffffff
	.long	.L.str70790
	.byte	80                      # 0x50
	.zero	3
	.long	0                       # 0x0
	.long	.L.str71791
	.long	4294967295              # 0xffffffff
	.long	.L.str72792
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str73793
	.long	4294967295              # 0xffffffff
	.long	.L.str74794
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str75795
	.long	4294967295              # 0xffffffff
	.long	.L.str76796
	.byte	68                      # 0x44
	.zero	3
	.long	0                       # 0x0
	.long	.L.str76796
	.long	4294967295              # 0xffffffff
	.long	.L.str77797
	.byte	0                       # 0x0
	.zero	3
	.long	5                       # 0x5
	.long	0
	.long	0                       # 0x0
	.long	.L.str78798
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str79799
	.long	4294967295              # 0xffffffff
	.long	.L.str80800
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str81801
	.long	4294967295              # 0xffffffff
	.long	.L.str82802
	.byte	88                      # 0x58
	.zero	3
	.long	0                       # 0x0
	.long	.L.str83803
	.long	4294967295              # 0xffffffff
	.long	.L.str84804
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str85805
	.long	4294967295              # 0xffffffff
	.long	.L.str86806
	.byte	101                     # 0x65
	.zero	3
	.long	6                       # 0x6
	.long	0
	.long	1                       # 0x1
	.long	.L.str87807
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str88808
	.long	4294967295              # 0xffffffff
	.long	.L.str89809
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str90810
	.long	4294967295              # 0xffffffff
	.long	.L.str91811
	.byte	120                     # 0x78
	.zero	3
	.long	1                       # 0x1
	.long	.L.str7725
	.long	4294967295              # 0xffffffff
	.long	.L.str92812
	.byte	70                      # 0x46
	.zero	3
	.long	1                       # 0x1
	.long	.L.str93813
	.long	4294967295              # 0xffffffff
	.long	.L.str94814
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str95815
	.long	4294967295              # 0xffffffff
	.long	.L.str96816
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str97817
	.long	4294967295              # 0xffffffff
	.long	.L.str98818
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str98818
	.long	4294967295              # 0xffffffff
	.long	.L.str99819
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str99819
	.long	4294967295              # 0xffffffff
	.long	.L.str100820
	.byte	104                     # 0x68
	.zero	3
	.long	2                       # 0x2
	.long	print_help
	.long	0                       # 0x0
	.long	.L.str101821
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str6724
	.long	4294967295              # 0xffffffff
	.long	.L.str102822
	.byte	69                      # 0x45
	.zero	3
	.long	1                       # 0x1
	.long	.L.str103823
	.long	4294967295              # 0xffffffff
	.long	.L.str104824
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str104824
	.long	4294967295              # 0xffffffff
	.long	.L.str105825
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str106826
	.long	4294967295              # 0xffffffff
	.long	.L.str107827
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str108828
	.long	4294967295              # 0xffffffff
	.long	.L.str109829
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str108828
	.long	4294967295              # 0xffffffff
	.long	.L.str110830
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str111831
	.long	4294967295              # 0xffffffff
	.long	.L.str112832
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str113833
	.long	4294967295              # 0xffffffff
	.long	.L.str114834
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str115835
	.long	4294967295              # 0xffffffff
	.long	.L.str116836
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str117837
	.long	4294967295              # 0xffffffff
	.long	.L.str118838
	.byte	73                      # 0x49
	.zero	3
	.long	0                       # 0x0
	.long	.L.str119839
	.long	4294967295              # 0xffffffff
	.long	.L.str120840
	.byte	52                      # 0x34
	.zero	3
	.long	1                       # 0x1
	.long	.L.str121841
	.long	4294967295              # 0xffffffff
	.long	.L.str122842
	.byte	54                      # 0x36
	.zero	3
	.long	1                       # 0x1
	.long	.L.str123843
	.long	4294967295              # 0xffffffff
	.long	.L.str124844
	.byte	105                     # 0x69
	.zero	3
	.long	0                       # 0x0
	.long	.L.str125845
	.long	4294967295              # 0xffffffff
	.long	.L.str126846
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str127847
	.long	4294967295              # 0xffffffff
	.long	.L.str128848
	.byte	108                     # 0x6c
	.zero	3
	.long	0                       # 0x0
	.long	.L.str129849
	.long	4294967295              # 0xffffffff
	.long	.L.str130850
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str131851
	.long	4294967295              # 0xffffffff
	.long	.L.str132852
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str133853
	.long	4294967295              # 0xffffffff
	.long	.L.str134854
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str135855
	.long	4294967295              # 0xffffffff
	.long	.L.str136856
	.byte	109                     # 0x6d
	.zero	3
	.long	1                       # 0x1
	.long	.L.str136856
	.long	4294967295              # 0xffffffff
	.long	.L.str137857
	.byte	110                     # 0x6e
	.zero	3
	.long	7                       # 0x7
	.long	0
	.long	1                       # 0x1
	.long	.L.str138858
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str8726
	.long	4294967295              # 0xffffffff
	.long	.L.str139859
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str9727
	.long	4294967295              # 0xffffffff
	.long	.L.str140860
	.byte	79                      # 0x4f
	.zero	3
	.long	0                       # 0x0
	.long	.L.str141861
	.long	4294967295              # 0xffffffff
	.long	.L.str142862
	.byte	111                     # 0x6f
	.zero	3
	.long	0                       # 0x0
	.long	.L.str4722
	.long	4294967295              # 0xffffffff
	.long	.L.str143863
	.byte	112                     # 0x70
	.zero	3
	.long	1                       # 0x1
	.long	.L.str144864
	.long	4294967295              # 0xffffffff
	.long	.L.str145
	.byte	0                       # 0x0
	.zero	3
	.long	8                       # 0x8
	.long	0
	.long	2                       # 0x2
	.long	.L.str146
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str147
	.long	4294967295              # 0xffffffff
	.long	.L.str148
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str148
	.long	4294967295              # 0xffffffff
	.long	.L.str149
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str150
	.long	4294967295              # 0xffffffff
	.long	.L.str151
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str152
	.long	4294967295              # 0xffffffff
	.long	.L.str153
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str154
	.long	4294967295              # 0xffffffff
	.long	.L.str155
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str156
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str157
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str158
	.long	4294967295              # 0xffffffff
	.long	.L.str159865
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str159865
	.long	4294967295              # 0xffffffff
	.long	.L.str160
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str161
	.long	4294967295              # 0xffffffff
	.long	.L.str162
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str163
	.long	4294967295              # 0xffffffff
	.long	.L.str164
	.byte	89                      # 0x59
	.zero	3
	.long	0                       # 0x0
	.long	.L.str163
	.long	4294967295              # 0xffffffff
	.long	.L.str165
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str166
	.long	4294967295              # 0xffffffff
	.long	.L.str167
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str166
	.long	4294967295              # 0xffffffff
	.long	.L.str168
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str169
	.long	4294967295              # 0xffffffff
	.long	.L.str170
	.byte	113                     # 0x71
	.zero	3
	.long	1                       # 0x1
	.long	.L.str170
	.long	4294967295              # 0xffffffff
	.long	.L.str171
	.byte	81                      # 0x51
	.zero	3
	.long	0                       # 0x0
	.long	.L.str171
	.long	4294967295              # 0xffffffff
	.long	.L.str172
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str173
	.long	4294967295              # 0xffffffff
	.long	.L.str174
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str175
	.long	4294967295              # 0xffffffff
	.long	.L.str176
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str177
	.long	4294967295              # 0xffffffff
	.long	.L.str178
	.byte	114                     # 0x72
	.zero	3
	.long	1                       # 0x1
	.long	.L.str178
	.long	4294967295              # 0xffffffff
	.long	.L.str179
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str179
	.long	4294967295              # 0xffffffff
	.long	.L.str180
	.byte	82                      # 0x52
	.zero	3
	.long	0                       # 0x0
	.long	.L.str180
	.long	4294967295              # 0xffffffff
	.long	.L.str181
	.byte	76                      # 0x4c
	.zero	3
	.long	1                       # 0x1
	.long	.L.str182
	.long	4294967295              # 0xffffffff
	.long	.L.str183
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str11729
	.long	4294967295              # 0xffffffff
	.long	.L.str184
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str185
	.long	4294967295              # 0xffffffff
	.long	.L.str186
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str187
	.long	4294967295              # 0xffffffff
	.long	.L.str188
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str189
	.long	4294967295              # 0xffffffff
	.long	.L.str190
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str191
	.long	4294967295              # 0xffffffff
	.long	.L.str192
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str193
	.long	4294967295              # 0xffffffff
	.long	0
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str194
	.long	4294967295              # 0xffffffff
	.long	.L.str195
	.byte	83                      # 0x53
	.zero	3
	.long	1                       # 0x1
	.long	.L.str196
	.long	4294967295              # 0xffffffff
	.long	.L.str197
	.byte	72                      # 0x48
	.zero	3
	.long	1                       # 0x1
	.long	.L.str198
	.long	4294967295              # 0xffffffff
	.long	.L.str199
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str199
	.long	4294967295              # 0xffffffff
	.long	.L.str200
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str201
	.long	4294967295              # 0xffffffff
	.long	.L.str202
	.byte	84                      # 0x54
	.zero	3
	.long	0                       # 0x0
	.long	.L.str202
	.long	4294967295              # 0xffffffff
	.long	.L.str203
	.byte	78                      # 0x4e
	.zero	3
	.long	1                       # 0x1
	.long	.L.str203
	.long	4294967295              # 0xffffffff
	.long	.L.str204
	.byte	116                     # 0x74
	.zero	3
	.long	0                       # 0x0
	.long	.L.str204
	.long	4294967295              # 0xffffffff
	.long	.L.str205
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str205
	.long	4294967295              # 0xffffffff
	.long	.L.str206
	.byte	85                      # 0x55
	.zero	3
	.long	0                       # 0x0
	.long	.L.str207866
	.long	4294967295              # 0xffffffff
	.long	.L.str5723
	.byte	118                     # 0x76
	.zero	3
	.long	1                       # 0x1
	.long	.L.str5723
	.long	4294967295              # 0xffffffff
	.long	.L.str5723
	.byte	0                       # 0x0
	.zero	3
	.long	1                       # 0x1
	.long	.L.str5723
	.long	4294967295              # 0xffffffff
	.long	.L.str208
	.byte	86                      # 0x56
	.zero	3
	.long	2                       # 0x2
	.long	print_version
	.long	0                       # 0x0
	.long	.L.str209
	.byte	119                     # 0x77
	.zero	3
	.long	0                       # 0x0
	.long	.L.str209
	.long	4294967295              # 0xffffffff
	.long	.L.str210
	.byte	0                       # 0x0
	.zero	3
	.long	0                       # 0x0
	.long	.L.str210
	.long	4294967295              # 0xffffffff
	.size	option_data, 2300

	.type	.L.str2720,@object      # @.str2720
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str2720:
	.asciz	 "0"
	.size	.L.str2720, 2

	.type	.L.str3721,@object      # @.str3721
.L.str3721:
	.asciz	 "1"
	.size	.L.str3721, 2

	.type	.L.str4722,@object      # @.str4722
.L.str4722:
	.asciz	 "logfile"
	.size	.L.str4722, 8

	.type	.L.str5723,@object      # @.str5723
.L.str5723:
	.asciz	 "verbose"
	.size	.L.str5723, 8

	.type	.L.str6724,@object      # @.str6724
.L.str6724:
	.asciz	 "addhostdir"
	.size	.L.str6724, 11

	.type	.L.str7725,@object      # @.str7725
.L.str7725:
	.asciz	 "dirstruct"
	.size	.L.str7725, 10

	.type	.L.str8726,@object      # @.str8726
.L.str8726:
	.asciz	 "noclobber"
	.size	.L.str8726, 10

	.type	.L.str9727,@object      # @.str9727
.L.str9727:
	.asciz	 "noparent"
	.size	.L.str9727, 9

	.type	.L.str10728,@object     # @.str10728
.L.str10728:
	.asciz	 "%s: illegal option -- `-n%c'\n"
	.size	.L.str10728, 30

	.type	.L.str11729,@object     # @.str11729
.L.str11729:
	.asciz	 "removelisting"
	.size	.L.str11729, 14

	.type	opt,@object             # @opt
	.comm	opt,344,4
	.type	.L.str12732,@object     # @.str12732
.L.str12732:
	.asciz	 "Can't be verbose and quiet at the same time.\n"
	.size	.L.str12732, 46

	.type	.L.str13733,@object     # @.str13733
.L.str13733:
	.asciz	 "Can't timestamp and not clobber old files at the same time.\n"
	.size	.L.str13733, 61

	.type	.L.str14734,@object     # @.str14734
.L.str14734:
	.asciz	 "Cannot specify both --inet4-only and --inet6-only.\n"
	.size	.L.str14734, 52

	.type	.L.str15735,@object     # @.str15735
.L.str15735:
	.asciz	 "Cannot specify both -k and -O if multiple URLs are given, or in combination\nwith -p or -r. See the manual for details.\n\n"
	.size	.L.str15735, 121

	.type	.L.str16736,@object     # @.str16736
.L.str16736:
	.asciz	 "%s"
	.size	.L.str16736, 3

	.type	.L.str17737,@object     # @.str17737
.L.str17737:
	.asciz	 "WARNING: combining -O with -r or -p will mean that all downloaded content\nwill be placed in the single file you specified.\n\n"
	.size	.L.str17737, 125

	.type	.L.str18738,@object     # @.str18738
.L.str18738:
	.asciz	 "WARNING: timestamping does nothing in combination with -O. See the manual\nfor details.\n\n"
	.size	.L.str18738, 89

	.type	.L.str19739,@object     # @.str19739
.L.str19739:
	.asciz	 "File `%s' already there; not retrieving.\n"
	.size	.L.str19739, 42

	.type	.L.str20740,@object     # @.str20740
.L.str20740:
	.asciz	 "%s: missing URL\n"
	.size	.L.str20740, 17

	.type	.L.str21741,@object     # @.str21741
.L.str21741:
	.asciz	 "DEBUG output created by Wget %s on %s.\n\n"
	.size	.L.str21741, 41

	.type	.L.str22742,@object     # @.str22742
.L.str22742:
	.asciz	 "linux-gnu"
	.size	.L.str22742, 10

	.type	.L.str23743,@object     # @.str23743
.L.str23743:
	.asciz	 "ab"
	.size	.L.str23743, 3

	.type	.L.str24744,@object     # @.str24744
.L.str24744:
	.asciz	 "wb"
	.size	.L.str24744, 3

	.type	.L.str25745,@object     # @.str25745
.L.str25745:
	.asciz	 "Removing file due to --delete-after in main():\n"
	.size	.L.str25745, 48

	.type	.L.str26746,@object     # @.str26746
.L.str26746:
	.asciz	 "Removing %s.\n"
	.size	.L.str26746, 14

	.type	.L.str27747,@object     # @.str27747
.L.str27747:
	.asciz	 "unlink: %s\n"
	.size	.L.str27747, 12

	.type	.L.str28748,@object     # @.str28748
.L.str28748:
	.asciz	 "No URLs found in %s.\n"
	.size	.L.str28748, 22

	.type	.L.str29749,@object     # @.str29749
.L.str29749:
	.asciz	 "FINISHED --%s--\nDownloaded: %d files, %s in %s (%s)\n"
	.size	.L.str29749, 53

	.type	.L.str30750,@object     # @.str30750
.L.str30750:
	.asciz	 "Download quota of %s EXCEEDED!\n"
	.size	.L.str30750, 32

	.type	.L.str31751,@object     # @.str31751
.L.str31751:
	.asciz	 "SIGHUP"
	.size	.L.str31751, 7

	.type	.L.str32752,@object     # @.str32752
.L.str32752:
	.asciz	 "SIGUSR1"
	.size	.L.str32752, 8

	.type	.L.str33753,@object     # @.str33753
.L.str33753:
	.asciz	 "WTF?!"
	.size	.L.str33753, 6

	.type	secs_to_human_time.buf,@object # @secs_to_human_time.buf
	.local	secs_to_human_time.buf
	.comm	secs_to_human_time.buf,32,1
	.type	.L.str34754,@object     # @.str34754
.L.str34754:
	.asciz	 "%dd %dh %dm %ds"
	.size	.L.str34754, 16

	.type	.L.str35755,@object     # @.str35755
.L.str35755:
	.asciz	 "%dh %dm %ds"
	.size	.L.str35755, 12

	.type	.L.str36756,@object     # @.str36756
.L.str36756:
	.asciz	 "%dm %ds"
	.size	.L.str36756, 8

	.type	.L.str37757,@object     # @.str37757
.L.str37757:
	.asciz	 "%ss"
	.size	.L.str37757, 4

	.type	.L.str38758,@object     # @.str38758
.L.str38758:
	.asciz	 "accept"
	.size	.L.str38758, 7

	.type	.L.str39759,@object     # @.str39759
.L.str39759:
	.asciz	 "append-output"
	.size	.L.str39759, 14

	.type	.L.str40760,@object     # @.str40760
.L.str40760:
	.asciz	 "auth-no-challenge"
	.size	.L.str40760, 18

	.type	.L.str41761,@object     # @.str41761
.L.str41761:
	.asciz	 "authnochallenge"
	.size	.L.str41761, 16

	.type	.L.str42762,@object     # @.str42762
.L.str42762:
	.asciz	 "background"
	.size	.L.str42762, 11

	.type	.L.str43763,@object     # @.str43763
.L.str43763:
	.asciz	 "backup-converted"
	.size	.L.str43763, 17

	.type	.L.str44764,@object     # @.str44764
.L.str44764:
	.asciz	 "backupconverted"
	.size	.L.str44764, 16

	.type	.L.str45765,@object     # @.str45765
.L.str45765:
	.asciz	 "backups"
	.size	.L.str45765, 8

	.type	.L.str46766,@object     # @.str46766
.L.str46766:
	.asciz	 "base"
	.size	.L.str46766, 5

	.type	.L.str47767,@object     # @.str47767
.L.str47767:
	.asciz	 "bind-address"
	.size	.L.str47767, 13

	.type	.L.str48768,@object     # @.str48768
.L.str48768:
	.asciz	 "bindaddress"
	.size	.L.str48768, 12

	.type	.L.str49769,@object     # @.str49769
.L.str49769:
	.asciz	 "cacertificate"
	.size	.L.str49769, 14

	.type	.L.str50770,@object     # @.str50770
.L.str50770:
	.asciz	 "cadirectory"
	.size	.L.str50770, 12

	.type	.L.str51771,@object     # @.str51771
.L.str51771:
	.asciz	 "cache"
	.size	.L.str51771, 6

	.type	.L.str52772,@object     # @.str52772
.L.str52772:
	.asciz	 "certificate"
	.size	.L.str52772, 12

	.type	.L.str53773,@object     # @.str53773
.L.str53773:
	.asciz	 "certificatetype"
	.size	.L.str53773, 16

	.type	.L.str54774,@object     # @.str54774
.L.str54774:
	.asciz	 "checkcertificate"
	.size	.L.str54774, 17

	.type	.L.str55775,@object     # @.str55775
.L.str55775:
	.asciz	 "clobber"
	.size	.L.str55775, 8

	.type	.L.str56776,@object     # @.str56776
.L.str56776:
	.asciz	 "connect-timeout"
	.size	.L.str56776, 16

	.type	.L.str57777,@object     # @.str57777
.L.str57777:
	.asciz	 "connecttimeout"
	.size	.L.str57777, 15

	.type	.L.str58778,@object     # @.str58778
.L.str58778:
	.asciz	 "continue"
	.size	.L.str58778, 9

	.type	.L.str59779,@object     # @.str59779
.L.str59779:
	.asciz	 "convert-links"
	.size	.L.str59779, 14

	.type	.L.str60780,@object     # @.str60780
.L.str60780:
	.asciz	 "convertlinks"
	.size	.L.str60780, 13

	.type	.L.str61781,@object     # @.str61781
.L.str61781:
	.asciz	 "content-disposition"
	.size	.L.str61781, 20

	.type	.L.str62782,@object     # @.str62782
.L.str62782:
	.asciz	 "contentdisposition"
	.size	.L.str62782, 19

	.type	.L.str63783,@object     # @.str63783
.L.str63783:
	.asciz	 "cookies"
	.size	.L.str63783, 8

	.type	.L.str64784,@object     # @.str64784
.L.str64784:
	.asciz	 "cut-dirs"
	.size	.L.str64784, 9

	.type	.L.str65785,@object     # @.str65785
.L.str65785:
	.asciz	 "cutdirs"
	.size	.L.str65785, 8

	.type	.L.str66786,@object     # @.str66786
.L.str66786:
	.asciz	 "debug"
	.size	.L.str66786, 6

	.type	.L.str67787,@object     # @.str67787
.L.str67787:
	.asciz	 "delete-after"
	.size	.L.str67787, 13

	.type	.L.str68788,@object     # @.str68788
.L.str68788:
	.asciz	 "deleteafter"
	.size	.L.str68788, 12

	.type	.L.str69789,@object     # @.str69789
.L.str69789:
	.asciz	 "directories"
	.size	.L.str69789, 12

	.type	.L.str70790,@object     # @.str70790
.L.str70790:
	.asciz	 "directory-prefix"
	.size	.L.str70790, 17

	.type	.L.str71791,@object     # @.str71791
.L.str71791:
	.asciz	 "dirprefix"
	.size	.L.str71791, 10

	.type	.L.str72792,@object     # @.str72792
.L.str72792:
	.asciz	 "dns-cache"
	.size	.L.str72792, 10

	.type	.L.str73793,@object     # @.str73793
.L.str73793:
	.asciz	 "dnscache"
	.size	.L.str73793, 9

	.type	.L.str74794,@object     # @.str74794
.L.str74794:
	.asciz	 "dns-timeout"
	.size	.L.str74794, 12

	.type	.L.str75795,@object     # @.str75795
.L.str75795:
	.asciz	 "dnstimeout"
	.size	.L.str75795, 11

	.type	.L.str76796,@object     # @.str76796
.L.str76796:
	.asciz	 "domains"
	.size	.L.str76796, 8

	.type	.L.str77797,@object     # @.str77797
.L.str77797:
	.asciz	 "dont-remove-listing"
	.size	.L.str77797, 20

	.type	.L.str78798,@object     # @.str78798
.L.str78798:
	.asciz	 "dot-style"
	.size	.L.str78798, 10

	.type	.L.str79799,@object     # @.str79799
.L.str79799:
	.asciz	 "dotstyle"
	.size	.L.str79799, 9

	.type	.L.str80800,@object     # @.str80800
.L.str80800:
	.asciz	 "egd-file"
	.size	.L.str80800, 9

	.type	.L.str81801,@object     # @.str81801
.L.str81801:
	.asciz	 "egdfile"
	.size	.L.str81801, 8

	.type	.L.str82802,@object     # @.str82802
.L.str82802:
	.asciz	 "exclude-directories"
	.size	.L.str82802, 20

	.type	.L.str83803,@object     # @.str83803
.L.str83803:
	.asciz	 "excludedirectories"
	.size	.L.str83803, 19

	.type	.L.str84804,@object     # @.str84804
.L.str84804:
	.asciz	 "exclude-domains"
	.size	.L.str84804, 16

	.type	.L.str85805,@object     # @.str85805
.L.str85805:
	.asciz	 "excludedomains"
	.size	.L.str85805, 15

	.type	.L.str86806,@object     # @.str86806
.L.str86806:
	.asciz	 "execute"
	.size	.L.str86806, 8

	.type	.L.str87807,@object     # @.str87807
.L.str87807:
	.asciz	 "follow-ftp"
	.size	.L.str87807, 11

	.type	.L.str88808,@object     # @.str88808
.L.str88808:
	.asciz	 "followftp"
	.size	.L.str88808, 10

	.type	.L.str89809,@object     # @.str89809
.L.str89809:
	.asciz	 "follow-tags"
	.size	.L.str89809, 12

	.type	.L.str90810,@object     # @.str90810
.L.str90810:
	.asciz	 "followtags"
	.size	.L.str90810, 11

	.type	.L.str91811,@object     # @.str91811
.L.str91811:
	.asciz	 "force-directories"
	.size	.L.str91811, 18

	.type	.L.str92812,@object     # @.str92812
.L.str92812:
	.asciz	 "force-html"
	.size	.L.str92812, 11

	.type	.L.str93813,@object     # @.str93813
.L.str93813:
	.asciz	 "forcehtml"
	.size	.L.str93813, 10

	.type	.L.str94814,@object     # @.str94814
.L.str94814:
	.asciz	 "ftp-password"
	.size	.L.str94814, 13

	.type	.L.str95815,@object     # @.str95815
.L.str95815:
	.asciz	 "ftppassword"
	.size	.L.str95815, 12

	.type	.L.str96816,@object     # @.str96816
.L.str96816:
	.asciz	 "ftp-user"
	.size	.L.str96816, 9

	.type	.L.str97817,@object     # @.str97817
.L.str97817:
	.asciz	 "ftpuser"
	.size	.L.str97817, 8

	.type	.L.str98818,@object     # @.str98818
.L.str98818:
	.asciz	 "glob"
	.size	.L.str98818, 5

	.type	.L.str99819,@object     # @.str99819
.L.str99819:
	.asciz	 "header"
	.size	.L.str99819, 7

	.type	.L.str100820,@object    # @.str100820
.L.str100820:
	.asciz	 "help"
	.size	.L.str100820, 5

	.type	.L.str101821,@object    # @.str101821
.L.str101821:
	.asciz	 "host-directories"
	.size	.L.str101821, 17

	.type	.L.str102822,@object    # @.str102822
.L.str102822:
	.asciz	 "html-extension"
	.size	.L.str102822, 15

	.type	.L.str103823,@object    # @.str103823
.L.str103823:
	.asciz	 "htmlextension"
	.size	.L.str103823, 14

	.type	.L.str104824,@object    # @.str104824
.L.str104824:
	.asciz	 "htmlify"
	.size	.L.str104824, 8

	.type	.L.str105825,@object    # @.str105825
.L.str105825:
	.asciz	 "http-keep-alive"
	.size	.L.str105825, 16

	.type	.L.str106826,@object    # @.str106826
.L.str106826:
	.asciz	 "httpkeepalive"
	.size	.L.str106826, 14

	.type	.L.str107827,@object    # @.str107827
.L.str107827:
	.asciz	 "http-passwd"
	.size	.L.str107827, 12

	.type	.L.str108828,@object    # @.str108828
.L.str108828:
	.asciz	 "httppassword"
	.size	.L.str108828, 13

	.type	.L.str109829,@object    # @.str109829
.L.str109829:
	.asciz	 "http-password"
	.size	.L.str109829, 14

	.type	.L.str110830,@object    # @.str110830
.L.str110830:
	.asciz	 "http-user"
	.size	.L.str110830, 10

	.type	.L.str111831,@object    # @.str111831
.L.str111831:
	.asciz	 "httpuser"
	.size	.L.str111831, 9

	.type	.L.str112832,@object    # @.str112832
.L.str112832:
	.asciz	 "ignore-case"
	.size	.L.str112832, 12

	.type	.L.str113833,@object    # @.str113833
.L.str113833:
	.asciz	 "ignorecase"
	.size	.L.str113833, 11

	.type	.L.str114834,@object    # @.str114834
.L.str114834:
	.asciz	 "ignore-length"
	.size	.L.str114834, 14

	.type	.L.str115835,@object    # @.str115835
.L.str115835:
	.asciz	 "ignorelength"
	.size	.L.str115835, 13

	.type	.L.str116836,@object    # @.str116836
.L.str116836:
	.asciz	 "ignore-tags"
	.size	.L.str116836, 12

	.type	.L.str117837,@object    # @.str117837
.L.str117837:
	.asciz	 "ignoretags"
	.size	.L.str117837, 11

	.type	.L.str118838,@object    # @.str118838
.L.str118838:
	.asciz	 "include-directories"
	.size	.L.str118838, 20

	.type	.L.str119839,@object    # @.str119839
.L.str119839:
	.asciz	 "includedirectories"
	.size	.L.str119839, 19

	.type	.L.str120840,@object    # @.str120840
.L.str120840:
	.asciz	 "inet4-only"
	.size	.L.str120840, 11

	.type	.L.str121841,@object    # @.str121841
.L.str121841:
	.asciz	 "inet4only"
	.size	.L.str121841, 10

	.type	.L.str122842,@object    # @.str122842
.L.str122842:
	.asciz	 "inet6-only"
	.size	.L.str122842, 11

	.type	.L.str123843,@object    # @.str123843
.L.str123843:
	.asciz	 "inet6only"
	.size	.L.str123843, 10

	.type	.L.str124844,@object    # @.str124844
.L.str124844:
	.asciz	 "input-file"
	.size	.L.str124844, 11

	.type	.L.str125845,@object    # @.str125845
.L.str125845:
	.asciz	 "input"
	.size	.L.str125845, 6

	.type	.L.str126846,@object    # @.str126846
.L.str126846:
	.asciz	 "keep-session-cookies"
	.size	.L.str126846, 21

	.type	.L.str127847,@object    # @.str127847
.L.str127847:
	.asciz	 "keepsessioncookies"
	.size	.L.str127847, 19

	.type	.L.str128848,@object    # @.str128848
.L.str128848:
	.asciz	 "level"
	.size	.L.str128848, 6

	.type	.L.str129849,@object    # @.str129849
.L.str129849:
	.asciz	 "reclevel"
	.size	.L.str129849, 9

	.type	.L.str130850,@object    # @.str130850
.L.str130850:
	.asciz	 "limit-rate"
	.size	.L.str130850, 11

	.type	.L.str131851,@object    # @.str131851
.L.str131851:
	.asciz	 "limitrate"
	.size	.L.str131851, 10

	.type	.L.str132852,@object    # @.str132852
.L.str132852:
	.asciz	 "load-cookies"
	.size	.L.str132852, 13

	.type	.L.str133853,@object    # @.str133853
.L.str133853:
	.asciz	 "loadcookies"
	.size	.L.str133853, 12

	.type	.L.str134854,@object    # @.str134854
.L.str134854:
	.asciz	 "max-redirect"
	.size	.L.str134854, 13

	.type	.L.str135855,@object    # @.str135855
.L.str135855:
	.asciz	 "maxredirect"
	.size	.L.str135855, 12

	.type	.L.str136856,@object    # @.str136856
.L.str136856:
	.asciz	 "mirror"
	.size	.L.str136856, 7

	.type	.L.str137857,@object    # @.str137857
.L.str137857:
	.asciz	 "no"
	.size	.L.str137857, 3

	.type	.L.str138858,@object    # @.str138858
.L.str138858:
	.asciz	 "no-clobber"
	.size	.L.str138858, 11

	.type	.L.str139859,@object    # @.str139859
.L.str139859:
	.asciz	 "no-parent"
	.size	.L.str139859, 10

	.type	.L.str140860,@object    # @.str140860
.L.str140860:
	.asciz	 "output-document"
	.size	.L.str140860, 16

	.type	.L.str141861,@object    # @.str141861
.L.str141861:
	.asciz	 "outputdocument"
	.size	.L.str141861, 15

	.type	.L.str142862,@object    # @.str142862
.L.str142862:
	.asciz	 "output-file"
	.size	.L.str142862, 12

	.type	.L.str143863,@object    # @.str143863
.L.str143863:
	.asciz	 "page-requisites"
	.size	.L.str143863, 16

	.type	.L.str144864,@object    # @.str144864
.L.str144864:
	.asciz	 "pagerequisites"
	.size	.L.str144864, 15

	.type	.L.str145,@object       # @.str145
.L.str145:
	.asciz	 "parent"
	.size	.L.str145, 7

	.type	.L.str146,@object       # @.str146
.L.str146:
	.asciz	 "passive-ftp"
	.size	.L.str146, 12

	.type	.L.str147,@object       # @.str147
.L.str147:
	.asciz	 "passiveftp"
	.size	.L.str147, 11

	.type	.L.str148,@object       # @.str148
.L.str148:
	.asciz	 "password"
	.size	.L.str148, 9

	.type	.L.str149,@object       # @.str149
.L.str149:
	.asciz	 "post-data"
	.size	.L.str149, 10

	.type	.L.str150,@object       # @.str150
.L.str150:
	.asciz	 "postdata"
	.size	.L.str150, 9

	.type	.L.str151,@object       # @.str151
.L.str151:
	.asciz	 "post-file"
	.size	.L.str151, 10

	.type	.L.str152,@object       # @.str152
.L.str152:
	.asciz	 "postfile"
	.size	.L.str152, 9

	.type	.L.str153,@object       # @.str153
.L.str153:
	.asciz	 "prefer-family"
	.size	.L.str153, 14

	.type	.L.str154,@object       # @.str154
.L.str154:
	.asciz	 "preferfamily"
	.size	.L.str154, 13

	.type	.L.str155,@object       # @.str155
.L.str155:
	.asciz	 "preserve-permissions"
	.size	.L.str155, 21

	.type	.L.str156,@object       # @.str156
.L.str156:
	.asciz	 "preservepermissions"
	.size	.L.str156, 20

	.type	.L.str157,@object       # @.str157
.L.str157:
	.asciz	 "privatekey"
	.size	.L.str157, 11

	.type	.L.str158,@object       # @.str158
.L.str158:
	.asciz	 "privatekeytype"
	.size	.L.str158, 15

	.type	.L.str159865,@object    # @.str159865
.L.str159865:
	.asciz	 "progress"
	.size	.L.str159865, 9

	.type	.L.str160,@object       # @.str160
.L.str160:
	.asciz	 "protocol-directories"
	.size	.L.str160, 21

	.type	.L.str161,@object       # @.str161
.L.str161:
	.asciz	 "protocoldirectories"
	.size	.L.str161, 20

	.type	.L.str162,@object       # @.str162
.L.str162:
	.asciz	 "proxy"
	.size	.L.str162, 6

	.type	.L.str163,@object       # @.str163
.L.str163:
	.asciz	 "useproxy"
	.size	.L.str163, 9

	.type	.L.str164,@object       # @.str164
.L.str164:
	.asciz	 "proxy__compat"
	.size	.L.str164, 14

	.type	.L.str165,@object       # @.str165
.L.str165:
	.asciz	 "proxy-passwd"
	.size	.L.str165, 13

	.type	.L.str166,@object       # @.str166
.L.str166:
	.asciz	 "proxypassword"
	.size	.L.str166, 14

	.type	.L.str167,@object       # @.str167
.L.str167:
	.asciz	 "proxy-password"
	.size	.L.str167, 15

	.type	.L.str168,@object       # @.str168
.L.str168:
	.asciz	 "proxy-user"
	.size	.L.str168, 11

	.type	.L.str169,@object       # @.str169
.L.str169:
	.asciz	 "proxyuser"
	.size	.L.str169, 10

	.type	.L.str170,@object       # @.str170
.L.str170:
	.asciz	 "quiet"
	.size	.L.str170, 6

	.type	.L.str171,@object       # @.str171
.L.str171:
	.asciz	 "quota"
	.size	.L.str171, 6

	.type	.L.str172,@object       # @.str172
.L.str172:
	.asciz	 "random-file"
	.size	.L.str172, 12

	.type	.L.str173,@object       # @.str173
.L.str173:
	.asciz	 "randomfile"
	.size	.L.str173, 11

	.type	.L.str174,@object       # @.str174
.L.str174:
	.asciz	 "random-wait"
	.size	.L.str174, 12

	.type	.L.str175,@object       # @.str175
.L.str175:
	.asciz	 "randomwait"
	.size	.L.str175, 11

	.type	.L.str176,@object       # @.str176
.L.str176:
	.asciz	 "read-timeout"
	.size	.L.str176, 13

	.type	.L.str177,@object       # @.str177
.L.str177:
	.asciz	 "readtimeout"
	.size	.L.str177, 12

	.type	.L.str178,@object       # @.str178
.L.str178:
	.asciz	 "recursive"
	.size	.L.str178, 10

	.type	.L.str179,@object       # @.str179
.L.str179:
	.asciz	 "referer"
	.size	.L.str179, 8

	.type	.L.str180,@object       # @.str180
.L.str180:
	.asciz	 "reject"
	.size	.L.str180, 7

	.type	.L.str181,@object       # @.str181
.L.str181:
	.asciz	 "relative"
	.size	.L.str181, 9

	.type	.L.str182,@object       # @.str182
.L.str182:
	.asciz	 "relativeonly"
	.size	.L.str182, 13

	.type	.L.str183,@object       # @.str183
.L.str183:
	.asciz	 "remove-listing"
	.size	.L.str183, 15

	.type	.L.str184,@object       # @.str184
.L.str184:
	.asciz	 "restrict-file-names"
	.size	.L.str184, 20

	.type	.L.str185,@object       # @.str185
.L.str185:
	.asciz	 "restrictfilenames"
	.size	.L.str185, 18

	.type	.L.str186,@object       # @.str186
.L.str186:
	.asciz	 "retr-symlinks"
	.size	.L.str186, 14

	.type	.L.str187,@object       # @.str187
.L.str187:
	.asciz	 "retrsymlinks"
	.size	.L.str187, 13

	.type	.L.str188,@object       # @.str188
.L.str188:
	.asciz	 "retry-connrefused"
	.size	.L.str188, 18

	.type	.L.str189,@object       # @.str189
.L.str189:
	.asciz	 "retryconnrefused"
	.size	.L.str189, 17

	.type	.L.str190,@object       # @.str190
.L.str190:
	.asciz	 "save-cookies"
	.size	.L.str190, 13

	.type	.L.str191,@object       # @.str191
.L.str191:
	.asciz	 "savecookies"
	.size	.L.str191, 12

	.type	.L.str192,@object       # @.str192
.L.str192:
	.asciz	 "save-headers"
	.size	.L.str192, 13

	.type	.L.str193,@object       # @.str193
.L.str193:
	.asciz	 "saveheaders"
	.size	.L.str193, 12

	.type	.L.str194,@object       # @.str194
.L.str194:
	.asciz	 "secureprotocol"
	.size	.L.str194, 15

	.type	.L.str195,@object       # @.str195
.L.str195:
	.asciz	 "server-response"
	.size	.L.str195, 16

	.type	.L.str196,@object       # @.str196
.L.str196:
	.asciz	 "serverresponse"
	.size	.L.str196, 15

	.type	.L.str197,@object       # @.str197
.L.str197:
	.asciz	 "span-hosts"
	.size	.L.str197, 11

	.type	.L.str198,@object       # @.str198
.L.str198:
	.asciz	 "spanhosts"
	.size	.L.str198, 10

	.type	.L.str199,@object       # @.str199
.L.str199:
	.asciz	 "spider"
	.size	.L.str199, 7

	.type	.L.str200,@object       # @.str200
.L.str200:
	.asciz	 "strict-comments"
	.size	.L.str200, 16

	.type	.L.str201,@object       # @.str201
.L.str201:
	.asciz	 "strictcomments"
	.size	.L.str201, 15

	.type	.L.str202,@object       # @.str202
.L.str202:
	.asciz	 "timeout"
	.size	.L.str202, 8

	.type	.L.str203,@object       # @.str203
.L.str203:
	.asciz	 "timestamping"
	.size	.L.str203, 13

	.type	.L.str204,@object       # @.str204
.L.str204:
	.asciz	 "tries"
	.size	.L.str204, 6

	.type	.L.str205,@object       # @.str205
.L.str205:
	.asciz	 "user"
	.size	.L.str205, 5

	.type	.L.str206,@object       # @.str206
.L.str206:
	.asciz	 "user-agent"
	.size	.L.str206, 11

	.type	.L.str207866,@object    # @.str207866
.L.str207866:
	.asciz	 "useragent"
	.size	.L.str207866, 10

	.type	.L.str208,@object       # @.str208
.L.str208:
	.asciz	 "version"
	.size	.L.str208, 8

	.type	.L.str209,@object       # @.str209
.L.str209:
	.asciz	 "wait"
	.size	.L.str209, 5

	.type	.L.str210,@object       # @.str210
.L.str210:
	.asciz	 "waitretry"
	.size	.L.str210, 10

	.type	.L.str211,@object       # @.str211
.L.str211:
	.asciz	 "GNU Wget %s\n\n"
	.size	.L.str211, 14

	.type	.L.str212,@object       # @.str212
.L.str212:
	.asciz	 "Copyright (C) 2008 Free Software Foundation, Inc.\n"
	.size	.L.str212, 51

	.type	.L.str213,@object       # @.str213
.L.str213:
	.asciz	 "License GPLv3+: GNU GPL version 3 or later\n<http://www.gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"
	.size	.L.str213, 205

	.type	.L.str214,@object       # @.str214
.L.str214:
	.asciz	 "\nOriginally written by Hrvoje Niksic <hniksic@xemacs.org>.\n"
	.size	.L.str214, 60

	.type	.L.str215,@object       # @.str215
.L.str215:
	.asciz	 "Currently maintained by Micah Cowan <micah@cowan.name>.\n"
	.size	.L.str215, 57

	.type	print_help.help,@object # @print_help.help
	.section	.rodata,"a",@progbits
	.align	4
print_help.help:
	.long	.L.str718
	.long	.L.str216
	.long	.L.str217
	.long	.L.str218867
	.long	.L.str219
	.long	.L.str220
	.long	.L.str221
	.long	.L.str718
	.long	.L.str222
	.long	.L.str223
	.long	.L.str224
	.long	.L.str225
	.long	.L.str226
	.long	.L.str227
	.long	.L.str228
	.long	.L.str229
	.long	.L.str230
	.long	.L.str231
	.long	.L.str718
	.long	.L.str232
	.long	.L.str233
	.long	.L.str234
	.long	.L.str235868
	.long	.L.str236
	.long	.L.str237
	.long	.L.str238
	.long	.L.str239
	.long	.L.str240
	.long	.L.str241
	.long	.L.str242
	.long	.L.str243
	.long	.L.str244
	.long	.L.str245
	.long	.L.str246
	.long	.L.str247
	.long	.L.str248
	.long	.L.str249
	.long	.L.str250
	.long	.L.str251
	.long	.L.str252
	.long	.L.str253
	.long	.L.str254
	.long	.L.str255
	.long	.L.str256
	.long	.L.str257
	.long	.L.str258
	.long	.L.str259
	.long	.L.str260869
	.long	.L.str718
	.long	.L.str261
	.long	.L.str262
	.long	.L.str263
	.long	.L.str264
	.long	.L.str265
	.long	.L.str266
	.long	.L.str267
	.long	.L.str718
	.long	.L.str268
	.long	.L.str269
	.long	.L.str270
	.long	.L.str271
	.long	.L.str272
	.long	.L.str273
	.long	.L.str274
	.long	.L.str275
	.long	.L.str276
	.long	.L.str277
	.long	.L.str278
	.long	.L.str279
	.long	.L.str280
	.long	.L.str281
	.long	.L.str282
	.long	.L.str283
	.long	.L.str284
	.long	.L.str285
	.long	.L.str286
	.long	.L.str287
	.long	.L.str288
	.long	.L.str289
	.long	.L.str718
	.long	.L.str290
	.long	.L.str291
	.long	.L.str292
	.long	.L.str293
	.long	.L.str294
	.long	.L.str295
	.long	.L.str296
	.long	.L.str297
	.long	.L.str718
	.long	.L.str298
	.long	.L.str299
	.long	.L.str300
	.long	.L.str301
	.long	.L.str302
	.long	.L.str303
	.long	.L.str304
	.long	.L.str305
	.long	.L.str306
	.long	.L.str718
	.long	.L.str307870
	.long	.L.str308
	.long	.L.str309
	.long	.L.str310
	.long	.L.str311
	.long	.L.str312
	.long	.L.str313
	.long	.L.str314
	.long	.L.str315
	.long	.L.str316
	.long	.L.str317
	.long	.L.str318
	.long	.L.str319871
	.long	.L.str718
	.long	.L.str320
	.size	print_help.help, 456

	.type	.L.str216,@object       # @.str216
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str216:
	.asciz	 "Mandatory arguments to long options are mandatory for short options too.\n\n"
	.size	.L.str216, 75

	.type	.L.str217,@object       # @.str217
.L.str217:
	.asciz	 "Startup:\n"
	.size	.L.str217, 10

	.type	.L.str218867,@object    # @.str218867
.L.str218867:
	.asciz	 "  -V,  --version           display the version of Wget and exit.\n"
	.size	.L.str218867, 66

	.type	.L.str219,@object       # @.str219
.L.str219:
	.asciz	 "  -h,  --help              print this help.\n"
	.size	.L.str219, 45

	.type	.L.str220,@object       # @.str220
.L.str220:
	.asciz	 "  -b,  --background        go to background after startup.\n"
	.size	.L.str220, 60

	.type	.L.str221,@object       # @.str221
.L.str221:
	.asciz	 "  -e,  --execute=COMMAND   execute a `.wgetrc'-style command.\n"
	.size	.L.str221, 63

	.type	.L.str222,@object       # @.str222
.L.str222:
	.asciz	 "Logging and input file:\n"
	.size	.L.str222, 25

	.type	.L.str223,@object       # @.str223
.L.str223:
	.asciz	 "  -o,  --output-file=FILE    log messages to FILE.\n"
	.size	.L.str223, 52

	.type	.L.str224,@object       # @.str224
.L.str224:
	.asciz	 "  -a,  --append-output=FILE  append messages to FILE.\n"
	.size	.L.str224, 55

	.type	.L.str225,@object       # @.str225
.L.str225:
	.asciz	 "  -d,  --debug               print lots of debugging information.\n"
	.size	.L.str225, 67

	.type	.L.str226,@object       # @.str226
.L.str226:
	.asciz	 "  -q,  --quiet               quiet (no output).\n"
	.size	.L.str226, 49

	.type	.L.str227,@object       # @.str227
.L.str227:
	.asciz	 "  -v,  --verbose             be verbose (this is the default).\n"
	.size	.L.str227, 64

	.type	.L.str228,@object       # @.str228
.L.str228:
	.asciz	 "  -nv, --no-verbose          turn off verboseness, without being quiet.\n"
	.size	.L.str228, 73

	.type	.L.str229,@object       # @.str229
.L.str229:
	.asciz	 "  -i,  --input-file=FILE     download URLs found in FILE.\n"
	.size	.L.str229, 59

	.type	.L.str230,@object       # @.str230
.L.str230:
	.asciz	 "  -F,  --force-html          treat input file as HTML.\n"
	.size	.L.str230, 56

	.type	.L.str231,@object       # @.str231
.L.str231:
	.asciz	 "  -B,  --base=URL            prepends URL to relative links in -F -i file.\n"
	.size	.L.str231, 76

	.type	.L.str232,@object       # @.str232
.L.str232:
	.asciz	 "Download:\n"
	.size	.L.str232, 11

	.type	.L.str233,@object       # @.str233
.L.str233:
	.asciz	 "  -t,  --tries=NUMBER            set number of retries to NUMBER (0 unlimits).\n"
	.size	.L.str233, 80

	.type	.L.str234,@object       # @.str234
.L.str234:
	.asciz	 "       --retry-connrefused       retry even if connection is refused.\n"
	.size	.L.str234, 71

	.type	.L.str235868,@object    # @.str235868
.L.str235868:
	.asciz	 "  -O,  --output-document=FILE    write documents to FILE.\n"
	.size	.L.str235868, 59

	.type	.L.str236,@object       # @.str236
.L.str236:
	.asciz	 "  -nc, --no-clobber              skip downloads that would download to\n                                 existing files.\n"
	.size	.L.str236, 121

	.type	.L.str237,@object       # @.str237
.L.str237:
	.asciz	 "  -c,  --continue                resume getting a partially-downloaded file.\n"
	.size	.L.str237, 78

	.type	.L.str238,@object       # @.str238
.L.str238:
	.asciz	 "       --progress=TYPE           select progress gauge type.\n"
	.size	.L.str238, 62

	.type	.L.str239,@object       # @.str239
.L.str239:
	.asciz	 "  -N,  --timestamping            don't re-retrieve files unless newer than\n                                 local.\n"
	.size	.L.str239, 116

	.type	.L.str240,@object       # @.str240
.L.str240:
	.asciz	 "  -S,  --server-response         print server response.\n"
	.size	.L.str240, 57

	.type	.L.str241,@object       # @.str241
.L.str241:
	.asciz	 "       --spider                  don't download anything.\n"
	.size	.L.str241, 59

	.type	.L.str242,@object       # @.str242
.L.str242:
	.asciz	 "  -T,  --timeout=SECONDS         set all timeout values to SECONDS.\n"
	.size	.L.str242, 69

	.type	.L.str243,@object       # @.str243
.L.str243:
	.asciz	 "       --dns-timeout=SECS        set the DNS lookup timeout to SECS.\n"
	.size	.L.str243, 70

	.type	.L.str244,@object       # @.str244
.L.str244:
	.asciz	 "       --connect-timeout=SECS    set the connect timeout to SECS.\n"
	.size	.L.str244, 67

	.type	.L.str245,@object       # @.str245
.L.str245:
	.asciz	 "       --read-timeout=SECS       set the read timeout to SECS.\n"
	.size	.L.str245, 64

	.type	.L.str246,@object       # @.str246
.L.str246:
	.asciz	 "  -w,  --wait=SECONDS            wait SECONDS between retrievals.\n"
	.size	.L.str246, 67

	.type	.L.str247,@object       # @.str247
.L.str247:
	.asciz	 "       --waitretry=SECONDS       wait 1..SECONDS between retries of a retrieval.\n"
	.size	.L.str247, 82

	.type	.L.str248,@object       # @.str248
.L.str248:
	.asciz	 "       --random-wait             wait from 0...2*WAIT secs between retrievals.\n"
	.size	.L.str248, 80

	.type	.L.str249,@object       # @.str249
.L.str249:
	.asciz	 "       --no-proxy                explicitly turn off proxy.\n"
	.size	.L.str249, 61

	.type	.L.str250,@object       # @.str250
.L.str250:
	.asciz	 "  -Q,  --quota=NUMBER            set retrieval quota to NUMBER.\n"
	.size	.L.str250, 65

	.type	.L.str251,@object       # @.str251
.L.str251:
	.asciz	 "       --bind-address=ADDRESS    bind to ADDRESS (hostname or IP) on local host.\n"
	.size	.L.str251, 82

	.type	.L.str252,@object       # @.str252
.L.str252:
	.asciz	 "       --limit-rate=RATE         limit download rate to RATE.\n"
	.size	.L.str252, 63

	.type	.L.str253,@object       # @.str253
.L.str253:
	.asciz	 "       --no-dns-cache            disable caching DNS lookups.\n"
	.size	.L.str253, 63

	.type	.L.str254,@object       # @.str254
.L.str254:
	.asciz	 "       --restrict-file-names=OS  restrict chars in file names to ones OS allows.\n"
	.size	.L.str254, 82

	.type	.L.str255,@object       # @.str255
.L.str255:
	.asciz	 "       --ignore-case             ignore case when matching files/directories.\n"
	.size	.L.str255, 79

	.type	.L.str256,@object       # @.str256
.L.str256:
	.asciz	 "  -4,  --inet4-only              connect only to IPv4 addresses.\n"
	.size	.L.str256, 66

	.type	.L.str257,@object       # @.str257
.L.str257:
	.asciz	 "  -6,  --inet6-only              connect only to IPv6 addresses.\n"
	.size	.L.str257, 66

	.type	.L.str258,@object       # @.str258
.L.str258:
	.asciz	 "       --prefer-family=FAMILY    connect first to addresses of specified family,\n                                 one of IPv6, IPv4, or none.\n"
	.size	.L.str258, 143

	.type	.L.str259,@object       # @.str259
.L.str259:
	.asciz	 "       --user=USER               set both ftp and http user to USER.\n"
	.size	.L.str259, 70

	.type	.L.str260869,@object    # @.str260869
.L.str260869:
	.asciz	 "       --password=PASS           set both ftp and http password to PASS.\n"
	.size	.L.str260869, 74

	.type	.L.str261,@object       # @.str261
.L.str261:
	.asciz	 "Directories:\n"
	.size	.L.str261, 14

	.type	.L.str262,@object       # @.str262
.L.str262:
	.asciz	 "  -nd, --no-directories           don't create directories.\n"
	.size	.L.str262, 61

	.type	.L.str263,@object       # @.str263
.L.str263:
	.asciz	 "  -x,  --force-directories        force creation of directories.\n"
	.size	.L.str263, 66

	.type	.L.str264,@object       # @.str264
.L.str264:
	.asciz	 "  -nH, --no-host-directories      don't create host directories.\n"
	.size	.L.str264, 66

	.type	.L.str265,@object       # @.str265
.L.str265:
	.asciz	 "       --protocol-directories     use protocol name in directories.\n"
	.size	.L.str265, 69

	.type	.L.str266,@object       # @.str266
.L.str266:
	.asciz	 "  -P,  --directory-prefix=PREFIX  save files to PREFIX/...\n"
	.size	.L.str266, 60

	.type	.L.str267,@object       # @.str267
.L.str267:
	.asciz	 "       --cut-dirs=NUMBER          ignore NUMBER remote directory components.\n"
	.size	.L.str267, 78

	.type	.L.str268,@object       # @.str268
.L.str268:
	.asciz	 "HTTP options:\n"
	.size	.L.str268, 15

	.type	.L.str269,@object       # @.str269
.L.str269:
	.asciz	 "       --http-user=USER        set http user to USER.\n"
	.size	.L.str269, 55

	.type	.L.str270,@object       # @.str270
.L.str270:
	.asciz	 "       --http-password=PASS    set http password to PASS.\n"
	.size	.L.str270, 59

	.type	.L.str271,@object       # @.str271
.L.str271:
	.asciz	 "       --no-cache              disallow server-cached data.\n"
	.size	.L.str271, 61

	.type	.L.str272,@object       # @.str272
.L.str272:
	.asciz	 "  -E,  --html-extension        save HTML documents with `.html' extension.\n"
	.size	.L.str272, 76

	.type	.L.str273,@object       # @.str273
.L.str273:
	.asciz	 "       --ignore-length         ignore `Content-Length' header field.\n"
	.size	.L.str273, 70

	.type	.L.str274,@object       # @.str274
.L.str274:
	.asciz	 "       --header=STRING         insert STRING among the headers.\n"
	.size	.L.str274, 65

	.type	.L.str275,@object       # @.str275
.L.str275:
	.asciz	 "       --max-redirect          maximum redirections allowed per page.\n"
	.size	.L.str275, 71

	.type	.L.str276,@object       # @.str276
.L.str276:
	.asciz	 "       --proxy-user=USER       set USER as proxy username.\n"
	.size	.L.str276, 60

	.type	.L.str277,@object       # @.str277
.L.str277:
	.asciz	 "       --proxy-password=PASS   set PASS as proxy password.\n"
	.size	.L.str277, 60

	.type	.L.str278,@object       # @.str278
.L.str278:
	.asciz	 "       --referer=URL           include `Referer: URL' header in HTTP request.\n"
	.size	.L.str278, 79

	.type	.L.str279,@object       # @.str279
.L.str279:
	.asciz	 "       --save-headers          save the HTTP headers to file.\n"
	.size	.L.str279, 63

	.type	.L.str280,@object       # @.str280
.L.str280:
	.asciz	 "  -U,  --user-agent=AGENT      identify as AGENT instead of Wget/VERSION.\n"
	.size	.L.str280, 75

	.type	.L.str281,@object       # @.str281
.L.str281:
	.asciz	 "       --no-http-keep-alive    disable HTTP keep-alive (persistent connections).\n"
	.size	.L.str281, 82

	.type	.L.str282,@object       # @.str282
.L.str282:
	.asciz	 "       --no-cookies            don't use cookies.\n"
	.size	.L.str282, 51

	.type	.L.str283,@object       # @.str283
.L.str283:
	.asciz	 "       --load-cookies=FILE     load cookies from FILE before session.\n"
	.size	.L.str283, 71

	.type	.L.str284,@object       # @.str284
.L.str284:
	.asciz	 "       --save-cookies=FILE     save cookies to FILE after session.\n"
	.size	.L.str284, 68

	.type	.L.str285,@object       # @.str285
.L.str285:
	.asciz	 "       --keep-session-cookies  load and save session (non-permanent) cookies.\n"
	.size	.L.str285, 79

	.type	.L.str286,@object       # @.str286
.L.str286:
	.asciz	 "       --post-data=STRING      use the POST method; send STRING as the data.\n"
	.size	.L.str286, 78

	.type	.L.str287,@object       # @.str287
.L.str287:
	.asciz	 "       --post-file=FILE        use the POST method; send contents of FILE.\n"
	.size	.L.str287, 76

	.type	.L.str288,@object       # @.str288
.L.str288:
	.asciz	 "       --content-disposition   honor the Content-Disposition header when\n                               choosing local file names (EXPERIMENTAL).\n"
	.size	.L.str288, 147

	.type	.L.str289,@object       # @.str289
.L.str289:
	.asciz	 "       --auth-no-challenge     Send Basic HTTP authentication information\n                               without first waiting for the server's\n                               challenge.\n"
	.size	.L.str289, 187

	.type	.L.str290,@object       # @.str290
.L.str290:
	.asciz	 "FTP options:\n"
	.size	.L.str290, 14

	.type	.L.str291,@object       # @.str291
.L.str291:
	.asciz	 "       --ftp-user=USER         set ftp user to USER.\n"
	.size	.L.str291, 54

	.type	.L.str292,@object       # @.str292
.L.str292:
	.asciz	 "       --ftp-password=PASS     set ftp password to PASS.\n"
	.size	.L.str292, 58

	.type	.L.str293,@object       # @.str293
.L.str293:
	.asciz	 "       --no-remove-listing     don't remove `.listing' files.\n"
	.size	.L.str293, 63

	.type	.L.str294,@object       # @.str294
.L.str294:
	.asciz	 "       --no-glob               turn off FTP file name globbing.\n"
	.size	.L.str294, 65

	.type	.L.str295,@object       # @.str295
.L.str295:
	.asciz	 "       --no-passive-ftp        disable the \"passive\" transfer mode.\n"
	.size	.L.str295, 69

	.type	.L.str296,@object       # @.str296
.L.str296:
	.asciz	 "       --retr-symlinks         when recursing, get linked-to files (not dir).\n"
	.size	.L.str296, 79

	.type	.L.str297,@object       # @.str297
.L.str297:
	.asciz	 "       --preserve-permissions  preserve remote file permissions.\n"
	.size	.L.str297, 66

	.type	.L.str298,@object       # @.str298
.L.str298:
	.asciz	 "Recursive download:\n"
	.size	.L.str298, 21

	.type	.L.str299,@object       # @.str299
.L.str299:
	.asciz	 "  -r,  --recursive          specify recursive download.\n"
	.size	.L.str299, 57

	.type	.L.str300,@object       # @.str300
.L.str300:
	.asciz	 "  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).\n"
	.size	.L.str300, 78

	.type	.L.str301,@object       # @.str301
.L.str301:
	.asciz	 "       --delete-after       delete files locally after downloading them.\n"
	.size	.L.str301, 74

	.type	.L.str302,@object       # @.str302
.L.str302:
	.asciz	 "  -k,  --convert-links      make links in downloaded HTML point to local files.\n"
	.size	.L.str302, 81

	.type	.L.str303,@object       # @.str303
.L.str303:
	.asciz	 "  -K,  --backup-converted   before converting file X, back up as X.orig.\n"
	.size	.L.str303, 74

	.type	.L.str304,@object       # @.str304
.L.str304:
	.asciz	 "  -m,  --mirror             shortcut for -N -r -l inf --no-remove-listing.\n"
	.size	.L.str304, 76

	.type	.L.str305,@object       # @.str305
.L.str305:
	.asciz	 "  -p,  --page-requisites    get all images, etc. needed to display HTML page.\n"
	.size	.L.str305, 79

	.type	.L.str306,@object       # @.str306
.L.str306:
	.asciz	 "       --strict-comments    turn on strict (SGML) handling of HTML comments.\n"
	.size	.L.str306, 78

	.type	.L.str307870,@object    # @.str307870
.L.str307870:
	.asciz	 "Recursive accept/reject:\n"
	.size	.L.str307870, 26

	.type	.L.str308,@object       # @.str308
.L.str308:
	.asciz	 "  -A,  --accept=LIST               comma-separated list of accepted extensions.\n"
	.size	.L.str308, 81

	.type	.L.str309,@object       # @.str309
.L.str309:
	.asciz	 "  -R,  --reject=LIST               comma-separated list of rejected extensions.\n"
	.size	.L.str309, 81

	.type	.L.str310,@object       # @.str310
.L.str310:
	.asciz	 "  -D,  --domains=LIST              comma-separated list of accepted domains.\n"
	.size	.L.str310, 78

	.type	.L.str311,@object       # @.str311
.L.str311:
	.asciz	 "       --exclude-domains=LIST      comma-separated list of rejected domains.\n"
	.size	.L.str311, 78

	.type	.L.str312,@object       # @.str312
.L.str312:
	.asciz	 "       --follow-ftp                follow FTP links from HTML documents.\n"
	.size	.L.str312, 74

	.type	.L.str313,@object       # @.str313
.L.str313:
	.asciz	 "       --follow-tags=LIST          comma-separated list of followed HTML tags.\n"
	.size	.L.str313, 80

	.type	.L.str314,@object       # @.str314
.L.str314:
	.asciz	 "       --ignore-tags=LIST          comma-separated list of ignored HTML tags.\n"
	.size	.L.str314, 79

	.type	.L.str315,@object       # @.str315
.L.str315:
	.asciz	 "  -H,  --span-hosts                go to foreign hosts when recursive.\n"
	.size	.L.str315, 72

	.type	.L.str316,@object       # @.str316
.L.str316:
	.asciz	 "  -L,  --relative                  follow relative links only.\n"
	.size	.L.str316, 64

	.type	.L.str317,@object       # @.str317
.L.str317:
	.asciz	 "  -I,  --include-directories=LIST  list of allowed directories.\n"
	.size	.L.str317, 65

	.type	.L.str318,@object       # @.str318
.L.str318:
	.asciz	 "  -X,  --exclude-directories=LIST  list of excluded directories.\n"
	.size	.L.str318, 66

	.type	.L.str319871,@object    # @.str319871
.L.str319871:
	.asciz	 "  -np, --no-parent                 don't ascend to the parent directory.\n"
	.size	.L.str319871, 74

	.type	.L.str320,@object       # @.str320
.L.str320:
	.asciz	 "Mail bug reports and suggestions to <bug-wget@gnu.org>.\n"
	.size	.L.str320, 57

	.type	.L.str321,@object       # @.str321
.L.str321:
	.asciz	 "GNU Wget %s, a non-interactive network retriever.\n"
	.size	.L.str321, 51

	.type	.L.str322,@object       # @.str322
.L.str322:
	.asciz	 "Usage: %s [OPTION]... [URL]...\n"
	.size	.L.str322, 32

	.type	.L.str323,@object       # @.str323
.L.str323:
	.asciz	 "opt->argtype != -1"
	.size	.L.str323, 19

	.type	.L.str324,@object       # @.str324
.L.str324:
	.asciz	 "main.c"
	.size	.L.str324, 7

	.type	.L__PRETTY_FUNCTION__.init_switches,@object # @__PRETTY_FUNCTION__.init_switches
.L__PRETTY_FUNCTION__.init_switches:
	.asciz	 "void init_switches()"
	.size	.L__PRETTY_FUNCTION__.init_switches, 21

	.type	.L.str325,@object       # @.str325
.L.str325:
	.asciz	 "o <= (sizeof (long_options) / sizeof ((long_options)[0]))"
	.size	.L.str325, 58

	.type	no_prefix.buffer,@object # @no_prefix.buffer
	.local	no_prefix.buffer
	.comm	no_prefix.buffer,1024,1
	.type	no_prefix.p,@object     # @no_prefix.p
	.data
	.align	4
no_prefix.p:
	.long	no_prefix.buffer
	.size	no_prefix.p, 4

	.type	.L.str326,@object       # @.str326
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str326:
	.zero	1
	.size	.L.str326, 1

	.type	.L.str327,@object       # @.str327
.L.str327:
	.asciz	 "wget"
	.size	.L.str327, 5

	.type	.L.str328,@object       # @.str328
.L.str328:
	.asciz	 "/usr/local/share/locale"
	.size	.L.str328, 24

	.type	fillbuf,@object         # @fillbuf
	.section	.rodata,"a",@progbits
fillbuf:
	.asciz	 "\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
	.size	fillbuf, 64

	.type	search_netrc.processed_netrc.b,@object # @search_netrc.processed_netrc.b
	.local	search_netrc.processed_netrc.b
	.comm	search_netrc.processed_netrc.b,1,1
	.type	netrc_list,@object      # @netrc_list
	.comm	netrc_list,4,4
	.type	.L.str886,@object       # @.str886
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str886:
	.asciz	 "%s/%s"
	.size	.L.str886, 6

	.type	.L.str1887,@object      # @.str1887
.L.str1887:
	.asciz	 ".netrc"
	.size	.L.str1887, 7

	.type	.L.str2888,@object      # @.str2888
.L.str2888:
	.asciz	 "r"
	.size	.L.str2888, 2

	.type	.L.str3889,@object      # @.str3889
.L.str3889:
	.asciz	 "%s: Cannot read %s (%s).\n"
	.size	.L.str3889, 26

	.type	.L.str4890,@object      # @.str4890
.L.str4890:
	.asciz	 "login"
	.size	.L.str4890, 6

	.type	.L.str5891,@object      # @.str5891
.L.str5891:
	.asciz	 "password"
	.size	.L.str5891, 9

	.type	.L.str6892,@object      # @.str6892
.L.str6892:
	.asciz	 "macdef"
	.size	.L.str6892, 7

	.type	.L.str7893,@object      # @.str7893
.L.str7893:
	.asciz	 "account"
	.size	.L.str7893, 8

	.type	.L.str8894,@object      # @.str8894
.L.str8894:
	.asciz	 "%s: %s:%d: warning: \"%s\" token appears before any machine name\n"
	.size	.L.str8894, 64

	.type	.L.str9895,@object      # @.str9895
.L.str9895:
	.asciz	 "default"
	.size	.L.str9895, 8

	.type	.L.str10896,@object     # @.str10896
.L.str10896:
	.asciz	 "machine"
	.size	.L.str10896, 8

	.type	.L.str11897,@object     # @.str11897
.L.str11897:
	.asciz	 "%s: %s:%d: unknown token \"%s\"\n"
	.size	.L.str11897, 31

	.type	implementations,@object # @implementations
	.data
	.align	4
implementations:
	.long	.L.str1901
	.byte	0                       # 0x0
	.zero	3
	.long	dot_create
	.long	dot_update
	.long	dot_finish
	.long	dot_set_params
	.long	.L.str900
	.byte	1                       # 0x1
	.zero	3
	.long	bar_create
	.long	bar_update
	.long	bar_finish
	.long	bar_set_params
	.size	implementations, 48

	.type	.L.str900,@object       # @.str900
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str900:
	.asciz	 "bar"
	.size	.L.str900, 4

	.type	current_impl,@object    # @current_impl
	.local	current_impl
	.comm	current_impl,4,4
	.type	current_impl_locked.b,@object # @current_impl_locked.b
	.local	current_impl_locked.b
	.comm	current_impl_locked.b,1,1
	.type	output_redirected.b,@object # @output_redirected.b
	.local	output_redirected.b
	.comm	output_redirected.b,1,1
	.type	.L.str1901,@object      # @.str1901
.L.str1901:
	.asciz	 "dot"
	.size	.L.str1901, 4

	.type	.L.str2902,@object      # @.str2902
.L.str2902:
	.asciz	 "bytes != 0"
	.size	.L.str2902, 11

	.type	.L.str3903,@object      # @.str3903
.L.str3903:
	.asciz	 "progress.c"
	.size	.L.str3903, 11

	.type	.L__PRETTY_FUNCTION__.count_cols,@object # @__PRETTY_FUNCTION__.count_cols
.L__PRETTY_FUNCTION__.count_cols:
	.asciz	 "int count_cols(const char *)"
	.size	.L__PRETTY_FUNCTION__.count_cols, 29

	.type	get_eta.eta_str,@object # @get_eta.eta_str
	.section	.rodata,"a",@progbits
get_eta.eta_str:
	.asciz	 "  eta %s"
	.size	get_eta.eta_str, 9

	.type	get_eta.eta_trans,@object # @get_eta.eta_trans
	.local	get_eta.eta_trans
	.comm	get_eta.eta_trans,4,4
	.type	get_eta.bytes_cols_diff,@object # @get_eta.bytes_cols_diff
	.local	get_eta.bytes_cols_diff
	.comm	get_eta.bytes_cols_diff,4,4
	.type	received_sigwinch,@object # @received_sigwinch
	.local	received_sigwinch
	.comm	received_sigwinch,4,4
	.type	.L.str4904,@object      # @.str4904
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str4904:
	.asciz	 "TERM"
	.size	.L.str4904, 5

	.type	.L.str5905,@object      # @.str5905
.L.str5905:
	.asciz	 "force"
	.size	.L.str5905, 6

	.type	.L.str6906,@object      # @.str6906
.L.str6906:
	.asciz	 "emacs"
	.size	.L.str6906, 6

	.type	.L.str7907,@object      # @.str7907
.L.str7907:
	.asciz	 "\n\n"
	.size	.L.str7907, 3

	.type	.L.str8908,@object      # @.str8908
.L.str8908:
	.asciz	 "\r"
	.size	.L.str8908, 2

	.type	.L.str9909,@object      # @.str9909
.L.str9909:
	.asciz	 "percentage <= 100"
	.size	.L.str9909, 18

	.type	.L__PRETTY_FUNCTION__.create_image,@object # @__PRETTY_FUNCTION__.create_image
.L__PRETTY_FUNCTION__.create_image:
	.asciz	 "void create_image(struct bar_progress *, double, _Bool)"
	.size	.L__PRETTY_FUNCTION__.create_image, 56

	.type	.L.str10910,@object     # @.str10910
.L.str10910:
	.asciz	 "%2d%% "
	.size	.L.str10910, 7

	.type	.L.str11911,@object     # @.str11911
.L.str11911:
	.asciz	 "100%"
	.size	.L.str11911, 5

	.type	.L.str13912,@object     # @.str13912
.L.str13912:
	.asciz	 "dlsz <= progress_size"
	.size	.L.str13912, 22

	.type	.L.str14913,@object     # @.str14913
.L.str14913:
	.asciz	 "insz <= dlsz"
	.size	.L.str14913, 13

	.type	.L.str15914,@object     # @.str15914
.L.str15914:
	.asciz	 " %s"
	.size	.L.str15914, 4

	.type	create_image.short_units,@object # @create_image.short_units
	.section	.rodata,"a",@progbits
	.align	4
create_image.short_units:
	.long	.L.str16915
	.long	.L.str17916
	.long	.L.str18917
	.long	.L.str19918
	.size	create_image.short_units, 16

	.type	.L.str16915,@object     # @.str16915
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str16915:
	.asciz	 "B/s"
	.size	.L.str16915, 4

	.type	.L.str17916,@object     # @.str17916
.L.str17916:
	.asciz	 "K/s"
	.size	.L.str17916, 4

	.type	.L.str18917,@object     # @.str18917
.L.str18917:
	.asciz	 "M/s"
	.size	.L.str18917, 4

	.type	.L.str19918,@object     # @.str19918
.L.str19918:
	.asciz	 "G/s"
	.size	.L.str19918, 4

	.type	.L.str20919,@object     # @.str20919
.L.str20919:
	.asciz	 " %4.*f%s"
	.size	.L.str20919, 9

	.type	.L.str22920,@object     # @.str22920
.L.str22920:
	.asciz	 "             "
	.size	.L.str22920, 14

	.type	.L.str23921,@object     # @.str23921
.L.str23921:
	.asciz	 "   in "
	.size	.L.str23921, 7

	.type	.L.str24922,@object     # @.str24922
.L.str24922:
	.asciz	 "%ss"
	.size	.L.str24922, 4

	.type	eta_to_human_short.buf,@object # @eta_to_human_short.buf
	.local	eta_to_human_short.buf
	.comm	eta_to_human_short.buf,10,1
	.type	eta_to_human_short.last,@object # @eta_to_human_short.last
	.data
	.align	4
eta_to_human_short.last:
	.long	4294967295              # 0xffffffff
	.size	eta_to_human_short.last, 4

	.type	.L.str25923,@object     # @.str25923
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str25923:
	.zero	1
	.size	.L.str25923, 1

	.type	.L.str26924,@object     # @.str26924
.L.str26924:
	.asciz	 " "
	.size	.L.str26924, 2

	.type	.L.str27925,@object     # @.str27925
.L.str27925:
	.asciz	 "%ds"
	.size	.L.str27925, 4

	.type	.L.str28926,@object     # @.str28926
.L.str28926:
	.asciz	 "%dm%s%ds"
	.size	.L.str28926, 9

	.type	.L.str29927,@object     # @.str29927
.L.str29927:
	.asciz	 "%dh%s%dm"
	.size	.L.str29927, 9

	.type	.L.str30928,@object     # @.str30928
.L.str30928:
	.asciz	 "%dd%s%dh"
	.size	.L.str30928, 9

	.type	.L.str31929,@object     # @.str31929
.L.str31929:
	.asciz	 "%dd"
	.size	.L.str31929, 4

	.type	screen_width,@object    # @screen_width
	.local	screen_width
	.comm	screen_width,4,4
	.type	.L.str32930,@object     # @.str32930
.L.str32930:
	.asciz	 "\n"
	.size	.L.str32930, 2

	.type	.L.str33931,@object     # @.str33931
.L.str33931:
	.asciz	 "default"
	.size	.L.str33931, 8

	.type	.L.str34932,@object     # @.str34932
.L.str34932:
	.asciz	 "binary"
	.size	.L.str34932, 7

	.type	.L.str35933,@object     # @.str35933
.L.str35933:
	.asciz	 "mega"
	.size	.L.str35933, 5

	.type	.L.str36934,@object     # @.str36934
.L.str36934:
	.asciz	 "giga"
	.size	.L.str36934, 5

	.type	.L.str37935,@object     # @.str37935
.L.str37935:
	.asciz	 "Invalid dot style specification `%s'; leaving unchanged.\n"
	.size	.L.str37935, 58

	.type	.L.str38936,@object     # @.str38936
.L.str38936:
	.asciz	 "\n%6sK"
	.size	.L.str38936, 6

	.type	.L.str39937,@object     # @.str39937
.L.str39937:
	.asciz	 "%3d%%"
	.size	.L.str39937, 6

	.type	print_row_stats.names,@object # @print_row_stats.names
	.section	.rodata.cst4,"aM",@progbits,4
print_row_stats.names:
	.ascii	 " KMG"
	.size	print_row_stats.names, 4

	.type	.L.str40938,@object     # @.str40938
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str40938:
	.asciz	 " %4.*f%c"
	.size	.L.str40938, 9

	.type	.L.str41939,@object     # @.str41939
.L.str41939:
	.asciz	 "=%s"
	.size	.L.str41939, 4

	.type	.L.str42940,@object     # @.str42940
.L.str42940:
	.asciz	 "=%ss"
	.size	.L.str42940, 5

	.type	.L.str43941,@object     # @.str43941
.L.str43941:
	.asciz	 "."
	.size	.L.str43941, 2

	.type	.L.str44942,@object     # @.str44942
.L.str44942:
	.asciz	 "\n%*s[ skipping %sK ]"
	.size	.L.str44942, 21

	.type	.L.str45943,@object     # @.str45943
.L.str45943:
	.asciz	 ","
	.size	.L.str45943, 2

	.type	.L.str46944,@object     # @.str46944
.L.str46944:
	.asciz	 "dp->dots < opt.dots_in_line"
	.size	.L.str46944, 28

	.type	.L__PRETTY_FUNCTION__.dot_create,@object # @__PRETTY_FUNCTION__.dot_create
.L__PRETTY_FUNCTION__.dot_create:
	.asciz	 "void *dot_create(wgint, wgint)"
	.size	.L__PRETTY_FUNCTION__.dot_create, 31

	.type	ptimer_new.init_done.b,@object # @ptimer_new.init_done.b
	.local	ptimer_new.init_done.b
	.comm	ptimer_new.init_done.b,1,1
	.type	posix_clock_resolution,@object # @posix_clock_resolution
	.local	posix_clock_resolution
	.comm	posix_clock_resolution,8,8
	.type	posix_clock_id,@object  # @posix_clock_id
	.local	posix_clock_id
	.comm	posix_clock_id,4,4
	.type	posix_init.clocks,@object # @posix_init.clocks
	.section	.rodata.cst16,"aM",@progbits,16
	.align	4
posix_init.clocks:
	.long	1                       # 0x1
	.long	149                     # 0x95
	.long	0                       # 0x0
	.long	4294967295              # 0xffffffff
	.size	posix_init.clocks, 16

	.type	.L.str953,@object       # @.str953
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str953:
	.asciz	 "Cannot get REALTIME clock frequency: %s\n"
	.size	.L.str953, 41

	.type	.L.str960,@object       # @.str960
.L.str960:
	.asciz	 "%s: %s.\n"
	.size	.L.str960, 9

	.type	.L.str1961,@object      # @.str1961
.L.str1961:
	.asciz	 "Already downloaded \"%s\", reusing it from \"%s\".\n"
	.size	.L.str1961, 48

	.type	.L.str2962,@object      # @.str2962
.L.str2962:
	.asciz	 "Not descending further; at depth %d, max. %d.\n"
	.size	.L.str2962, 47

	.type	.L.str3963,@object      # @.str3963
.L.str3963:
	.asciz	 "url_parsed != ((void*)0)"
	.size	.L.str3963, 25

	.type	.L.str4964,@object      # @.str4964
.L.str4964:
	.asciz	 "recur.c"
	.size	.L.str4964, 8

	.type	.L__PRETTY_FUNCTION__.retrieve_tree,@object # @__PRETTY_FUNCTION__.retrieve_tree
.L__PRETTY_FUNCTION__.retrieve_tree:
	.asciz	 "uerr_t retrieve_tree(const char *)"
	.size	.L__PRETTY_FUNCTION__.retrieve_tree, 35

	.type	.L.str5965,@object      # @.str5965
.L.str5965:
	.asciz	 "Removing file due to %s in recursive_retrieve():\n"
	.size	.L.str5965, 50

	.type	.L.str6966,@object      # @.str6966
.L.str6966:
	.asciz	 "--delete-after"
	.size	.L.str6966, 15

	.type	.L.str7967,@object      # @.str7967
.L.str7967:
	.asciz	 "--spider"
	.size	.L.str7967, 9

	.type	.L.str8968,@object      # @.str8968
.L.str8968:
	.asciz	 "recursive rejection criteria"
	.size	.L.str8968, 29

	.type	.L.str9969,@object      # @.str9969
.L.str9969:
	.asciz	 "Removing %s.\n"
	.size	.L.str9969, 14

	.type	.L.str10970,@object     # @.str10970
.L.str10970:
	.asciz	 "Removing %s since it should be rejected.\n"
	.size	.L.str10970, 42

	.type	.L.str11971,@object     # @.str11971
.L.str11971:
	.asciz	 "unlink: %s\n"
	.size	.L.str11971, 12

	.type	.L.str12972,@object     # @.str12972
.L.str12972:
	.asciz	 "\n"
	.size	.L.str12972, 2

	.type	.L.str13973,@object     # @.str13973
.L.str13973:
	.asciz	 "orig_parsed != ((void*)0)"
	.size	.L.str13973, 26

	.type	.L__PRETTY_FUNCTION__.descend_redirect_p,@object # @__PRETTY_FUNCTION__.descend_redirect_p
.L__PRETTY_FUNCTION__.descend_redirect_p:
	.asciz	 "_Bool descend_redirect_p(const char *, const char *, int, struct url *, struct hash_table *)"
	.size	.L__PRETTY_FUNCTION__.descend_redirect_p, 93

	.type	.L.str14974,@object     # @.str14974
.L.str14974:
	.asciz	 "new_parsed != ((void*)0)"
	.size	.L.str14974, 25

	.type	.L.str15975,@object     # @.str15975
.L.str15975:
	.asciz	 "Redirection \"%s\" failed the test.\n"
	.size	.L.str15975, 35

	.type	.L.str16976,@object     # @.str16976
.L.str16976:
	.asciz	 "Deciding whether to enqueue \"%s\".\n"
	.size	.L.str16976, 35

	.type	.L.str17977,@object     # @.str17977
.L.str17977:
	.asciz	 "download_child_p: parent->url is: `%s'\n"
	.size	.L.str17977, 40

	.type	.L.str18978,@object     # @.str18978
.L.str18978:
	.asciz	 "Already on the black list.\n"
	.size	.L.str18978, 28

	.type	.L.str19979,@object     # @.str19979
.L.str19979:
	.asciz	 "Not following non-HTTP schemes.\n"
	.size	.L.str19979, 33

	.type	.L.str20980,@object     # @.str20980
.L.str20980:
	.asciz	 "It doesn't really look like a relative link.\n"
	.size	.L.str20980, 46

	.type	.L.str21981,@object     # @.str21981
.L.str21981:
	.asciz	 "The domain was not accepted.\n"
	.size	.L.str21981, 30

	.type	.L.str22982,@object     # @.str22982
.L.str22982:
	.asciz	 "Going to \"%s\" would escape \"%s\" with no_parent on.\n"
	.size	.L.str22982, 52

	.type	.L.str23983,@object     # @.str23983
.L.str23983:
	.asciz	 "%s (%s) is excluded/not-included.\n"
	.size	.L.str23983, 35

	.type	.L.str24984,@object     # @.str24984
.L.str24984:
	.asciz	 "%s (%s) does not match acc/rej rules.\n"
	.size	.L.str24984, 39

	.type	.L.str25985,@object     # @.str25985
.L.str25985:
	.asciz	 "This is not the same hostname as the parent's (%s and %s).\n"
	.size	.L.str25985, 60

	.type	.L.str26986,@object     # @.str26986
.L.str26986:
	.zero	1
	.size	.L.str26986, 1

	.type	.L.str27987,@object     # @.str27987
.L.str27987:
	.asciz	 "Not following %s because robots.txt forbids it.\n"
	.size	.L.str27987, 49

	.type	.L.str28988,@object     # @.str28988
.L.str28988:
	.asciz	 "Decided to load it.\n"
	.size	.L.str28988, 21

	.type	.L.str29989,@object     # @.str29989
.L.str29989:
	.asciz	 "Decided NOT to load it.\n"
	.size	.L.str29989, 25

	.type	.L.str30990,@object     # @.str30990
.L.str30990:
	.asciz	 "Dequeuing %s at depth %d\n"
	.size	.L.str30990, 26

	.type	.L.str31991,@object     # @.str31991
.L.str31991:
	.asciz	 "Queue count %d, maxcount %d.\n"
	.size	.L.str31991, 30

	.type	.L.str32992,@object     # @.str32992
.L.str32992:
	.asciz	 "Enqueuing %s at depth %d\n"
	.size	.L.str32992, 26

	.type	.L.str995,@object       # @.str995
.L.str995:
	.asciz	 "!((p) >= lineend)"
	.size	.L.str995, 18

	.type	.L.str1996,@object      # @.str1996
.L.str1996:
	.asciz	 "res.c"
	.size	.L.str1996, 6

	.type	.L__PRETTY_FUNCTION__.res_parse,@object # @__PRETTY_FUNCTION__.res_parse
.L__PRETTY_FUNCTION__.res_parse:
	.asciz	 "struct robot_specs *res_parse(const char *, int)"
	.size	.L__PRETTY_FUNCTION__.res_parse, 49

	.type	.L.str2997,@object      # @.str2997
.L.str2997:
	.asciz	 "Ignoring malformed line %d"
	.size	.L.str2997, 27

	.type	.L.str3998,@object      # @.str3998
.L.str3998:
	.asciz	 "user-agent"
	.size	.L.str3998, 11

	.type	.L.str4999,@object      # @.str4999
.L.str4999:
	.asciz	 "allow"
	.size	.L.str4999, 6

	.type	.L.str51000,@object     # @.str51000
.L.str51000:
	.asciz	 "disallow"
	.size	.L.str51000, 9

	.type	.L.str61001,@object     # @.str61001
.L.str61001:
	.asciz	 "Ignoring unknown field at line %d"
	.size	.L.str61001, 34

	.type	.L.str71002,@object     # @.str71002
.L.str71002:
	.asciz	 "Cannot open %s: %s"
	.size	.L.str71002, 19

	.type	.L.str81003,@object     # @.str81003
.L.str81003:
	.asciz	 "%s path %s because of rule `%s'.\n"
	.size	.L.str81003, 34

	.type	.L.str91004,@object     # @.str91004
.L.str91004:
	.asciz	 "Allowing"
	.size	.L.str91004, 9

	.type	.L.str101005,@object    # @.str101005
.L.str101005:
	.asciz	 "Rejecting"
	.size	.L.str101005, 10

	.type	registered_specs,@object # @registered_specs
	.local	registered_specs
	.comm	registered_specs,4,4
	.type	.L.str111006,@object    # @.str111006
.L.str111006:
	.asciz	 "/robots.txt"
	.size	.L.str111006, 12

	.type	.L.str121007,@object    # @.str121007
.L.str121007:
	.asciz	 "Loading robots.txt; please ignore errors.\n"
	.size	.L.str121007, 43

	.type	.L.str131008,@object    # @.str131008
.L.str131008:
	.asciz	 "j == cnt"
	.size	.L.str131008, 9

	.type	.L__PRETTY_FUNCTION__.prune_non_exact,@object # @__PRETTY_FUNCTION__.prune_non_exact
.L__PRETTY_FUNCTION__.prune_non_exact:
	.asciz	 "void prune_non_exact(struct robot_specs *)"
	.size	.L__PRETTY_FUNCTION__.prune_non_exact, 43

	.type	.L.str141009,@object    # @.str141009
.L.str141009:
	.asciz	 "wget"
	.size	.L.str141009, 5

	.type	fd_read_body.dlbuf,@object # @fd_read_body.dlbuf
	.local	fd_read_body.dlbuf
	.comm	fd_read_body.dlbuf,16384,1
	.type	.L.str1022,@object      # @.str1022
.L.str1022:
	.asciz	 "maxsize >= bufsize"
	.size	.L.str1022, 19

	.type	.L.str11023,@object     # @.str11023
.L.str11023:
	.asciz	 "retr.c"
	.size	.L.str11023, 7

	.type	.L__PRETTY_FUNCTION__.fd_read_hunk,@object # @__PRETTY_FUNCTION__.fd_read_hunk
.L__PRETTY_FUNCTION__.fd_read_hunk:
	.asciz	 "char *fd_read_hunk(int, hunk_terminator_t, long, long)"
	.size	.L__PRETTY_FUNCTION__.fd_read_hunk, 55

	.type	.L.str21024,@object     # @.str21024
.L.str21024:
	.asciz	 "remain >= 0"
	.size	.L.str21024, 12

	.type	retr_rate.res,@object   # @retr_rate.res
	.local	retr_rate.res
	.comm	retr_rate.res,20,1
	.type	retr_rate.rate_names,@object # @retr_rate.rate_names
	.section	.rodata,"a",@progbits
	.align	4
retr_rate.rate_names:
	.long	.L.str31025
	.long	.L.str41026
	.long	.L.str51027
	.long	.L.str61028
	.size	retr_rate.rate_names, 16

	.type	.L.str31025,@object     # @.str31025
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str31025:
	.asciz	 "B/s"
	.size	.L.str31025, 4

	.type	.L.str41026,@object     # @.str41026
.L.str41026:
	.asciz	 "KB/s"
	.size	.L.str41026, 5

	.type	.L.str51027,@object     # @.str51027
.L.str51027:
	.asciz	 "MB/s"
	.size	.L.str51027, 5

	.type	.L.str61028,@object     # @.str61028
.L.str61028:
	.asciz	 "GB/s"
	.size	.L.str61028, 5

	.type	.L.str71029,@object     # @.str71029
.L.str71029:
	.asciz	 "%.*f %s"
	.size	.L.str71029, 8

	.type	.L.str81030,@object     # @.str81030
.L.str81030:
	.asciz	 "secs >= 0"
	.size	.L.str81030, 10

	.type	.L__PRETTY_FUNCTION__.calc_rate,@object # @__PRETTY_FUNCTION__.calc_rate
.L__PRETTY_FUNCTION__.calc_rate:
	.asciz	 "double calc_rate(wgint, double, int *)"
	.size	.L__PRETTY_FUNCTION__.calc_rate, 39

	.type	.L.str91031,@object     # @.str91031
.L.str91031:
	.asciz	 "bytes >= 0"
	.size	.L.str91031, 11

	.type	.L.str101032,@object    # @.str101032
.L.str101032:
	.asciz	 "%s: %s.\n"
	.size	.L.str101032, 9

	.type	.L.str111033,@object    # @.str111033
.L.str111033:
	.asciz	 "Error parsing proxy URL %s: %s.\n"
	.size	.L.str111033, 33

	.type	.L.str121034,@object    # @.str121034
.L.str121034:
	.asciz	 "Error in proxy URL %s: Must be HTTP.\n"
	.size	.L.str121034, 38

	.type	.L.str131035,@object    # @.str131035
.L.str131035:
	.asciz	 "mynewloc != ((void*)0)"
	.size	.L.str131035, 23

	.type	.L__PRETTY_FUNCTION__.retrieve_url,@object # @__PRETTY_FUNCTION__.retrieve_url
.L__PRETTY_FUNCTION__.retrieve_url:
	.asciz	 "uerr_t retrieve_url(const char *, char **, char **, const char *, int *, _Bool)"
	.size	.L__PRETTY_FUNCTION__.retrieve_url, 80

	.type	.L.str141036,@object    # @.str141036
.L.str141036:
	.asciz	 "%d redirections exceeded.\n"
	.size	.L.str141036, 27

	.type	total_downloaded_bytes,@object # @total_downloaded_bytes
	.comm	total_downloaded_bytes,8,8
	.type	.L.str151039,@object    # @.str151039
.L.str151039:
	.asciz	 "Removing file due to --delete-after in retrieve_from_file():\n"
	.size	.L.str151039, 62

	.type	.L.str161040,@object    # @.str161040
.L.str161040:
	.asciz	 "Removing %s.\n"
	.size	.L.str161040, 14

	.type	.L.str171041,@object    # @.str171041
.L.str171041:
	.asciz	 "unlink: %s\n"
	.size	.L.str171041, 12

	.type	.L.str181042,@object    # @.str181042
.L.str181042:
	.asciz	 "Giving up.\n\n"
	.size	.L.str181042, 13

	.type	.L.str191043,@object    # @.str191043
.L.str191043:
	.asciz	 "Retrying.\n\n"
	.size	.L.str191043, 12

	.type	sleep_between_retrievals.first_retrieval.b,@object # @sleep_between_retrievals.first_retrieval.b
	.local	sleep_between_retrievals.first_retrieval.b
	.comm	sleep_between_retrievals.first_retrieval.b,1,1
	.type	.L.str201044,@object    # @.str201044
.L.str201044:
	.asciz	 "sleep_between_retrievals: avg=%f,sleep=%f\n"
	.size	.L.str201044, 43

	.type	.L.str211045,@object    # @.str211045
.L.str211045:
	.asciz	 "%s.%d"
	.size	.L.str211045, 6

	.type	total_download_time,@object # @total_download_time
	.comm	total_download_time,8,8
	.type	output_stream,@object   # @output_stream
	.comm	output_stream,4,4
	.type	output_stream_regular,@object # @output_stream_regular
	.comm	output_stream_regular,1,1
	.type	getproxy.rewritten_storage,@object # @getproxy.rewritten_storage
	.local	getproxy.rewritten_storage
	.comm	getproxy.rewritten_storage,1024,1
	.type	.L.str221052,@object    # @.str221052
.L.str221052:
	.asciz	 "http_proxy"
	.size	.L.str221052, 11

	.type	.L.str231053,@object    # @.str231053
.L.str231053:
	.asciz	 "ftp_proxy"
	.size	.L.str231053, 10

	.type	limit_data,@object      # @limit_data
	.local	limit_data
	.comm	limit_data,24,8
	.type	.L.str241054,@object    # @.str241054
.L.str241054:
	.asciz	 "deferring a %.2f ms sleep (%s/%.2f).\n"
	.size	.L.str241054, 38

	.type	.L.str251055,@object    # @.str251055
.L.str251055:
	.asciz	 "\nsleeping %.2f ms for %s bytes, adjust %.2f ms\n"
	.size	.L.str251055, 48

	.type	_sch_istable,@object    # @_sch_istable
	.section	.rodata,"a",@progbits
	.globl	_sch_istable
	.align	2
_sch_istable:
	.short	2050                    # 0x802
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2115                    # 0x843
	.short	1090                    # 0x442
	.short	2114                    # 0x842
	.short	2114                    # 0x842
	.short	1090                    # 0x442
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2                       # 0x2
	.short	2129                    # 0x851
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	276                     # 0x114
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	912                     # 0x390
	.short	912                     # 0x390
	.short	912                     # 0x390
	.short	912                     # 0x390
	.short	912                     # 0x390
	.short	912                     # 0x390
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	656                     # 0x290
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	560                     # 0x230
	.short	48                      # 0x30
	.short	792                     # 0x318
	.short	792                     # 0x318
	.short	792                     # 0x318
	.short	792                     # 0x318
	.short	792                     # 0x318
	.short	792                     # 0x318
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	536                     # 0x218
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	48                      # 0x30
	.short	2                       # 0x2
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.short	0                       # 0x0
	.size	_sch_istable, 512

	.type	_sch_tolower,@object    # @_sch_tolower
	.globl	_sch_tolower
_sch_tolower:
	.ascii	 "\000\001\002\003\004\005\006\007\b\t\n\013\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037 !\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377"
	.size	_sch_tolower, 256

	.type	_sch_toupper,@object    # @_sch_toupper
	.globl	_sch_toupper
_sch_toupper:
	.ascii	 "\000\001\002\003\004\005\006\007\b\t\n\013\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377"
	.size	_sch_toupper, 256

	.type	nonexisting_urls_set,@object # @nonexisting_urls_set
	.local	nonexisting_urls_set
	.comm	nonexisting_urls_set,4,4
	.type	.L.str1086,@object      # @.str1086
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str1086:
	.asciz	 "Found no broken links.\n\n"
	.size	.L.str1086, 25

	.type	.L.str11087,@object     # @.str11087
.L.str11087:
	.asciz	 "num_elems > 0"
	.size	.L.str11087, 14

	.type	.L.str21088,@object     # @.str21088
.L.str21088:
	.asciz	 "spider.c"
	.size	.L.str21088, 9

	.type	.L__PRETTY_FUNCTION__.print_broken_links,@object # @__PRETTY_FUNCTION__.print_broken_links
.L__PRETTY_FUNCTION__.print_broken_links:
	.asciz	 "void print_broken_links()"
	.size	.L__PRETTY_FUNCTION__.print_broken_links, 26

	.type	.L.str31089,@object     # @.str31089
.L.str31089:
	.asciz	 "Found %d broken link.\n\n"
	.size	.L.str31089, 24

	.type	.L.str41090,@object     # @.str41090
.L.str41090:
	.asciz	 "Found %d broken links.\n\n"
	.size	.L.str41090, 25

	.type	.L.str51091,@object     # @.str51091
.L.str51091:
	.asciz	 "%s\n"
	.size	.L.str51091, 4

	.type	.L.str61092,@object     # @.str61092
.L.str61092:
	.asciz	 "\n"
	.size	.L.str61092, 2

	.type	supported_schemes,@object # @supported_schemes
	.data
	.align	4
supported_schemes:
	.long	.L.str311126
	.long	.L.str321127
	.long	80                      # 0x50
	.long	12                      # 0xc
	.long	.L.str331128
	.long	.L.str341129
	.long	21                      # 0x15
	.long	10                      # 0xa
	.long	0
	.long	0
	.long	4294967295              # 0xffffffff
	.long	0                       # 0x0
	.size	supported_schemes, 48

	.type	.L.str11097,@object     # @.str11097
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str11097:
	.asciz	 "0123456789"
	.size	.L.str11097, 11

	.type	.L.str21098,@object     # @.str21098
.L.str21098:
	.asciz	 "ftp://%s"
	.size	.L.str21098, 9

	.type	.L.str31099,@object     # @.str31099
.L.str31099:
	.asciz	 "http://%s"
	.size	.L.str31099, 10

	.type	.L.str41100,@object     # @.str41100
.L.str41100:
	.asciz	 "*p == 0"
	.size	.L.str41100, 8

	.type	.L.str51101,@object     # @.str51101
.L.str51101:
	.asciz	 "url.c"
	.size	.L.str51101, 6

	.type	.L__PRETTY_FUNCTION__.url_parse,@object # @__PRETTY_FUNCTION__.url_parse
.L__PRETTY_FUNCTION__.url_parse:
	.asciz	 "struct url *url_parse(const char *, int *)"
	.size	.L__PRETTY_FUNCTION__.url_parse, 43

	.type	.L.str61102,@object     # @.str61102
.L.str61102:
	.asciz	 "error_code >= 0 && error_code < (sizeof (parse_errors) / sizeof ((parse_errors)[0]))"
	.size	.L.str61102, 85

	.type	.L__PRETTY_FUNCTION__.url_error,@object # @__PRETTY_FUNCTION__.url_error
.L__PRETTY_FUNCTION__.url_error:
	.asciz	 "const char *url_error(int)"
	.size	.L__PRETTY_FUNCTION__.url_error, 27

	.type	parse_errors,@object    # @parse_errors
	.section	.rodata,"a",@progbits
	.align	4
parse_errors:
	.long	.L.str211116
	.long	.L.str221117
	.long	.L.str231118
	.long	.L.str241119
	.long	.L.str251120
	.long	.L.str261121
	.long	.L.str271122
	.long	.L.str281123
	.size	parse_errors, 32

	.type	.L.str71103,@object     # @.str71103
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str71103:
	.asciz	 "Removing %s because of directory danger!\n"
	.size	.L.str71103, 42

	.type	.L.str81104,@object     # @.str81104
.L.str81104:
	.asciz	 "%s: %s"
	.size	.L.str81104, 7

	.type	.L.str101105,@object    # @.str101105
.L.str101105:
	.asciz	 "%2E%2E"
	.size	.L.str101105, 7

	.type	.L.str111106,@object    # @.str111106
.L.str111106:
	.asciz	 "index.html"
	.size	.L.str111106, 11

	.type	.L.str121107,@object    # @.str121107
.L.str121107:
	.asciz	 "scheme_str != ((void*)0)"
	.size	.L.str121107, 25

	.type	.L__PRETTY_FUNCTION__.url_string,@object # @__PRETTY_FUNCTION__.url_string
.L__PRETTY_FUNCTION__.url_string:
	.asciz	 "char *url_string(const struct url *, enum url_auth_mode)"
	.size	.L__PRETTY_FUNCTION__.url_string, 57

	.type	.L.str131108,@object    # @.str131108
.L.str131108:
	.asciz	 "*password*"
	.size	.L.str131108, 11

	.type	.L.str141109,@object    # @.str141109
.L.str141109:
	.asciz	 "p - result == size"
	.size	.L.str141109, 19

	.type	.L.str151110,@object    # @.str151110
.L.str151110:
	.asciz	 "u1 && u2"
	.size	.L.str151110, 9

	.type	.L__PRETTY_FUNCTION__.are_urls_equal,@object # @__PRETTY_FUNCTION__.are_urls_equal
.L__PRETTY_FUNCTION__.are_urls_equal:
	.asciz	 "_Bool are_urls_equal(const char *, const char *)"
	.size	.L__PRETTY_FUNCTION__.are_urls_equal, 49

	.type	.L.str161111,@object    # @.str161111
.L.str161111:
	.asciz	 "str && *str"
	.size	.L.str161111, 12

	.type	.L__PRETTY_FUNCTION__.getchar_from_escaped_string,@object # @__PRETTY_FUNCTION__.getchar_from_escaped_string
.L__PRETTY_FUNCTION__.getchar_from_escaped_string:
	.asciz	 "int getchar_from_escaped_string(const char *, char *)"
	.size	.L__PRETTY_FUNCTION__.getchar_from_escaped_string, 54

	.type	.L.str171112,@object    # @.str171112
.L.str171112:
	.asciz	 "c"
	.size	.L.str171112, 2

	.type	urlchr_table,@object    # @urlchr_table
	.section	.rodata,"a",@progbits
urlchr_table:
	.ascii	 "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\000\002\003\001\002\001\000\000\000\000\001\001\000\000\001\000\000\000\000\000\000\000\000\000\000\003\001\002\001\002\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\003\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\002\000\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
	.size	urlchr_table, 256

	.type	.L.str181113,@object    # @.str181113
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str181113:
	.asciz	 "0123456789ABCDEF"
	.size	.L.str181113, 17

	.type	filechr_table,@object   # @filechr_table
	.section	.rodata,"a",@progbits
filechr_table:
	.asciz	 "\007\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\000\000\002\000\000\000\000\000\000\000\002\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
	.size	filechr_table, 256

	.type	.L.str191114,@object    # @.str191114
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str191114:
	.asciz	 "q - ((dest)->base + (dest)->tail) == outlen"
	.size	.L.str191114, 44

	.type	.L__PRETTY_FUNCTION__.append_uri_pathel,@object # @__PRETTY_FUNCTION__.append_uri_pathel
.L__PRETTY_FUNCTION__.append_uri_pathel:
	.asciz	 "void append_uri_pathel(const char *, const char *, _Bool, struct growable *)"
	.size	.L__PRETTY_FUNCTION__.append_uri_pathel, 77

	.type	.L.str201115,@object    # @.str201115
.L.str201115:
	.zero	1
	.size	.L.str201115, 1

	.type	.L.str211116,@object    # @.str211116
.L.str211116:
	.asciz	 "No error"
	.size	.L.str211116, 9

	.type	.L.str221117,@object    # @.str221117
.L.str221117:
	.asciz	 "Unsupported scheme"
	.size	.L.str221117, 19

	.type	.L.str231118,@object    # @.str231118
.L.str231118:
	.asciz	 "Invalid host name"
	.size	.L.str231118, 18

	.type	.L.str241119,@object    # @.str241119
.L.str241119:
	.asciz	 "Bad port number"
	.size	.L.str241119, 16

	.type	.L.str251120,@object    # @.str251120
.L.str251120:
	.asciz	 "Invalid user name"
	.size	.L.str251120, 18

	.type	.L.str261121,@object    # @.str261121
.L.str261121:
	.asciz	 "Unterminated IPv6 numeric address"
	.size	.L.str261121, 34

	.type	.L.str271122,@object    # @.str271122
.L.str271122:
	.asciz	 "IPv6 addresses not supported"
	.size	.L.str271122, 29

	.type	.L.str281123,@object    # @.str281123
.L.str281123:
	.asciz	 "Invalid IPv6 numeric address"
	.size	.L.str281123, 29

	.type	init_seps.seps,@object  # @init_seps.seps
	.data
init_seps.seps:
	.asciz	 ":/\000\000\000\000\000"
	.size	init_seps.seps, 8

	.type	.L.str291124,@object    # @.str291124
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str291124:
	.asciz	 "@/?#;"
	.size	.L.str291124, 6

	.type	.L.str301125,@object    # @.str301125
.L.str301125:
	.asciz	 "p2 - newstr == newlen"
	.size	.L.str301125, 22

	.type	.L__PRETTY_FUNCTION__.reencode_escapes,@object # @__PRETTY_FUNCTION__.reencode_escapes
.L__PRETTY_FUNCTION__.reencode_escapes:
	.asciz	 "char *reencode_escapes(const char *)"
	.size	.L__PRETTY_FUNCTION__.reencode_escapes, 37

	.type	.L.str311126,@object    # @.str311126
.L.str311126:
	.asciz	 "http"
	.size	.L.str311126, 5

	.type	.L.str321127,@object    # @.str321127
.L.str321127:
	.asciz	 "http://"
	.size	.L.str321127, 8

	.type	.L.str331128,@object    # @.str331128
.L.str331128:
	.asciz	 "ftp"
	.size	.L.str331128, 4

	.type	.L.str341129,@object    # @.str341129
.L.str341129:
	.asciz	 "ftp://"
	.size	.L.str341129, 7

	.type	.L__PRETTY_FUNCTION__.url_escape_1,@object # @__PRETTY_FUNCTION__.url_escape_1
.L__PRETTY_FUNCTION__.url_escape_1:
	.asciz	 "char *url_escape_1(const char *, unsigned char, _Bool)"
	.size	.L__PRETTY_FUNCTION__.url_escape_1, 55

	.type	.L.str1164,@object      # @.str1164
.L.str1164:
	.asciz	 "%H:%M:%S"
	.size	.L.str1164, 9

	.type	.L.str11165,@object     # @.str11165
.L.str11165:
	.asciz	 "%Y-%m-%d %H:%M:%S"
	.size	.L.str11165, 18

	.type	.L.str21166,@object     # @.str21166
.L.str21166:
	.asciz	 "wget-log"
	.size	.L.str21166, 9

	.type	.L.str31167,@object     # @.str31167
.L.str31167:
	.asciz	 "fork"
	.size	.L.str31167, 5

	.type	.L.str41168,@object     # @.str41168
.L.str41168:
	.asciz	 "Continuing in background, pid %d.\n"
	.size	.L.str41168, 35

	.type	.L.str51169,@object     # @.str51169
.L.str51169:
	.asciz	 "Output will be written to `%s'.\n"
	.size	.L.str51169, 33

	.type	.L.str61170,@object     # @.str61170
.L.str61170:
	.asciz	 "/dev/null"
	.size	.L.str61170, 10

	.type	.L.str71171,@object     # @.str71171
.L.str71171:
	.asciz	 "r"
	.size	.L.str71171, 2

	.type	.L.str81172,@object     # @.str81172
.L.str81172:
	.asciz	 "w"
	.size	.L.str81172, 2

	.type	.L.str91173,@object     # @.str91173
.L.str91173:
	.asciz	 "utime(%s): %s\n"
	.size	.L.str91173, 15

	.type	.L.str101174,@object    # @.str101174
.L.str101174:
	.asciz	 "Unlinking %s (symlink).\n"
	.size	.L.str101174, 25

	.type	.L.str111175,@object    # @.str111175
.L.str111175:
	.asciz	 "Failed to unlink symlink `%s': %s\n"
	.size	.L.str111175, 35

	.type	.L.str121176,@object    # @.str121176
.L.str121176:
	.asciz	 "rb"
	.size	.L.str121176, 3

	.type	.L.str131177,@object    # @.str131177
.L.str131177:
	.asciz	 "wb"
	.size	.L.str131177, 3

	.type	.L.str141178,@object    # @.str141178
.L.str141178:
	.asciz	 "html"
	.size	.L.str141178, 5

	.type	.L.str151179,@object    # @.str151179
.L.str151179:
	.asciz	 "htm"
	.size	.L.str151179, 4

	.type	.L.str161180,@object    # @.str161180
.L.str161180:
	.asciz	 "1"
	.size	.L.str161180, 2

	.type	with_thousand_seps.outbuf,@object # @with_thousand_seps.outbuf
	.local	with_thousand_seps.outbuf
	.comm	with_thousand_seps.outbuf,48,1
	.type	human_readable.powers,@object # @human_readable.powers
	.section	.rodata,"a",@progbits
human_readable.powers:
	.ascii	 "KMGTPE"
	.size	human_readable.powers, 6

	.type	human_readable.buf,@object # @human_readable.buf
	.local	human_readable.buf
	.comm	human_readable.buf,8,1
	.type	.L.str171181,@object    # @.str171181
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str171181:
	.asciz	 "%d"
	.size	.L.str171181, 3

	.type	.L.str181182,@object    # @.str181182
.L.str181182:
	.asciz	 "%.*f%c"
	.size	.L.str181182, 7

	.type	number_to_static_string.ring,@object # @number_to_static_string.ring
	.local	number_to_static_string.ring
	.comm	number_to_static_string.ring,72,1
	.type	number_to_static_string.ringpos,@object # @number_to_static_string.ringpos
	.local	number_to_static_string.ringpos
	.comm	number_to_static_string.ringpos,4,4
	.type	rnd_seeded.b,@object    # @rnd_seeded.b
	.local	rnd_seeded.b
	.comm	rnd_seeded.b,1,1
	.type	run_with_timeout_env,@object # @run_with_timeout_env
	.local	run_with_timeout_env
	.comm	run_with_timeout_env,156,4
	.type	base64_encode.tbl,@object # @base64_encode.tbl
	.section	.rodata,"a",@progbits
base64_encode.tbl:
	.ascii	 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	.size	base64_encode.tbl, 64

	.type	base64_decode.base64_char_to_value,@object # @base64_decode.base64_char_to_value
base64_decode.base64_char_to_value:
	.ascii	 "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377>\377\377\377?456789:;<=\377\377\377\377\377\377\377\000\001\002\003\004\005\006\007\b\t\n\013\f\r\016\017\020\021\022\023\024\025\026\027\030\031\377\377\377\377\377\377\032\033\034\035\036\037 !\"#$%&'()*+,-./0123\377\377\377\377\377"
	.size	base64_decode.base64_char_to_value, 128

	.type	print_decimal.buf,@object # @print_decimal.buf
	.local	print_decimal.buf
	.comm	print_decimal.buf,32,2
	.type	.L.str191183,@object    # @.str191183
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str191183:
	.asciz	 "%.0f"
	.size	.L.str191183, 5

	.type	.L.str201184,@object    # @.str201184
.L.str201184:
	.asciz	 "%.1f"
	.size	.L.str201184, 5

	.type	.L.str211185,@object    # @.str211185
.L.str211185:
	.asciz	 "%.1g"
	.size	.L.str211185, 5

	.type	.L.str221186,@object    # @.str221186
.L.str221186:
	.asciz	 "%.3f"
	.size	.L.str221186, 5

	.type	.L.str241187,@object    # @.str241187
.L.str241187:
	.asciz	 "sig == 14"
	.size	.L.str241187, 10

	.type	.L.str251188,@object    # @.str251188
.L.str251188:
	.asciz	 "utils.c"
	.size	.L.str251188, 8

	.type	.L__PRETTY_FUNCTION__.abort_run_with_timeout,@object # @__PRETTY_FUNCTION__.abort_run_with_timeout
.L__PRETTY_FUNCTION__.abort_run_with_timeout:
	.asciz	 "void abort_run_with_timeout(int)"
	.size	.L__PRETTY_FUNCTION__.abort_run_with_timeout, 33

	.type	get_grouping_data.cached_sep,@object # @get_grouping_data.cached_sep
	.local	get_grouping_data.cached_sep
	.comm	get_grouping_data.cached_sep,4,4
	.type	get_grouping_data.cached_grouping,@object # @get_grouping_data.cached_grouping
	.local	get_grouping_data.cached_grouping
	.comm	get_grouping_data.cached_grouping,4,4
	.type	get_grouping_data.initialized.b,@object # @get_grouping_data.initialized.b
	.local	get_grouping_data.initialized.b
	.comm	get_grouping_data.initialized.b,1,1
	.type	.L.str261189,@object    # @.str261189
.L.str261189:
	.asciz	 ","
	.size	.L.str261189, 2

	.type	.L.str271190,@object    # @.str271190
.L.str271190:
	.asciz	 "."
	.size	.L.str271190, 2

	.type	.L.str281191,@object    # @.str281191
.L.str281191:
	.asciz	 "\003"
	.size	.L.str281191, 2

	.type	fmttime.output,@object  # @fmttime.output
	.local	fmttime.output
	.comm	fmttime.output,32,1
	.type	.L.str1286,@object      # @.str1286
.L.str1286:
	.asciz	 "1.11.4"
	.size	.L.str1286, 7

	.type	version_string,@object  # @version_string
	.data
	.globl	version_string
	.align	4
version_string:
	.long	.L.str1286
	.size	version_string, 4

	.type	.L.str1289,@object      # @.str1289
	.section	.rodata.str1.1,"aMS",@progbits,1
.L.str1289:
	.asciz	 "malloc"
	.size	.L.str1289, 7

	.type	.L.str11290,@object     # @.str11290
.L.str11290:
	.asciz	 "calloc"
	.size	.L.str11290, 7

	.type	.L.str21291,@object     # @.str21291
.L.str21291:
	.asciz	 "realloc"
	.size	.L.str21291, 8

	.type	.L.str31292,@object     # @.str31292
.L.str31292:
	.asciz	 "strdup"
	.size	.L.str31292, 7

	.type	.L.str41293,@object     # @.str41293
.L.str41293:
	.asciz	 "ptr != ((void*)0)"
	.size	.L.str41293, 18

	.type	.L.str51294,@object     # @.str51294
.L.str51294:
	.asciz	 "xmalloc.c"
	.size	.L.str51294, 10

	.type	.L__PRETTY_FUNCTION__.checking_free,@object # @__PRETTY_FUNCTION__.checking_free
.L__PRETTY_FUNCTION__.checking_free:
	.asciz	 "void checking_free(void *)"
	.size	.L__PRETTY_FUNCTION__.checking_free, 27

	.type	.L.str61295,@object     # @.str61295
.L.str61295:
	.asciz	 "%s: %s: Failed to allocate %ld bytes; memory exhausted.\n"
	.size	.L.str61295, 57


	.section	".note.GNU-stack","",@progbits
